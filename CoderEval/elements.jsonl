{"ce_id": "62e60f43d76274f8a4026e28", "namespace": "62e60f43d76274f8a4026e28", "namespace_real": "neo4j._codec.hydration.v1.temporal.hydrate_time", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "function", "class_name": null, "function_name": "hydrate_time", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom datetime import (\n    datetime,\n    time,\n    timedelta,\n)\n\nfrom ....time import (\n    Date,\n    DateTime,\n    Duration,\n    Time,\n)\nfrom ...packstream import Structure\n\n\ndef get_date_unix_epoch():\n    return Date(1970, 1, 1)\n\n\ndef get_date_unix_epoch_ordinal():\n    return get_date_unix_epoch().to_ordinal()\n\n\ndef get_datetime_unix_epoch_utc():\n    from pytz import utc\n    return DateTime(1970, 1, 1, 0, 0, 0, utc)\n\n\ndef hydrate_date(days):\n    \"\"\" Hydrator for `Date` values.\n\n    :param days:\n    :return: Date\n    \"\"\"\n    return Date.from_ordinal(get_date_unix_epoch_ordinal() + days)\n\n\ndef dehydrate_date(value):\n    \"\"\" Dehydrator for `date` values.\n\n    :param value:\n    :type value: Date\n    :return:\n    \"\"\"\n    return Structure(b\"D\", value.toordinal() - get_date_unix_epoch().toordinal())\n\n", "contexts_below": "\n def dehydrate_time(value):\n     \"\"\" Dehydrator for `time` values.\n \n     :param value:\n     :type value: Time\n     :return:\n     \"\"\"\n     if isinstance(value, Time):\n         nanoseconds = value.ticks\n     elif isinstance(value, time):\n         nanoseconds = (3600000000000 * value.hour + 60000000000 * value.minute +\n                        1000000000 * value.second + 1000 * value.microsecond)\n     else:\n         raise TypeError(\"Value must be a neo4j.time.Time or a datetime.time\")\n     if value.tzinfo:\n         return Structure(b\"T\", nanoseconds,\n                          int(value.tzinfo.utcoffset(value).total_seconds()))\n     else:\n         return Structure(b\"t\", nanoseconds)\n \n \n def hydrate_datetime(seconds, nanoseconds, tz=None):\n     \"\"\" Hydrator for `DateTime` and `LocalDateTime` values.\n \n     :param seconds:\n     :param nanoseconds:\n     :param tz:\n     :return: datetime\n     \"\"\"\n     from pytz import (\n         FixedOffset,\n         timezone,\n     )\n     minutes, seconds = map(int, divmod(seconds, 60))\n     hours, minutes = map(int, divmod(minutes, 60))\n     days, hours = map(int, divmod(hours, 24))\n     t = DateTime.combine(\n         Date.from_ordinal(get_date_unix_epoch_ordinal() + days),\n         Time(hours, minutes, seconds, nanoseconds)\n     )\n     if tz is None:\n         return t\n     if isinstance(tz, int):\n         tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n         zone = FixedOffset(tz_offset_minutes)\n     else:\n         zone = timezone(tz)\n     return zone.localize(t)\n \n \n def dehydrate_datetime(value):\n     \"\"\" Dehydrator for `datetime` values.\n \n     :param value:\n     :type value: datetime or DateTime\n     :return:\n     \"\"\"\n \n     def seconds_and_nanoseconds(dt):\n         if isinstance(dt, datetime):\n             dt = DateTime.from_native(dt)\n         zone_epoch = DateTime(1970, 1, 1, tzinfo=dt.tzinfo)\n         dt_clock_time = dt.to_clock_time()\n         zone_epoch_clock_time = zone_epoch.to_clock_time()\n         t = dt_clock_time - zone_epoch_clock_time\n         return t.seconds, t.nanoseconds\n \n     tz = value.tzinfo\n     if tz is None:\n         # without time zone\n         from pytz import utc\n         value = utc.localize(value)\n         seconds, nanoseconds = seconds_and_nanoseconds(value)\n         return Structure(b\"d\", seconds, nanoseconds)\n     elif hasattr(tz, \"zone\") and tz.zone and isinstance(tz.zone, str):\n         # with named pytz time zone\n         seconds, nanoseconds = seconds_and_nanoseconds(value)\n         return Structure(b\"f\", seconds, nanoseconds, tz.zone)\n     elif hasattr(tz, \"key\") and tz.key and isinstance(tz.key, str):\n         # with named zoneinfo (Python 3.9+) time zone\n         seconds, nanoseconds = seconds_and_nanoseconds(value)\n         return Structure(b\"f\", seconds, nanoseconds, tz.key)\n     else:\n         # with time offset\n         seconds, nanoseconds = seconds_and_nanoseconds(value)\n         return Structure(b\"F\", seconds, nanoseconds,\n                          int(tz.utcoffset(value).total_seconds()))\n \n \n def hydrate_duration(months, days, seconds, nanoseconds):\n     \"\"\" Hydrator for `Duration` values.\n \n     :param months:\n     :param days:\n     :param seconds:\n     :param nanoseconds:\n     :return: `duration` namedtuple\n     \"\"\"\n     return Duration(months=months, days=days, seconds=seconds, nanoseconds=nanoseconds)\n \n \n def dehydrate_duration(value):\n     \"\"\" Dehydrator for `duration` values.\n \n     :param value:\n     :type value: Duration\n     :return:\n     \"\"\"\n     return Structure(b\"E\", value.months, value.days, value.seconds, value.nanoseconds)\n \n \n def dehydrate_timedelta(value):\n     \"\"\" Dehydrator for `timedelta` values.\n \n     :param value:\n     :type value: timedelta\n     :return:\n     \"\"\"\n     months = 0\n     days = value.days\n     seconds = value.seconds\n     nanoseconds = 1000 * value.microseconds\n     return Structure(b\"E\", months, days, seconds, nanoseconds)\n ", "input_code": "def hydrate_time(nanoseconds, tz=None):\n\"\"\"\nHydrator for `Time` and `LocalTime` values.\n\n:param nanoseconds:\n:param tz:\n:return: Time\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def hydrate_time(nanoseconds, tz=None):\n    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :return: Time\n    \"\"\"\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n    zone = FixedOffset(tz_offset_minutes)\n    return zone.localize(t)", "signature": "def hydrate_time(nanoseconds, tz=None):", "completion_path": "neo4j/_codec/hydration/v1/temporal.py"}
{"ce_id": "62e60f3bd76274f8a4026e10", "namespace": "62e60f3bd76274f8a4026e10", "namespace_real": "neo4j._codec.hydration.v1.temporal.dehydrate_timedelta", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "function", "class_name": null, "function_name": "dehydrate_timedelta", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom datetime import (\n    datetime,\n    time,\n    timedelta,\n)\n\nfrom ....time import (\n    Date,\n    DateTime,\n    Duration,\n    Time,\n)\nfrom ...packstream import Structure\n\n\ndef get_date_unix_epoch():\n    return Date(1970, 1, 1)\n\n\ndef get_date_unix_epoch_ordinal():\n    return get_date_unix_epoch().to_ordinal()\n\n\ndef get_datetime_unix_epoch_utc():\n    from pytz import utc\n    return DateTime(1970, 1, 1, 0, 0, 0, utc)\n\n\ndef hydrate_date(days):\n    \"\"\" Hydrator for `Date` values.\n\n    :param days:\n    :return: Date\n    \"\"\"\n    return Date.from_ordinal(get_date_unix_epoch_ordinal() + days)\n\n\ndef dehydrate_date(value):\n    \"\"\" Dehydrator for `date` values.\n\n    :param value:\n    :type value: Date\n    :return:\n    \"\"\"\n    return Structure(b\"D\", value.toordinal() - get_date_unix_epoch().toordinal())\n\n\ndef hydrate_time(nanoseconds, tz=None):\n    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :return: Time\n    \"\"\"\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n    zone = FixedOffset(tz_offset_minutes)\n    return zone.localize(t)\n\n\ndef dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :return:\n    \"\"\"\n    if isinstance(value, Time):\n        nanoseconds = value.ticks\n    elif isinstance(value, time):\n        nanoseconds = (3600000000000 * value.hour + 60000000000 * value.minute +\n                       1000000000 * value.second + 1000 * value.microsecond)\n    else:\n        raise TypeError(\"Value must be a neo4j.time.Time or a datetime.time\")\n    if value.tzinfo:\n        return Structure(b\"T\", nanoseconds,\n                         int(value.tzinfo.utcoffset(value).total_seconds()))\n    else:\n        return Structure(b\"t\", nanoseconds)\n\n\ndef hydrate_datetime(seconds, nanoseconds, tz=None):\n    \"\"\" Hydrator for `DateTime` and `LocalDateTime` values.\n\n    :param seconds:\n    :param nanoseconds:\n    :param tz:\n    :return: datetime\n    \"\"\"\n    from pytz import (\n        FixedOffset,\n        timezone,\n    )\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    days, hours = map(int, divmod(hours, 24))\n    t = DateTime.combine(\n        Date.from_ordinal(get_date_unix_epoch_ordinal() + days),\n        Time(hours, minutes, seconds, nanoseconds)\n    )\n    if tz is None:\n        return t\n    if isinstance(tz, int):\n        tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n        zone = FixedOffset(tz_offset_minutes)\n    else:\n        zone = timezone(tz)\n    return zone.localize(t)\n\n\ndef dehydrate_datetime(value):\n    \"\"\" Dehydrator for `datetime` values.\n\n    :param value:\n    :type value: datetime or DateTime\n    :return:\n    \"\"\"\n\n    def seconds_and_nanoseconds(dt):\n        if isinstance(dt, datetime):\n            dt = DateTime.from_native(dt)\n        zone_epoch = DateTime(1970, 1, 1, tzinfo=dt.tzinfo)\n        dt_clock_time = dt.to_clock_time()\n        zone_epoch_clock_time = zone_epoch.to_clock_time()\n        t = dt_clock_time - zone_epoch_clock_time\n        return t.seconds, t.nanoseconds\n\n    tz = value.tzinfo\n    if tz is None:\n        # without time zone\n        from pytz import utc\n        value = utc.localize(value)\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"d\", seconds, nanoseconds)\n    elif hasattr(tz, \"zone\") and tz.zone and isinstance(tz.zone, str):\n        # with named pytz time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"f\", seconds, nanoseconds, tz.zone)\n    elif hasattr(tz, \"key\") and tz.key and isinstance(tz.key, str):\n        # with named zoneinfo (Python 3.9+) time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"f\", seconds, nanoseconds, tz.key)\n    else:\n        # with time offset\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"F\", seconds, nanoseconds,\n                         int(tz.utcoffset(value).total_seconds()))\n\n\ndef hydrate_duration(months, days, seconds, nanoseconds):\n    \"\"\" Hydrator for `Duration` values.\n\n    :param months:\n    :param days:\n    :param seconds:\n    :param nanoseconds:\n    :return: `duration` namedtuple\n    \"\"\"\n    return Duration(months=months, days=days, seconds=seconds, nanoseconds=nanoseconds)\n\n\ndef dehydrate_duration(value):\n    \"\"\" Dehydrator for `duration` values.\n\n    :param value:\n    :type value: Duration\n    :return:\n    \"\"\"\n    return Structure(b\"E\", value.months, value.days, value.seconds, value.nanoseconds)\n\n", "contexts_below": "", "input_code": "def dehydrate_timedelta(value):\n\"\"\"\nDehydrator for `timedelta` values.\n\n:param value:\n:type value: timedelta\n:return:\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def dehydrate_timedelta(value):\n    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :return:\n    \"\"\"\n    months = 0\n    days = value.days\n    seconds = value.seconds\n    nanoseconds = 1000 * value.microseconds\n    return Structure(b\"E\", months, days, seconds, nanoseconds)", "signature": "def dehydrate_timedelta(value):", "completion_path": "neo4j/_codec/hydration/v1/temporal.py"}
{"ce_id": "62e60f37d76274f8a4026dfd", "namespace": "62e60f37d76274f8a4026dfd", "namespace_real": "neo4j._codec.hydration.v1.temporal.dehydrate_time", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "function", "class_name": null, "function_name": "dehydrate_time", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom datetime import (\n    datetime,\n    time,\n    timedelta,\n)\n\nfrom ....time import (\n    Date,\n    DateTime,\n    Duration,\n    Time,\n)\nfrom ...packstream import Structure\n\n\ndef get_date_unix_epoch():\n    return Date(1970, 1, 1)\n\n\ndef get_date_unix_epoch_ordinal():\n    return get_date_unix_epoch().to_ordinal()\n\n\ndef get_datetime_unix_epoch_utc():\n    from pytz import utc\n    return DateTime(1970, 1, 1, 0, 0, 0, utc)\n\n\ndef hydrate_date(days):\n    \"\"\" Hydrator for `Date` values.\n\n    :param days:\n    :return: Date\n    \"\"\"\n    return Date.from_ordinal(get_date_unix_epoch_ordinal() + days)\n\n\ndef dehydrate_date(value):\n    \"\"\" Dehydrator for `date` values.\n\n    :param value:\n    :type value: Date\n    :return:\n    \"\"\"\n    return Structure(b\"D\", value.toordinal() - get_date_unix_epoch().toordinal())\n\n\ndef hydrate_time(nanoseconds, tz=None):\n    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :return: Time\n    \"\"\"\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n    zone = FixedOffset(tz_offset_minutes)\n    return zone.localize(t)\n\n", "contexts_below": "\n def hydrate_datetime(seconds, nanoseconds, tz=None):\n     \"\"\" Hydrator for `DateTime` and `LocalDateTime` values.\n \n     :param seconds:\n     :param nanoseconds:\n     :param tz:\n     :return: datetime\n     \"\"\"\n     from pytz import (\n         FixedOffset,\n         timezone,\n     )\n     minutes, seconds = map(int, divmod(seconds, 60))\n     hours, minutes = map(int, divmod(minutes, 60))\n     days, hours = map(int, divmod(hours, 24))\n     t = DateTime.combine(\n         Date.from_ordinal(get_date_unix_epoch_ordinal() + days),\n         Time(hours, minutes, seconds, nanoseconds)\n     )\n     if tz is None:\n         return t\n     if isinstance(tz, int):\n         tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n         zone = FixedOffset(tz_offset_minutes)\n     else:\n         zone = timezone(tz)\n     return zone.localize(t)\n \n \n def dehydrate_datetime(value):\n     \"\"\" Dehydrator for `datetime` values.\n \n     :param value:\n     :type value: datetime or DateTime\n     :return:\n     \"\"\"\n \n     def seconds_and_nanoseconds(dt):\n         if isinstance(dt, datetime):\n             dt = DateTime.from_native(dt)\n         zone_epoch = DateTime(1970, 1, 1, tzinfo=dt.tzinfo)\n         dt_clock_time = dt.to_clock_time()\n         zone_epoch_clock_time = zone_epoch.to_clock_time()\n         t = dt_clock_time - zone_epoch_clock_time\n         return t.seconds, t.nanoseconds\n \n     tz = value.tzinfo\n     if tz is None:\n         # without time zone\n         from pytz import utc\n         value = utc.localize(value)\n         seconds, nanoseconds = seconds_and_nanoseconds(value)\n         return Structure(b\"d\", seconds, nanoseconds)\n     elif hasattr(tz, \"zone\") and tz.zone and isinstance(tz.zone, str):\n         # with named pytz time zone\n         seconds, nanoseconds = seconds_and_nanoseconds(value)\n         return Structure(b\"f\", seconds, nanoseconds, tz.zone)\n     elif hasattr(tz, \"key\") and tz.key and isinstance(tz.key, str):\n         # with named zoneinfo (Python 3.9+) time zone\n         seconds, nanoseconds = seconds_and_nanoseconds(value)\n         return Structure(b\"f\", seconds, nanoseconds, tz.key)\n     else:\n         # with time offset\n         seconds, nanoseconds = seconds_and_nanoseconds(value)\n         return Structure(b\"F\", seconds, nanoseconds,\n                          int(tz.utcoffset(value).total_seconds()))\n \n \n def hydrate_duration(months, days, seconds, nanoseconds):\n     \"\"\" Hydrator for `Duration` values.\n \n     :param months:\n     :param days:\n     :param seconds:\n     :param nanoseconds:\n     :return: `duration` namedtuple\n     \"\"\"\n     return Duration(months=months, days=days, seconds=seconds, nanoseconds=nanoseconds)\n \n \n def dehydrate_duration(value):\n     \"\"\" Dehydrator for `duration` values.\n \n     :param value:\n     :type value: Duration\n     :return:\n     \"\"\"\n     return Structure(b\"E\", value.months, value.days, value.seconds, value.nanoseconds)\n \n \n def dehydrate_timedelta(value):\n     \"\"\" Dehydrator for `timedelta` values.\n \n     :param value:\n     :type value: timedelta\n     :return:\n     \"\"\"\n     months = 0\n     days = value.days\n     seconds = value.seconds\n     nanoseconds = 1000 * value.microseconds\n     return Structure(b\"E\", months, days, seconds, nanoseconds)\n ", "input_code": "def dehydrate_time(value):\n\"\"\"\nDehydrator for `time` values.\n\n:param value:\n:type value: Time\n:return:\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :return:\n    \"\"\"\n    if isinstance(value, Time):\n        nanoseconds = value.ticks\n    elif isinstance(value, time):\n        nanoseconds = (3600000000000 * value.hour + 60000000000 * value.minute +\n                       1000000000 * value.second + 1000 * value.microsecond)\n    else:\n        raise TypeError(\"Value must be a neo4j.time.Time or a datetime.time\")\n    if value.tzinfo:\n        return Structure(b\"T\", nanoseconds,\n                         int(value.tzinfo.utcoffset(value).total_seconds()))\n    else:\n        return Structure(b\"t\", nanoseconds)", "signature": "def dehydrate_time(value):", "completion_path": "neo4j/_codec/hydration/v1/temporal.py"}
{"ce_id": "62e60f33d76274f8a4026de9", "namespace": "62e60f33d76274f8a4026de9", "namespace_real": "neo4j._codec.hydration.v1.spatial.dehydrate_point", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "function", "class_name": null, "function_name": "dehydrate_point", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom ...._spatial import (\n    Point,\n    srid_table,\n)\nfrom ...packstream import Structure\n\n\ndef hydrate_point(srid, *coordinates):\n    \"\"\" Create a new instance of a Point subclass from a raw\n    set of fields. The subclass chosen is determined by the\n    given SRID; a ValueError will be raised if no such\n    subclass can be found.\n    \"\"\"\n    try:\n        point_class, dim = srid_table[srid]\n    except KeyError:\n        point = Point(coordinates)\n        point.srid = srid\n        return point\n    else:\n        if len(coordinates) != dim:\n            raise ValueError(\"SRID %d requires %d coordinates (%d provided)\" % (srid, dim, len(coordinates)))\n        return point_class(coordinates)\n\n", "contexts_below": "\n __all__ = [\n     \"hydrate_point\",\n     \"dehydrate_point\",\n ]\n ", "input_code": "def dehydrate_point(value):\n\"\"\"\nDehydrator for Point data.\n\n:param value:\n:type value: Point\n:return:\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def dehydrate_point(value):\n    \"\"\" Dehydrator for Point data.\n\n    :param value:\n    :type value: Point\n    :return:\n    \"\"\"\n    dim = len(value)\n    if dim == 2:\n        return Structure(b\"X\", value.srid, *value)\n    elif dim == 3:\n        return Structure(b\"Y\", value.srid, *value)\n    else:\n        raise ValueError(\"Cannot dehydrate Point with %d dimensions\" % dim)", "signature": "def dehydrate_point(value):", "completion_path": "neo4j/_codec/hydration/v1/spatial.py"}
{"ce_id": "62e60ed4d76274f8a4026da0", "namespace": "62e60ed4d76274f8a4026da0", "namespace_real": "neo4j._data.keys", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "class", "class_name": "_data", "function_name": "keys", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom abc import (\n    ABCMeta,\n    abstractmethod,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n    Set,\n)\nfrom functools import reduce\nfrom operator import xor as xor_operator\n\nfrom ._codec.hydration import BrokenHydrationObject\nfrom ._conf import iter_items\nfrom ._meta import deprecated\nfrom .exceptions import BrokenRecordError\nfrom .graph import (\n    Node,\n    Path,\n    Relationship,\n)\n\n\nclass Record(tuple, Mapping):\n    \"\"\" A :class:`.Record` is an immutable ordered collection of key-value\n    pairs. It is generally closer to a :py:class:`namedtuple` than to a\n    :py:class:`OrderedDict` in as much as iteration of the collection will\n    yield values rather than keys.\n    \"\"\"\n\n    __keys = None\n\n    def __new__(cls, iterable=()):\n        keys = []\n        values = []\n        for key, value in iter_items(iterable):\n            keys.append(key)\n            values.append(value)\n        inst = tuple.__new__(cls, values)\n        inst.__keys = tuple(keys)\n        return inst\n\n    def _broken_record_error(self, index):\n        return BrokenRecordError(\n            f\"Record contains broken data at {index} ('{self.__keys[index]}')\"\n        )\n\n    def _super_getitem_single(self, index):\n        value = super().__getitem__(index)\n        if isinstance(value, BrokenHydrationObject):\n            raise self._broken_record_error(index) from value.error\n        return value\n\n    def __repr__(self):\n        return \"<%s %s>\" % (\n            self.__class__.__name__,\n            \" \".join(\"%s=%r\" % (field, value)\n                     for field, value in zip(self.__keys, super().__iter__()))\n        )\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __eq__(self, other):\n        \"\"\" In order to be flexible regarding comparison, the equality rules\n        for a record permit comparison with any other Sequence or Mapping.\n\n        :param other:\n        :return:\n        \"\"\"\n        compare_as_sequence = isinstance(other, Sequence)\n        compare_as_mapping = isinstance(other, Mapping)\n        if compare_as_sequence and compare_as_mapping:\n            return list(self) == list(other) and dict(self) == dict(other)\n        elif compare_as_sequence:\n            return list(self) == list(other)\n        elif compare_as_mapping:\n            return dict(self) == dict(other)\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return reduce(xor_operator, map(hash, self.items()))\n\n    def __iter__(self):\n        for i, v in enumerate(super().__iter__()):\n            if isinstance(v, BrokenHydrationObject):\n                raise self._broken_record_error(i) from v.error\n            yield v\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            keys = self.__keys[key]\n            values = super().__getitem__(key)\n            return self.__class__(zip(keys, values))\n        try:\n            index = self.index(key)\n        except IndexError:\n            return None\n        else:\n            return self._super_getitem_single(index)\n\n    # TODO: 6.0 - remove\n    @deprecated(\"This method is deprecated and will be removed in the future.\")\n    def __getslice__(self, start, stop):\n        key = slice(start, stop)\n        keys = self.__keys[key]\n        values = tuple(self)[key]\n        return self.__class__(zip(keys, values))\n\n    def get(self, key, default=None):\n        \"\"\" Obtain a value from the record by key, returning a default\n        value if the key does not exist.\n\n        :param key: a key\n        :param default: default value\n        :return: a value\n        \"\"\"\n        try:\n            index = self.__keys.index(str(key))\n        except ValueError:\n            return default\n        if 0 <= index < len(self):\n            return self._super_getitem_single(index)\n        else:\n            return default\n\n    def index(self, key):\n        \"\"\" Return the index of the given item.\n\n        :param key: a key\n        :return: index\n        :rtype: int\n        \"\"\"\n        if isinstance(key, int):\n            if 0 <= key < len(self.__keys):\n                return key\n            raise IndexError(key)\n        elif isinstance(key, str):\n            try:\n                return self.__keys.index(key)\n            except ValueError:\n                raise KeyError(key)\n        else:\n            raise TypeError(key)\n\n    def value(self, key=0, default=None):\n        \"\"\" Obtain a single value from the record by index or key. If no\n        index or key is specified, the first value is returned. If the\n        specified item does not exist, the default value is returned.\n\n        :param key: an index or key\n        :param default: default value\n        :return: a single value\n        \"\"\"\n        try:\n            index = self.index(key)\n        except (IndexError, KeyError):\n            return default\n        else:\n            return self[index]\n", "contexts_below": "    def values(self, *keys):\n         \"\"\" Return the values of the record, optionally filtering to\n         include only certain values by index or key.\n \n         :param keys: indexes or keys of the items to include; if none\n                      are provided, all values will be included\n         :return: list of values\n         :rtype: list\n         \"\"\"\n         if keys:\n             d = []\n             for key in keys:\n                 try:\n                     i = self.index(key)\n                 except KeyError:\n                     d.append(None)\n                 else:\n                     d.append(self[i])\n             return d\n         return list(self)\n \n     def items(self, *keys):\n         \"\"\" Return the fields of the record as a list of key and value tuples\n \n         :return: a list of value tuples\n         :rtype: list\n         \"\"\"\n         if keys:\n             d = []\n             for key in keys:\n                 try:\n                     i = self.index(key)\n                 except KeyError:\n                     d.append((key, None))\n                 else:\n                     d.append((self.__keys[i], self[i]))\n             return d\n         return list((self.__keys[i], self._super_getitem_single(i))\n                     for i in range(len(self)))\n \n     def data(self, *keys):\n         \"\"\" Return the keys and values of this record as a dictionary,\n         optionally including only certain values by index or key. Keys\n         provided in the items that are not in the record will be\n         inserted with a value of :const:`None`; indexes provided\n         that are out of bounds will trigger an :exc:`IndexError`.\n \n         :param keys: indexes or keys of the items to include; if none\n                       are provided, all values will be included\n         :return: dictionary of values, keyed by field name\n         :raises: :exc:`IndexError` if an out-of-bounds index is specified\n         \"\"\"\n         return RecordExporter().transform(dict(self.items(*keys)))\n \n \n class DataTransformer(metaclass=ABCMeta):\n     \"\"\" Abstract base class for transforming data from one form into\n     another.\n     \"\"\"\n \n     @abstractmethod\n     def transform(self, x):\n         \"\"\" Transform a value, or collection of values.\n \n         :param x: input value\n         :return: output value\n         \"\"\"\n \n \n class RecordExporter(DataTransformer):\n     \"\"\" Transformer class used by the :meth:`.Record.data` method.\n     \"\"\"\n \n     def transform(self, x):\n         if isinstance(x, Node):\n             return self.transform(dict(x))\n         elif isinstance(x, Relationship):\n             return (self.transform(dict(x.start_node)),\n                     x.__class__.__name__,\n                     self.transform(dict(x.end_node)))\n         elif isinstance(x, Path):\n             path = [self.transform(x.start_node)]\n             for i, relationship in enumerate(x.relationships):\n                 path.append(self.transform(relationship.__class__.__name__))\n                 path.append(self.transform(x.nodes[i + 1]))\n             return path\n         elif isinstance(x, str):\n             return x\n         elif isinstance(x, Sequence):\n             t = type(x)\n             return t(map(self.transform, x))\n         elif isinstance(x, Set):\n             t = type(x)\n             return t(map(self.transform, x))\n         elif isinstance(x, Mapping):\n             t = type(x)\n             return t((k, self.transform(v)) for k, v in x.items())\n         else:\n             return x\n \n \n class RecordTableRowExporter(DataTransformer):\n     \"\"\"Transformer class used by the :meth:`.Result.to_df` method.\"\"\"\n \n     def transform(self, x):\n         assert isinstance(x, Mapping)\n         t = type(x)\n         return t(item\n                  for k, v in x.items()\n                  for item in self._transform(\n                      v, prefix=k.replace(\"\\\\\", \"\\\\\\\\\").replace(\".\", \"\\\\.\")\n                  ).items())\n \n     def _transform(self, x, prefix):\n         if isinstance(x, Node):\n             res = {\n                 \"%s().element_id\" % prefix: x.element_id,\n                 \"%s().labels\" % prefix: x.labels,\n             }\n             res.update((\"%s().prop.%s\" % (prefix, k), v) for k, v in x.items())\n             return res\n         elif isinstance(x, Relationship):\n             res = {\n                 \"%s->.element_id\" % prefix: x.element_id,\n                 \"%s->.start.element_id\" % prefix: x.start_node.element_id,\n                 \"%s->.end.element_id\" % prefix: x.end_node.element_id,\n                 \"%s->.type\" % prefix: x.__class__.__name__,\n             }\n             res.update((\"%s->.prop.%s\" % (prefix, k), v) for k, v in x.items())\n             return res\n         elif isinstance(x, Path) or isinstance(x, str):\n             return {prefix: x}\n         elif isinstance(x, Sequence):\n             return dict(\n                 item\n                 for i, v in enumerate(x)\n                 for item in self._transform(\n                     v, prefix=\"%s[].%i\" % (prefix, i)\n                 ).items()\n             )\n         elif isinstance(x, Mapping):\n             t = type(x)\n             return t(\n                 item\n                 for k, v in x.items()\n                 for item in self._transform(\n                     v, prefix=\"%s{}.%s\" % (prefix, k.replace(\"\\\\\", \"\\\\\\\\\")\n                                                     .replace(\".\", \"\\\\.\"))\n                 ).items()\n             )\n         else:\n             return {prefix: x}\n ", "input_code": "def keys(self):\n\"\"\"\nReturn the keys of the record.\n\n:return: list of key names\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def keys(self):\n        \"\"\" Return the keys of the record.\n\n        :return: list of key names\n        \"\"\"\n        return list(self.__keys)", "signature": "def keys(self):", "completion_path": "neo4j/_data.py"}
{"ce_id": "62e60ecfd76274f8a4026d6a", "namespace": "62e60ecfd76274f8a4026d6a", "namespace_real": "neo4j._sync.io._bolt.protocol_handlers", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "class", "class_name": "_bolt", "function_name": "protocol_handlers", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport abc\nimport asyncio\nfrom collections import deque\nfrom logging import getLogger\nfrom time import perf_counter\n\nfrom ..._async_compat.network import BoltSocket\nfrom ..._async_compat.util import Util\nfrom ..._codec.hydration import v1 as hydration_v1\nfrom ..._codec.packstream import v1 as packstream_v1\nfrom ..._conf import PoolConfig\nfrom ..._exceptions import (\n    BoltError,\n    BoltHandshakeError,\n    SocketDeadlineExceeded,\n)\nfrom ..._meta import get_user_agent\nfrom ...addressing import Address\nfrom ...api import (\n    ServerInfo,\n    Version,\n)\nfrom ...exceptions import (\n    AuthError,\n    DriverError,\n    IncompleteCommit,\n    ServiceUnavailable,\n    SessionExpired,\n)\nfrom ._common import (\n    CommitResponse,\n    Inbox,\n    Outbox,\n)\n\n\n# Set up logger\nlog = getLogger(\"neo4j\")\n\n\nclass Bolt:\n    \"\"\" Server connection for Bolt protocol.\n\n    A :class:`.Bolt` should be constructed following a\n    successful .open()\n\n    Bolt handshake and takes the socket over which\n    the handshake was carried out.\n    \"\"\"\n\n    # TODO: let packer/unpacker know of hydration (give them hooks?)\n    # TODO: make sure query parameter dehydration gets clear error message.\n\n    PACKER_CLS = packstream_v1.Packer\n    UNPACKER_CLS = packstream_v1.Unpacker\n    HYDRATION_HANDLER_CLS = hydration_v1.HydrationHandler\n\n    MAGIC_PREAMBLE = b\"\\x60\\x60\\xB0\\x17\"\n\n    PROTOCOL_VERSION = None\n\n    # flag if connection needs RESET to go back to READY state\n    is_reset = False\n\n    # The socket\n    in_use = False\n\n    # When the connection was last put back into the pool\n    idle_since = float(\"-inf\")\n\n    # The socket\n    _closing = False\n    _closed = False\n\n    # The socket\n    _defunct = False\n\n    #: The pool of which this connection is a member\n    pool = None\n\n    # Store the id of the most recent ran query to be able to reduce sent bits by\n    # using the default (-1) to refer to the most recent query when pulling\n    # results for it.\n    most_recent_qid = None\n\n    def __init__(self, unresolved_address, sock, max_connection_lifetime, *,\n                 auth=None, user_agent=None, routing_context=None):\n        self.unresolved_address = unresolved_address\n        self.socket = sock\n        self.local_port = self.socket.getsockname()[1]\n        self.server_info = ServerInfo(Address(sock.getpeername()),\n                                      self.PROTOCOL_VERSION)\n        # so far `connection.recv_timeout_seconds` is the only available\n        # configuration hint that exists. Therefore, all hints can be stored at\n        # connection level. This might change in the future.\n        self.configuration_hints = {}\n        self.patch = {}\n        self.outbox = Outbox(\n            self.socket, on_error=self._set_defunct_write,\n            packer_cls=self.PACKER_CLS\n        )\n        self.inbox = Inbox(\n            self.socket, on_error=self._set_defunct_read,\n            unpacker_cls=self.UNPACKER_CLS\n        )\n        self.hydration_handler = self.HYDRATION_HANDLER_CLS()\n        self.responses = deque()\n        self._max_connection_lifetime = max_connection_lifetime\n        self._creation_timestamp = perf_counter()\n        self.routing_context = routing_context\n        self.idle_since = perf_counter()\n\n        # Determine the user agent\n        if user_agent:\n            self.user_agent = user_agent\n        else:\n            self.user_agent = get_user_agent()\n\n        # Determine auth details\n        if not auth:\n            self.auth_dict = {}\n        elif isinstance(auth, tuple) and 2 <= len(auth) <= 3:\n            from neo4j import Auth\n            self.auth_dict = vars(Auth(\"basic\", *auth))\n        else:\n            try:\n                self.auth_dict = vars(auth)\n            except (KeyError, TypeError):\n                raise AuthError(\"Cannot determine auth details from %r\" % auth)\n\n        # Check for missing password\n        try:\n            credentials = self.auth_dict[\"credentials\"]\n        except KeyError:\n            pass\n        else:\n            if credentials is None:\n                raise AuthError(\"Password cannot be None\")\n\n    def __del__(self):\n        if not asyncio.iscoroutinefunction(self.close):\n            self.close()\n\n    @property\n    @abc.abstractmethod\n    def supports_multiple_results(self):\n        \"\"\" Boolean flag to indicate if the connection version supports multiple\n        queries to be buffered on the server side (True) or if all results need\n        to be eagerly pulled before sending the next RUN (False).\n        \"\"\"\n        pass\n\n    @property\n    @abc.abstractmethod\n    def supports_multiple_databases(self):\n        \"\"\" Boolean flag to indicate if the connection version supports multiple\n        databases.\n        \"\"\"\n        pass\n\n    @classmethod", "contexts_below": "    @classmethod\n     def version_list(cls, versions, limit=4):\n         \"\"\" Return a list of supported protocol versions in order of\n         preference. The number of protocol versions (or ranges)\n         returned is limited to four.\n         \"\"\"\n         # In fact, 4.3 is the fist version to support ranges. However, the\n         # range support got backported to 4.2. But even if the server is too\n         # old to have the backport, negotiating BOLT 4.1 is no problem as it's\n         # equivalent to 4.2\n         first_with_range_support = Version(4, 2)\n         result = []\n         for version in versions:\n             if (result\n                     and version >= first_with_range_support\n                     and result[-1][0] == version[0]\n                     and result[-1][1][1] == version[1] + 1):\n                 # can use range to encompass this version\n                 result[-1][1][1] = version[1]\n                 continue\n             result.append(Version(version[0], [version[1], version[1]]))\n             if len(result) == 4:\n                 break\n         return result\n \n     @classmethod\n     def get_handshake(cls):\n         \"\"\" Return the supported Bolt versions as bytes.\n         The length is 16 bytes as specified in the Bolt version negotiation.\n         :return: bytes\n         \"\"\"\n         supported_versions = sorted(cls.protocol_handlers().keys(), reverse=True)\n         offered_versions = cls.version_list(supported_versions)\n         return b\"\".join(version.to_bytes() for version in offered_versions).ljust(16, b\"\\x00\")\n \n     @classmethod\n     def ping(cls, address, *, timeout=None, **config):\n         \"\"\" Attempt to establish a Bolt connection, returning the\n         agreed Bolt protocol version if successful.\n         \"\"\"\n         config = PoolConfig.consume(config)\n         try:\n             s, protocol_version, handshake, data = \\\n                 BoltSocket.connect(\n                     address,\n                     timeout=timeout,\n                     custom_resolver=config.resolver,\n                     ssl_context=config.get_ssl_context(),\n                     keep_alive=config.keep_alive,\n                 )\n         except (ServiceUnavailable, SessionExpired, BoltHandshakeError):\n             return None\n         else:\n             BoltSocket.close_socket(s)\n             return protocol_version\n \n     @classmethod\n     def open(\n         cls, address, *, auth=None, timeout=None, routing_context=None,\n         **pool_config\n     ):\n         \"\"\"Open a new Bolt connection to a given server address.\n \n         :param address:\n         :param auth:\n         :param timeout: the connection timeout in seconds\n         :param routing_context: dict containing routing context\n         :param pool_config:\n \n         :return: connected Bolt instance\n \n         :raise BoltHandshakeError:\n             raised if the Bolt Protocol can not negotiate a protocol version.\n         :raise ServiceUnavailable: raised if there was a connection issue.\n         \"\"\"\n         def time_remaining():\n             if timeout is None:\n                 return None\n             t = timeout - (perf_counter() - t0)\n             return t if t > 0 else 0\n \n         t0 = perf_counter()\n         pool_config = PoolConfig.consume(pool_config)\n \n         socket_connection_timeout = pool_config.connection_timeout\n         if socket_connection_timeout is None:\n             socket_connection_timeout = time_remaining()\n         elif timeout is not None:\n             socket_connection_timeout = min(pool_config.connection_timeout,\n                                             time_remaining())\n         s, pool_config.protocol_version, handshake, data = \\\n             BoltSocket.connect(\n                 address,\n                 timeout=socket_connection_timeout,\n                 custom_resolver=pool_config.resolver,\n                 ssl_context=pool_config.get_ssl_context(),\n                 keep_alive=pool_config.keep_alive,\n             )\n \n         # Carry out Bolt subclass imports locally to avoid circular dependency\n         # issues.\n         if pool_config.protocol_version == (3, 0):\n             from ._bolt3 import Bolt3\n             bolt_cls = Bolt3\n         # Implementation for 4.0 exists, but there was no space left in the\n         # handshake to offer this version to the server. Hence, the server\n         # should never request us to speak bolt 4.0.\n         # elif pool_config.protocol_version == (4, 0):\n         #     from ._bolt4 import AsyncBolt4x0\n         #     bolt_cls = AsyncBolt4x0\n         elif pool_config.protocol_version == (4, 1):\n             from ._bolt4 import Bolt4x1\n             bolt_cls = Bolt4x1\n         elif pool_config.protocol_version == (4, 2):\n             from ._bolt4 import Bolt4x2\n             bolt_cls = Bolt4x2\n         elif pool_config.protocol_version == (4, 3):\n             from ._bolt4 import Bolt4x3\n             bolt_cls = Bolt4x3\n         elif pool_config.protocol_version == (4, 4):\n             from ._bolt4 import Bolt4x4\n             bolt_cls = Bolt4x4\n         elif pool_config.protocol_version == (5, 0):\n             from ._bolt5 import Bolt5x0\n             bolt_cls = Bolt5x0\n         else:\n             log.debug(\"[#%04X]  S: <CLOSE>\", s.getsockname()[1])\n             BoltSocket.close_socket(s)\n \n             supported_versions = cls.protocol_handlers().keys()\n             raise BoltHandshakeError(\n                 \"The Neo4J server does not support communication with this \"\n                 \"driver. This driver has support for Bolt protocols \"\n                 \"{}\".format(tuple(map(str, supported_versions))),\n                 address=address, request_data=handshake, response_data=data\n             )\n \n         connection = bolt_cls(\n             address, s, pool_config.max_connection_lifetime, auth=auth,\n             user_agent=pool_config.user_agent, routing_context=routing_context\n         )\n \n         try:\n             connection.socket.set_deadline(time_remaining())\n             try:\n                 connection.hello()\n             finally:\n                 connection.socket.set_deadline(None)\n         except Exception:\n             connection.close_non_blocking()\n             raise\n \n         return connection\n \n     @property\n     @abc.abstractmethod\n     def encrypted(self):\n         pass\n \n     @property\n     @abc.abstractmethod\n     def der_encoded_server_certificate(self):\n         pass\n \n     @abc.abstractmethod\n     def hello(self, dehydration_hooks=None, hydration_hooks=None):\n         \"\"\" Appends a HELLO message to the outgoing queue, sends it and consumes\n          all remaining messages.\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     def route(\n         self, database=None, imp_user=None, bookmarks=None,\n         dehydration_hooks=None, hydration_hooks=None\n     ):\n         \"\"\" Fetch a routing table from the server for the given\n         `database`. For Bolt 4.3 and above, this appends a ROUTE\n         message; for earlier versions, a procedure call is made via\n         the regular Cypher execution mechanism. In all cases, this is\n         sent to the network, and a response is fetched.\n \n         :param database: database for which to fetch a routing table\n             Requires Bolt 4.0+.\n         :param imp_user: the user to impersonate\n             Requires Bolt 4.4+.\n         :param bookmarks: iterable of bookmark values after which this\n                           transaction should begin\n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     def run(self, query, parameters=None, mode=None, bookmarks=None,\n             metadata=None, timeout=None, db=None, imp_user=None,\n             dehydration_hooks=None, hydration_hooks=None,\n             **handlers):\n         \"\"\" Appends a RUN message to the output queue.\n \n         :param query: Cypher query string\n         :param parameters: dictionary of Cypher parameters\n         :param mode: access mode for routing - \"READ\" or \"WRITE\" (default)\n         :param bookmarks: iterable of bookmark values after which this transaction should begin\n         :param metadata: custom metadata dictionary to attach to the transaction\n         :param timeout: timeout for transaction execution (seconds)\n         :param db: name of the database against which to begin the transaction\n             Requires Bolt 4.0+.\n         :param imp_user: the user to impersonate\n             Requires Bolt 4.4+.\n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         :param handlers: handler functions passed into the returned Response object\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     def discard(self, n=-1, qid=-1, dehydration_hooks=None,\n                 hydration_hooks=None, **handlers):\n         \"\"\" Appends a DISCARD message to the output queue.\n \n         :param n: number of records to discard, default = -1 (ALL)\n         :param qid: query ID to discard for, default = -1 (last query)\n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         :param handlers: handler functions passed into the returned Response object\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     def pull(self, n=-1, qid=-1, dehydration_hooks=None, hydration_hooks=None,\n              **handlers):\n         \"\"\" Appends a PULL message to the output queue.\n \n         :param n: number of records to pull, default = -1 (ALL)\n         :param qid: query ID to pull for, default = -1 (last query)\n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         :param handlers: handler functions passed into the returned Response object\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     def begin(self, mode=None, bookmarks=None, metadata=None, timeout=None,\n               db=None, imp_user=None, dehydration_hooks=None,\n               hydration_hooks=None, **handlers):\n         \"\"\" Appends a BEGIN message to the output queue.\n \n         :param mode: access mode for routing - \"READ\" or \"WRITE\" (default)\n         :param bookmarks: iterable of bookmark values after which this transaction should begin\n         :param metadata: custom metadata dictionary to attach to the transaction\n         :param timeout: timeout for transaction execution (seconds)\n         :param db: name of the database against which to begin the transaction\n             Requires Bolt 4.0+.\n         :param imp_user: the user to impersonate\n             Requires Bolt 4.4+\n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         :param handlers: handler functions passed into the returned Response object\n         :return: Response object\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     def commit(self, dehydration_hooks=None, hydration_hooks=None, **handlers):\n         \"\"\" Appends a COMMIT message to the output queue.\n \n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     def rollback(self, dehydration_hooks=None, hydration_hooks=None, **handlers):\n         \"\"\" Appends a ROLLBACK message to the output queue.\n \n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\"\"\"\n         pass\n \n     @abc.abstractmethod\n     def reset(self, dehydration_hooks=None, hydration_hooks=None):\n         \"\"\" Appends a RESET message to the outgoing queue, sends it and consumes\n          all remaining messages.\n \n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     def goodbye(self, dehydration_hooks=None, hydration_hooks=None):\n         \"\"\"Append a GOODBYE message to the outgoing queue.\n \n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         \"\"\"\n         pass\n \n     def new_hydration_scope(self):\n         return self.hydration_handler.new_hydration_scope()\n \n     def _append(self, signature, fields=(), response=None,\n                 dehydration_hooks=None):\n         \"\"\" Appends a message to the outgoing queue.\n \n         :param signature: the signature of the message\n         :param fields: the fields of the message as a tuple\n         :param response: a response object to handle callbacks\n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         \"\"\"\n         self.outbox.append_message(signature, fields, dehydration_hooks)\n         self.responses.append(response)\n \n     def _send_all(self):\n         if self.outbox.flush():\n             self.idle_since = perf_counter()\n \n     def send_all(self):\n         \"\"\" Send all queued messages to the server.\n         \"\"\"\n         if self.closed():\n             raise ServiceUnavailable(\n                 \"Failed to write to closed connection {!r} ({!r})\".format(\n                     self.unresolved_address, self.server_info.address\n                 )\n             )\n         if self.defunct():\n             raise ServiceUnavailable(\n                 \"Failed to write to defunct connection {!r} ({!r})\".format(\n                     self.unresolved_address, self.server_info.address\n                 )\n             )\n \n         self._send_all()\n \n     @abc.abstractmethod\n     def _process_message(self, tag, fields):\n         \"\"\" Receive at most one message from the server, if available.\n \n         :return: 2-tuple of number of detail messages and number of summary\n                  messages fetched\n         \"\"\"\n         pass\n \n     def fetch_message(self):\n         if self._closed:\n             raise ServiceUnavailable(\n                 \"Failed to read from closed connection {!r} ({!r})\".format(\n                     self.unresolved_address, self.server_info.address\n                 )\n             )\n         if self._defunct:\n             raise ServiceUnavailable(\n                 \"Failed to read from defunct connection {!r} ({!r})\".format(\n                     self.unresolved_address, self.server_info.address\n                 )\n             )\n         if not self.responses:\n             return 0, 0\n \n         # Receive exactly one message\n         tag, fields = self.inbox.pop(\n             hydration_hooks=self.responses[0].hydration_hooks\n         )\n         res = self._process_message(tag, fields)\n         self.idle_since = perf_counter()\n         return res\n \n     def fetch_all(self):\n         \"\"\" Fetch all outstanding messages.\n \n         :return: 2-tuple of number of detail messages and number of summary\n                  messages fetched\n         \"\"\"\n         detail_count = summary_count = 0\n         while self.responses:\n             response = self.responses[0]\n             while not response.complete:\n                 detail_delta, summary_delta = self.fetch_message()\n                 detail_count += detail_delta\n                 summary_count += summary_delta\n         return detail_count, summary_count\n \n     def _set_defunct_read(self, error=None, silent=False):\n         message = \"Failed to read from defunct connection {!r} ({!r})\".format(\n             self.unresolved_address, self.server_info.address\n         )\n         self._set_defunct(message, error=error, silent=silent)\n \n     def _set_defunct_write(self, error=None, silent=False):\n         message = \"Failed to write data to connection {!r} ({!r})\".format(\n             self.unresolved_address, self.server_info.address\n         )\n         self._set_defunct(message, error=error, silent=silent)\n \n     def _set_defunct(self, message, error=None, silent=False):\n         from ._pool import BoltPool\n         direct_driver = isinstance(self.pool, BoltPool)\n \n         if error:\n             log.debug(\"[#%04X]  %r\", self.socket.getsockname()[1], error)\n         log.error(message)\n         # We were attempting to receive data but the connection\n         # has unexpectedly terminated. So, we need to close the\n         # connection from the client side, and remove the address\n         # from the connection pool.\n         self._defunct = True\n         if not self._closing:\n             # If we fail while closing the connection, there is no need to\n             # remove the connection from the pool, nor to try to close the\n             # connection again.\n             self.close()\n             if self.pool:\n                 self.pool.deactivate(address=self.unresolved_address)\n         # Iterate through the outstanding responses, and if any correspond\n         # to COMMIT requests then raise an error to signal that we are\n         # unable to confirm that the COMMIT completed successfully.\n         if silent:\n             return\n         for response in self.responses:\n             if isinstance(response, CommitResponse):\n                 if error:\n                     raise IncompleteCommit(message) from error\n                 else:\n                     raise IncompleteCommit(message)\n \n         if direct_driver:\n             if error:\n                 raise ServiceUnavailable(message) from error\n             else:\n                 raise ServiceUnavailable(message)\n         else:\n             if error:\n                 raise SessionExpired(message) from error\n             else:\n                 raise SessionExpired(message)\n \n     def stale(self):\n         return (self._stale\n                 or (0 <= self._max_connection_lifetime\n                     <= perf_counter() - self._creation_timestamp))\n \n     _stale = False\n \n     def set_stale(self):\n         self._stale = True\n \n     def close(self):\n         \"\"\"Close the connection.\"\"\"\n         if self._closed or self._closing:\n             return\n         self._closing = True\n         if not self._defunct:\n             self.goodbye()\n             try:\n                 self._send_all()\n             except (OSError, BoltError, DriverError):\n                 pass\n         log.debug(\"[#%04X]  C: <CLOSE>\", self.local_port)\n         try:\n             self.socket.close()\n         except OSError:\n             pass\n         finally:\n             self._closed = True\n \n     def close_non_blocking(self):\n         \"\"\"Set the socket to non-blocking and close it.\n \n         This will try to send the `GOODBYE` message (given the socket is not\n         marked as defunct). However, should the write operation require\n         blocking (e.g., a full network buffer), then the socket will be closed\n         immediately (without `GOODBYE` message).\n         \"\"\"\n         if self._closed or self._closing:\n             return\n         self.socket.settimeout(0)\n         self.close()\n \n     def closed(self):\n         return self._closed\n \n     def defunct(self):\n         return self._defunct\n \n     def is_idle_for(self, timeout):\n         \"\"\"Check if connection has been idle for at least the given timeout.\n \n         :param timeout: timeout in seconds\n         :type timeout: float\n \n         :rtype: bool\n         \"\"\"\n         return perf_counter() - self.idle_since > timeout\n \n \n BoltSocket.Bolt = Bolt\n ", "input_code": "@classmethod\ndef protocol_handlers(cls, protocol_version=None):\n\"\"\"\nReturn a dictionary of available Bolt protocol handlers,\nkeyed by version tuple. If an explicit protocol version is\nprovided, the dictionary will contain either zero or one items,\ndepending on whether that version is supported. If no protocol\nversion is provided, all available versions will be returned.\n\n:param protocol_version: tuple identifying a specific protocol\n    version (e.g. (3, 5)) or None\n:return: dictionary of version tuple to handler class for all\n    relevant and supported protocol versions\n:raise TypeError: if protocol version is not passed in a tuple\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @classmethod\n    def protocol_handlers(cls, protocol_version=None):\n        \"\"\" Return a dictionary of available Bolt protocol handlers,\n        keyed by version tuple. If an explicit protocol version is\n        provided, the dictionary will contain either zero or one items,\n        depending on whether that version is supported. If no protocol\n        version is provided, all available versions will be returned.\n\n        :param protocol_version: tuple identifying a specific protocol\n            version (e.g. (3, 5)) or None\n        :return: dictionary of version tuple to handler class for all\n            relevant and supported protocol versions\n        :raise TypeError: if protocol version is not passed in a tuple\n        \"\"\"\n\n        # Carry out Bolt subclass imports locally to avoid circular dependency issues.\n        from ._bolt3 import Bolt3\n        from ._bolt4 import (\n            Bolt4x1,\n            Bolt4x2,\n            Bolt4x3,\n            Bolt4x4,\n        )\n        from ._bolt5 import Bolt5x0\n\n        handlers = {\n            Bolt3.PROTOCOL_VERSION: Bolt3,\n            # 4.0 unsupported because no space left in the handshake\n            Bolt4x1.PROTOCOL_VERSION: Bolt4x1,\n            Bolt4x2.PROTOCOL_VERSION: Bolt4x2,\n            Bolt4x3.PROTOCOL_VERSION: Bolt4x3,\n            Bolt4x4.PROTOCOL_VERSION: Bolt4x4,\n            Bolt5x0.PROTOCOL_VERSION: Bolt5x0,\n        }\n\n        if protocol_version is None:\n            return handlers\n\n        if not isinstance(protocol_version, tuple):\n            raise TypeError(\"Protocol version must be specified as a tuple\")\n\n        if protocol_version in handlers:\n            return {protocol_version: handlers[protocol_version]}\n\n        return {}", "signature": "@classmethod\ndef protocol_handlers(cls, protocol_version=None):", "completion_path": "neo4j/_sync/io/_bolt.py"}
{"ce_id": "62e60e49d76274f8a4026d25", "namespace": "62e60e49d76274f8a4026d25", "namespace_real": "neo4j.work.query.unit_of_work", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "function", "class_name": null, "function_name": "unit_of_work", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nclass Query:\n    \"\"\" Create a new query.\n\n    :param text: The query text.\n    :type text: str\n    :param metadata: metadata attached to the query.\n    :type metadata: dict\n    :param timeout: seconds.\n    :type timeout: float or :const:`None`\n    \"\"\"\n    def __init__(self, text, metadata=None, timeout=None):\n        self.text = text\n\n        self.metadata = metadata\n        self.timeout = timeout\n\n    def __str__(self):\n        return str(self.text)\n\n", "contexts_below": "", "input_code": "def unit_of_work(metadata=None, timeout=None):\n\"\"\"\nThis function is a decorator for transaction functions that allows extra control over how the transaction is carried out.\n\nFor example, a timeout may be applied::\n\n    from neo4j import unit_of_work\n\n    @unit_of_work(timeout=100)\n    def count_people_tx(tx):\n        result = tx.run(\"MATCH (a:Person) RETURN count(a) AS persons\")\n        record = result.single()\n        return record[\"persons\"]\n\n:param metadata:\n    a dictionary with metadata.\n    Specified metadata will be attached to the executing transaction and visible in the output of ``dbms.listQueries`` and ``dbms.listTransactions`` procedures.\n    It will also get logged to the ``query.log``.\n    This functionality makes it easier to tag transactions and is equivalent to ``dbms.setTXMetaData`` procedure, see https://neo4j.com/docs/operations-manual/current/reference/procedures/ for procedure reference.\n:type metadata: dict\n\n:param timeout:\n    the transaction timeout in seconds.\n    Transactions that execute longer than the configured timeout will be terminated by the database.\n    This functionality allows to limit query/transaction execution time.\n    Specified timeout overrides the default timeout configured in the database using ``dbms.transaction.timeout`` setting.\n    Value should not represent a negative duration.\n    A zero duration will make the transaction execute indefinitely.\n    None will use the default timeout configured in the database.\n:type timeout: float or :const:`None`\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def unit_of_work(metadata=None, timeout=None):\n    \"\"\"This function is a decorator for transaction functions that allows extra control over how the transaction is carried out.\n\n    For example, a timeout may be applied::\n\n        from neo4j import unit_of_work\n\n        @unit_of_work(timeout=100)\n        def count_people_tx(tx):\n            result = tx.run(\"MATCH (a:Person) RETURN count(a) AS persons\")\n            record = result.single()\n            return record[\"persons\"]\n\n    :param metadata:\n        a dictionary with metadata.\n        Specified metadata will be attached to the executing transaction and visible in the output of ``dbms.listQueries`` and ``dbms.listTransactions`` procedures.\n        It will also get logged to the ``query.log``.\n        This functionality makes it easier to tag transactions and is equivalent to ``dbms.setTXMetaData`` procedure, see https://neo4j.com/docs/operations-manual/current/reference/procedures/ for procedure reference.\n    :type metadata: dict\n\n    :param timeout:\n        the transaction timeout in seconds.\n        Transactions that execute longer than the configured timeout will be terminated by the database.\n        This functionality allows to limit query/transaction execution time.\n        Specified timeout overrides the default timeout configured in the database using ``dbms.transaction.timeout`` setting.\n        Value should not represent a negative duration.\n        A zero duration will make the transaction execute indefinitely.\n        None will use the default timeout configured in the database.\n    :type timeout: float or :const:`None`\n    \"\"\"\n\n    def wrapper(f):\n\n        def wrapped(*args, **kwargs):\n            return f(*args, **kwargs)\n\n        wrapped.metadata = metadata\n        wrapped.timeout = timeout\n        return wrapped\n\n    return wrapper", "signature": "def unit_of_work(metadata=None, timeout=None):", "completion_path": "neo4j/work/query.py"}
{"ce_id": "62e60e05d76274f8a4026cfd", "namespace": "62e60e05d76274f8a4026cfd", "namespace_real": "neo4j._data.index", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "class", "class_name": "_data", "function_name": "index", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom abc import (\n    ABCMeta,\n    abstractmethod,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n    Set,\n)\nfrom functools import reduce\nfrom operator import xor as xor_operator\n\nfrom ._codec.hydration import BrokenHydrationObject\nfrom ._conf import iter_items\nfrom ._meta import deprecated\nfrom .exceptions import BrokenRecordError\nfrom .graph import (\n    Node,\n    Path,\n    Relationship,\n)\n\n\nclass Record(tuple, Mapping):\n    \"\"\" A :class:`.Record` is an immutable ordered collection of key-value\n    pairs. It is generally closer to a :py:class:`namedtuple` than to a\n    :py:class:`OrderedDict` in as much as iteration of the collection will\n    yield values rather than keys.\n    \"\"\"\n\n    __keys = None\n\n    def __new__(cls, iterable=()):\n        keys = []\n        values = []\n        for key, value in iter_items(iterable):\n            keys.append(key)\n            values.append(value)\n        inst = tuple.__new__(cls, values)\n        inst.__keys = tuple(keys)\n        return inst\n\n    def _broken_record_error(self, index):\n        return BrokenRecordError(\n            f\"Record contains broken data at {index} ('{self.__keys[index]}')\"\n        )\n\n    def _super_getitem_single(self, index):\n        value = super().__getitem__(index)\n        if isinstance(value, BrokenHydrationObject):\n            raise self._broken_record_error(index) from value.error\n        return value\n\n    def __repr__(self):\n        return \"<%s %s>\" % (\n            self.__class__.__name__,\n            \" \".join(\"%s=%r\" % (field, value)\n                     for field, value in zip(self.__keys, super().__iter__()))\n        )\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __eq__(self, other):\n        \"\"\" In order to be flexible regarding comparison, the equality rules\n        for a record permit comparison with any other Sequence or Mapping.\n\n        :param other:\n        :return:\n        \"\"\"\n        compare_as_sequence = isinstance(other, Sequence)\n        compare_as_mapping = isinstance(other, Mapping)\n        if compare_as_sequence and compare_as_mapping:\n            return list(self) == list(other) and dict(self) == dict(other)\n        elif compare_as_sequence:\n            return list(self) == list(other)\n        elif compare_as_mapping:\n            return dict(self) == dict(other)\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return reduce(xor_operator, map(hash, self.items()))\n\n    def __iter__(self):\n        for i, v in enumerate(super().__iter__()):\n            if isinstance(v, BrokenHydrationObject):\n                raise self._broken_record_error(i) from v.error\n            yield v\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            keys = self.__keys[key]\n            values = super().__getitem__(key)\n            return self.__class__(zip(keys, values))\n        try:\n            index = self.index(key)\n        except IndexError:\n            return None\n        else:\n            return self._super_getitem_single(index)\n\n    # TODO: 6.0 - remove\n    @deprecated(\"This method is deprecated and will be removed in the future.\")\n    def __getslice__(self, start, stop):\n        key = slice(start, stop)\n        keys = self.__keys[key]\n        values = tuple(self)[key]\n        return self.__class__(zip(keys, values))\n\n    def get(self, key, default=None):\n        \"\"\" Obtain a value from the record by key, returning a default\n        value if the key does not exist.\n\n        :param key: a key\n        :param default: default value\n        :return: a value\n        \"\"\"\n        try:\n            index = self.__keys.index(str(key))\n        except ValueError:\n            return default\n        if 0 <= index < len(self):\n            return self._super_getitem_single(index)\n        else:\n            return default\n", "contexts_below": "    def value(self, key=0, default=None):\n         \"\"\" Obtain a single value from the record by index or key. If no\n         index or key is specified, the first value is returned. If the\n         specified item does not exist, the default value is returned.\n \n         :param key: an index or key\n         :param default: default value\n         :return: a single value\n         \"\"\"\n         try:\n             index = self.index(key)\n         except (IndexError, KeyError):\n             return default\n         else:\n             return self[index]\n \n     def keys(self):\n         \"\"\" Return the keys of the record.\n \n         :return: list of key names\n         \"\"\"\n         return list(self.__keys)\n \n     def values(self, *keys):\n         \"\"\" Return the values of the record, optionally filtering to\n         include only certain values by index or key.\n \n         :param keys: indexes or keys of the items to include; if none\n                      are provided, all values will be included\n         :return: list of values\n         :rtype: list\n         \"\"\"\n         if keys:\n             d = []\n             for key in keys:\n                 try:\n                     i = self.index(key)\n                 except KeyError:\n                     d.append(None)\n                 else:\n                     d.append(self[i])\n             return d\n         return list(self)\n \n     def items(self, *keys):\n         \"\"\" Return the fields of the record as a list of key and value tuples\n \n         :return: a list of value tuples\n         :rtype: list\n         \"\"\"\n         if keys:\n             d = []\n             for key in keys:\n                 try:\n                     i = self.index(key)\n                 except KeyError:\n                     d.append((key, None))\n                 else:\n                     d.append((self.__keys[i], self[i]))\n             return d\n         return list((self.__keys[i], self._super_getitem_single(i))\n                     for i in range(len(self)))\n \n     def data(self, *keys):\n         \"\"\" Return the keys and values of this record as a dictionary,\n         optionally including only certain values by index or key. Keys\n         provided in the items that are not in the record will be\n         inserted with a value of :const:`None`; indexes provided\n         that are out of bounds will trigger an :exc:`IndexError`.\n \n         :param keys: indexes or keys of the items to include; if none\n                       are provided, all values will be included\n         :return: dictionary of values, keyed by field name\n         :raises: :exc:`IndexError` if an out-of-bounds index is specified\n         \"\"\"\n         return RecordExporter().transform(dict(self.items(*keys)))\n \n \n class DataTransformer(metaclass=ABCMeta):\n     \"\"\" Abstract base class for transforming data from one form into\n     another.\n     \"\"\"\n \n     @abstractmethod\n     def transform(self, x):\n         \"\"\" Transform a value, or collection of values.\n \n         :param x: input value\n         :return: output value\n         \"\"\"\n \n \n class RecordExporter(DataTransformer):\n     \"\"\" Transformer class used by the :meth:`.Record.data` method.\n     \"\"\"\n \n     def transform(self, x):\n         if isinstance(x, Node):\n             return self.transform(dict(x))\n         elif isinstance(x, Relationship):\n             return (self.transform(dict(x.start_node)),\n                     x.__class__.__name__,\n                     self.transform(dict(x.end_node)))\n         elif isinstance(x, Path):\n             path = [self.transform(x.start_node)]\n             for i, relationship in enumerate(x.relationships):\n                 path.append(self.transform(relationship.__class__.__name__))\n                 path.append(self.transform(x.nodes[i + 1]))\n             return path\n         elif isinstance(x, str):\n             return x\n         elif isinstance(x, Sequence):\n             t = type(x)\n             return t(map(self.transform, x))\n         elif isinstance(x, Set):\n             t = type(x)\n             return t(map(self.transform, x))\n         elif isinstance(x, Mapping):\n             t = type(x)\n             return t((k, self.transform(v)) for k, v in x.items())\n         else:\n             return x\n \n \n class RecordTableRowExporter(DataTransformer):\n     \"\"\"Transformer class used by the :meth:`.Result.to_df` method.\"\"\"\n \n     def transform(self, x):\n         assert isinstance(x, Mapping)\n         t = type(x)\n         return t(item\n                  for k, v in x.items()\n                  for item in self._transform(\n                      v, prefix=k.replace(\"\\\\\", \"\\\\\\\\\").replace(\".\", \"\\\\.\")\n                  ).items())\n \n     def _transform(self, x, prefix):\n         if isinstance(x, Node):\n             res = {\n                 \"%s().element_id\" % prefix: x.element_id,\n                 \"%s().labels\" % prefix: x.labels,\n             }\n             res.update((\"%s().prop.%s\" % (prefix, k), v) for k, v in x.items())\n             return res\n         elif isinstance(x, Relationship):\n             res = {\n                 \"%s->.element_id\" % prefix: x.element_id,\n                 \"%s->.start.element_id\" % prefix: x.start_node.element_id,\n                 \"%s->.end.element_id\" % prefix: x.end_node.element_id,\n                 \"%s->.type\" % prefix: x.__class__.__name__,\n             }\n             res.update((\"%s->.prop.%s\" % (prefix, k), v) for k, v in x.items())\n             return res\n         elif isinstance(x, Path) or isinstance(x, str):\n             return {prefix: x}\n         elif isinstance(x, Sequence):\n             return dict(\n                 item\n                 for i, v in enumerate(x)\n                 for item in self._transform(\n                     v, prefix=\"%s[].%i\" % (prefix, i)\n                 ).items()\n             )\n         elif isinstance(x, Mapping):\n             t = type(x)\n             return t(\n                 item\n                 for k, v in x.items()\n                 for item in self._transform(\n                     v, prefix=\"%s{}.%s\" % (prefix, k.replace(\"\\\\\", \"\\\\\\\\\")\n                                                     .replace(\".\", \"\\\\.\"))\n                 ).items()\n             )\n         else:\n             return {prefix: x}\n ", "input_code": "def index(self, key):\n\"\"\"\nReturn the index of the given item.\n\n:param key: a key\n:return: index\n:rtype: int\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def index(self, key):\n        \"\"\" Return the index of the given item.\n\n        :param key: a key\n        :return: index\n        :rtype: int\n        \"\"\"\n        if isinstance(key, int):\n            if 0 <= key < len(self.__keys):\n                return key\n            raise IndexError(key)\n        elif isinstance(key, str):\n            try:\n                return self.__keys.index(key)\n            except ValueError:\n                raise KeyError(key)\n        else:\n            raise TypeError(key)", "signature": "def index(self, key):", "completion_path": "neo4j/_data.py"}
{"ce_id": "62e60da4d76274f8a4026cf1", "namespace": "62e60da4d76274f8a4026cf1", "namespace_real": "neo4j._data.values", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "class", "class_name": "_data", "function_name": "values", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom abc import (\n    ABCMeta,\n    abstractmethod,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n    Set,\n)\nfrom functools import reduce\nfrom operator import xor as xor_operator\n\nfrom ._codec.hydration import BrokenHydrationObject\nfrom ._conf import iter_items\nfrom ._meta import deprecated\nfrom .exceptions import BrokenRecordError\nfrom .graph import (\n    Node,\n    Path,\n    Relationship,\n)\n\n\nclass Record(tuple, Mapping):\n    \"\"\" A :class:`.Record` is an immutable ordered collection of key-value\n    pairs. It is generally closer to a :py:class:`namedtuple` than to a\n    :py:class:`OrderedDict` in as much as iteration of the collection will\n    yield values rather than keys.\n    \"\"\"\n\n    __keys = None\n\n    def __new__(cls, iterable=()):\n        keys = []\n        values = []\n        for key, value in iter_items(iterable):\n            keys.append(key)\n            values.append(value)\n        inst = tuple.__new__(cls, values)\n        inst.__keys = tuple(keys)\n        return inst\n\n    def _broken_record_error(self, index):\n        return BrokenRecordError(\n            f\"Record contains broken data at {index} ('{self.__keys[index]}')\"\n        )\n\n    def _super_getitem_single(self, index):\n        value = super().__getitem__(index)\n        if isinstance(value, BrokenHydrationObject):\n            raise self._broken_record_error(index) from value.error\n        return value\n\n    def __repr__(self):\n        return \"<%s %s>\" % (\n            self.__class__.__name__,\n            \" \".join(\"%s=%r\" % (field, value)\n                     for field, value in zip(self.__keys, super().__iter__()))\n        )\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __eq__(self, other):\n        \"\"\" In order to be flexible regarding comparison, the equality rules\n        for a record permit comparison with any other Sequence or Mapping.\n\n        :param other:\n        :return:\n        \"\"\"\n        compare_as_sequence = isinstance(other, Sequence)\n        compare_as_mapping = isinstance(other, Mapping)\n        if compare_as_sequence and compare_as_mapping:\n            return list(self) == list(other) and dict(self) == dict(other)\n        elif compare_as_sequence:\n            return list(self) == list(other)\n        elif compare_as_mapping:\n            return dict(self) == dict(other)\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return reduce(xor_operator, map(hash, self.items()))\n\n    def __iter__(self):\n        for i, v in enumerate(super().__iter__()):\n            if isinstance(v, BrokenHydrationObject):\n                raise self._broken_record_error(i) from v.error\n            yield v\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            keys = self.__keys[key]\n            values = super().__getitem__(key)\n            return self.__class__(zip(keys, values))\n        try:\n            index = self.index(key)\n        except IndexError:\n            return None\n        else:\n            return self._super_getitem_single(index)\n\n    # TODO: 6.0 - remove\n    @deprecated(\"This method is deprecated and will be removed in the future.\")\n    def __getslice__(self, start, stop):\n        key = slice(start, stop)\n        keys = self.__keys[key]\n        values = tuple(self)[key]\n        return self.__class__(zip(keys, values))\n\n    def get(self, key, default=None):\n        \"\"\" Obtain a value from the record by key, returning a default\n        value if the key does not exist.\n\n        :param key: a key\n        :param default: default value\n        :return: a value\n        \"\"\"\n        try:\n            index = self.__keys.index(str(key))\n        except ValueError:\n            return default\n        if 0 <= index < len(self):\n            return self._super_getitem_single(index)\n        else:\n            return default\n\n    def index(self, key):\n        \"\"\" Return the index of the given item.\n\n        :param key: a key\n        :return: index\n        :rtype: int\n        \"\"\"\n        if isinstance(key, int):\n            if 0 <= key < len(self.__keys):\n                return key\n            raise IndexError(key)\n        elif isinstance(key, str):\n            try:\n                return self.__keys.index(key)\n            except ValueError:\n                raise KeyError(key)\n        else:\n            raise TypeError(key)\n\n    def value(self, key=0, default=None):\n        \"\"\" Obtain a single value from the record by index or key. If no\n        index or key is specified, the first value is returned. If the\n        specified item does not exist, the default value is returned.\n\n        :param key: an index or key\n        :param default: default value\n        :return: a single value\n        \"\"\"\n        try:\n            index = self.index(key)\n        except (IndexError, KeyError):\n            return default\n        else:\n            return self[index]\n\n    def keys(self):\n        \"\"\" Return the keys of the record.\n\n        :return: list of key names\n        \"\"\"\n        return list(self.__keys)\n", "contexts_below": "    def items(self, *keys):\n         \"\"\" Return the fields of the record as a list of key and value tuples\n \n         :return: a list of value tuples\n         :rtype: list\n         \"\"\"\n         if keys:\n             d = []\n             for key in keys:\n                 try:\n                     i = self.index(key)\n                 except KeyError:\n                     d.append((key, None))\n                 else:\n                     d.append((self.__keys[i], self[i]))\n             return d\n         return list((self.__keys[i], self._super_getitem_single(i))\n                     for i in range(len(self)))\n \n     def data(self, *keys):\n         \"\"\" Return the keys and values of this record as a dictionary,\n         optionally including only certain values by index or key. Keys\n         provided in the items that are not in the record will be\n         inserted with a value of :const:`None`; indexes provided\n         that are out of bounds will trigger an :exc:`IndexError`.\n \n         :param keys: indexes or keys of the items to include; if none\n                       are provided, all values will be included\n         :return: dictionary of values, keyed by field name\n         :raises: :exc:`IndexError` if an out-of-bounds index is specified\n         \"\"\"\n         return RecordExporter().transform(dict(self.items(*keys)))\n \n \n class DataTransformer(metaclass=ABCMeta):\n     \"\"\" Abstract base class for transforming data from one form into\n     another.\n     \"\"\"\n \n     @abstractmethod\n     def transform(self, x):\n         \"\"\" Transform a value, or collection of values.\n \n         :param x: input value\n         :return: output value\n         \"\"\"\n \n \n class RecordExporter(DataTransformer):\n     \"\"\" Transformer class used by the :meth:`.Record.data` method.\n     \"\"\"\n \n     def transform(self, x):\n         if isinstance(x, Node):\n             return self.transform(dict(x))\n         elif isinstance(x, Relationship):\n             return (self.transform(dict(x.start_node)),\n                     x.__class__.__name__,\n                     self.transform(dict(x.end_node)))\n         elif isinstance(x, Path):\n             path = [self.transform(x.start_node)]\n             for i, relationship in enumerate(x.relationships):\n                 path.append(self.transform(relationship.__class__.__name__))\n                 path.append(self.transform(x.nodes[i + 1]))\n             return path\n         elif isinstance(x, str):\n             return x\n         elif isinstance(x, Sequence):\n             t = type(x)\n             return t(map(self.transform, x))\n         elif isinstance(x, Set):\n             t = type(x)\n             return t(map(self.transform, x))\n         elif isinstance(x, Mapping):\n             t = type(x)\n             return t((k, self.transform(v)) for k, v in x.items())\n         else:\n             return x\n \n \n class RecordTableRowExporter(DataTransformer):\n     \"\"\"Transformer class used by the :meth:`.Result.to_df` method.\"\"\"\n \n     def transform(self, x):\n         assert isinstance(x, Mapping)\n         t = type(x)\n         return t(item\n                  for k, v in x.items()\n                  for item in self._transform(\n                      v, prefix=k.replace(\"\\\\\", \"\\\\\\\\\").replace(\".\", \"\\\\.\")\n                  ).items())\n \n     def _transform(self, x, prefix):\n         if isinstance(x, Node):\n             res = {\n                 \"%s().element_id\" % prefix: x.element_id,\n                 \"%s().labels\" % prefix: x.labels,\n             }\n             res.update((\"%s().prop.%s\" % (prefix, k), v) for k, v in x.items())\n             return res\n         elif isinstance(x, Relationship):\n             res = {\n                 \"%s->.element_id\" % prefix: x.element_id,\n                 \"%s->.start.element_id\" % prefix: x.start_node.element_id,\n                 \"%s->.end.element_id\" % prefix: x.end_node.element_id,\n                 \"%s->.type\" % prefix: x.__class__.__name__,\n             }\n             res.update((\"%s->.prop.%s\" % (prefix, k), v) for k, v in x.items())\n             return res\n         elif isinstance(x, Path) or isinstance(x, str):\n             return {prefix: x}\n         elif isinstance(x, Sequence):\n             return dict(\n                 item\n                 for i, v in enumerate(x)\n                 for item in self._transform(\n                     v, prefix=\"%s[].%i\" % (prefix, i)\n                 ).items()\n             )\n         elif isinstance(x, Mapping):\n             t = type(x)\n             return t(\n                 item\n                 for k, v in x.items()\n                 for item in self._transform(\n                     v, prefix=\"%s{}.%s\" % (prefix, k.replace(\"\\\\\", \"\\\\\\\\\")\n                                                     .replace(\".\", \"\\\\.\"))\n                 ).items()\n             )\n         else:\n             return {prefix: x}\n ", "input_code": "def values(self, *keys):\n\"\"\"\nReturn the values of the record, optionally filtering to\ninclude only certain values by index or key.\n\n:param keys: indexes or keys of the items to include; if none\n             are provided, all values will be included\n:return: list of values\n:rtype: list\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def values(self, *keys):\n        \"\"\" Return the values of the record, optionally filtering to\n        include only certain values by index or key.\n\n        :param keys: indexes or keys of the items to include; if none\n                     are provided, all values will be included\n        :return: list of values\n        :rtype: list\n        \"\"\"\n        if keys:\n            d = []\n            for key in keys:\n                try:\n                    i = self.index(key)\n                except KeyError:\n                    d.append(None)\n                else:\n                    d.append(self[i])\n            return d\n        return list(self)", "signature": "def values(self, *keys):", "completion_path": "neo4j/_data.py"}
{"ce_id": "62e60b10d76274f8a4026ccd", "namespace": "62e60b10d76274f8a4026ccd", "namespace_real": "neo4j._data.data", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "class", "class_name": "_data", "function_name": "data", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom abc import (\n    ABCMeta,\n    abstractmethod,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n    Set,\n)\nfrom functools import reduce\nfrom operator import xor as xor_operator\n\nfrom ._codec.hydration import BrokenHydrationObject\nfrom ._conf import iter_items\nfrom ._meta import deprecated\nfrom .exceptions import BrokenRecordError\nfrom .graph import (\n    Node,\n    Path,\n    Relationship,\n)\n\n\nclass Record(tuple, Mapping):\n    \"\"\" A :class:`.Record` is an immutable ordered collection of key-value\n    pairs. It is generally closer to a :py:class:`namedtuple` than to a\n    :py:class:`OrderedDict` in as much as iteration of the collection will\n    yield values rather than keys.\n    \"\"\"\n\n    __keys = None\n\n    def __new__(cls, iterable=()):\n        keys = []\n        values = []\n        for key, value in iter_items(iterable):\n            keys.append(key)\n            values.append(value)\n        inst = tuple.__new__(cls, values)\n        inst.__keys = tuple(keys)\n        return inst\n\n    def _broken_record_error(self, index):\n        return BrokenRecordError(\n            f\"Record contains broken data at {index} ('{self.__keys[index]}')\"\n        )\n\n    def _super_getitem_single(self, index):\n        value = super().__getitem__(index)\n        if isinstance(value, BrokenHydrationObject):\n            raise self._broken_record_error(index) from value.error\n        return value\n\n    def __repr__(self):\n        return \"<%s %s>\" % (\n            self.__class__.__name__,\n            \" \".join(\"%s=%r\" % (field, value)\n                     for field, value in zip(self.__keys, super().__iter__()))\n        )\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __eq__(self, other):\n        \"\"\" In order to be flexible regarding comparison, the equality rules\n        for a record permit comparison with any other Sequence or Mapping.\n\n        :param other:\n        :return:\n        \"\"\"\n        compare_as_sequence = isinstance(other, Sequence)\n        compare_as_mapping = isinstance(other, Mapping)\n        if compare_as_sequence and compare_as_mapping:\n            return list(self) == list(other) and dict(self) == dict(other)\n        elif compare_as_sequence:\n            return list(self) == list(other)\n        elif compare_as_mapping:\n            return dict(self) == dict(other)\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return reduce(xor_operator, map(hash, self.items()))\n\n    def __iter__(self):\n        for i, v in enumerate(super().__iter__()):\n            if isinstance(v, BrokenHydrationObject):\n                raise self._broken_record_error(i) from v.error\n            yield v\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            keys = self.__keys[key]\n            values = super().__getitem__(key)\n            return self.__class__(zip(keys, values))\n        try:\n            index = self.index(key)\n        except IndexError:\n            return None\n        else:\n            return self._super_getitem_single(index)\n\n    # TODO: 6.0 - remove\n    @deprecated(\"This method is deprecated and will be removed in the future.\")\n    def __getslice__(self, start, stop):\n        key = slice(start, stop)\n        keys = self.__keys[key]\n        values = tuple(self)[key]\n        return self.__class__(zip(keys, values))\n\n    def get(self, key, default=None):\n        \"\"\" Obtain a value from the record by key, returning a default\n        value if the key does not exist.\n\n        :param key: a key\n        :param default: default value\n        :return: a value\n        \"\"\"\n        try:\n            index = self.__keys.index(str(key))\n        except ValueError:\n            return default\n        if 0 <= index < len(self):\n            return self._super_getitem_single(index)\n        else:\n            return default\n\n    def index(self, key):\n        \"\"\" Return the index of the given item.\n\n        :param key: a key\n        :return: index\n        :rtype: int\n        \"\"\"\n        if isinstance(key, int):\n            if 0 <= key < len(self.__keys):\n                return key\n            raise IndexError(key)\n        elif isinstance(key, str):\n            try:\n                return self.__keys.index(key)\n            except ValueError:\n                raise KeyError(key)\n        else:\n            raise TypeError(key)\n\n    def value(self, key=0, default=None):\n        \"\"\" Obtain a single value from the record by index or key. If no\n        index or key is specified, the first value is returned. If the\n        specified item does not exist, the default value is returned.\n\n        :param key: an index or key\n        :param default: default value\n        :return: a single value\n        \"\"\"\n        try:\n            index = self.index(key)\n        except (IndexError, KeyError):\n            return default\n        else:\n            return self[index]\n\n    def keys(self):\n        \"\"\" Return the keys of the record.\n\n        :return: list of key names\n        \"\"\"\n        return list(self.__keys)\n\n    def values(self, *keys):\n        \"\"\" Return the values of the record, optionally filtering to\n        include only certain values by index or key.\n\n        :param keys: indexes or keys of the items to include; if none\n                     are provided, all values will be included\n        :return: list of values\n        :rtype: list\n        \"\"\"\n        if keys:\n            d = []\n            for key in keys:\n                try:\n                    i = self.index(key)\n                except KeyError:\n                    d.append(None)\n                else:\n                    d.append(self[i])\n            return d\n        return list(self)\n\n    def items(self, *keys):\n        \"\"\" Return the fields of the record as a list of key and value tuples\n\n        :return: a list of value tuples\n        :rtype: list\n        \"\"\"\n        if keys:\n            d = []\n            for key in keys:\n                try:\n                    i = self.index(key)\n                except KeyError:\n                    d.append((key, None))\n                else:\n                    d.append((self.__keys[i], self[i]))\n            return d\n        return list((self.__keys[i], self._super_getitem_single(i))\n                    for i in range(len(self)))\n", "contexts_below": "\n class DataTransformer(metaclass=ABCMeta):\n     \"\"\" Abstract base class for transforming data from one form into\n     another.\n     \"\"\"\n \n     @abstractmethod\n     def transform(self, x):\n         \"\"\" Transform a value, or collection of values.\n \n         :param x: input value\n         :return: output value\n         \"\"\"\n \n \n class RecordExporter(DataTransformer):\n     \"\"\" Transformer class used by the :meth:`.Record.data` method.\n     \"\"\"\n \n     def transform(self, x):\n         if isinstance(x, Node):\n             return self.transform(dict(x))\n         elif isinstance(x, Relationship):\n             return (self.transform(dict(x.start_node)),\n                     x.__class__.__name__,\n                     self.transform(dict(x.end_node)))\n         elif isinstance(x, Path):\n             path = [self.transform(x.start_node)]\n             for i, relationship in enumerate(x.relationships):\n                 path.append(self.transform(relationship.__class__.__name__))\n                 path.append(self.transform(x.nodes[i + 1]))\n             return path\n         elif isinstance(x, str):\n             return x\n         elif isinstance(x, Sequence):\n             t = type(x)\n             return t(map(self.transform, x))\n         elif isinstance(x, Set):\n             t = type(x)\n             return t(map(self.transform, x))\n         elif isinstance(x, Mapping):\n             t = type(x)\n             return t((k, self.transform(v)) for k, v in x.items())\n         else:\n             return x\n \n \n class RecordTableRowExporter(DataTransformer):\n     \"\"\"Transformer class used by the :meth:`.Result.to_df` method.\"\"\"\n \n     def transform(self, x):\n         assert isinstance(x, Mapping)\n         t = type(x)\n         return t(item\n                  for k, v in x.items()\n                  for item in self._transform(\n                      v, prefix=k.replace(\"\\\\\", \"\\\\\\\\\").replace(\".\", \"\\\\.\")\n                  ).items())\n \n     def _transform(self, x, prefix):\n         if isinstance(x, Node):\n             res = {\n                 \"%s().element_id\" % prefix: x.element_id,\n                 \"%s().labels\" % prefix: x.labels,\n             }\n             res.update((\"%s().prop.%s\" % (prefix, k), v) for k, v in x.items())\n             return res\n         elif isinstance(x, Relationship):\n             res = {\n                 \"%s->.element_id\" % prefix: x.element_id,\n                 \"%s->.start.element_id\" % prefix: x.start_node.element_id,\n                 \"%s->.end.element_id\" % prefix: x.end_node.element_id,\n                 \"%s->.type\" % prefix: x.__class__.__name__,\n             }\n             res.update((\"%s->.prop.%s\" % (prefix, k), v) for k, v in x.items())\n             return res\n         elif isinstance(x, Path) or isinstance(x, str):\n             return {prefix: x}\n         elif isinstance(x, Sequence):\n             return dict(\n                 item\n                 for i, v in enumerate(x)\n                 for item in self._transform(\n                     v, prefix=\"%s[].%i\" % (prefix, i)\n                 ).items()\n             )\n         elif isinstance(x, Mapping):\n             t = type(x)\n             return t(\n                 item\n                 for k, v in x.items()\n                 for item in self._transform(\n                     v, prefix=\"%s{}.%s\" % (prefix, k.replace(\"\\\\\", \"\\\\\\\\\")\n                                                     .replace(\".\", \"\\\\.\"))\n                 ).items()\n             )\n         else:\n             return {prefix: x}\n ", "input_code": "def data(self, *keys):\n\"\"\"\nReturn the keys and values of this record as a dictionary,\noptionally including only certain values by index or key. Keys\nprovided in the items that are not in the record will be\ninserted with a value of :const:`None`; indexes provided\nthat are out of bounds will trigger an :exc:`IndexError`.\n\n:param keys: indexes or keys of the items to include; if none\n              are provided, all values will be included\n:return: dictionary of values, keyed by field name\n:raises: :exc:`IndexError` if an out-of-bounds index is specified\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def data(self, *keys):\n        \"\"\" Return the keys and values of this record as a dictionary,\n        optionally including only certain values by index or key. Keys\n        provided in the items that are not in the record will be\n        inserted with a value of :const:`None`; indexes provided\n        that are out of bounds will trigger an :exc:`IndexError`.\n\n        :param keys: indexes or keys of the items to include; if none\n                      are provided, all values will be included\n        :return: dictionary of values, keyed by field name\n        :raises: :exc:`IndexError` if an out-of-bounds index is specified\n        \"\"\"\n        return RecordExporter().transform(dict(self.items(*keys)))", "signature": "def data(self, *keys):", "completion_path": "neo4j/_data.py"}
{"ce_id": "62e6087bd76274f8a4026bfa", "namespace": "62e6087bd76274f8a4026bfa", "namespace_real": "neo4j._codec.packstream.v1.__init__.pop_u16", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "class", "class_name": "__init__", "function_name": "pop_u16", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom codecs import decode\nfrom contextlib import contextmanager\nfrom struct import (\n    pack as struct_pack,\n    unpack as struct_unpack,\n)\n\nfrom .._common import Structure\n\n\nPACKED_UINT_8 = [struct_pack(\">B\", value) for value in range(0x100)]\nPACKED_UINT_16 = [struct_pack(\">H\", value) for value in range(0x10000)]\n\nUNPACKED_UINT_8 = {bytes(bytearray([x])): x for x in range(0x100)}\nUNPACKED_UINT_16 = {struct_pack(\">H\", x): x for x in range(0x10000)}\n\nUNPACKED_MARKERS = {b\"\\xC0\": None, b\"\\xC2\": False, b\"\\xC3\": True}\nUNPACKED_MARKERS.update({bytes(bytearray([z])): z for z in range(0x00, 0x80)})\nUNPACKED_MARKERS.update({bytes(bytearray([z + 256])): z for z in range(-0x10, 0x00)})\n\n\nINT64_MIN = -(2 ** 63)\nINT64_MAX = 2 ** 63\n\n\nclass Packer:\n\n    def __init__(self, stream):\n        self.stream = stream\n        self._write = self.stream.write\n\n    def pack_raw(self, data):\n        self._write(data)\n\n    def pack(self, value, dehydration_hooks=None):\n        write = self._write\n\n        # None\n        if value is None:\n            write(b\"\\xC0\")  # NULL\n\n        # Boolean\n        elif value is True:\n            write(b\"\\xC3\")\n        elif value is False:\n            write(b\"\\xC2\")\n\n        # Float (only double precision is supported)\n        elif isinstance(value, float):\n            write(b\"\\xC1\")\n            write(struct_pack(\">d\", value))\n\n        # Integer\n        elif isinstance(value, int):\n            if -0x10 <= value < 0x80:\n                write(PACKED_UINT_8[value % 0x100])\n            elif -0x80 <= value < -0x10:\n                write(b\"\\xC8\")\n                write(PACKED_UINT_8[value % 0x100])\n            elif -0x8000 <= value < 0x8000:\n                write(b\"\\xC9\")\n                write(PACKED_UINT_16[value % 0x10000])\n            elif -0x80000000 <= value < 0x80000000:\n                write(b\"\\xCA\")\n                write(struct_pack(\">i\", value))\n            elif INT64_MIN <= value < INT64_MAX:\n                write(b\"\\xCB\")\n                write(struct_pack(\">q\", value))\n            else:\n                raise OverflowError(\"Integer %s out of range\" % value)\n\n        # String\n        elif isinstance(value, str):\n            encoded = value.encode(\"utf-8\")\n            self.pack_string_header(len(encoded))\n            self.pack_raw(encoded)\n\n        # Bytes\n        elif isinstance(value, (bytes, bytearray)):\n            self.pack_bytes_header(len(value))\n            self.pack_raw(value)\n\n        # List\n        elif isinstance(value, list):\n            self.pack_list_header(len(value))\n            for item in value:\n                self.pack(item, dehydration_hooks=dehydration_hooks)\n\n        # Map\n        elif isinstance(value, dict):\n            self.pack_map_header(len(value))\n            for key, item in value.items():\n                if not isinstance(key, str):\n                    raise TypeError(\n                        \"Map keys must be strings, not {}\".format(type(key))\n                    )\n                self.pack(key, dehydration_hooks=dehydration_hooks)\n                self.pack(item, dehydration_hooks=dehydration_hooks)\n\n        # Structure\n        elif isinstance(value, Structure):\n            self.pack_struct(value.tag, value.fields)\n\n        # Other\n        elif dehydration_hooks and type(value) in dehydration_hooks:\n            self.pack(dehydration_hooks[type(value)](value))\n        else:\n            raise ValueError(\"Values of type %s are not supported\" % type(value))\n\n    def pack_bytes_header(self, size):\n        write = self._write\n        if size < 0x100:\n            write(b\"\\xCC\")\n            write(PACKED_UINT_8[size])\n        elif size < 0x10000:\n            write(b\"\\xCD\")\n            write(PACKED_UINT_16[size])\n        elif size < 0x100000000:\n            write(b\"\\xCE\")\n            write(struct_pack(\">I\", size))\n        else:\n            raise OverflowError(\"Bytes header size out of range\")\n\n    def pack_string_header(self, size):\n        write = self._write\n        if size <= 0x0F:\n            write(bytes((0x80 | size,)))\n        elif size < 0x100:\n            write(b\"\\xD0\")\n            write(PACKED_UINT_8[size])\n        elif size < 0x10000:\n            write(b\"\\xD1\")\n            write(PACKED_UINT_16[size])\n        elif size < 0x100000000:\n            write(b\"\\xD2\")\n            write(struct_pack(\">I\", size))\n        else:\n            raise OverflowError(\"String header size out of range\")\n\n    def pack_list_header(self, size):\n        write = self._write\n        if size <= 0x0F:\n            write(bytes((0x90 | size,)))\n        elif size < 0x100:\n            write(b\"\\xD4\")\n            write(PACKED_UINT_8[size])\n        elif size < 0x10000:\n            write(b\"\\xD5\")\n            write(PACKED_UINT_16[size])\n        elif size < 0x100000000:\n            write(b\"\\xD6\")\n            write(struct_pack(\">I\", size))\n        else:\n            raise OverflowError(\"List header size out of range\")\n\n    def pack_map_header(self, size):\n        write = self._write\n        if size <= 0x0F:\n            write(bytes((0xA0 | size,)))\n        elif size < 0x100:\n            write(b\"\\xD8\")\n            write(PACKED_UINT_8[size])\n        elif size < 0x10000:\n            write(b\"\\xD9\")\n            write(PACKED_UINT_16[size])\n        elif size < 0x100000000:\n            write(b\"\\xDA\")\n            write(struct_pack(\">I\", size))\n        else:\n            raise OverflowError(\"Map header size out of range\")\n\n    def pack_struct(self, signature, fields, dehydration_hooks=None):\n        if len(signature) != 1 or not isinstance(signature, bytes):\n            raise ValueError(\"Structure signature must be a single byte value\")\n        write = self._write\n        size = len(fields)\n        if size <= 0x0F:\n            write(bytes((0xB0 | size,)))\n        else:\n            raise OverflowError(\"Structure size out of range\")\n        write(signature)\n        for field in fields:\n            self.pack(field, dehydration_hooks=dehydration_hooks)\n\n    @staticmethod\n    def new_packable_buffer():\n        return PackableBuffer()\n\n\nclass PackableBuffer:\n    def __init__(self):\n        self.data = bytearray()\n        # export write method for packer; \"inline\" for performance\n        self.write = self.data.extend\n        self.clear = self.data.clear\n        self._tmp_buffering = 0\n\n    @contextmanager\n    def tmp_buffer(self):\n        self._tmp_buffering += 1\n        old_len = len(self.data)\n        try:\n            yield\n        except Exception:\n            del self.data[old_len:]\n            raise\n        finally:\n            self._tmp_buffering -= 1\n\n    def is_tmp_buffering(self):\n        return bool(self._tmp_buffering)\n\n\nclass Unpacker:\n\n    def __init__(self, unpackable):\n        self.unpackable = unpackable\n\n    def reset(self):\n        self.unpackable.reset()\n\n    def read(self, n=1):\n        return self.unpackable.read(n)\n\n    def read_u8(self):\n        return self.unpackable.read_u8()\n\n    def unpack(self, hydration_hooks=None):\n        value = self._unpack(hydration_hooks=hydration_hooks)\n        if hydration_hooks and type(value) in hydration_hooks:\n            return hydration_hooks[type(value)](value)\n        return value\n\n    def _unpack(self, hydration_hooks=None):\n        marker = self.read_u8()\n\n        if marker == -1:\n            raise ValueError(\"Nothing to unpack\")\n\n        # Tiny Integer\n        if 0x00 <= marker <= 0x7F:\n            return marker\n        elif 0xF0 <= marker <= 0xFF:\n            return marker - 0x100\n\n        # Null\n        elif marker == 0xC0:\n            return None\n\n        # Float\n        elif marker == 0xC1:\n            value, = struct_unpack(\">d\", self.read(8))\n            return value\n\n        # Boolean\n        elif marker == 0xC2:\n            return False\n        elif marker == 0xC3:\n            return True\n\n        # Integer\n        elif marker == 0xC8:\n            return struct_unpack(\">b\", self.read(1))[0]\n        elif marker == 0xC9:\n            return struct_unpack(\">h\", self.read(2))[0]\n        elif marker == 0xCA:\n            return struct_unpack(\">i\", self.read(4))[0]\n        elif marker == 0xCB:\n            return struct_unpack(\">q\", self.read(8))[0]\n\n        # Bytes\n        elif marker == 0xCC:\n            size, = struct_unpack(\">B\", self.read(1))\n            return self.read(size).tobytes()\n        elif marker == 0xCD:\n            size, = struct_unpack(\">H\", self.read(2))\n            return self.read(size).tobytes()\n        elif marker == 0xCE:\n            size, = struct_unpack(\">I\", self.read(4))\n            return self.read(size).tobytes()\n\n        else:\n            marker_high = marker & 0xF0\n            # String\n            if marker_high == 0x80:  # TINY_STRING\n                return decode(self.read(marker & 0x0F), \"utf-8\")\n            elif marker == 0xD0:  # STRING_8:\n                size, = struct_unpack(\">B\", self.read(1))\n                return decode(self.read(size), \"utf-8\")\n            elif marker == 0xD1:  # STRING_16:\n                size, = struct_unpack(\">H\", self.read(2))\n                return decode(self.read(size), \"utf-8\")\n            elif marker == 0xD2:  # STRING_32:\n                size, = struct_unpack(\">I\", self.read(4))\n                return decode(self.read(size), \"utf-8\")\n\n            # List\n            elif 0x90 <= marker <= 0x9F or 0xD4 <= marker <= 0xD6:\n                return list(self._unpack_list_items(\n                    marker, hydration_hooks=hydration_hooks)\n                )\n\n            # Map\n            elif 0xA0 <= marker <= 0xAF or 0xD8 <= marker <= 0xDA:\n                return self._unpack_map(\n                    marker, hydration_hooks=hydration_hooks\n                )\n\n            # Structure\n            elif 0xB0 <= marker <= 0xBF:\n                size, tag = self._unpack_structure_header(marker)\n                value = Structure(tag, *([None] * size))\n                for i in range(len(value)):\n                    value[i] = self.unpack(hydration_hooks=hydration_hooks)\n                return value\n\n            else:\n                raise ValueError(\"Unknown PackStream marker %02X\" % marker)\n\n    def _unpack_list_items(self, marker, hydration_hooks=None):\n        marker_high = marker & 0xF0\n        if marker_high == 0x90:\n            size = marker & 0x0F\n            if size == 0:\n                return\n            elif size == 1:\n                yield self.unpack(hydration_hooks=hydration_hooks)\n            else:\n                for _ in range(size):\n                    yield self.unpack(hydration_hooks=hydration_hooks)\n        elif marker == 0xD4:  # LIST_8:\n            size, = struct_unpack(\">B\", self.read(1))\n            for _ in range(size):\n                yield self.unpack(hydration_hooks=hydration_hooks)\n        elif marker == 0xD5:  # LIST_16:\n            size, = struct_unpack(\">H\", self.read(2))\n            for _ in range(size):\n                yield self.unpack(hydration_hooks=hydration_hooks)\n        elif marker == 0xD6:  # LIST_32:\n            size, = struct_unpack(\">I\", self.read(4))\n            for _ in range(size):\n                yield self.unpack(hydration_hooks=hydration_hooks)\n        else:\n            return\n\n    def unpack_map(self, hydration_hooks=None):\n        marker = self.read_u8()\n        return self._unpack_map(marker, hydration_hooks=hydration_hooks)\n\n    def _unpack_map(self, marker, hydration_hooks=None):\n        marker_high = marker & 0xF0\n        if marker_high == 0xA0:\n            size = marker & 0x0F\n            value = {}\n            for _ in range(size):\n                key = self.unpack(hydration_hooks=hydration_hooks)\n                value[key] = self.unpack(hydration_hooks=hydration_hooks)\n            return value\n        elif marker == 0xD8:  # MAP_8:\n            size, = struct_unpack(\">B\", self.read(1))\n            value = {}\n            for _ in range(size):\n                key = self.unpack(hydration_hooks=hydration_hooks)\n                value[key] = self.unpack(hydration_hooks=hydration_hooks)\n            return value\n        elif marker == 0xD9:  # MAP_16:\n            size, = struct_unpack(\">H\", self.read(2))\n            value = {}\n            for _ in range(size):\n                key = self.unpack(hydration_hooks=hydration_hooks)\n                value[key] = self.unpack(hydration_hooks=hydration_hooks)\n            return value\n        elif marker == 0xDA:  # MAP_32:\n            size, = struct_unpack(\">I\", self.read(4))\n            value = {}\n            for _ in range(size):\n                key = self.unpack(hydration_hooks=hydration_hooks)\n                value[key] = self.unpack(hydration_hooks=hydration_hooks)\n            return value\n        else:\n            return None\n\n    def unpack_structure_header(self):\n        marker = self.read_u8()\n        if marker == -1:\n            return None, None\n        else:\n            return self._unpack_structure_header(marker)\n\n    def _unpack_structure_header(self, marker):\n        marker_high = marker & 0xF0\n        if marker_high == 0xB0:  # TINY_STRUCT\n            signature = self.read(1).tobytes()\n            return marker & 0x0F, signature\n        else:\n            raise ValueError(\"Expected structure, found marker %02X\" % marker)\n\n    @staticmethod\n    def new_unpackable_buffer():\n        return UnpackableBuffer()\n\n\nclass UnpackableBuffer:\n\n    initial_capacity = 8192\n\n    def __init__(self, data=None):\n        if data is None:\n            self.data = bytearray(self.initial_capacity)\n            self.used = 0\n        else:\n            self.data = bytearray(data)\n            self.used = len(self.data)\n        self.p = 0\n\n    def reset(self):\n        self.used = 0\n        self.p = 0\n\n    def read(self, n=1):\n        view = memoryview(self.data)\n        q = self.p + n\n        subview = view[self.p:q]\n        self.p = q\n        return subview\n\n    def read_u8(self):\n        if self.used - self.p >= 1:\n            value = self.data[self.p]\n            self.p += 1\n            return value\n        else:\n            return -1\n", "contexts_below": "", "input_code": "def pop_u16(self):\n\"\"\"\nRemove the last two bytes of data, returning them as a big-endian\n16-bit unsigned integer.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def pop_u16(self):\n        \"\"\" Remove the last two bytes of data, returning them as a big-endian\n        16-bit unsigned integer.\n        \"\"\"\n        if self.used >= 2:\n            value = 0x100 * self.data[self.used - 2] + self.data[self.used - 1]\n            self.used -= 2\n            return value\n        else:\n            return -1", "signature": "def pop_u16(self):", "completion_path": "neo4j/_codec/packstream/v1/__init__.py"}
{"ce_id": "62e6087ad76274f8a4026bf2", "namespace": "62e6087ad76274f8a4026bf2", "namespace_real": "neo4j._async.io._bolt3.discard", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "class", "class_name": "_bolt3", "function_name": "discard", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom enum import Enum\nfrom logging import getLogger\nfrom ssl import SSLSocket\n\nfrom ..._async_compat.util import AsyncUtil\nfrom ..._exceptions import (\n    BoltError,\n    BoltProtocolError,\n)\nfrom ...api import (\n    READ_ACCESS,\n    Version,\n)\nfrom ...exceptions import (\n    ConfigurationError,\n    DatabaseUnavailable,\n    DriverError,\n    ForbiddenOnReadOnlyDatabase,\n    Neo4jError,\n    NotALeader,\n    ServiceUnavailable,\n)\nfrom ._bolt import AsyncBolt\nfrom ._common import (\n    check_supported_server_product,\n    CommitResponse,\n    InitResponse,\n    Response,\n)\n\n\nlog = getLogger(\"neo4j\")\n\n\nclass ServerStates(Enum):\n    CONNECTED = \"CONNECTED\"\n    READY = \"READY\"\n    STREAMING = \"STREAMING\"\n    TX_READY_OR_TX_STREAMING = \"TX_READY||TX_STREAMING\"\n    FAILED = \"FAILED\"\n\n\nclass ServerStateManager:\n    _STATE_TRANSITIONS = {\n        ServerStates.CONNECTED: {\n            \"hello\": ServerStates.READY,\n        },\n        ServerStates.READY: {\n            \"run\": ServerStates.STREAMING,\n            \"begin\": ServerStates.TX_READY_OR_TX_STREAMING,\n        },\n        ServerStates.STREAMING: {\n            \"pull\": ServerStates.READY,\n            \"discard\": ServerStates.READY,\n            \"reset\": ServerStates.READY,\n        },\n        ServerStates.TX_READY_OR_TX_STREAMING: {\n            \"commit\": ServerStates.READY,\n            \"rollback\": ServerStates.READY,\n            \"reset\": ServerStates.READY,\n        },\n        ServerStates.FAILED: {\n            \"reset\": ServerStates.READY,\n        }\n    }\n\n    def __init__(self, init_state, on_change=None):\n        self.state = init_state\n        self._on_change = on_change\n\n    def transition(self, message, metadata):\n        if metadata.get(\"has_more\"):\n            return\n        state_before = self.state\n        self.state = self._STATE_TRANSITIONS\\\n            .get(self.state, {})\\\n            .get(message, self.state)\n        if state_before != self.state and callable(self._on_change):\n            self._on_change(state_before, self.state)\n\n\nclass AsyncBolt3(AsyncBolt):\n    \"\"\" Protocol handler for Bolt 3.\n\n    This is supported by Neo4j versions 3.5, 4.0, 4.1, 4.2, 4.3, and 4.4.\n    \"\"\"\n\n    PROTOCOL_VERSION = Version(3, 0)\n\n    supports_multiple_results = False\n\n    supports_multiple_databases = False\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._server_state_manager = ServerStateManager(\n            ServerStates.CONNECTED, on_change=self._on_server_state_change\n        )\n\n    def _on_server_state_change(self, old_state, new_state):\n        log.debug(\"[#%04X]  State: %s > %s\", self.local_port,\n                  old_state.name, new_state.name)\n\n    @property\n    def is_reset(self):\n        # We can't be sure of the server's state if there are still pending\n        # responses. Unless the last message we sent was RESET. In that case\n        # the server state will always be READY when we're done.\n        if (self.responses and self.responses[-1]\n                and self.responses[-1].message == \"reset\"):\n            return True\n        return self._server_state_manager.state == ServerStates.READY\n\n    @property\n    def encrypted(self):\n        return isinstance(self.socket, SSLSocket)\n\n    @property\n    def der_encoded_server_certificate(self):\n        return self.socket.getpeercert(binary_form=True)\n\n    def get_base_headers(self):\n        return {\n            \"user_agent\": self.user_agent,\n        }\n\n    async def hello(self, dehydration_hooks=None, hydration_hooks=None):\n        headers = self.get_base_headers()\n        headers.update(self.auth_dict)\n        logged_headers = dict(headers)\n        if \"credentials\" in logged_headers:\n            logged_headers[\"credentials\"] = \"*******\"\n        log.debug(\"[#%04X]  C: HELLO %r\", self.local_port, logged_headers)\n        self._append(b\"\\x01\", (headers,),\n                     response=InitResponse(self, \"hello\", hydration_hooks,\n                                           on_success=self.server_info.update),\n                     dehydration_hooks=dehydration_hooks)\n        await self.send_all()\n        await self.fetch_all()\n        check_supported_server_product(self.server_info.agent)\n\n    async def route(\n        self, database=None, imp_user=None, bookmarks=None,\n        dehydration_hooks=None, hydration_hooks=None\n    ):\n        if database is not None:\n            raise ConfigurationError(\n                \"Database name parameter for selecting database is not \"\n                \"supported in Bolt Protocol {!r}. Database name {!r}. \"\n                \"Server Agent {!r}\".format(\n                    self.PROTOCOL_VERSION, database, self.server_info.agent\n                )\n            )\n        if imp_user is not None:\n            raise ConfigurationError(\n                \"Impersonation is not supported in Bolt Protocol {!r}. \"\n                \"Trying to impersonate {!r}.\".format(\n                    self.PROTOCOL_VERSION, imp_user\n                )\n            )\n\n        metadata = {}\n        records = []\n\n        # Ignoring database and bookmarks because there is no multi-db support.\n        # The bookmarks are only relevant for making sure a previously created\n        # db exists before querying a routing table for it.\n        self.run(\n            \"CALL dbms.cluster.routing.getRoutingTable($context)\",  # This is an internal procedure call. Only available if the Neo4j 3.5 is setup with clustering.\n            {\"context\": self.routing_context},\n            mode=\"r\",                                               # Bolt Protocol Version(3, 0) supports mode=\"r\"\n            dehydration_hooks=dehydration_hooks,\n            hydration_hooks=hydration_hooks,\n            on_success=metadata.update\n        )\n        self.pull(dehydration_hooks = None, hydration_hooks = None,\n                  on_success=metadata.update, on_records=records.extend)\n        await self.send_all()\n        await self.fetch_all()\n        routing_info = [dict(zip(metadata.get(\"fields\", ()), values)) for values in records]\n        return routing_info\n\n    def run(self, query, parameters=None, mode=None, bookmarks=None,\n            metadata=None, timeout=None, db=None, imp_user=None,\n            dehydration_hooks=None, hydration_hooks=None, **handlers):\n        if db is not None:\n            raise ConfigurationError(\n                \"Database name parameter for selecting database is not \"\n                \"supported in Bolt Protocol {!r}. Database name {!r}.\".format(\n                    self.PROTOCOL_VERSION, db\n                )\n            )\n        if imp_user is not None:\n            raise ConfigurationError(\n                \"Impersonation is not supported in Bolt Protocol {!r}. \"\n                \"Trying to impersonate {!r}.\".format(\n                    self.PROTOCOL_VERSION, imp_user\n                )\n            )\n        if not parameters:\n            parameters = {}\n        extra = {}\n        if mode in (READ_ACCESS, \"r\"):\n            extra[\"mode\"] = \"r\"  # It will default to mode \"w\" if nothing is specified\n        if bookmarks:\n            try:\n                extra[\"bookmarks\"] = list(bookmarks)\n            except TypeError:\n                raise TypeError(\"Bookmarks must be provided within an iterable\")\n        if metadata:\n            try:\n                extra[\"tx_metadata\"] = dict(metadata)\n            except TypeError:\n                raise TypeError(\"Metadata must be coercible to a dict\")\n        if timeout is not None:\n            try:\n                extra[\"tx_timeout\"] = int(1000 * float(timeout))\n            except TypeError:\n                raise TypeError(\"Timeout must be specified as a number of seconds\")\n            if extra[\"tx_timeout\"] < 0:\n                raise ValueError(\"Timeout must be a positive number or 0.\")\n        fields = (query, parameters, extra)\n        log.debug(\"[#%04X]  C: RUN %s\", self.local_port, \" \".join(map(repr, fields)))\n        self._append(b\"\\x10\", fields,\n                     Response(self, \"run\", hydration_hooks, **handlers),\n                     dehydration_hooks=dehydration_hooks)\n", "contexts_below": "    def pull(self, n=-1, qid=-1, dehydration_hooks=None, hydration_hooks=None,\n              **handlers):\n         # Just ignore n and qid, it is not supported in the Bolt 3 Protocol.\n         log.debug(\"[#%04X]  C: PULL_ALL\", self.local_port)\n         self._append(b\"\\x3F\", (),\n                      Response(self, \"pull\", hydration_hooks, **handlers),\n                      dehydration_hooks=dehydration_hooks)\n \n     def begin(self, mode=None, bookmarks=None, metadata=None, timeout=None,\n               db=None, imp_user=None, dehydration_hooks=None,\n               hydration_hooks=None, **handlers):\n         if db is not None:\n             raise ConfigurationError(\n                 \"Database name parameter for selecting database is not \"\n                 \"supported in Bolt Protocol {!r}. Database name {!r}.\".format(\n                     self.PROTOCOL_VERSION, db\n                 )\n             )\n         if imp_user is not None:\n             raise ConfigurationError(\n                 \"Impersonation is not supported in Bolt Protocol {!r}. \"\n                 \"Trying to impersonate {!r}.\".format(\n                     self.PROTOCOL_VERSION, imp_user\n                 )\n             )\n         extra = {}\n         if mode in (READ_ACCESS, \"r\"):\n             extra[\"mode\"] = \"r\"  # It will default to mode \"w\" if nothing is specified\n         if bookmarks:\n             try:\n                 extra[\"bookmarks\"] = list(bookmarks)\n             except TypeError:\n                 raise TypeError(\"Bookmarks must be provided within an iterable\")\n         if metadata:\n             try:\n                 extra[\"tx_metadata\"] = dict(metadata)\n             except TypeError:\n                 raise TypeError(\"Metadata must be coercible to a dict\")\n         if timeout is not None:\n             try:\n                 extra[\"tx_timeout\"] = int(1000 * float(timeout))\n             except TypeError:\n                 raise TypeError(\"Timeout must be specified as a number of seconds\")\n             if extra[\"tx_timeout\"] < 0:\n                 raise ValueError(\"Timeout must be a positive number or 0.\")\n         log.debug(\"[#%04X]  C: BEGIN %r\", self.local_port, extra)\n         self._append(b\"\\x11\", (extra,),\n                      Response(self, \"begin\", hydration_hooks, **handlers),\n                      dehydration_hooks=dehydration_hooks)\n \n     def commit(self, dehydration_hooks=None, hydration_hooks=None, **handlers):\n         log.debug(\"[#%04X]  C: COMMIT\", self.local_port)\n         self._append(b\"\\x12\", (),\n                      CommitResponse(self, \"commit\", hydration_hooks,\n                                     **handlers),\n                      dehydration_hooks=dehydration_hooks)\n \n     def rollback(self, dehydration_hooks=None, hydration_hooks=None,\n                  **handlers):\n         log.debug(\"[#%04X]  C: ROLLBACK\", self.local_port)\n         self._append(b\"\\x13\", (),\n                      Response(self, \"rollback\", hydration_hooks, **handlers),\n                      dehydration_hooks=dehydration_hooks)\n \n     async def reset(self, dehydration_hooks=None, hydration_hooks=None):\n         \"\"\" Add a RESET message to the outgoing queue, send\n         it and consume all remaining messages.\n         \"\"\"\n \n         def fail(metadata):\n             raise BoltProtocolError(\"RESET failed %r\" % metadata, address=self.unresolved_address)\n \n         log.debug(\"[#%04X]  C: RESET\", self.local_port)\n         self._append(b\"\\x0F\",\n                      response=Response(self, \"reset\", hydration_hooks,\n                                        on_failure=fail),\n                      dehydration_hooks=dehydration_hooks)\n         await self.send_all()\n         await self.fetch_all()\n \n     def goodbye(self, dehydration_hooks=None, hydration_hooks=None):\n         log.debug(\"[#%04X]  C: GOODBYE\", self.local_port)\n         self._append(b\"\\x02\", (), dehydration_hooks=dehydration_hooks)\n \n     async def _process_message(self, tag, fields):\n         \"\"\" Process at most one message from the server, if available.\n \n         :return: 2-tuple of number of detail messages and number of summary\n                  messages fetched\n         \"\"\"\n         details = []\n         summary_signature = summary_metadata = None\n         if tag == b\"\\x71\":  # RECORD\n             details = fields\n         elif fields:\n             summary_signature = tag\n             summary_metadata = fields[0]\n         else:\n             summary_signature = tag\n \n         if details:\n             log.debug(\"[#%04X]  S: RECORD * %d\", self.local_port, len(details))  # Do not log any data\n             await self.responses[0].on_records(details)\n \n         if summary_signature is None:\n             return len(details), 0\n \n         response = self.responses.popleft()\n         response.complete = True\n         if summary_signature == b\"\\x70\":\n             log.debug(\"[#%04X]  S: SUCCESS %r\", self.local_port, summary_metadata)\n             self._server_state_manager.transition(response.message,\n                                                   summary_metadata)\n             await response.on_success(summary_metadata or {})\n         elif summary_signature == b\"\\x7E\":\n             log.debug(\"[#%04X]  S: IGNORED\", self.local_port)\n             await response.on_ignored(summary_metadata or {})\n         elif summary_signature == b\"\\x7F\":\n             log.debug(\"[#%04X]  S: FAILURE %r\", self.local_port, summary_metadata)\n             self._server_state_manager.state = ServerStates.FAILED\n             try:\n                 await response.on_failure(summary_metadata or {})\n             except (ServiceUnavailable, DatabaseUnavailable):\n                 if self.pool:\n                     await self.pool.deactivate(address=self.unresolved_address)\n                 raise\n             except (NotALeader, ForbiddenOnReadOnlyDatabase):\n                 if self.pool:\n                     self.pool.on_write_failure(address=self.unresolved_address)\n                 raise\n             except Neo4jError as e:\n                 if self.pool and e.invalidates_all_connections():\n                     await self.pool.mark_all_stale()\n                 raise\n         else:\n             raise BoltProtocolError(\"Unexpected response message with signature %02X\" % summary_signature, address=self.unresolved_address)\n \n         return len(details), 1\n ", "input_code": "def discard(self, n=-1, qid=-1, dehydration_hooks=None, hydration_hooks=None, **handlers):\n\"\"\"\nAppends a DISCARD message to the output queue.\n\n:param n: number of records to discard, default = -1 (ALL)\n:param qid: query ID to discard for, default = -1 (last query)\n:param dehydration_hooks:\n    Hooks to dehydrate types (dict from type (class) to dehydration\n    function). Dehydration functions receive the value and returns an\n    object of type understood by packstream.\n:param hydration_hooks:\n    Hooks to hydrate types (mapping from type (class) to\n    dehydration function). Dehydration functions receive the value of\n    type understood by packstream and are free to return anything.\n:param handlers: handler functions passed into the returned Response object\n\"\"\"\n", "indent_space": "                ", "ground_truth": "    def discard(self, n=-1, qid=-1, dehydration_hooks=None,\n                hydration_hooks=None, **handlers):\n        # Just ignore n and qid, it is not supported in the Bolt 3 Protocol.\n        log.debug(\"[#%04X]  C: DISCARD_ALL\", self.local_port)\n        self._append(b\"\\x2F\", (),\n                     Response(self, \"discard\", hydration_hooks, **handlers),\n                     dehydration_hooks=dehydration_hooks)", "signature": "def discard(self, n=-1, qid=-1, dehydration_hooks=None, hydration_hooks=None, **handlers):", "completion_path": "neo4j/_async/io/_bolt3.py"}
{"ce_id": "62e60879d76274f8a4026bec", "namespace": "62e60879d76274f8a4026bec", "namespace_real": "neo4j._async.io._bolt3.begin", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "class", "class_name": "_bolt3", "function_name": "begin", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom enum import Enum\nfrom logging import getLogger\nfrom ssl import SSLSocket\n\nfrom ..._async_compat.util import AsyncUtil\nfrom ..._exceptions import (\n    BoltError,\n    BoltProtocolError,\n)\nfrom ...api import (\n    READ_ACCESS,\n    Version,\n)\nfrom ...exceptions import (\n    ConfigurationError,\n    DatabaseUnavailable,\n    DriverError,\n    ForbiddenOnReadOnlyDatabase,\n    Neo4jError,\n    NotALeader,\n    ServiceUnavailable,\n)\nfrom ._bolt import AsyncBolt\nfrom ._common import (\n    check_supported_server_product,\n    CommitResponse,\n    InitResponse,\n    Response,\n)\n\n\nlog = getLogger(\"neo4j\")\n\n\nclass ServerStates(Enum):\n    CONNECTED = \"CONNECTED\"\n    READY = \"READY\"\n    STREAMING = \"STREAMING\"\n    TX_READY_OR_TX_STREAMING = \"TX_READY||TX_STREAMING\"\n    FAILED = \"FAILED\"\n\n\nclass ServerStateManager:\n    _STATE_TRANSITIONS = {\n        ServerStates.CONNECTED: {\n            \"hello\": ServerStates.READY,\n        },\n        ServerStates.READY: {\n            \"run\": ServerStates.STREAMING,\n            \"begin\": ServerStates.TX_READY_OR_TX_STREAMING,\n        },\n        ServerStates.STREAMING: {\n            \"pull\": ServerStates.READY,\n            \"discard\": ServerStates.READY,\n            \"reset\": ServerStates.READY,\n        },\n        ServerStates.TX_READY_OR_TX_STREAMING: {\n            \"commit\": ServerStates.READY,\n            \"rollback\": ServerStates.READY,\n            \"reset\": ServerStates.READY,\n        },\n        ServerStates.FAILED: {\n            \"reset\": ServerStates.READY,\n        }\n    }\n\n    def __init__(self, init_state, on_change=None):\n        self.state = init_state\n        self._on_change = on_change\n\n    def transition(self, message, metadata):\n        if metadata.get(\"has_more\"):\n            return\n        state_before = self.state\n        self.state = self._STATE_TRANSITIONS\\\n            .get(self.state, {})\\\n            .get(message, self.state)\n        if state_before != self.state and callable(self._on_change):\n            self._on_change(state_before, self.state)\n\n\nclass AsyncBolt3(AsyncBolt):\n    \"\"\" Protocol handler for Bolt 3.\n\n    This is supported by Neo4j versions 3.5, 4.0, 4.1, 4.2, 4.3, and 4.4.\n    \"\"\"\n\n    PROTOCOL_VERSION = Version(3, 0)\n\n    supports_multiple_results = False\n\n    supports_multiple_databases = False\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._server_state_manager = ServerStateManager(\n            ServerStates.CONNECTED, on_change=self._on_server_state_change\n        )\n\n    def _on_server_state_change(self, old_state, new_state):\n        log.debug(\"[#%04X]  State: %s > %s\", self.local_port,\n                  old_state.name, new_state.name)\n\n    @property\n    def is_reset(self):\n        # We can't be sure of the server's state if there are still pending\n        # responses. Unless the last message we sent was RESET. In that case\n        # the server state will always be READY when we're done.\n        if (self.responses and self.responses[-1]\n                and self.responses[-1].message == \"reset\"):\n            return True\n        return self._server_state_manager.state == ServerStates.READY\n\n    @property\n    def encrypted(self):\n        return isinstance(self.socket, SSLSocket)\n\n    @property\n    def der_encoded_server_certificate(self):\n        return self.socket.getpeercert(binary_form=True)\n\n    def get_base_headers(self):\n        return {\n            \"user_agent\": self.user_agent,\n        }\n\n    async def hello(self, dehydration_hooks=None, hydration_hooks=None):\n        headers = self.get_base_headers()\n        headers.update(self.auth_dict)\n        logged_headers = dict(headers)\n        if \"credentials\" in logged_headers:\n            logged_headers[\"credentials\"] = \"*******\"\n        log.debug(\"[#%04X]  C: HELLO %r\", self.local_port, logged_headers)\n        self._append(b\"\\x01\", (headers,),\n                     response=InitResponse(self, \"hello\", hydration_hooks,\n                                           on_success=self.server_info.update),\n                     dehydration_hooks=dehydration_hooks)\n        await self.send_all()\n        await self.fetch_all()\n        check_supported_server_product(self.server_info.agent)\n\n    async def route(\n        self, database=None, imp_user=None, bookmarks=None,\n        dehydration_hooks=None, hydration_hooks=None\n    ):\n        if database is not None:\n            raise ConfigurationError(\n                \"Database name parameter for selecting database is not \"\n                \"supported in Bolt Protocol {!r}. Database name {!r}. \"\n                \"Server Agent {!r}\".format(\n                    self.PROTOCOL_VERSION, database, self.server_info.agent\n                )\n            )\n        if imp_user is not None:\n            raise ConfigurationError(\n                \"Impersonation is not supported in Bolt Protocol {!r}. \"\n                \"Trying to impersonate {!r}.\".format(\n                    self.PROTOCOL_VERSION, imp_user\n                )\n            )\n\n        metadata = {}\n        records = []\n\n        # Ignoring database and bookmarks because there is no multi-db support.\n        # The bookmarks are only relevant for making sure a previously created\n        # db exists before querying a routing table for it.\n        self.run(\n            \"CALL dbms.cluster.routing.getRoutingTable($context)\",  # This is an internal procedure call. Only available if the Neo4j 3.5 is setup with clustering.\n            {\"context\": self.routing_context},\n            mode=\"r\",                                               # Bolt Protocol Version(3, 0) supports mode=\"r\"\n            dehydration_hooks=dehydration_hooks,\n            hydration_hooks=hydration_hooks,\n            on_success=metadata.update\n        )\n        self.pull(dehydration_hooks = None, hydration_hooks = None,\n                  on_success=metadata.update, on_records=records.extend)\n        await self.send_all()\n        await self.fetch_all()\n        routing_info = [dict(zip(metadata.get(\"fields\", ()), values)) for values in records]\n        return routing_info\n\n    def run(self, query, parameters=None, mode=None, bookmarks=None,\n            metadata=None, timeout=None, db=None, imp_user=None,\n            dehydration_hooks=None, hydration_hooks=None, **handlers):\n        if db is not None:\n            raise ConfigurationError(\n                \"Database name parameter for selecting database is not \"\n                \"supported in Bolt Protocol {!r}. Database name {!r}.\".format(\n                    self.PROTOCOL_VERSION, db\n                )\n            )\n        if imp_user is not None:\n            raise ConfigurationError(\n                \"Impersonation is not supported in Bolt Protocol {!r}. \"\n                \"Trying to impersonate {!r}.\".format(\n                    self.PROTOCOL_VERSION, imp_user\n                )\n            )\n        if not parameters:\n            parameters = {}\n        extra = {}\n        if mode in (READ_ACCESS, \"r\"):\n            extra[\"mode\"] = \"r\"  # It will default to mode \"w\" if nothing is specified\n        if bookmarks:\n            try:\n                extra[\"bookmarks\"] = list(bookmarks)\n            except TypeError:\n                raise TypeError(\"Bookmarks must be provided within an iterable\")\n        if metadata:\n            try:\n                extra[\"tx_metadata\"] = dict(metadata)\n            except TypeError:\n                raise TypeError(\"Metadata must be coercible to a dict\")\n        if timeout is not None:\n            try:\n                extra[\"tx_timeout\"] = int(1000 * float(timeout))\n            except TypeError:\n                raise TypeError(\"Timeout must be specified as a number of seconds\")\n            if extra[\"tx_timeout\"] < 0:\n                raise ValueError(\"Timeout must be a positive number or 0.\")\n        fields = (query, parameters, extra)\n        log.debug(\"[#%04X]  C: RUN %s\", self.local_port, \" \".join(map(repr, fields)))\n        self._append(b\"\\x10\", fields,\n                     Response(self, \"run\", hydration_hooks, **handlers),\n                     dehydration_hooks=dehydration_hooks)\n\n    def discard(self, n=-1, qid=-1, dehydration_hooks=None,\n                hydration_hooks=None, **handlers):\n        # Just ignore n and qid, it is not supported in the Bolt 3 Protocol.\n        log.debug(\"[#%04X]  C: DISCARD_ALL\", self.local_port)\n        self._append(b\"\\x2F\", (),\n                     Response(self, \"discard\", hydration_hooks, **handlers),\n                     dehydration_hooks=dehydration_hooks)\n\n    def pull(self, n=-1, qid=-1, dehydration_hooks=None, hydration_hooks=None,\n             **handlers):\n        # Just ignore n and qid, it is not supported in the Bolt 3 Protocol.\n        log.debug(\"[#%04X]  C: PULL_ALL\", self.local_port)\n        self._append(b\"\\x3F\", (),\n                     Response(self, \"pull\", hydration_hooks, **handlers),\n                     dehydration_hooks=dehydration_hooks)\n", "contexts_below": "    def commit(self, dehydration_hooks=None, hydration_hooks=None, **handlers):\n         log.debug(\"[#%04X]  C: COMMIT\", self.local_port)\n         self._append(b\"\\x12\", (),\n                      CommitResponse(self, \"commit\", hydration_hooks,\n                                     **handlers),\n                      dehydration_hooks=dehydration_hooks)\n \n     def rollback(self, dehydration_hooks=None, hydration_hooks=None,\n                  **handlers):\n         log.debug(\"[#%04X]  C: ROLLBACK\", self.local_port)\n         self._append(b\"\\x13\", (),\n                      Response(self, \"rollback\", hydration_hooks, **handlers),\n                      dehydration_hooks=dehydration_hooks)\n \n     async def reset(self, dehydration_hooks=None, hydration_hooks=None):\n         \"\"\" Add a RESET message to the outgoing queue, send\n         it and consume all remaining messages.\n         \"\"\"\n \n         def fail(metadata):\n             raise BoltProtocolError(\"RESET failed %r\" % metadata, address=self.unresolved_address)\n \n         log.debug(\"[#%04X]  C: RESET\", self.local_port)\n         self._append(b\"\\x0F\",\n                      response=Response(self, \"reset\", hydration_hooks,\n                                        on_failure=fail),\n                      dehydration_hooks=dehydration_hooks)\n         await self.send_all()\n         await self.fetch_all()\n \n     def goodbye(self, dehydration_hooks=None, hydration_hooks=None):\n         log.debug(\"[#%04X]  C: GOODBYE\", self.local_port)\n         self._append(b\"\\x02\", (), dehydration_hooks=dehydration_hooks)\n \n     async def _process_message(self, tag, fields):\n         \"\"\" Process at most one message from the server, if available.\n \n         :return: 2-tuple of number of detail messages and number of summary\n                  messages fetched\n         \"\"\"\n         details = []\n         summary_signature = summary_metadata = None\n         if tag == b\"\\x71\":  # RECORD\n             details = fields\n         elif fields:\n             summary_signature = tag\n             summary_metadata = fields[0]\n         else:\n             summary_signature = tag\n \n         if details:\n             log.debug(\"[#%04X]  S: RECORD * %d\", self.local_port, len(details))  # Do not log any data\n             await self.responses[0].on_records(details)\n \n         if summary_signature is None:\n             return len(details), 0\n \n         response = self.responses.popleft()\n         response.complete = True\n         if summary_signature == b\"\\x70\":\n             log.debug(\"[#%04X]  S: SUCCESS %r\", self.local_port, summary_metadata)\n             self._server_state_manager.transition(response.message,\n                                                   summary_metadata)\n             await response.on_success(summary_metadata or {})\n         elif summary_signature == b\"\\x7E\":\n             log.debug(\"[#%04X]  S: IGNORED\", self.local_port)\n             await response.on_ignored(summary_metadata or {})\n         elif summary_signature == b\"\\x7F\":\n             log.debug(\"[#%04X]  S: FAILURE %r\", self.local_port, summary_metadata)\n             self._server_state_manager.state = ServerStates.FAILED\n             try:\n                 await response.on_failure(summary_metadata or {})\n             except (ServiceUnavailable, DatabaseUnavailable):\n                 if self.pool:\n                     await self.pool.deactivate(address=self.unresolved_address)\n                 raise\n             except (NotALeader, ForbiddenOnReadOnlyDatabase):\n                 if self.pool:\n                     self.pool.on_write_failure(address=self.unresolved_address)\n                 raise\n             except Neo4jError as e:\n                 if self.pool and e.invalidates_all_connections():\n                     await self.pool.mark_all_stale()\n                 raise\n         else:\n             raise BoltProtocolError(\"Unexpected response message with signature %02X\" % summary_signature, address=self.unresolved_address)\n \n         return len(details), 1\n ", "input_code": "def begin(self, mode=None, bookmarks=None, metadata=None, timeout=None, db=None, imp_user=None, dehydration_hooks=None, hydration_hooks=None, **handlers):\n\"\"\"\nAppends a BEGIN message to the output queue.\n\n:param mode: access mode for routing - \"READ\" or \"WRITE\" (default)\n:param bookmarks: iterable of bookmark values after which this transaction should begin\n:param metadata: custom metadata dictionary to attach to the transaction\n:param timeout: timeout for transaction execution (seconds)\n:param db: name of the database against which to begin the transaction\n    Requires Bolt 4.0+.\n:param imp_user: the user to impersonate\n    Requires Bolt 4.4+\n:param dehydration_hooks:\n    Hooks to dehydrate types (dict from type (class) to dehydration\n    function). Dehydration functions receive the value and returns an\n    object of type understood by packstream.\n:param hydration_hooks:\n    Hooks to hydrate types (mapping from type (class) to\n    dehydration function). Dehydration functions receive the value of\n    type understood by packstream and are free to return anything.\n:param handlers: handler functions passed into the returned Response object\n:return: Response object\n\"\"\"\n", "indent_space": "              ", "ground_truth": "    def begin(self, mode=None, bookmarks=None, metadata=None, timeout=None,\n              db=None, imp_user=None, dehydration_hooks=None,\n              hydration_hooks=None, **handlers):\n        if db is not None:\n            raise ConfigurationError(\n                \"Database name parameter for selecting database is not \"\n                \"supported in Bolt Protocol {!r}. Database name {!r}.\".format(\n                    self.PROTOCOL_VERSION, db\n                )\n            )\n        if imp_user is not None:\n            raise ConfigurationError(\n                \"Impersonation is not supported in Bolt Protocol {!r}. \"\n                \"Trying to impersonate {!r}.\".format(\n                    self.PROTOCOL_VERSION, imp_user\n                )\n            )\n        extra = {}\n        if mode in (READ_ACCESS, \"r\"):\n            extra[\"mode\"] = \"r\"  # It will default to mode \"w\" if nothing is specified\n        if bookmarks:\n            try:\n                extra[\"bookmarks\"] = list(bookmarks)\n            except TypeError:\n                raise TypeError(\"Bookmarks must be provided within an iterable\")\n        if metadata:\n            try:\n                extra[\"tx_metadata\"] = dict(metadata)\n            except TypeError:\n                raise TypeError(\"Metadata must be coercible to a dict\")\n        if timeout is not None:\n            try:\n                extra[\"tx_timeout\"] = int(1000 * float(timeout))\n            except TypeError:\n                raise TypeError(\"Timeout must be specified as a number of seconds\")\n            if extra[\"tx_timeout\"] < 0:\n                raise ValueError(\"Timeout must be a positive number or 0.\")\n        log.debug(\"[#%04X]  C: BEGIN %r\", self.local_port, extra)\n        self._append(b\"\\x11\", (extra,),\n                     Response(self, \"begin\", hydration_hooks, **handlers),\n                     dehydration_hooks=dehydration_hooks)", "signature": "def begin(self, mode=None, bookmarks=None, metadata=None, timeout=None, db=None, imp_user=None, dehydration_hooks=None, hydration_hooks=None, **handlers):", "completion_path": "neo4j/_async/io/_bolt3.py"}
{"ce_id": "62e60723d76274f8a4026b75", "namespace": "62e60723d76274f8a4026b75", "namespace_real": "neo4j.time._arithmetic.round_half_to_even", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "function", "class_name": null, "function_name": "round_half_to_even", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\n__all__ = [\n    \"nano_add\",\n    \"nano_div\",\n    \"nano_divmod\",\n    \"symmetric_divmod\",\n    \"round_half_to_even\",\n]\n\n\ndef nano_add(x, y):\n    \"\"\"\n\n        >>> 0.7 + 0.2\n        0.8999999999999999\n        >>> -0.7 + 0.2\n        -0.49999999999999994\n        >>> nano_add(0.7, 0.2)\n        0.9\n        >>> nano_add(-0.7, 0.2)\n        -0.5\n\n    :param x:\n    :param y:\n    :return:\n    \"\"\"\n    return (int(1000000000 * x) + int(1000000000 * y)) / 1000000000\n\n\ndef nano_div(x, y):\n    \"\"\"\n\n        >>> 0.7 / 0.2\n        3.4999999999999996\n        >>> -0.7 / 0.2\n        -3.4999999999999996\n        >>> nano_div(0.7, 0.2)\n        3.5\n        >>> nano_div(-0.7, 0.2)\n        -3.5\n\n    :param x:\n    :param y:\n    :return:\n    \"\"\"\n    return float(1000000000 * x) / int(1000000000 * y)\n\n\ndef nano_divmod(x, y):\n    \"\"\"\n\n        >>> divmod(0.7, 0.2)\n        (3.0, 0.09999999999999992)\n        >>> nano_divmod(0.7, 0.2)\n        (3, 0.1)\n\n    :param x:\n    :param y:\n    :return:\n    \"\"\"\n    number = type(x)\n    nx = int(1000000000 * x)\n    ny = int(1000000000 * y)\n    q, r = divmod(nx, ny)\n    return int(q), number(r / 1000000000)\n\n\ndef symmetric_divmod(dividend, divisor):\n    number = type(dividend)\n    if dividend >= 0:\n        quotient, remainder = divmod(dividend, divisor)\n        return int(quotient), number(remainder)\n    else:\n        quotient, remainder = divmod(-dividend, divisor)\n        return -int(quotient), -number(remainder)\n\n", "contexts_below": "", "input_code": "def round_half_to_even(n):\n\"\"\"\n>>> round_half_to_even(3)\n    3\n    >>> round_half_to_even(3.2)\n    3\n    >>> round_half_to_even(3.5)\n    4\n    >>> round_half_to_even(3.7)\n    4\n    >>> round_half_to_even(4)\n    4\n    >>> round_half_to_even(4.2)\n    4\n    >>> round_half_to_even(4.5)\n    4\n    >>> round_half_to_even(4.7)\n    5\n\n:param n:\n:return:\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def round_half_to_even(n):\n    \"\"\"\n\n        >>> round_half_to_even(3)\n        3\n        >>> round_half_to_even(3.2)\n        3\n        >>> round_half_to_even(3.5)\n        4\n        >>> round_half_to_even(3.7)\n        4\n        >>> round_half_to_even(4)\n        4\n        >>> round_half_to_even(4.2)\n        4\n        >>> round_half_to_even(4.5)\n        4\n        >>> round_half_to_even(4.7)\n        5\n\n    :param n:\n    :return:\n    \"\"\"\n    ten_n = 10 * n\n    if ten_n == int(ten_n) and ten_n % 10 == 5:\n        up = int(n + 0.5)\n        down = int(n - 0.5)\n        return up if up % 2 == 0 else down\n    else:\n        return int(round(n))", "signature": "def round_half_to_even(n):", "completion_path": "neo4j/time/_arithmetic.py"}
{"ce_id": "62e60707d76274f8a4026b69", "namespace": "62e60707d76274f8a4026b69", "namespace_real": "neo4j._spatial.__init__.point_type", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "function", "class_name": null, "function_name": "point_type", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\n\"\"\"\nThis module defines _spatial data types.\n\"\"\"\n\n\nfrom threading import Lock\n\n\n# SRID to subclass mappings\nsrid_table = {}\nsrid_table_lock = Lock()\n\n\nclass Point(tuple):\n    \"\"\"Base-class for _spatial data.\n\n    A point within a geometric space. This type is generally used via its\n    subclasses and should not be instantiated directly unless there is no\n    subclass defined for the required SRID.\n\n    :param iterable:\n        An iterable of coordinates.\n        All items will be converted to :class:`float`.\n    \"\"\"\n\n    #: The SRID (_spatial reference identifier) of the _spatial data.\n    #: A number that identifies the coordinate system the _spatial type is to be\n    #: interpreted in.\n    #:\n    #: :type: int\n    srid = None\n\n    def __new__(cls, iterable):\n        return tuple.__new__(cls, map(float, iterable))\n\n    def __repr__(self):\n        return \"POINT(%s)\" % \" \".join(map(str, self))\n\n    def __eq__(self, other):\n        try:\n            return type(self) is type(other) and tuple(self) == tuple(other)\n        except (AttributeError, TypeError):\n            return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(type(self)) ^ hash(tuple(self))\n\n", "contexts_below": "\n # Point subclass definitions\n CartesianPoint = point_type(\"CartesianPoint\", [\"x\", \"y\", \"z\"],\n                             {2: 7203, 3: 9157})\n WGS84Point = point_type(\"WGS84Point\", [\"longitude\", \"latitude\", \"height\"],\n                         {2: 4326, 3: 4979})\n ", "input_code": "def point_type(name, fields, srid_map):\n\"\"\"\nDynamically create a Point subclass.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def point_type(name, fields, srid_map):\n    \"\"\" Dynamically create a Point subclass.\n    \"\"\"\n\n    def srid(self):\n        try:\n            return srid_map[len(self)]\n        except KeyError:\n            return None\n\n    attributes = {\"srid\": property(srid)}\n\n    for index, subclass_field in enumerate(fields):\n\n        def accessor(self, i=index, f=subclass_field):\n            try:\n                return self[i]\n            except IndexError:\n                raise AttributeError(f)\n\n        for field_alias in {subclass_field, \"xyz\"[index]}:\n            attributes[field_alias] = property(accessor)\n\n    cls = type(name, (Point,), attributes)\n\n    with srid_table_lock:\n        for dim, srid in srid_map.items():\n            srid_table[srid] = (cls, dim)\n\n    return cls", "signature": "def point_type(name, fields, srid_map):", "completion_path": "neo4j/_spatial/__init__.py"}
{"ce_id": "62e5dc9ed76274f8a4026b5b", "namespace": "62e5dc9ed76274f8a4026b5b", "namespace_real": "neo4j._meta.deprecated", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "function", "class_name": null, "function_name": "deprecated", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport asyncio\nfrom functools import wraps\nfrom warnings import warn\n\n\n# Can be automatically overridden in builds\npackage = \"neo4j\"\nversion = \"5.0.dev0\"\n\n\ndef get_user_agent():\n    \"\"\" Obtain the default user agent string sent to the server after\n    a successful handshake.\n    \"\"\"\n    from sys import (\n        platform,\n        version_info,\n    )\n    template = \"neo4j-python/{} Python/{}.{}.{}-{}-{} ({})\"\n    fields = (version,) + tuple(version_info) + (platform,)\n    return template.format(*fields)\n\n\ndef deprecation_warn(message, stack_level=1):\n    warn(message, category=DeprecationWarning, stacklevel=stack_level + 1)\n\n", "contexts_below": "\n class ExperimentalWarning(Warning):\n     \"\"\" Base class for warnings about experimental features.\n     \"\"\"\n \n \n def experimental_warn(message, stack_level=1):\n     warn(message, category=ExperimentalWarning, stacklevel=stack_level + 1)\n \n \n def experimental(message):\n     \"\"\" Decorator for tagging experimental functions and methods.\n \n     ::\n \n         @experimental(\"'foo' is an experimental function and may be \"\n                       \"removed in a future release\")\n         def foo(x):\n             pass\n \n     \"\"\"\n     def decorator(f):\n         if asyncio.iscoroutinefunction(f):\n             @wraps(f)\n             async def inner(*args, **kwargs):\n                 experimental_warn(message, stack_level=2)\n                 return await f(*args, **kwargs)\n \n             return inner\n         else:\n             @wraps(f)\n             def inner(*args, **kwargs):\n                 experimental_warn(message, stack_level=2)\n                 return f(*args, **kwargs)\n \n             return inner\n \n     return decorator\n \n \n def unclosed_resource_warn(obj):\n     import tracemalloc\n     from warnings import warn\n     msg = f\"Unclosed {obj!r}.\"\n     trace = tracemalloc.get_object_traceback(obj)\n     if trace:\n         msg += \"\\nObject allocated at (most recent call last):\\n\"\n         msg += \"\\n\".join(trace.format())\n     else:\n         msg += \"\\nEnable tracemalloc to get the object allocation traceback.\"\n     warn(msg, ResourceWarning, stacklevel=2, source=obj)\n ", "input_code": "def deprecated(message):\n\"\"\"\nDecorator for deprecating functions and methods.\n\n::\n\n    @deprecated(\"'foo' has been deprecated in favour of 'bar'\")\n    def foo(x):\n        pass\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def deprecated(message):\n    \"\"\" Decorator for deprecating functions and methods.\n\n    ::\n\n        @deprecated(\"'foo' has been deprecated in favour of 'bar'\")\n        def foo(x):\n            pass\n\n    \"\"\"\n    def decorator(f):\n        if asyncio.iscoroutinefunction(f):\n            @wraps(f)\n            async def inner(*args, **kwargs):\n                deprecation_warn(message, stack_level=2)\n                return await f(*args, **kwargs)\n\n            return inner\n        else:\n            @wraps(f)\n            def inner(*args, **kwargs):\n                deprecation_warn(message, stack_level=2)\n                return f(*args, **kwargs)\n\n            return inner\n\n    return decorator", "signature": "def deprecated(message):", "completion_path": "neo4j/_meta.py"}
{"ce_id": "62e4fc3c85ea98643089041e", "namespace": "62e4fc3c85ea98643089041e", "namespace_real": "pre_commit.languages.r._inline_r_setup", "real_proj_path": "pre-commit---pre-commit/", "type": "function", "class_name": null, "function_name": "_inline_r_setup", "contexts_above": "from __future__ import annotations\n\nimport contextlib\nimport os\nimport shlex\nimport shutil\nfrom typing import Generator\nfrom typing import Sequence\n\nfrom pre_commit.envcontext import envcontext\nfrom pre_commit.envcontext import PatchesT\nfrom pre_commit.envcontext import UNSET\nfrom pre_commit.hook import Hook\nfrom pre_commit.languages import helpers\nfrom pre_commit.prefix import Prefix\nfrom pre_commit.util import clean_path_on_failure\nfrom pre_commit.util import cmd_output_b\n\nENVIRONMENT_DIR = 'renv'\nRSCRIPT_OPTS = ('--no-save', '--no-restore', '--no-site-file', '--no-environ')\nget_default_version = helpers.basic_get_default_version\nhealth_check = helpers.basic_health_check\n\n\ndef get_env_patch(venv: str) -> PatchesT:\n    return (\n        ('R_PROFILE_USER', os.path.join(venv, 'activate.R')),\n        ('RENV_PROJECT', UNSET),\n    )\n\n\n@contextlib.contextmanager\ndef in_env(\n        prefix: Prefix,\n        language_version: str,\n) -> Generator[None, None, None]:\n    envdir = _get_env_dir(prefix, language_version)\n    with envcontext(get_env_patch(envdir)):\n        yield\n\n\ndef _get_env_dir(prefix: Prefix, version: str) -> str:\n    return prefix.path(helpers.environment_dir(ENVIRONMENT_DIR, version))\n\n\ndef _prefix_if_non_local_file_entry(\n    entry: Sequence[str],\n    prefix: Prefix,\n    src: str,\n) -> Sequence[str]:\n    if entry[1] == '-e':\n        return entry[1:]\n    else:\n        if src == 'local':\n            path = entry[1]\n        else:\n            path = prefix.path(entry[1])\n        return (path,)\n\n\ndef _rscript_exec() -> str:\n    r_home = os.environ.get('R_HOME')\n    if r_home is None:\n        return 'Rscript'\n    else:\n        return os.path.join(r_home, 'bin', 'Rscript')\n\n\ndef _entry_validate(entry: Sequence[str]) -> None:\n    \"\"\"\n    Allowed entries:\n    # Rscript -e expr\n    # Rscript path/to/file\n    \"\"\"\n    if entry[0] != 'Rscript':\n        raise ValueError('entry must start with `Rscript`.')\n\n    if entry[1] == '-e':\n        if len(entry) > 3:\n            raise ValueError('You can supply at most one expression.')\n    elif len(entry) > 2:\n        raise ValueError(\n            'The only valid syntax is `Rscript -e {expr}`',\n            'or `Rscript path/to/hook/script`',\n        )\n\n\ndef _cmd_from_hook(hook: Hook) -> tuple[str, ...]:\n    entry = shlex.split(hook.entry)\n    _entry_validate(entry)\n\n    return (\n        *entry[:1], *RSCRIPT_OPTS,\n        *_prefix_if_non_local_file_entry(entry, hook.prefix, hook.src),\n        *hook.args,\n    )\n\n\ndef install_environment(\n        prefix: Prefix,\n        version: str,\n        additional_dependencies: Sequence[str],\n) -> None:\n    env_dir = _get_env_dir(prefix, version)\n    with clean_path_on_failure(env_dir):\n        os.makedirs(env_dir, exist_ok=True)\n        shutil.copy(prefix.path('renv.lock'), env_dir)\n        shutil.copytree(prefix.path('renv'), os.path.join(env_dir, 'renv'))\n\n        r_code_inst_environment = f\"\"\"\\\n            prefix_dir <- {prefix.prefix_dir!r}\n            options(\n                repos = c(CRAN = \"https://cran.rstudio.com\"),\n                renv.consent = TRUE\n            )\n            source(\"renv/activate.R\")\n            renv::restore()\n            activate_statement <- paste0(\n              'suppressWarnings({{',\n              'old <- setwd(\"', getwd(), '\"); ',\n              'source(\"renv/activate.R\"); ',\n              'setwd(old); ',\n              'renv::load(\"', getwd(), '\");}})'\n            )\n            writeLines(activate_statement, 'activate.R')\n            is_package <- tryCatch(\n              {{\n                  path_desc <- file.path(prefix_dir, 'DESCRIPTION')\n                  suppressWarnings(desc <- read.dcf(path_desc))\n                  \"Package\" %in% colnames(desc)\n              }},\n              error = function(...) FALSE\n            )\n            if (is_package) {{\n                renv::install(prefix_dir)\n            }}\n            \"\"\"\n\n        cmd_output_b(\n            _rscript_exec(), '--vanilla', '-e',\n            _inline_r_setup(r_code_inst_environment),\n            cwd=env_dir,\n        )\n        if additional_dependencies:\n            r_code_inst_add = 'renv::install(commandArgs(trailingOnly = TRUE))'\n            with in_env(prefix, version):\n                cmd_output_b(\n                    _rscript_exec(), *RSCRIPT_OPTS, '-e',\n                    _inline_r_setup(r_code_inst_add),\n                    *additional_dependencies,\n                    cwd=env_dir,\n                )\n\n", "contexts_below": "\n def run_hook(\n         hook: Hook,\n         file_args: Sequence[str],\n         color: bool,\n ) -> tuple[int, bytes]:\n     with in_env(hook.prefix, hook.language_version):\n         return helpers.run_xargs(\n             hook, _cmd_from_hook(hook), file_args, color=color,\n         )\n ", "input_code": "def _inline_r_setup(code: str) -> str:\n\"\"\"\nSome behaviour of R cannot be configured via env variables, but can\nonly be configured via R options once R has started. These are set here.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _inline_r_setup(code: str) -> str:\n    \"\"\"\n    Some behaviour of R cannot be configured via env variables, but can\n    only be configured via R options once R has started. These are set here.\n    \"\"\"\n    with_option = f\"\"\"\\\n    options(install.packages.compile.from.source = \"never\")\n    {code}\n    \"\"\"\n    return with_option", "signature": "def _inline_r_setup(code: str) -> str:", "completion_path": "pre_commit/languages/r.py"}
{"ce_id": "62e4fbda85ea986430890405", "namespace": "62e4fbda85ea986430890405", "namespace_real": "pre_commit.xargs.xargs", "real_proj_path": "pre-commit---pre-commit/", "type": "function", "class_name": null, "function_name": "xargs", "contexts_above": "from __future__ import annotations\n\nimport concurrent.futures\nimport contextlib\nimport math\nimport os\nimport subprocess\nimport sys\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generator\nfrom typing import Iterable\nfrom typing import MutableMapping\nfrom typing import Sequence\nfrom typing import TypeVar\n\nfrom pre_commit import parse_shebang\nfrom pre_commit.util import cmd_output_b\nfrom pre_commit.util import cmd_output_p\n\nTArg = TypeVar('TArg')\nTRet = TypeVar('TRet')\n\n\ndef _environ_size(_env: MutableMapping[str, str] | None = None) -> int:\n    environ = _env if _env is not None else getattr(os, 'environb', os.environ)\n    size = 8 * len(environ)  # number of pointers in `envp`\n    for k, v in environ.items():\n        size += len(k) + len(v) + 2  # c strings in `envp`\n    return size\n\n\ndef _get_platform_max_length() -> int:  # pragma: no cover (platform specific)\n    if os.name == 'posix':\n        maximum = os.sysconf('SC_ARG_MAX') - 2048 - _environ_size()\n        maximum = max(min(maximum, 2 ** 17), 2 ** 12)\n        return maximum\n    elif os.name == 'nt':\n        return 2 ** 15 - 2048  # UNICODE_STRING max - headroom\n    else:\n        # posix minimum\n        return 2 ** 12\n\n\ndef _command_length(*cmd: str) -> int:\n    full_cmd = ' '.join(cmd)\n\n    # win32 uses the amount of characters, more details at:\n    # https://github.com/pre-commit/pre-commit/pull/839\n    if sys.platform == 'win32':\n        return len(full_cmd.encode('utf-16le')) // 2\n    else:\n        return len(full_cmd.encode(sys.getfilesystemencoding()))\n\n\nclass ArgumentTooLongError(RuntimeError):\n    pass\n\n\ndef partition(\n        cmd: Sequence[str],\n        varargs: Sequence[str],\n        target_concurrency: int,\n        _max_length: int | None = None,\n) -> tuple[tuple[str, ...], ...]:\n    _max_length = _max_length or _get_platform_max_length()\n\n    # Generally, we try to partition evenly into at least `target_concurrency`\n    # partitions, but we don't want a bunch of tiny partitions.\n    max_args = max(4, math.ceil(len(varargs) / target_concurrency))\n\n    cmd = tuple(cmd)\n    ret = []\n\n    ret_cmd: list[str] = []\n    # Reversed so arguments are in order\n    varargs = list(reversed(varargs))\n\n    total_length = _command_length(*cmd) + 1\n    while varargs:\n        arg = varargs.pop()\n\n        arg_length = _command_length(arg) + 1\n        if (\n                total_length + arg_length <= _max_length and\n                len(ret_cmd) < max_args\n        ):\n            ret_cmd.append(arg)\n            total_length += arg_length\n        elif not ret_cmd:\n            raise ArgumentTooLongError(arg)\n        else:\n            # We've exceeded the length, yield a command\n            ret.append(cmd + tuple(ret_cmd))\n            ret_cmd = []\n            total_length = _command_length(*cmd) + 1\n            varargs.append(arg)\n\n    ret.append(cmd + tuple(ret_cmd))\n\n    return tuple(ret)\n\n\n@contextlib.contextmanager\ndef _thread_mapper(maxsize: int) -> Generator[\n    Callable[[Callable[[TArg], TRet], Iterable[TArg]], Iterable[TRet]],\n    None, None,\n]:\n    if maxsize == 1:\n        yield map\n    else:\n        with concurrent.futures.ThreadPoolExecutor(maxsize) as ex:\n            yield ex.map\n\n", "contexts_below": "", "input_code": "def xargs(cmd: tuple[str, ...], varargs: Sequence[str], *, color: bool=False, target_concurrency: int=1, _max_length: int=_get_platform_max_length(), **kwargs: Any) -> tuple[int, bytes]:\n\"\"\"\nA simplified implementation of xargs.\n\ncolor: Make a pty if on a platform that supports it\ntarget_concurrency: Target number of partitions to run concurrently\n\"\"\"\n", "indent_space": "        ", "ground_truth": "def xargs(\n        cmd: tuple[str, ...],\n        varargs: Sequence[str],\n        *,\n        color: bool = False,\n        target_concurrency: int = 1,\n        _max_length: int = _get_platform_max_length(),\n        **kwargs: Any,\n) -> tuple[int, bytes]:\n    \"\"\"A simplified implementation of xargs.\n\n    color: Make a pty if on a platform that supports it\n    target_concurrency: Target number of partitions to run concurrently\n    \"\"\"\n    cmd_fn = cmd_output_p if color else cmd_output_b\n    retcode = 0\n    stdout = b''\n\n    try:\n        cmd = parse_shebang.normalize_cmd(cmd)\n    except parse_shebang.ExecutableNotFoundError as e:\n        return e.to_output()[:2]\n\n    # on windows, batch files have a separate length limit than windows itself\n    if (\n            sys.platform == 'win32' and\n            cmd[0].lower().endswith(('.bat', '.cmd'))\n    ):  # pragma: win32 cover\n        # this is implementation details but the command gets translated into\n        # full/path/to/cmd.exe /c *cmd\n        cmd_exe = parse_shebang.find_executable('cmd.exe')\n        # 1024 is additionally subtracted to give headroom for further\n        # expansion inside the batch file\n        _max_length = 8192 - len(cmd_exe) - len(' /c ') - 1024\n\n    partitions = partition(cmd, varargs, target_concurrency, _max_length)\n\n    def run_cmd_partition(\n            run_cmd: tuple[str, ...],\n    ) -> tuple[int, bytes, bytes | None]:\n        return cmd_fn(\n            *run_cmd, retcode=None, stderr=subprocess.STDOUT, **kwargs,\n        )\n\n    threads = min(len(partitions), target_concurrency)\n    with _thread_mapper(threads) as thread_map:\n        results = thread_map(run_cmd_partition, partitions)\n\n        for proc_retcode, proc_out, _ in results:\n            retcode = max(retcode, proc_retcode)\n            stdout += proc_out\n\n    return retcode, stdout", "signature": "def xargs(cmd: tuple[str, ...], varargs: Sequence[str], *, color: bool=False, target_concurrency: int=1, _max_length: int=_get_platform_max_length(), **kwargs: Any) -> tuple[int, bytes]:", "completion_path": "pre_commit/xargs.py"}
{"ce_id": "62e4fbda85ea986430890403", "namespace": "62e4fbda85ea986430890403", "namespace_real": "pre_commit.languages.helpers._shuffled", "real_proj_path": "pre-commit---pre-commit/", "type": "function", "class_name": null, "function_name": "_shuffled", "contexts_above": "from __future__ import annotations\n\nimport multiprocessing\nimport os\nimport random\nimport re\nfrom typing import Any\nfrom typing import NoReturn\nfrom typing import overload\nfrom typing import Sequence\n\nimport pre_commit.constants as C\nfrom pre_commit import parse_shebang\nfrom pre_commit.hook import Hook\nfrom pre_commit.prefix import Prefix\nfrom pre_commit.util import cmd_output_b\nfrom pre_commit.xargs import xargs\n\nFIXED_RANDOM_SEED = 1542676187\n\nSHIMS_RE = re.compile(r'[/\\\\]shims[/\\\\]')\n\n\ndef exe_exists(exe: str) -> bool:\n    found = parse_shebang.find_executable(exe)\n    if found is None:  # exe exists\n        return False\n\n    homedir = os.path.expanduser('~')\n    try:\n        common: str | None = os.path.commonpath((found, homedir))\n    except ValueError:  # on windows, different drives raises ValueError\n        common = None\n\n    return (\n        # it is not in a /shims/ directory\n        not SHIMS_RE.search(found) and\n        (\n            # the homedir is / (docker, service user, etc.)\n            os.path.dirname(homedir) == homedir or\n            # the exe is not contained in the home directory\n            common != homedir\n        )\n    )\n\n\ndef run_setup_cmd(prefix: Prefix, cmd: tuple[str, ...], **kwargs: Any) -> None:\n    cmd_output_b(*cmd, cwd=prefix.prefix_dir, **kwargs)\n\n\n@overload\ndef environment_dir(d: None, language_version: str) -> None: ...\n@overload\ndef environment_dir(d: str, language_version: str) -> str: ...\n\n\ndef environment_dir(d: str | None, language_version: str) -> str | None:\n    if d is None:\n        return None\n    else:\n        return f'{d}-{language_version}'\n\n\ndef assert_version_default(binary: str, version: str) -> None:\n    if version != C.DEFAULT:\n        raise AssertionError(\n            f'for now, pre-commit requires system-installed {binary} -- '\n            f'you selected `language_version: {version}`',\n        )\n\n\ndef assert_no_additional_deps(\n        lang: str,\n        additional_deps: Sequence[str],\n) -> None:\n    if additional_deps:\n        raise AssertionError(\n            f'for now, pre-commit does not support '\n            f'additional_dependencies for {lang} -- '\n            f'you selected `additional_dependencies: {additional_deps}`',\n        )\n\n\ndef basic_get_default_version() -> str:\n    return C.DEFAULT\n\n\ndef basic_health_check(prefix: Prefix, language_version: str) -> str | None:\n    return None\n\n\ndef no_install(\n        prefix: Prefix,\n        version: str,\n        additional_dependencies: Sequence[str],\n) -> NoReturn:\n    raise AssertionError('This type is not installable')\n\n\ndef target_concurrency(hook: Hook) -> int:\n    if hook.require_serial or 'PRE_COMMIT_NO_CONCURRENCY' in os.environ:\n        return 1\n    else:\n        # Travis appears to have a bunch of CPUs, but we can't use them all.\n        if 'TRAVIS' in os.environ:\n            return 2\n        else:\n            try:\n                return multiprocessing.cpu_count()\n            except NotImplementedError:\n                return 1\n\n", "contexts_below": "\n def run_xargs(\n         hook: Hook,\n         cmd: tuple[str, ...],\n         file_args: Sequence[str],\n         **kwargs: Any,\n ) -> tuple[int, bytes]:\n     # Shuffle the files so that they more evenly fill out the xargs partitions,\n     # but do it deterministically in case a hook cares about ordering.\n     file_args = _shuffled(file_args)\n     kwargs['target_concurrency'] = target_concurrency(hook)\n     return xargs(cmd, file_args, **kwargs)\n ", "input_code": "def _shuffled(seq: Sequence[str]) -> list[str]:\n\"\"\"\nDeterministically shuffle\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _shuffled(seq: Sequence[str]) -> list[str]:\n    \"\"\"Deterministically shuffle\"\"\"\n    fixed_random = random.Random()\n    fixed_random.seed(FIXED_RANDOM_SEED, version=1)\n\n    seq = list(seq)\n    fixed_random.shuffle(seq)\n    return seq", "signature": "def _shuffled(seq: Sequence[str]) -> list[str]:", "completion_path": "pre_commit/languages/helpers.py"}
{"ce_id": "62e4fb6585ea98643089032b", "namespace": "62e4fb6585ea98643089032b", "namespace_real": "pre_commit.util.parse_version", "real_proj_path": "pre-commit---pre-commit/", "type": "function", "class_name": null, "function_name": "parse_version", "contexts_above": "from __future__ import annotations\n\nimport contextlib\nimport errno\nimport functools\nimport importlib.resources\nimport os.path\nimport shutil\nimport stat\nimport subprocess\nimport sys\nimport tempfile\nfrom types import TracebackType\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generator\nfrom typing import IO\n\nimport yaml\n\nfrom pre_commit import parse_shebang\n\nLoader = getattr(yaml, 'CSafeLoader', yaml.SafeLoader)\nyaml_load = functools.partial(yaml.load, Loader=Loader)\nDumper = getattr(yaml, 'CSafeDumper', yaml.SafeDumper)\n\n\ndef yaml_dump(o: Any, **kwargs: Any) -> str:\n    # when python/mypy#1484 is solved, this can be `functools.partial`\n    return yaml.dump(\n        o, Dumper=Dumper, default_flow_style=False, indent=4, sort_keys=False,\n        **kwargs,\n    )\n\n\ndef force_bytes(exc: Any) -> bytes:\n    with contextlib.suppress(TypeError):\n        return bytes(exc)\n    with contextlib.suppress(Exception):\n        return str(exc).encode()\n    return f'<unprintable {type(exc).__name__} object>'.encode()\n\n\n@contextlib.contextmanager\ndef clean_path_on_failure(path: str) -> Generator[None, None, None]:\n    \"\"\"Cleans up the directory on an exceptional failure.\"\"\"\n    try:\n        yield\n    except BaseException:\n        if os.path.exists(path):\n            rmtree(path)\n        raise\n\n\n@contextlib.contextmanager\ndef tmpdir() -> Generator[str, None, None]:\n    \"\"\"Contextmanager to create a temporary directory.  It will be cleaned up\n    afterwards.\n    \"\"\"\n    tempdir = tempfile.mkdtemp()\n    try:\n        yield tempdir\n    finally:\n        rmtree(tempdir)\n\n\ndef resource_bytesio(filename: str) -> IO[bytes]:\n    return importlib.resources.open_binary('pre_commit.resources', filename)\n\n\ndef resource_text(filename: str) -> str:\n    return importlib.resources.read_text('pre_commit.resources', filename)\n\n\ndef make_executable(filename: str) -> None:\n    original_mode = os.stat(filename).st_mode\n    new_mode = original_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH\n    os.chmod(filename, new_mode)\n\n\nclass CalledProcessError(RuntimeError):\n    def __init__(\n            self,\n            returncode: int,\n            cmd: tuple[str, ...],\n            expected_returncode: int,\n            stdout: bytes,\n            stderr: bytes | None,\n    ) -> None:\n        super().__init__(returncode, cmd, expected_returncode, stdout, stderr)\n        self.returncode = returncode\n        self.cmd = cmd\n        self.expected_returncode = expected_returncode\n        self.stdout = stdout\n        self.stderr = stderr\n\n    def __bytes__(self) -> bytes:\n        def _indent_or_none(part: bytes | None) -> bytes:\n            if part:\n                return b'\\n    ' + part.replace(b'\\n', b'\\n    ')\n            else:\n                return b' (none)'\n\n        return b''.join((\n            f'command: {self.cmd!r}\\n'.encode(),\n            f'return code: {self.returncode}\\n'.encode(),\n            f'expected return code: {self.expected_returncode}\\n'.encode(),\n            b'stdout:', _indent_or_none(self.stdout), b'\\n',\n            b'stderr:', _indent_or_none(self.stderr),\n        ))\n\n    def __str__(self) -> str:\n        return self.__bytes__().decode()\n\n\ndef _setdefault_kwargs(kwargs: dict[str, Any]) -> None:\n    for arg in ('stdin', 'stdout', 'stderr'):\n        kwargs.setdefault(arg, subprocess.PIPE)\n\n\ndef _oserror_to_output(e: OSError) -> tuple[int, bytes, None]:\n    return 1, force_bytes(e).rstrip(b'\\n') + b'\\n', None\n\n\ndef cmd_output_b(\n        *cmd: str,\n        retcode: int | None = 0,\n        **kwargs: Any,\n) -> tuple[int, bytes, bytes | None]:\n    _setdefault_kwargs(kwargs)\n\n    try:\n        cmd = parse_shebang.normalize_cmd(cmd)\n    except parse_shebang.ExecutableNotFoundError as e:\n        returncode, stdout_b, stderr_b = e.to_output()\n    else:\n        try:\n            proc = subprocess.Popen(cmd, **kwargs)\n        except OSError as e:\n            returncode, stdout_b, stderr_b = _oserror_to_output(e)\n        else:\n            stdout_b, stderr_b = proc.communicate()\n            returncode = proc.returncode\n\n    if retcode is not None and retcode != returncode:\n        raise CalledProcessError(returncode, cmd, retcode, stdout_b, stderr_b)\n\n    return returncode, stdout_b, stderr_b\n\n\ndef cmd_output(*cmd: str, **kwargs: Any) -> tuple[int, str, str | None]:\n    returncode, stdout_b, stderr_b = cmd_output_b(*cmd, **kwargs)\n    stdout = stdout_b.decode() if stdout_b is not None else None\n    stderr = stderr_b.decode() if stderr_b is not None else None\n    return returncode, stdout, stderr\n\n\nif os.name != 'nt':  # pragma: win32 no cover\n    from os import openpty\n    import termios\n\n    class Pty:\n        def __init__(self) -> None:\n            self.r: int | None = None\n            self.w: int | None = None\n\n        def __enter__(self) -> Pty:\n            self.r, self.w = openpty()\n\n            # tty flags normally change \\n to \\r\\n\n            attrs = termios.tcgetattr(self.w)\n            assert isinstance(attrs[1], int)\n            attrs[1] &= ~(termios.ONLCR | termios.OPOST)\n            termios.tcsetattr(self.w, termios.TCSANOW, attrs)\n\n            return self\n\n        def close_w(self) -> None:\n            if self.w is not None:\n                os.close(self.w)\n                self.w = None\n\n        def close_r(self) -> None:\n            assert self.r is not None\n            os.close(self.r)\n            self.r = None\n\n        def __exit__(\n                self,\n                exc_type: type[BaseException] | None,\n                exc_value: BaseException | None,\n                traceback: TracebackType | None,\n        ) -> None:\n            self.close_w()\n            self.close_r()\n\n    def cmd_output_p(\n            *cmd: str,\n            retcode: int | None = 0,\n            **kwargs: Any,\n    ) -> tuple[int, bytes, bytes | None]:\n        assert retcode is None\n        assert kwargs['stderr'] == subprocess.STDOUT, kwargs['stderr']\n        _setdefault_kwargs(kwargs)\n\n        try:\n            cmd = parse_shebang.normalize_cmd(cmd)\n        except parse_shebang.ExecutableNotFoundError as e:\n            return e.to_output()\n\n        with open(os.devnull) as devnull, Pty() as pty:\n            assert pty.r is not None\n            kwargs.update({'stdin': devnull, 'stdout': pty.w, 'stderr': pty.w})\n            try:\n                proc = subprocess.Popen(cmd, **kwargs)\n            except OSError as e:\n                return _oserror_to_output(e)\n\n            pty.close_w()\n\n            buf = b''\n            while True:\n                try:\n                    bts = os.read(pty.r, 4096)\n                except OSError as e:\n                    if e.errno == errno.EIO:\n                        bts = b''\n                    else:\n                        raise\n                else:\n                    buf += bts\n                if not bts:\n                    break\n\n        return proc.wait(), buf, None\nelse:  # pragma: no cover\n    cmd_output_p = cmd_output_b\n\n\ndef rmtree(path: str) -> None:\n    \"\"\"On windows, rmtree fails for readonly dirs.\"\"\"\n    def handle_remove_readonly(\n            func: Callable[..., Any],\n            path: str,\n            exc: tuple[type[OSError], OSError, TracebackType],\n    ) -> None:\n        excvalue = exc[1]\n        if (\n                func in (os.rmdir, os.remove, os.unlink) and\n                excvalue.errno in {errno.EACCES, errno.EPERM}\n        ):\n            for p in (path, os.path.dirname(path)):\n                os.chmod(p, os.stat(p).st_mode | stat.S_IWUSR)\n            func(path)\n        else:\n            raise\n    shutil.rmtree(path, ignore_errors=False, onerror=handle_remove_readonly)\n\n", "contexts_below": "\n def win_exe(s: str) -> str:\n     return s if sys.platform != 'win32' else f'{s}.exe'\n ", "input_code": "def parse_version(s: str) -> tuple[int, ...]:\n\"\"\"\npoor man's version comparison\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def parse_version(s: str) -> tuple[int, ...]:\n    \"\"\"poor man's version comparison\"\"\"\n    return tuple(int(p) for p in s.split('.'))", "signature": "def parse_version(s: str) -> tuple[int, ...]:", "completion_path": "pre_commit/util.py"}
{"ce_id": "62e4fb4d85ea9864308902e7", "namespace": "62e4fb4d85ea9864308902e7", "namespace_real": "pre_commit.parse_shebang.normalize_cmd", "real_proj_path": "pre-commit---pre-commit/", "type": "function", "class_name": null, "function_name": "normalize_cmd", "contexts_above": "from __future__ import annotations\n\nimport os.path\nfrom typing import Mapping\nfrom typing import NoReturn\n\nfrom identify.identify import parse_shebang_from_file\n\n\nclass ExecutableNotFoundError(OSError):\n    def to_output(self) -> tuple[int, bytes, None]:\n        return (1, self.args[0].encode(), None)\n\n\ndef parse_filename(filename: str) -> tuple[str, ...]:\n    if not os.path.exists(filename):\n        return ()\n    else:\n        return parse_shebang_from_file(filename)\n\n\ndef find_executable(\n        exe: str, _environ: Mapping[str, str] | None = None,\n) -> str | None:\n    exe = os.path.normpath(exe)\n    if os.sep in exe:\n        return exe\n\n    environ = _environ if _environ is not None else os.environ\n\n    if 'PATHEXT' in environ:\n        exts = environ['PATHEXT'].split(os.pathsep)\n        possible_exe_names = tuple(f'{exe}{ext}' for ext in exts) + (exe,)\n    else:\n        possible_exe_names = (exe,)\n\n    for path in environ.get('PATH', '').split(os.pathsep):\n        for possible_exe_name in possible_exe_names:\n            joined = os.path.join(path, possible_exe_name)\n            if os.path.isfile(joined) and os.access(joined, os.X_OK):\n                return joined\n    else:\n        return None\n\n\ndef normexe(orig: str) -> str:\n    def _error(msg: str) -> NoReturn:\n        raise ExecutableNotFoundError(f'Executable `{orig}` {msg}')\n\n    if os.sep not in orig and (not os.altsep or os.altsep not in orig):\n        exe = find_executable(orig)\n        if exe is None:\n            _error('not found')\n        return exe\n    elif os.path.isdir(orig):\n        _error('is a directory')\n    elif not os.path.isfile(orig):\n        _error('not found')\n    elif not os.access(orig, os.X_OK):  # pragma: win32 no cover\n        _error('is not executable')\n    else:\n        return orig\n\n", "contexts_below": "", "input_code": "def normalize_cmd(cmd: tuple[str, ...]) -> tuple[str, ...]:\n\"\"\"\nFixes for the following issues on windows\n- https://bugs.python.org/issue8557\n- windows does not parse shebangs\n\nThis function also makes deep-path shebangs work just fine\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def normalize_cmd(cmd: tuple[str, ...]) -> tuple[str, ...]:\n    \"\"\"Fixes for the following issues on windows\n    - https://bugs.python.org/issue8557\n    - windows does not parse shebangs\n\n    This function also makes deep-path shebangs work just fine\n    \"\"\"\n    # Use PATH to determine the executable\n    exe = normexe(cmd[0])\n\n    # Figure out the shebang from the resulting command\n    cmd = parse_filename(exe) + (exe,) + cmd[1:]\n\n    # This could have given us back another bare executable\n    exe = normexe(cmd[0])\n\n    return (exe,) + cmd[1:]", "signature": "def normalize_cmd(cmd: tuple[str, ...]) -> tuple[str, ...]:", "completion_path": "pre_commit/parse_shebang.py"}
{"ce_id": "62b8d27a48ba5a41d1c3f4c6", "namespace": "62b8d27a48ba5a41d1c3f4c6", "namespace_real": "cachetools.decorators.cached", "real_proj_path": "pexip---os-python-cachetools/", "type": "function", "class_name": null, "function_name": "cached", "contexts_above": "import functools\n\nfrom .keys import hashkey\n\n", "contexts_below": "\n def cachedmethod(cache, key=hashkey, lock=None):\n     \"\"\"Decorator to wrap a class or instance method with a memoizing\n     callable that saves results in a cache.\n \n     \"\"\"\n     def decorator(method):\n         if lock is None:\n             def wrapper(self, *args, **kwargs):\n                 c = cache(self)\n                 if c is None:\n                     return method(self, *args, **kwargs)\n                 k = key(*args, **kwargs)\n                 try:\n                     return c[k]\n                 except KeyError:\n                     pass  # key not found\n                 v = method(self, *args, **kwargs)\n                 try:\n                     c[k] = v\n                 except ValueError:\n                     pass  # value too large\n                 return v\n         else:\n             def wrapper(self, *args, **kwargs):\n                 c = cache(self)\n                 if c is None:\n                     return method(self, *args, **kwargs)\n                 k = key(*args, **kwargs)\n                 try:\n                     with lock(self):\n                         return c[k]\n                 except KeyError:\n                     pass  # key not found\n                 v = method(self, *args, **kwargs)\n                 # in case of a race, prefer the item already in the cache\n                 try:\n                     with lock(self):\n                         return c.setdefault(k, v)\n                 except ValueError:\n                     return v  # value too large\n         return functools.update_wrapper(wrapper, method)\n     return decorator\n ", "input_code": "def cached(cache, key=hashkey, lock=None):\n\"\"\"\nDecorator to wrap a function with a memoizing callable that saves\nresults in a cache.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def cached(cache, key=hashkey, lock=None):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    results in a cache.\n\n    \"\"\"\n    def decorator(func):\n        if cache is None:\n            def wrapper(*args, **kwargs):\n                return func(*args, **kwargs)\n        elif lock is None:\n            def wrapper(*args, **kwargs):\n                k = key(*args, **kwargs)\n                try:\n                    return cache[k]\n                except KeyError:\n                    pass  # key not found\n                v = func(*args, **kwargs)\n                try:\n                    cache[k] = v\n                except ValueError:\n                    pass  # value too large\n                return v\n        else:\n            def wrapper(*args, **kwargs):\n                k = key(*args, **kwargs)\n                try:\n                    with lock:\n                        return cache[k]\n                except KeyError:\n                    pass  # key not found\n                v = func(*args, **kwargs)\n                # in case of a race, prefer the item already in the cache\n                try:\n                    with lock:\n                        return cache.setdefault(k, v)\n                except ValueError:\n                    return v  # value too large\n        return functools.update_wrapper(wrapper, func)\n    return decorator", "signature": "def cached(cache, key=hashkey, lock=None):", "completion_path": "cachetools/decorators.py"}
{"ce_id": "62b8d24048ba5a41d1c3f49f", "namespace": "62b8d24048ba5a41d1c3f49f", "namespace_real": "cachetools.func.ttl_cache", "real_proj_path": "pexip---os-python-cachetools/", "type": "function", "class_name": null, "function_name": "ttl_cache", "contexts_above": "\"\"\"`functools.lru_cache` compatible memoizing function decorators.\"\"\"\n\nimport collections\nimport functools\nimport math\nimport random\nimport time\n\ntry:\n    from threading import RLock\nexcept ImportError:  # pragma: no cover\n    from dummy_threading import RLock\n\nfrom . import keys\nfrom .fifo import FIFOCache\nfrom .lfu import LFUCache\nfrom .lru import LRUCache\nfrom .mru import MRUCache\nfrom .rr import RRCache\nfrom .ttl import TTLCache\n\n__all__ = ('lfu_cache', 'lru_cache', 'mru_cache', 'rr_cache', 'ttl_cache')\n\n\n_CacheInfo = collections.namedtuple('CacheInfo', [\n    'hits', 'misses', 'maxsize', 'currsize'\n])\n\n\nclass _UnboundCache(dict):\n\n    @property\n    def maxsize(self):\n        return None\n\n    @property\n    def currsize(self):\n        return len(self)\n\n\nclass _UnboundTTLCache(TTLCache):\n    def __init__(self, ttl, timer):\n        TTLCache.__init__(self, math.inf, ttl, timer)\n\n    @property\n    def maxsize(self):\n        return None\n\n\ndef _cache(cache, typed):\n    maxsize = cache.maxsize\n\n    def decorator(func):\n        key = keys.typedkey if typed else keys.hashkey\n        lock = RLock()\n        stats = [0, 0]\n\n        def wrapper(*args, **kwargs):\n            k = key(*args, **kwargs)\n            with lock:\n                try:\n                    v = cache[k]\n                    stats[0] += 1\n                    return v\n                except KeyError:\n                    stats[1] += 1\n            v = func(*args, **kwargs)\n            # in case of a race, prefer the item already in the cache\n            try:\n                with lock:\n                    return cache.setdefault(k, v)\n            except ValueError:\n                return v  # value too large\n\n        def cache_info():\n            with lock:\n                hits, misses = stats\n                maxsize = cache.maxsize\n                currsize = cache.currsize\n            return _CacheInfo(hits, misses, maxsize, currsize)\n\n        def cache_clear():\n            with lock:\n                try:\n                    cache.clear()\n                finally:\n                    stats[:] = [0, 0]\n\n        wrapper.cache_info = cache_info\n        wrapper.cache_clear = cache_clear\n        wrapper.cache_parameters = lambda: {'maxsize': maxsize, 'typed': typed}\n        functools.update_wrapper(wrapper, func)\n        return wrapper\n    return decorator\n\n\ndef fifo_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a First In First Out (FIFO)\n    algorithm.\n\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(FIFOCache(128), typed)(maxsize)\n    else:\n        return _cache(FIFOCache(maxsize), typed)\n\n\ndef lfu_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a Least Frequently Used (LFU)\n    algorithm.\n\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(LFUCache(128), typed)(maxsize)\n    else:\n        return _cache(LFUCache(maxsize), typed)\n\n\ndef lru_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a Least Recently Used (LRU)\n    algorithm.\n\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(LRUCache(128), typed)(maxsize)\n    else:\n        return _cache(LRUCache(maxsize), typed)\n\n\ndef mru_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a Most Recently Used (MRU)\n    algorithm.\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(MRUCache(128), typed)(maxsize)\n    else:\n        return _cache(MRUCache(maxsize), typed)\n\n\ndef rr_cache(maxsize=128, choice=random.choice, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a Random Replacement (RR)\n    algorithm.\n\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(RRCache(128, choice), typed)(maxsize)\n    else:\n        return _cache(RRCache(maxsize, choice), typed)\n\n", "contexts_below": "", "input_code": "def ttl_cache(maxsize=128, ttl=600, timer=time.monotonic, typed=False):\n\"\"\"\nDecorator to wrap a function with a memoizing callable that saves\nup to `maxsize` results based on a Least Recently Used (LRU)\nalgorithm with a per-item time-to-live (TTL) value.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def ttl_cache(maxsize=128, ttl=600, timer=time.monotonic, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a Least Recently Used (LRU)\n    algorithm with a per-item time-to-live (TTL) value.\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundTTLCache(ttl, timer), typed)\n    elif callable(maxsize):\n        return _cache(TTLCache(128, ttl, timer), typed)(maxsize)\n    else:\n        return _cache(TTLCache(maxsize, ttl, timer), typed)", "signature": "def ttl_cache(maxsize=128, ttl=600, timer=time.monotonic, typed=False):", "completion_path": "cachetools/func.py"}
{"ce_id": "62b8d23b48ba5a41d1c3f49a", "namespace": "62b8d23b48ba5a41d1c3f49a", "namespace_real": "cachetools.func.mru_cache", "real_proj_path": "pexip---os-python-cachetools/", "type": "function", "class_name": null, "function_name": "mru_cache", "contexts_above": "\"\"\"`functools.lru_cache` compatible memoizing function decorators.\"\"\"\n\nimport collections\nimport functools\nimport math\nimport random\nimport time\n\ntry:\n    from threading import RLock\nexcept ImportError:  # pragma: no cover\n    from dummy_threading import RLock\n\nfrom . import keys\nfrom .fifo import FIFOCache\nfrom .lfu import LFUCache\nfrom .lru import LRUCache\nfrom .mru import MRUCache\nfrom .rr import RRCache\nfrom .ttl import TTLCache\n\n__all__ = ('lfu_cache', 'lru_cache', 'mru_cache', 'rr_cache', 'ttl_cache')\n\n\n_CacheInfo = collections.namedtuple('CacheInfo', [\n    'hits', 'misses', 'maxsize', 'currsize'\n])\n\n\nclass _UnboundCache(dict):\n\n    @property\n    def maxsize(self):\n        return None\n\n    @property\n    def currsize(self):\n        return len(self)\n\n\nclass _UnboundTTLCache(TTLCache):\n    def __init__(self, ttl, timer):\n        TTLCache.__init__(self, math.inf, ttl, timer)\n\n    @property\n    def maxsize(self):\n        return None\n\n\ndef _cache(cache, typed):\n    maxsize = cache.maxsize\n\n    def decorator(func):\n        key = keys.typedkey if typed else keys.hashkey\n        lock = RLock()\n        stats = [0, 0]\n\n        def wrapper(*args, **kwargs):\n            k = key(*args, **kwargs)\n            with lock:\n                try:\n                    v = cache[k]\n                    stats[0] += 1\n                    return v\n                except KeyError:\n                    stats[1] += 1\n            v = func(*args, **kwargs)\n            # in case of a race, prefer the item already in the cache\n            try:\n                with lock:\n                    return cache.setdefault(k, v)\n            except ValueError:\n                return v  # value too large\n\n        def cache_info():\n            with lock:\n                hits, misses = stats\n                maxsize = cache.maxsize\n                currsize = cache.currsize\n            return _CacheInfo(hits, misses, maxsize, currsize)\n\n        def cache_clear():\n            with lock:\n                try:\n                    cache.clear()\n                finally:\n                    stats[:] = [0, 0]\n\n        wrapper.cache_info = cache_info\n        wrapper.cache_clear = cache_clear\n        wrapper.cache_parameters = lambda: {'maxsize': maxsize, 'typed': typed}\n        functools.update_wrapper(wrapper, func)\n        return wrapper\n    return decorator\n\n\ndef fifo_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a First In First Out (FIFO)\n    algorithm.\n\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(FIFOCache(128), typed)(maxsize)\n    else:\n        return _cache(FIFOCache(maxsize), typed)\n\n\ndef lfu_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a Least Frequently Used (LFU)\n    algorithm.\n\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(LFUCache(128), typed)(maxsize)\n    else:\n        return _cache(LFUCache(maxsize), typed)\n\n\ndef lru_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a Least Recently Used (LRU)\n    algorithm.\n\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(LRUCache(128), typed)(maxsize)\n    else:\n        return _cache(LRUCache(maxsize), typed)\n\n", "contexts_below": "\n def rr_cache(maxsize=128, choice=random.choice, typed=False):\n     \"\"\"Decorator to wrap a function with a memoizing callable that saves\n     up to `maxsize` results based on a Random Replacement (RR)\n     algorithm.\n \n     \"\"\"\n     if maxsize is None:\n         return _cache(_UnboundCache(), typed)\n     elif callable(maxsize):\n         return _cache(RRCache(128, choice), typed)(maxsize)\n     else:\n         return _cache(RRCache(maxsize, choice), typed)\n \n \n def ttl_cache(maxsize=128, ttl=600, timer=time.monotonic, typed=False):\n     \"\"\"Decorator to wrap a function with a memoizing callable that saves\n     up to `maxsize` results based on a Least Recently Used (LRU)\n     algorithm with a per-item time-to-live (TTL) value.\n     \"\"\"\n     if maxsize is None:\n         return _cache(_UnboundTTLCache(ttl, timer), typed)\n     elif callable(maxsize):\n         return _cache(TTLCache(128, ttl, timer), typed)(maxsize)\n     else:\n         return _cache(TTLCache(maxsize, ttl, timer), typed)\n ", "input_code": "def mru_cache(maxsize=128, typed=False):\n\"\"\"\nDecorator to wrap a function with a memoizing callable that saves\nup to `maxsize` results based on a Most Recently Used (MRU)\nalgorithm.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def mru_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a Most Recently Used (MRU)\n    algorithm.\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(MRUCache(128), typed)(maxsize)\n    else:\n        return _cache(MRUCache(maxsize), typed)", "signature": "def mru_cache(maxsize=128, typed=False):", "completion_path": "cachetools/func.py"}
{"ce_id": "62b8d23948ba5a41d1c3f498", "namespace": "62b8d23948ba5a41d1c3f498", "namespace_real": "cachetools.func.lru_cache", "real_proj_path": "pexip---os-python-cachetools/", "type": "function", "class_name": null, "function_name": "lru_cache", "contexts_above": "\"\"\"`functools.lru_cache` compatible memoizing function decorators.\"\"\"\n\nimport collections\nimport functools\nimport math\nimport random\nimport time\n\ntry:\n    from threading import RLock\nexcept ImportError:  # pragma: no cover\n    from dummy_threading import RLock\n\nfrom . import keys\nfrom .fifo import FIFOCache\nfrom .lfu import LFUCache\nfrom .lru import LRUCache\nfrom .mru import MRUCache\nfrom .rr import RRCache\nfrom .ttl import TTLCache\n\n__all__ = ('lfu_cache', 'lru_cache', 'mru_cache', 'rr_cache', 'ttl_cache')\n\n\n_CacheInfo = collections.namedtuple('CacheInfo', [\n    'hits', 'misses', 'maxsize', 'currsize'\n])\n\n\nclass _UnboundCache(dict):\n\n    @property\n    def maxsize(self):\n        return None\n\n    @property\n    def currsize(self):\n        return len(self)\n\n\nclass _UnboundTTLCache(TTLCache):\n    def __init__(self, ttl, timer):\n        TTLCache.__init__(self, math.inf, ttl, timer)\n\n    @property\n    def maxsize(self):\n        return None\n\n\ndef _cache(cache, typed):\n    maxsize = cache.maxsize\n\n    def decorator(func):\n        key = keys.typedkey if typed else keys.hashkey\n        lock = RLock()\n        stats = [0, 0]\n\n        def wrapper(*args, **kwargs):\n            k = key(*args, **kwargs)\n            with lock:\n                try:\n                    v = cache[k]\n                    stats[0] += 1\n                    return v\n                except KeyError:\n                    stats[1] += 1\n            v = func(*args, **kwargs)\n            # in case of a race, prefer the item already in the cache\n            try:\n                with lock:\n                    return cache.setdefault(k, v)\n            except ValueError:\n                return v  # value too large\n\n        def cache_info():\n            with lock:\n                hits, misses = stats\n                maxsize = cache.maxsize\n                currsize = cache.currsize\n            return _CacheInfo(hits, misses, maxsize, currsize)\n\n        def cache_clear():\n            with lock:\n                try:\n                    cache.clear()\n                finally:\n                    stats[:] = [0, 0]\n\n        wrapper.cache_info = cache_info\n        wrapper.cache_clear = cache_clear\n        wrapper.cache_parameters = lambda: {'maxsize': maxsize, 'typed': typed}\n        functools.update_wrapper(wrapper, func)\n        return wrapper\n    return decorator\n\n\ndef fifo_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a First In First Out (FIFO)\n    algorithm.\n\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(FIFOCache(128), typed)(maxsize)\n    else:\n        return _cache(FIFOCache(maxsize), typed)\n\n\ndef lfu_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a Least Frequently Used (LFU)\n    algorithm.\n\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(LFUCache(128), typed)(maxsize)\n    else:\n        return _cache(LFUCache(maxsize), typed)\n\n", "contexts_below": "\n def mru_cache(maxsize=128, typed=False):\n     \"\"\"Decorator to wrap a function with a memoizing callable that saves\n     up to `maxsize` results based on a Most Recently Used (MRU)\n     algorithm.\n     \"\"\"\n     if maxsize is None:\n         return _cache(_UnboundCache(), typed)\n     elif callable(maxsize):\n         return _cache(MRUCache(128), typed)(maxsize)\n     else:\n         return _cache(MRUCache(maxsize), typed)\n \n \n def rr_cache(maxsize=128, choice=random.choice, typed=False):\n     \"\"\"Decorator to wrap a function with a memoizing callable that saves\n     up to `maxsize` results based on a Random Replacement (RR)\n     algorithm.\n \n     \"\"\"\n     if maxsize is None:\n         return _cache(_UnboundCache(), typed)\n     elif callable(maxsize):\n         return _cache(RRCache(128, choice), typed)(maxsize)\n     else:\n         return _cache(RRCache(maxsize, choice), typed)\n \n \n def ttl_cache(maxsize=128, ttl=600, timer=time.monotonic, typed=False):\n     \"\"\"Decorator to wrap a function with a memoizing callable that saves\n     up to `maxsize` results based on a Least Recently Used (LRU)\n     algorithm with a per-item time-to-live (TTL) value.\n     \"\"\"\n     if maxsize is None:\n         return _cache(_UnboundTTLCache(ttl, timer), typed)\n     elif callable(maxsize):\n         return _cache(TTLCache(128, ttl, timer), typed)(maxsize)\n     else:\n         return _cache(TTLCache(maxsize, ttl, timer), typed)\n ", "input_code": "def lru_cache(maxsize=128, typed=False):\n\"\"\"\nDecorator to wrap a function with a memoizing callable that saves\nup to `maxsize` results based on a Least Recently Used (LRU)\nalgorithm.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def lru_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a Least Recently Used (LRU)\n    algorithm.\n\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(LRUCache(128), typed)(maxsize)\n    else:\n        return _cache(LRUCache(maxsize), typed)", "signature": "def lru_cache(maxsize=128, typed=False):", "completion_path": "cachetools/func.py"}
{"ce_id": "62b8d23748ba5a41d1c3f496", "namespace": "62b8d23748ba5a41d1c3f496", "namespace_real": "cachetools.func.lfu_cache", "real_proj_path": "pexip---os-python-cachetools/", "type": "function", "class_name": null, "function_name": "lfu_cache", "contexts_above": "\"\"\"`functools.lru_cache` compatible memoizing function decorators.\"\"\"\n\nimport collections\nimport functools\nimport math\nimport random\nimport time\n\ntry:\n    from threading import RLock\nexcept ImportError:  # pragma: no cover\n    from dummy_threading import RLock\n\nfrom . import keys\nfrom .fifo import FIFOCache\nfrom .lfu import LFUCache\nfrom .lru import LRUCache\nfrom .mru import MRUCache\nfrom .rr import RRCache\nfrom .ttl import TTLCache\n\n__all__ = ('lfu_cache', 'lru_cache', 'mru_cache', 'rr_cache', 'ttl_cache')\n\n\n_CacheInfo = collections.namedtuple('CacheInfo', [\n    'hits', 'misses', 'maxsize', 'currsize'\n])\n\n\nclass _UnboundCache(dict):\n\n    @property\n    def maxsize(self):\n        return None\n\n    @property\n    def currsize(self):\n        return len(self)\n\n\nclass _UnboundTTLCache(TTLCache):\n    def __init__(self, ttl, timer):\n        TTLCache.__init__(self, math.inf, ttl, timer)\n\n    @property\n    def maxsize(self):\n        return None\n\n\ndef _cache(cache, typed):\n    maxsize = cache.maxsize\n\n    def decorator(func):\n        key = keys.typedkey if typed else keys.hashkey\n        lock = RLock()\n        stats = [0, 0]\n\n        def wrapper(*args, **kwargs):\n            k = key(*args, **kwargs)\n            with lock:\n                try:\n                    v = cache[k]\n                    stats[0] += 1\n                    return v\n                except KeyError:\n                    stats[1] += 1\n            v = func(*args, **kwargs)\n            # in case of a race, prefer the item already in the cache\n            try:\n                with lock:\n                    return cache.setdefault(k, v)\n            except ValueError:\n                return v  # value too large\n\n        def cache_info():\n            with lock:\n                hits, misses = stats\n                maxsize = cache.maxsize\n                currsize = cache.currsize\n            return _CacheInfo(hits, misses, maxsize, currsize)\n\n        def cache_clear():\n            with lock:\n                try:\n                    cache.clear()\n                finally:\n                    stats[:] = [0, 0]\n\n        wrapper.cache_info = cache_info\n        wrapper.cache_clear = cache_clear\n        wrapper.cache_parameters = lambda: {'maxsize': maxsize, 'typed': typed}\n        functools.update_wrapper(wrapper, func)\n        return wrapper\n    return decorator\n\n\ndef fifo_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a First In First Out (FIFO)\n    algorithm.\n\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(FIFOCache(128), typed)(maxsize)\n    else:\n        return _cache(FIFOCache(maxsize), typed)\n\n", "contexts_below": "\n def lru_cache(maxsize=128, typed=False):\n     \"\"\"Decorator to wrap a function with a memoizing callable that saves\n     up to `maxsize` results based on a Least Recently Used (LRU)\n     algorithm.\n \n     \"\"\"\n     if maxsize is None:\n         return _cache(_UnboundCache(), typed)\n     elif callable(maxsize):\n         return _cache(LRUCache(128), typed)(maxsize)\n     else:\n         return _cache(LRUCache(maxsize), typed)\n \n \n def mru_cache(maxsize=128, typed=False):\n     \"\"\"Decorator to wrap a function with a memoizing callable that saves\n     up to `maxsize` results based on a Most Recently Used (MRU)\n     algorithm.\n     \"\"\"\n     if maxsize is None:\n         return _cache(_UnboundCache(), typed)\n     elif callable(maxsize):\n         return _cache(MRUCache(128), typed)(maxsize)\n     else:\n         return _cache(MRUCache(maxsize), typed)\n \n \n def rr_cache(maxsize=128, choice=random.choice, typed=False):\n     \"\"\"Decorator to wrap a function with a memoizing callable that saves\n     up to `maxsize` results based on a Random Replacement (RR)\n     algorithm.\n \n     \"\"\"\n     if maxsize is None:\n         return _cache(_UnboundCache(), typed)\n     elif callable(maxsize):\n         return _cache(RRCache(128, choice), typed)(maxsize)\n     else:\n         return _cache(RRCache(maxsize, choice), typed)\n \n \n def ttl_cache(maxsize=128, ttl=600, timer=time.monotonic, typed=False):\n     \"\"\"Decorator to wrap a function with a memoizing callable that saves\n     up to `maxsize` results based on a Least Recently Used (LRU)\n     algorithm with a per-item time-to-live (TTL) value.\n     \"\"\"\n     if maxsize is None:\n         return _cache(_UnboundTTLCache(ttl, timer), typed)\n     elif callable(maxsize):\n         return _cache(TTLCache(128, ttl, timer), typed)(maxsize)\n     else:\n         return _cache(TTLCache(maxsize, ttl, timer), typed)\n ", "input_code": "def lfu_cache(maxsize=128, typed=False):\n\"\"\"\nDecorator to wrap a function with a memoizing callable that saves\nup to `maxsize` results based on a Least Frequently Used (LFU)\nalgorithm.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def lfu_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a Least Frequently Used (LFU)\n    algorithm.\n\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(LFUCache(128), typed)(maxsize)\n    else:\n        return _cache(LFUCache(maxsize), typed)", "signature": "def lfu_cache(maxsize=128, typed=False):", "completion_path": "cachetools/func.py"}
{"ce_id": "62b8d22f48ba5a41d1c3f488", "namespace": "62b8d22f48ba5a41d1c3f488", "namespace_real": "cachetools.fifo.popitem", "real_proj_path": "pexip---os-python-cachetools/", "type": "class", "class_name": "fifo", "function_name": "popitem", "contexts_above": "import collections\n\nfrom .cache import Cache\n\n\nclass FIFOCache(Cache):\n    \"\"\"First In First Out (FIFO) cache implementation.\"\"\"\n\n    def __init__(self, maxsize, getsizeof=None):\n        Cache.__init__(self, maxsize, getsizeof)\n        self.__order = collections.OrderedDict()\n\n    def __setitem__(self, key, value, cache_setitem=Cache.__setitem__):\n        cache_setitem(self, key, value)\n        try:\n            self.__order.move_to_end(key)\n        except KeyError:\n            self.__order[key] = None\n\n    def __delitem__(self, key, cache_delitem=Cache.__delitem__):\n        cache_delitem(self, key)\n        del self.__order[key]\n", "contexts_below": "", "input_code": "def popitem(self):\n\"\"\"\nRemove and return the `(key, value)` pair first inserted.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def popitem(self):\n        \"\"\"Remove and return the `(key, value)` pair first inserted.\"\"\"\n        try:\n            key = next(iter(self.__order))\n        except StopIteration:\n            raise KeyError('%s is empty' % type(self).__name__) from None\n        else:\n            return (key, self.pop(key))", "signature": "def popitem(self):", "completion_path": "cachetools/fifo.py"}
{"ce_id": "62b8d22a48ba5a41d1c3f47e", "namespace": "62b8d22a48ba5a41d1c3f47e", "namespace_real": "cachetools.cache.setdefault", "real_proj_path": "pexip---os-python-cachetools/", "type": "class", "class_name": "cache", "function_name": "setdefault", "contexts_above": "from collections.abc import MutableMapping\n\n\nclass _DefaultSize(object):\n\n    __slots__ = ()\n\n    def __getitem__(self, _):\n        return 1\n\n    def __setitem__(self, _, value):\n        assert value == 1\n\n    def pop(self, _):\n        return 1\n\n\nclass Cache(MutableMapping):\n    \"\"\"Mutable mapping to serve as a simple cache or cache base class.\"\"\"\n\n    __marker = object()\n\n    __size = _DefaultSize()\n\n    def __init__(self, maxsize, getsizeof=None):\n        if getsizeof:\n            self.getsizeof = getsizeof\n        if self.getsizeof is not Cache.getsizeof:\n            self.__size = dict()\n        self.__data = dict()\n        self.__currsize = 0\n        self.__maxsize = maxsize\n\n    def __repr__(self):\n        return '%s(%r, maxsize=%r, currsize=%r)' % (\n            self.__class__.__name__,\n            list(self.__data.items()),\n            self.__maxsize,\n            self.__currsize,\n        )\n\n    def __getitem__(self, key):\n        try:\n            return self.__data[key]\n        except KeyError:\n            return self.__missing__(key)\n\n    def __setitem__(self, key, value):\n        maxsize = self.__maxsize\n        size = self.getsizeof(value)\n        if size > maxsize:\n            raise ValueError('value too large')\n        if key not in self.__data or self.__size[key] < size:\n            while self.__currsize + size > maxsize:\n                self.popitem()\n        if key in self.__data:\n            diffsize = size - self.__size[key]\n        else:\n            diffsize = size\n        self.__data[key] = value\n        self.__size[key] = size\n        self.__currsize += diffsize\n\n    def __delitem__(self, key):\n        size = self.__size.pop(key)\n        del self.__data[key]\n        self.__currsize -= size\n\n    def __contains__(self, key):\n        return key in self.__data\n\n    def __missing__(self, key):\n        raise KeyError(key)\n\n    def __iter__(self):\n        return iter(self.__data)\n\n    def __len__(self):\n        return len(self.__data)\n\n    def get(self, key, default=None):\n        if key in self:\n            return self[key]\n        else:\n            return default\n\n    def pop(self, key, default=__marker):\n        if key in self:\n            value = self[key]\n            del self[key]\n        elif default is self.__marker:\n            raise KeyError(key)\n        else:\n            value = default\n        return value\n", "contexts_below": "    @property\n     def maxsize(self):\n         \"\"\"The maximum size of the cache.\"\"\"\n         return self.__maxsize\n \n     @property\n     def currsize(self):\n         \"\"\"The current size of the cache.\"\"\"\n         return self.__currsize\n \n     @staticmethod\n     def getsizeof(value):\n         \"\"\"Return the size of a cache element's value.\"\"\"\n         return 1\n ", "input_code": "def setdefault(self, key, default=None):\n\"\"\"\nD.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def setdefault(self, key, default=None):\n        if key in self:\n            value = self[key]\n        else:\n            self[key] = value = default\n        return value", "signature": "def setdefault(self, key, default=None):", "completion_path": "cachetools/cache.py"}
{"ce_id": "62b8d22948ba5a41d1c3f47c", "namespace": "62b8d22948ba5a41d1c3f47c", "namespace_real": "cachetools.cache.get", "real_proj_path": "pexip---os-python-cachetools/", "type": "class", "class_name": "cache", "function_name": "get", "contexts_above": "from collections.abc import MutableMapping\n\n\nclass _DefaultSize(object):\n\n    __slots__ = ()\n\n    def __getitem__(self, _):\n        return 1\n\n    def __setitem__(self, _, value):\n        assert value == 1\n\n    def pop(self, _):\n        return 1\n\n\nclass Cache(MutableMapping):\n    \"\"\"Mutable mapping to serve as a simple cache or cache base class.\"\"\"\n\n    __marker = object()\n\n    __size = _DefaultSize()\n\n    def __init__(self, maxsize, getsizeof=None):\n        if getsizeof:\n            self.getsizeof = getsizeof\n        if self.getsizeof is not Cache.getsizeof:\n            self.__size = dict()\n        self.__data = dict()\n        self.__currsize = 0\n        self.__maxsize = maxsize\n\n    def __repr__(self):\n        return '%s(%r, maxsize=%r, currsize=%r)' % (\n            self.__class__.__name__,\n            list(self.__data.items()),\n            self.__maxsize,\n            self.__currsize,\n        )\n\n    def __getitem__(self, key):\n        try:\n            return self.__data[key]\n        except KeyError:\n            return self.__missing__(key)\n\n    def __setitem__(self, key, value):\n        maxsize = self.__maxsize\n        size = self.getsizeof(value)\n        if size > maxsize:\n            raise ValueError('value too large')\n        if key not in self.__data or self.__size[key] < size:\n            while self.__currsize + size > maxsize:\n                self.popitem()\n        if key in self.__data:\n            diffsize = size - self.__size[key]\n        else:\n            diffsize = size\n        self.__data[key] = value\n        self.__size[key] = size\n        self.__currsize += diffsize\n\n    def __delitem__(self, key):\n        size = self.__size.pop(key)\n        del self.__data[key]\n        self.__currsize -= size\n\n    def __contains__(self, key):\n        return key in self.__data\n\n    def __missing__(self, key):\n        raise KeyError(key)\n\n    def __iter__(self):\n        return iter(self.__data)\n\n    def __len__(self):\n        return len(self.__data)\n", "contexts_below": "    def pop(self, key, default=__marker):\n         if key in self:\n             value = self[key]\n             del self[key]\n         elif default is self.__marker:\n             raise KeyError(key)\n         else:\n             value = default\n         return value\n \n     def setdefault(self, key, default=None):\n         if key in self:\n             value = self[key]\n         else:\n             self[key] = value = default\n         return value\n \n     @property\n     def maxsize(self):\n         \"\"\"The maximum size of the cache.\"\"\"\n         return self.__maxsize\n \n     @property\n     def currsize(self):\n         \"\"\"The current size of the cache.\"\"\"\n         return self.__currsize\n \n     @staticmethod\n     def getsizeof(value):\n         \"\"\"Return the size of a cache element's value.\"\"\"\n         return 1\n ", "input_code": "def get(self, key, default=None):\n\"\"\"\nD.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def get(self, key, default=None):\n        if key in self:\n            return self[key]\n        else:\n            return default", "signature": "def get(self, key, default=None):", "completion_path": "cachetools/cache.py"}
{"ce_id": "62b8d22548ba5a41d1c3f472", "namespace": "62b8d22548ba5a41d1c3f472", "namespace_real": "cachetools.decorators.cachedmethod", "real_proj_path": "pexip---os-python-cachetools/", "type": "function", "class_name": null, "function_name": "cachedmethod", "contexts_above": "import functools\n\nfrom .keys import hashkey\n\n\ndef cached(cache, key=hashkey, lock=None):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    results in a cache.\n\n    \"\"\"\n    def decorator(func):\n        if cache is None:\n            def wrapper(*args, **kwargs):\n                return func(*args, **kwargs)\n        elif lock is None:\n            def wrapper(*args, **kwargs):\n                k = key(*args, **kwargs)\n                try:\n                    return cache[k]\n                except KeyError:\n                    pass  # key not found\n                v = func(*args, **kwargs)\n                try:\n                    cache[k] = v\n                except ValueError:\n                    pass  # value too large\n                return v\n        else:\n            def wrapper(*args, **kwargs):\n                k = key(*args, **kwargs)\n                try:\n                    with lock:\n                        return cache[k]\n                except KeyError:\n                    pass  # key not found\n                v = func(*args, **kwargs)\n                # in case of a race, prefer the item already in the cache\n                try:\n                    with lock:\n                        return cache.setdefault(k, v)\n                except ValueError:\n                    return v  # value too large\n        return functools.update_wrapper(wrapper, func)\n    return decorator\n\n", "contexts_below": "", "input_code": "def cachedmethod(cache, key=hashkey, lock=None):\n\"\"\"\nDecorator to wrap a class or instance method with a memoizing\ncallable that saves results in a cache.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def cachedmethod(cache, key=hashkey, lock=None):\n    \"\"\"Decorator to wrap a class or instance method with a memoizing\n    callable that saves results in a cache.\n\n    \"\"\"\n    def decorator(method):\n        if lock is None:\n            def wrapper(self, *args, **kwargs):\n                c = cache(self)\n                if c is None:\n                    return method(self, *args, **kwargs)\n                k = key(*args, **kwargs)\n                try:\n                    return c[k]\n                except KeyError:\n                    pass  # key not found\n                v = method(self, *args, **kwargs)\n                try:\n                    c[k] = v\n                except ValueError:\n                    pass  # value too large\n                return v\n        else:\n            def wrapper(self, *args, **kwargs):\n                c = cache(self)\n                if c is None:\n                    return method(self, *args, **kwargs)\n                k = key(*args, **kwargs)\n                try:\n                    with lock(self):\n                        return c[k]\n                except KeyError:\n                    pass  # key not found\n                v = method(self, *args, **kwargs)\n                # in case of a race, prefer the item already in the cache\n                try:\n                    with lock(self):\n                        return c.setdefault(k, v)\n                except ValueError:\n                    return v  # value too large\n        return functools.update_wrapper(wrapper, method)\n    return decorator", "signature": "def cachedmethod(cache, key=hashkey, lock=None):", "completion_path": "cachetools/decorators.py"}
{"ce_id": "62b8c517e0d34b282c18122e", "namespace": "62b8c517e0d34b282c18122e", "namespace_real": "pysolbase.SolBase.extostr", "real_proj_path": "champax---pysolbase/", "type": "class", "class_name": "SolBase", "function_name": "extostr", "contexts_above": "\"\"\"\n# -*- coding: utf-8 -*-\n# ===============================================================================\n#\n# Copyright (C) 2013/2017 Laurent Labatut / Laurent Champagnac\n#\n#\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA\n# ===============================================================================\n\"\"\"\nimport ast\nimport logging\nimport os\nimport platform\nimport sys\nimport time\nimport traceback\nfrom logging.config import dictConfig\nfrom logging.handlers import WatchedFileHandler, TimedRotatingFileHandler, SysLogHandler\nfrom threading import Lock\n\nimport gevent\nimport pytz\nfrom datetime import datetime\n\nfrom gevent import monkey, config\nfrom yaml import load, SafeLoader\n\nfrom pysolbase.ContextFilter import ContextFilter\n\nlogger = logging.getLogger(__name__)\nlifecyclelogger = logging.getLogger(\"lifecycle\")\n\n\nclass SolBase(object):\n    \"\"\"\n    Base utilities & helpers.\n    \"\"\"\n\n    # ===============================\n    # STATIC STUFF\n    # ===============================\n\n    # Component name (mainly for rsyslog)\n    _compo_name = \"CompoNotSet\"\n\n    # Global init stuff\n    _voodoo_initialized = False\n    _voodoo_lock = Lock()\n\n    # Logging stuff\n    _logging_initialized = False\n    _logging_lock = Lock()\n\n    # Fork stuff\n    _master_process = True\n\n    # ===============================\n    # DATE & MS\n    # ===============================\n\n    @classmethod\n    def mscurrent(cls):\n        \"\"\"\n        Return current millis since epoch\n        :return float\n        :rtype float\n        \"\"\"\n        return time.time() * 1000.0\n\n    @classmethod\n    def securrent(cls):\n        \"\"\"\n        Return current seconds since epoch\n        :return float\n        :rtype float\n        \"\"\"\n        return time.time()\n\n    @classmethod\n    def msdiff(cls, ms_start, ms_end=None):\n        \"\"\"\n        Get difference in millis between current millis and provided millis.\n        :param ms_start: Start millis\n        :type ms_start: float\n        :param ms_end: End millis (will use current if not provided)\n        :type ms_end: float\n        :return float\n        :rtype float\n        \"\"\"\n\n        if not ms_end:\n            ms_end = cls.mscurrent()\n\n        return ms_end - ms_start\n\n    @classmethod\n    def datecurrent(cls, erase_mode=0):\n        \"\"\"\n        Return current date (UTC)\n        :param erase_mode: Erase mode (0=nothing, 1=remove microseconds but keep millis, 2=remove millis completely)\n        :return datetime.datetime\n        :rtype datetime.datetime\n        \"\"\"\n\n        if erase_mode == 0:\n            return datetime.utcnow()\n        elif erase_mode == 1:\n            # Force precision loss (keep millis, kick micro)\n            dt = datetime.utcnow()\n            return dt.replace(microsecond=int((dt.microsecond * 0.001) * 1000))\n        elif erase_mode == 2:\n            return datetime.utcnow().replace(microsecond=0)\n\n    @classmethod\n    def datediff(cls, dt_start, dt_end=None):\n        \"\"\"\n        Get difference in millis between two datetime\n        :param dt_start: Start datetime\n        :type dt_start: datetime.datetime\n        :param dt_end: End datetime (will use current utc if not provided)\n        :type dt_end: datetime.datetime\n        :return float\n        :rtype float\n        \"\"\"\n\n        # Fix\n        if not dt_end:\n            dt_end = cls.datecurrent()\n\n        # Get delta\n        delta = dt_end - dt_start\n        return ((delta.days * 86400 + delta.seconds) * 1000) + (delta.microseconds * 0.001)\n\n    # ==========================================\n    # EPOCH / DT\n    # ==========================================\n\n    DT_EPOCH = datetime.utcfromtimestamp(0)\n\n    @classmethod\n    def dt_to_epoch(cls, dt):\n        \"\"\"\n        Convert a datetime (UTC required) to a unix time since epoch, as seconds, as integer.\n        Note that millis precision is lost.\n        :param dt: datetime\n        :type dt: datetime\n        :return int\n        :rtype int\n        \"\"\"\n\n        return int((dt - cls.DT_EPOCH).total_seconds())\n\n    @classmethod\n    def epoch_to_dt(cls, epoch):\n        \"\"\"\n        Convert an epoch float or int to datetime (UTC)\n        :param epoch: float,int\n        :type epoch: float,int\n        :return datetime\n        :rtype datetime\n        \"\"\"\n\n        return datetime.utcfromtimestamp(epoch)\n\n    @classmethod\n    def dt_is_naive(cls, dt):\n        \"\"\"\n        Return true if dt is naive\n        :param dt: datetime.datetime\n        :type dt: datetime.datetime\n        :return bool\n        :rtype bool\n        \"\"\"\n\n        # Naive : no tzinfo\n        if not dt.tzinfo:\n            return True\n\n        # Aware\n        return False\n\n    @classmethod\n    def dt_ensure_utc_aware(cls, dt):\n        \"\"\"\n        Switch dt to utc time zone. If dt is naive, assume utc, otherwise, convert it to utc timezone.\n        Return an AWARE timezone (utc switched) datetime,\n        :param dt: datetime.datetime\n        :type dt:datetime.datetime\n        :return datetime.datetime\n        :rtype datetime.datetime\n        \"\"\"\n\n        # If naive, add utc\n        if cls.dt_is_naive(dt):\n            return dt.replace(tzinfo=pytz.utc)\n        else:\n            # Not naive, go utc, keep aware\n            return dt.astimezone(pytz.utc)\n\n    @classmethod\n    def dt_ensure_utc_naive(cls, dt):\n        \"\"\"\n        Ensure dt is naive. Return dt, switched to UTC (if applicable), and naive.\n        :param dt: datetime.datetime\n        :type dt:datetime.datetime\n        :return datetime.datetime\n        :rtype datetime.datetime\n        \"\"\"\n\n        dt = cls.dt_ensure_utc_aware(dt)\n        return dt.replace(tzinfo=None)\n\n    # ===============================\n    # COMPO NAME (FOR RSYSLOG)\n    # ===============================\n\n    @classmethod\n    def set_compo_name(cls, compo_name):\n        \"\"\"\n        Set the component name. Useful for rsyslog.\n        :param compo_name: The component name or None. If None, method do nothing.\n        :type compo_name: str,None\n        \"\"\"\n\n        if compo_name:\n            cls._compo_name = compo_name\n            lifecyclelogger.debug(\"compo_name now set to=%s\", cls._compo_name)\n\n    @classmethod\n    def get_compo_name(cls):\n        \"\"\"\n        Get current component name.\n        :return str\n        :rtype str\n        \"\"\"\n\n        return cls._compo_name\n\n    @classmethod\n    def get_machine_name(cls):\n        \"\"\"\n        Get machine name\n        :return: Machine name\n        :rtype: str\n        \"\"\"\n\n        return platform.uname()[1]\n\n    # ===============================\n    # MISC\n    # ===============================\n\n    @classmethod\n    def sleep(cls, sleep_ms):\n        \"\"\"\n        Sleep for specified ms.\n        Also used as gevent context switch in code, since it rely on gevent.sleep.\n        :param sleep_ms: Millis to sleep.\n        :type sleep_ms: int\n        :return Nothing.\n        \"\"\"\n        ms = sleep_ms * 0.001\n\n        # gevent 1.3 : ms is not fully respected (100 can be 80-100)\n        gevent.sleep(ms)\n\n    # ===============================\n    # EXCEPTION HELPER\n    # ===============================\n\n    @classmethod", "contexts_below": "    # ===============================\n     # VOODOO INIT\n     # ===============================\n \n     @classmethod\n     def _reset(cls):\n         \"\"\"\n         For unittest only\n         \"\"\"\n \n         cls._logging_initialized = False\n         cls._voodoo_initialized = False\n \n     @classmethod\n     def voodoo_init(cls, aggressive=True, init_logging=True):\n         \"\"\"\n         Global initialization, to call asap.\n         Apply gevent stuff & default logging configuration.\n         :param aggressive: bool\n         :type aggressive: bool\n         :param init_logging: If True, logging_init is called.\n         :type init_logging: bool\n         :return Nothing.\n         \"\"\"\n \n         try:\n             # Check\n             if cls._voodoo_initialized:\n                 return\n \n             # Lock\n             with cls._voodoo_lock:\n                 # Re-check\n                 if cls._voodoo_initialized:\n                     return\n \n                 # Fire the voodoo magic :)\n                 lifecyclelogger.debug(\"Voodoo : gevent : entering, aggressive=%s\", aggressive)\n                 monkey.patch_all(aggressive=aggressive)\n                 lifecyclelogger.debug(\"Voodoo : gevent : entering\")\n \n                 # Gevent 1.3 : by default, gevent keep tracks of spawn call stack\n                 # This may lead to memory leak, if a method spawn itself in loop (timer mode)\n                 # We disable this\n                 config.track_greenlet_tree = False\n \n                 # Initialize log level to INFO\n                 if init_logging:\n                     lifecyclelogger.debug(\"Voodoo : logging : entering\")\n                     cls.logging_init()\n                     lifecyclelogger.debug(\"Voodoo : logging : done\")\n \n                 # Done\n                 cls._voodoo_initialized = True\n         finally:\n             # If whenever init_logging if set AND it is NOT initialized => we must init it\n             # => we may have been called previously with init_logging=false, but monkey patch is SET and logging not initialized\n             # => so it must be init now\n             if init_logging and not cls._logging_initialized:\n                 lifecyclelogger.debug(\"Voodoo : logging : not yet init : entering\")\n                 cls.logging_init()\n                 lifecyclelogger.debug(\"Voodoo : logging : not yet init : done\")\n \n     # ===============================\n     # LOGGING\n     # ===============================\n \n     @classmethod\n     def logging_init(cls, log_level=\"INFO\", force_reset=False, log_callback=None,\n                      log_to_file=None,\n                      log_to_syslog=True,\n                      log_to_syslog_facility=SysLogHandler.LOG_LOCAL0,\n                      log_to_console=True,\n                      log_to_file_mode=\"watched_file\",\n                      context_filter=None):\n         \"\"\"\n         Initialize logging sub system with default settings (console, pre-formatted output)\n         :param log_to_console: if True to console\n         :type log_to_console: bool\n         :param log_level: The log level to set. Any value in \"DEBUG\", \"INFO\", \"WARN\", \"ERROR\", \"CRITICAL\"\n         :type log_level: str\n         :param force_reset: If true, logging system is reset.\n         :type force_reset: bool\n         :param log_to_file: If specified, log to file\n         :type log_to_file: str,None\n         :param log_to_syslog: If specified, log to syslog\n         :type log_to_syslog: bool\n         :param log_to_syslog_facility: Syslog facility.\n         :type log_to_syslog_facility: int\n         :param log_to_file_mode: str \"watched_file\" for WatchedFileHandler, \"time_file\" for TimedRotatingFileHandler (or time_file_seconds for unittest)\n         :type log_to_file_mode: str\n         :param log_callback: Callback for unittest\n         :param context_filter: Context filter. If None, pysolbase.ContextFilter.ContextFilter is used. If used instance has an attr \"filter\", it is added to all handlers and \"%(kfilter)s\" will be populated by all thread context key/values, using filter method call. Refer to our ContextFilter default implementation for details.\n         :type context_filter: None,object\n         :return Nothing.\n         \"\"\"\n \n         if cls._logging_initialized and not force_reset:\n             return\n \n         with cls._logging_lock:\n             if cls._logging_initialized and not force_reset:\n                 return\n \n             # Reset\n             cls._reset_logging()\n \n             # Default\n             logging.basicConfig(level=log_level)\n \n             # Filter\n             if context_filter:\n                 c_filter = context_filter\n             else:\n                 c_filter = ContextFilter()\n \n             # Format begin\n             s_f = \"%(asctime)s | %(levelname)s | %(module)s@%(funcName)s@%(lineno)d | %(message)s \"\n \n             # Browse\n             if hasattr(c_filter, \"filter\"):\n                 # Push generic field\n                 # We expect it to be formatted like our pysolbase.ContextFilter.ContextFilter#filter method.\n                 s_f += \"|%(kfilter)s\"\n \n             # Format end\n             s_f += \"| %(thread)d:%(threadName)s | %(process)d:%(processName)s\"\n \n             # Formatter\n             f = logging.Formatter(s_f)\n \n             # Console handler\n             c = None\n             if log_to_console:\n                 # This can be overriden by unittest, we use __stdout__\n                 c = logging.StreamHandler(sys.__stdout__)\n                 c.setLevel(logging.getLevelName(log_level))\n                 c.setFormatter(f)\n \n             # File handler to /tmp\n             cf = None\n             if log_to_file:\n                 if log_to_file_mode == \"watched_file\":\n                     cf = WatchedFileHandler(log_to_file, encoding=\"utf-8\")\n                     cf.setLevel(logging.getLevelName(log_level))\n                     cf.setFormatter(f)\n                 elif log_to_file_mode == \"time_file\":\n                     cf = TimedRotatingFileHandler(log_to_file, encoding=\"utf-8\", utc=True, when=\"D\", interval=1, backupCount=7)\n                     cf.setLevel(logging.getLevelName(log_level))\n                     cf.setFormatter(f)\n                 elif log_to_file_mode == \"time_file_seconds\":\n                     # For unittest only\n                     cf = TimedRotatingFileHandler(log_to_file, encoding=\"utf-8\", utc=True, when=\"S\", interval=1, backupCount=7)\n                     cf.setLevel(logging.getLevelName(log_level))\n                     cf.setFormatter(f)\n                 else:\n                     logger.warning(\"Invalid log_to_file_mode=%s\", log_to_file_mode)\n \n             # Syslog handler\n             syslog = None\n             if log_to_syslog:\n                 try:\n                     from pysolbase.SysLogger import SysLogger\n \n                     syslog = SysLogger(log_callback=log_callback, facility=log_to_syslog_facility)\n                     syslog.setLevel(logging.getLevelName(log_level))\n                     syslog.setFormatter(f)\n                 except Exception as e:\n                     # This will fail on WINDOWS (no attr AF_UNIX)\n                     logger.debug(\"Unable to import SysLogger, e=%s\", SolBase.extostr(e))\n                     syslog = False\n \n             # Initialize\n             root = logging.getLogger()\n             root.setLevel(logging.getLevelName(log_level))\n             root.handlers = []\n             if log_to_console:\n                 c.addFilter(c_filter)\n                 root.addHandler(c)\n             if log_to_file and cf:\n                 cf.addFilter(c_filter)\n                 root.addHandler(cf)\n             if log_to_syslog and syslog:\n                 syslog.addFilter(c_filter)\n                 root.addHandler(syslog)\n \n             # Done\n             cls._logging_initialized = True\n             if force_reset:\n                 lifecyclelogger.info(\"Logging : initialized from memory, log_level=%s, force_reset=%s\", log_level, force_reset)\n             else:\n                 lifecyclelogger.debug(\"Logging : initialized from memory, log_level=%s, force_reset=%s\", log_level, force_reset)\n \n     @classmethod\n     def _register_filter(cls, c_filter):\n         \"\"\"\n         Register filter across the whole logging (root and all loggers)\n         Notice : addFilter is protected against duplicates add\n         :param c_filter: pysolbase.ContextFilter.ContextFilter\n         :type c_filter: pysolbase.ContextFilter.ContextFilter\n         \"\"\"\n \n         # Initialize\n         root = logging.getLogger()\n         for h in list(root.handlers):\n             h.addFilter(c_filter)\n \n         # Browse all loggers and set\n         for name in logging.root.manager.loggerDict:\n             cur_logger = logging.getLogger(name)\n             for h in list(cur_logger.handlers):\n                 h.addFilter(c_filter)\n \n     @classmethod\n     def _reset_logging(cls):\n         \"\"\"\n         Reset\n         \"\"\"\n \n         # Found no way to fully reset the logging stuff while running\n         # We reset root and all loggers to INFO, and kick handlers\n \n         # Initialize\n         root = logging.getLogger()\n         root.setLevel(logging.getLevelName(\"INFO\"))\n         for h in root.handlers:\n             # noinspection PyBroadException\n             try:\n                 h.close()\n             except:\n                 pass\n         root.handlers = []\n \n         # Browse all loggers and set\n         for name in logging.root.manager.loggerDict:\n             cur_logger = logging.getLogger(name)\n             cur_logger.setLevel(logging.getLevelName(\"INFO\"))\n             for h in cur_logger.handlers:\n                 # noinspection PyBroadException\n                 try:\n                     h.close()\n                 except:\n                     pass\n             cur_logger.handlers = []\n \n     @classmethod\n     def logging_initfromfile(cls, config_file_name, force_reset=False, context_filter=None):\n         \"\"\"\n         Initialize logging system from a configuration file, with optional reset.\n         :param config_file_name: Configuration file name\n         :type config_file_name: str\n         :param force_reset: If true, logging system is reset.\n         :type force_reset: bool\n         :param context_filter: Context filter. If None, pysolbase.ContextFilter.ContextFilter is used. If used instance has an attr \"filter\", it is added to all handlers and \"%(kfilter)s\" will be populated by all thread context key/values, using filter method call. Refer to our ContextFilter default implementation for details.\n         :type context_filter: None,object\n         :return Nothing.\n         \"\"\"\n \n         if cls._logging_initialized and not force_reset:\n             return\n \n         with cls._logging_lock:\n             if cls._logging_initialized and not force_reset:\n                 return\n \n             try:\n                 # Filter\n                 if context_filter:\n                     c_filter = context_filter\n                 else:\n                     c_filter = ContextFilter()\n \n                 # Reset\n                 cls._reset_logging()\n \n                 # Load\n                 logger.debug(\"Logging : yaml config_file_name=%s\", config_file_name)\n                 with open(config_file_name, 'r') as f:\n                     d = load(f, Loader=SafeLoader)\n                     dictConfig(d)\n \n                 # Register filter\n                 if c_filter:\n                     cls._register_filter(c_filter)\n \n                 if force_reset:\n                     lifecyclelogger.info(\"Logging : initialized from yaml file, config_file_name=%s\", config_file_name)\n                 else:\n                     lifecyclelogger.debug(\"Logging : initialized from yaml file, config_file_name=%s\", config_file_name)\n             except Exception:\n                 raise\n \n     @classmethod\n     def context_set(cls, k, v):\n         \"\"\"\n         Set thread/greenlet context value\n \n         This is a wrapper to pysolbase.ContextFilter.ContextFilter#set_value\n         and will work only if ContextFilter is defined (which is by default)\n         :param k: key name\n         :type k: basestring\n         :param v: value\n         :type v: object\n         \"\"\"\n \n         ContextFilter.set_value(k, v)\n \n     # ===============================\n     # FORK STUFF\n     # ===============================\n \n     @classmethod\n     def get_master_process(cls):\n         \"\"\"\n         Return True if we are the master process, False otherwise.\n         :return bool\n         :rtype bool\n         \"\"\"\n         return cls._master_process\n \n     @classmethod\n     def set_master_process(cls, b):\n         \"\"\"\n         Set is we are a fork master or not\n         :param b: True if we are master process, False if we are a child process.\n         :type b: bool\n         :return Nothing\n         \"\"\"\n \n         logger.debug(\"Switching _masterProcess to %s\", b)\n         cls._master_process = b\n \n     # ===============================\n     # BINARY STUFF\n     # ===============================\n \n     @classmethod\n     def binary_to_unicode(cls, bin_buf, encoding=\"utf-8\"):\n         \"\"\"\n         Binary buffer to str, using the specified encoding\n         :param bin_buf: Binary buffer\n         :type bin_buf: bytes\n         :param encoding: Encoding to use\n         :type encoding: str\n         :return str\n         :rtype str\n         \"\"\"\n \n         return bin_buf.decode(encoding)\n \n     @classmethod\n     def unicode_to_binary(cls, unicode_buf, encoding=\"utf-8\"):\n         \"\"\"\n         Unicode to binary buffer, using the specified encoding\n         :param unicode_buf: String to convert.\n         :type unicode_buf: str\n         :param encoding: Encoding to use.\n         :type encoding: str\n         :return bytes\n         :rtype bytes\n         \"\"\"\n \n         return unicode_buf.encode(encoding)\n \n     @classmethod\n     def fix_paths_for_popen(cls):\n         \"\"\"\n         Fix path and env for popen calls toward current project\n         Mainly used for unittests, which requires current env to be propagated while testing command line invocation within same project\n         \"\"\"\n \n         # Merge all\n         ar_p_path = sys.path\n         if os.environ.get(\"PYTHONPATH\"):\n             ar_p_path.extend(os.environ.get(\"PYTHONPATH\").split(\":\"))\n         if os.environ.get(\"PATH\"):\n             ar_p_path.extend(os.environ.get(\"PATH\").split(\":\"))\n \n         # Join\n         new_path = \":\".join(ar_p_path)\n \n         # Re-Assign\n         os.environ[\"PATH\"] = new_path\n         os.environ[\"PYTHONPATH\"] = new_path\n \n     # ===============================\n     # CONVERSIONS\n     # ===============================\n \n     @classmethod\n     def to_int(cls, v):\n         \"\"\"\n         Convert to int\n         :param v: int,str\n         :type v: int,str\n         :return: int\n         :rtype int\n         \"\"\"\n \n         if isinstance(v, int):\n             return v\n         else:\n             return int(v)\n \n     @classmethod\n     def to_bool(cls, v):\n         \"\"\"\n         Convert to bool\n         :param v: bool,str\n         :type v: bool,str\n         :return: bool\n         :rtype bool\n         \"\"\"\n \n         if isinstance(v, bool):\n             return v\n         else:\n             return ast.literal_eval(v)\n \n     @classmethod\n     def get_classname(cls, my_instance):\n         \"\"\"\n         Return the class name of my_instance, or \"Instance.None\".\n         :param cls: Our class.\n         :param my_instance: Instance to use.\n         :return: Return the class name of my_instance, or \"Instance.None\" in case of error/None value.\n         \"\"\"\n         if my_instance is None:\n             return \"Instance.None\"\n         else:\n             return my_instance.__class__.__name__\n \n     @classmethod\n     def get_pathseparator(cls):\n         \"\"\"\n         Return the path separator.\n         https://docs.python.org/library/os.html#os.sep\n         :param cls: Our class\n         :return: The path separator (string)\n         \"\"\"\n         return os.sep\n \n     @classmethod\n     def is_bool(cls, my_bool):\n         \"\"\"\n         Return true if the provided my_bool is a boolean.\n         :param cls: Our class.\n         :param my_bool: A boolean..\n         :return: Return true if the provided my_bool is a boolean. False otherwise.\n         \"\"\"\n         if my_bool is None:\n             return False\n         else:\n             return isinstance(my_bool, bool)\n \n     @classmethod\n     def is_int(cls, my_int):\n         \"\"\"\n         Return true if the provided my_int is a integer.\n         :param cls: Our class.\n         :param my_int: An integer..\n         :return: Return true if the provided my_int is a integer. False otherwise.\n         \"\"\"\n         if my_int is None:\n             return False\n         # Caution, boolean is an integer...\n         elif SolBase.is_bool(my_int):\n             return False\n         else:\n             return isinstance(my_int, int)\n \n     @classmethod\n     def get_current_pid_as_string(cls):\n         \"\"\"\n         Return the current pids as string.\n         :param cls: Our class.\n         :return: A String\n         \"\"\"\n         try:\n             return \"pid={0}, ppid={1}\".format(os.getpid(), os.getppid())\n         except AttributeError:\n             return \"pid={0}\".format(os.getpid())\n \n     # =====================================================\n     # HELPER FOR SOCKET CLOSING\n     # =====================================================\n \n     @classmethod\n     def safe_close_socket(cls, soc_to_close):\n         \"\"\"\n         Safe close a socket\n         :param soc_to_close: socket\n         :type soc_to_close: socket.socket\n         \"\"\"\n \n         if soc_to_close is None:\n             return\n \n         try:\n             soc_to_close.shutdown(2)\n         except Exception as e:\n             logger.debug(\"Socket shutdown ex=%s\", SolBase.extostr(e))\n \n         try:\n             soc_to_close.close()\n         except Exception as e:\n             logger.debug(\"Socket close ex=%s\", SolBase.extostr(e))\n \n         try:\n             del soc_to_close\n         except Exception as e:\n             logger.debug(\"Socket del ex=%s\", SolBase.extostr(e))\n ", "input_code": "@classmethod\ndef extostr(cls, e, max_level=30, max_path_level=5):\n\"\"\"\nFormat an exception.\n:param e: Any exception instance.\n:type e: Exception\n:param max_level: Maximum call stack level (default 30)\n:type max_level: int\n:param max_path_level: Maximum path level (default 5)\n:type max_path_level: int\n:return The exception readable string\n:rtype str\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @classmethod\n    def extostr(cls, e, max_level=30, max_path_level=5):\n        \"\"\"\n        Format an exception.\n        :param e: Any exception instance.\n        :type e: Exception\n        :param max_level: Maximum call stack level (default 30)\n        :type max_level: int\n        :param max_path_level: Maximum path level (default 5)\n        :type max_path_level: int\n        :return The exception readable string\n        :rtype str\n        \"\"\"\n\n        # Go\n        list_frame = None\n        try:\n            out_buffer = \"\"\n\n            # Class type\n            out_buffer += \"e.cls:[{0}]\".format(e.__class__.__name__)\n\n            # To string\n            try:\n                ex_buf = str(e)\n            except UnicodeEncodeError:\n                ex_buf = repr(str(e))\n            except Exception as e:\n                logger.warning(\"Exception, e=%s\", e)\n                raise\n            out_buffer += \", e.bytes:[{0}]\".format(ex_buf)\n\n            # Traceback\n            si = sys.exc_info()\n\n            # Raw frame\n            # tuple : (file, lineno, method, code)\n            raw_frame = traceback.extract_tb(si[2])\n            raw_frame.reverse()\n\n            # Go to last tb_next\n            last_tb_next = None\n            cur_tb = si[2]\n            while cur_tb:\n                last_tb_next = cur_tb\n                cur_tb = cur_tb.tb_next\n\n            # Skip frame up to current raw frame count\n            list_frame = list()\n            cur_count = -1\n            skip_count = len(raw_frame)\n            if last_tb_next:\n                cur_frame = last_tb_next.tb_frame\n            else:\n                cur_frame = None\n            while cur_frame:\n                cur_count += 1\n                if cur_count < skip_count:\n                    cur_frame = cur_frame.f_back\n                else:\n                    # Need : tuple : (file, lineno, method, code)\n                    raw_frame.append((cur_frame.f_code.co_filename, cur_frame.f_lineno, cur_frame.f_code.co_name, \"\"))\n                    cur_frame = cur_frame.f_back\n\n            # Build it\n            cur_idx = 0\n            out_buffer += \", e.cs=[\"\n            for tu in raw_frame:\n                line = tu[1]\n                cur_file = tu[0]\n                method = tu[2]\n\n                # Handle max path level\n                ar_token = cur_file.rsplit(os.sep, max_path_level)\n                if len(ar_token) > max_path_level:\n                    # Remove head\n                    ar_token.pop(0)\n                    # Join\n                    cur_file = \"...\" + os.sep.join(ar_token)\n\n                # Format\n                out_buffer += \"in:{0}#{1}@{2} \".format(method, cur_file, line)\n\n                # Loop\n                cur_idx += 1\n                if cur_idx >= max_level:\n                    out_buffer += \"...\"\n                    break\n\n            # Close\n            out_buffer += \"]\"\n\n            # Ok\n            return out_buffer\n        finally:\n            if list_frame:\n                del list_frame", "signature": "@classmethod\ndef extostr(cls, e, max_level=30, max_path_level=5):", "completion_path": "pysolbase/SolBase.py"}
{"ce_id": "62b8bbbfe0d34b282c181210", "namespace": "62b8bbbfe0d34b282c181210", "namespace_real": "pysolbase.FileUtility.append_text_to_file", "real_proj_path": "champax---pysolbase/", "type": "class", "class_name": "FileUtility", "function_name": "append_text_to_file", "contexts_above": "\"\"\"\n# -*- coding: utf-8 -*-\n# ===============================================================================\n#\n# Copyright (C) 2013/2017 Laurent Labatut / Laurent Champagnac\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA\n# ===============================================================================\n\"\"\"\n\n# Import\nimport logging\n\nimport os\nimport codecs\n\nfrom pysolbase.SolBase import SolBase\n\nlogger = logging.getLogger(__name__)\n\n\nclass FileUtility(object):\n    \"\"\"\n    File utility\n    \"\"\"\n\n    @staticmethod\n    def is_path_exist(path_name):\n        \"\"\"\n        Check if a path (file or dir) name exist.\n        :param path_name: Path name.\n        :type path_name text_type\n        :return: Return true (exist), false (do not exist, or invalid file name)\n        :rtype bool\n        \"\"\"\n\n        # Check\n        if path_name is None:\n            logger.warning(\"is_path_exist : file_name is None\")\n            return False\n        elif not isinstance(path_name, str):\n            logger.warning(\"is_path_exist : path_name not a text_type, className=%s\", SolBase.get_classname(path_name))\n            return False\n\n        # Go\n        return os.path.exists(path_name)\n\n    @staticmethod\n    def is_file_exist(file_name):\n        \"\"\"\n        Check if file name exist.\n        :param file_name: File name.\n        :type file_name: str\n        :return: Return true (exist), false (do not exist, or invalid file name)\n        :rtype bool\n        \"\"\"\n\n        # Check\n        if file_name is None:\n            logger.warning(\"is_file_exist : file_name is None\")\n            return False\n        elif not isinstance(file_name, str):\n            logger.warning(\"is_file_exist : file_name not a text_type, className=%s\", SolBase.get_classname(file_name))\n            return False\n\n        # Go\n        return os.path.isfile(file_name)\n\n    @staticmethod\n    def is_dir_exist(dir_name):\n        \"\"\"\n        Check if dir name exist.\n        :param dir_name: Directory name.\n        :type dir_name: str\n        :return: Return true (exist), false (do not exist, or invalid file name)\n        :rtype bool\n        \"\"\"\n\n        # Check\n        if dir_name is None:\n            logger.warning(\"is_dir_exist : file_name is None\")\n            return False\n        elif not isinstance(dir_name, str):\n            logger.warning(\"is_dir_exist : file_name not a text_type, className=%s\", SolBase.get_classname(dir_name))\n            return False\n\n        # Go\n        return os.path.isdir(dir_name)\n\n    @staticmethod\n    def get_file_size(file_name):\n        \"\"\"\n        Return a file size in bytes.\n        :param file_name: File name.\n        :type file_name: str\n        :return: An integer, gt-eq 0 if file exist, lt 0 if error.\n        :rtype int\n        \"\"\"\n        if not FileUtility.is_file_exist(file_name):\n            return -1\n        else:\n            return os.path.getsize(file_name)\n\n    @classmethod\n    def get_current_dir(cls):\n        \"\"\"\n        Return the current directory.\n        :return: A String\n        :rtype text_type\n        \"\"\"\n\n        return os.getcwd()\n\n    @staticmethod\n    def file_to_binary(file_name):\n        \"\"\"\n        Load a file toward a binary buffer.\n        :param file_name: File name.\n        :type file_name: str\n        :return: Return the binary buffer or None in case of error.\n        :rtype: bytes,None\n        \"\"\"\n\n        # Check\n        if not FileUtility.is_file_exist(file_name):\n            logger.warning(\"file_to_binary : file_name not exist, file_name=%s\", file_name)\n            return None\n\n        # Go\n        rd = None\n        try:\n            # Open (binary : open return a io.BufferedReader)\n            rd = open(file_name, \"rb\")\n\n            # Read everything\n            return rd.read()\n        except IOError as e:\n            # Exception...\n            logger.warning(\"IOError, ex=%s\", SolBase.extostr(e))\n            return None\n        except Exception as e:\n            logger.warning(\"Exception, ex=%s\", SolBase.extostr(e))\n            return None\n        finally:\n            # Close if not None...\n            if rd:\n                rd.close()\n\n    @staticmethod\n    def file_to_textbuffer(file_name, encoding):\n        \"\"\"\n        Load a file toward a text buffer (UTF-8), using the specify encoding while reading.\n        CAUTION : This will read the whole file IN MEMORY.\n        :param file_name: File name.\n        :type file_name: str\n        :param encoding: Encoding to use.\n        :type encoding: str\n        :return: A text buffer or None in case of error.\n        :rtype str\n        \"\"\"\n\n        # Check\n        if not FileUtility.is_file_exist(file_name):\n            logger.warning(\"file_to_textbuffer : file_name not exist, file_name=%s\", file_name)\n            return None\n\n        # Go\n        rd = None\n        try:\n            # Open (text : open return a io.BufferedReader)\n            rd = codecs.open(file_name, \"r\", encoding, \"strict\", -1)\n\n            # Read everything\n            return rd.read()\n        except IOError as e:\n            # Exception...\n            logger.warning(\"file_to_binary : IOError, ex=%s\", SolBase.extostr(e))\n            return None\n        except Exception as e:\n            logger.warning(\"file_to_binary : Exception, ex=%s\", SolBase.extostr(e))\n            return None\n        finally:\n            # Close if not None...\n            if rd:\n                rd.close()\n\n    @staticmethod\n    def append_binary_to_file(file_name, bin_buf):\n        \"\"\"\n        Write to the specified filename, the provided binary buffer.\n        Create the file if required.\n        :param file_name:  File name.\n        :type file_name: str\n        :param bin_buf: Binary buffer to write.\n        :type bin_buf: bytes\n        :return: The number of bytes written or lt 0 if error.\n        :rtype int\n        \"\"\"\n\n        # Go\n        rd = None\n        try:\n            # Open (text : open return a io.BufferedReader)\n            rd = open(file_name, \"ab+\")\n\n            # Read everything\n            return rd.write(bin_buf)\n        except IOError as e:\n            # Exception...\n            logger.warning(\"append_binary_to_file : IOError, ex=%s\", SolBase.extostr(e))\n            return -1\n        except Exception as e:\n            logger.warning(\"append_binary_to_file : Exception, ex=%s\", SolBase.extostr(e))\n            return -1\n        finally:\n            # Close if not None...\n            if rd:\n                rd.close()\n\n    @staticmethod", "contexts_below": "", "input_code": "@staticmethod\ndef append_text_to_file(file_name, text_buffer, encoding, overwrite=False):\n\"\"\"\nWrite to the specified filename, the provided binary buffer\nCreate the file if required.\n:param file_name:  File name.\n:type file_name: str\n:param text_buffer: Text buffer to write.\n:type text_buffer: str\n:param encoding: The encoding to use.\n:type encoding: str\n:param overwrite: If true, file is overwritten.\n:type overwrite: bool\n:return: The number of bytes written or lt 0 if error.\n:rtype int\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @staticmethod\n    def append_text_to_file(file_name, text_buffer, encoding, overwrite=False):\n        \"\"\"\n        Write to the specified filename, the provided binary buffer\n        Create the file if required.\n        :param file_name:  File name.\n        :type file_name: str\n        :param text_buffer: Text buffer to write.\n        :type text_buffer: str\n        :param encoding: The encoding to use.\n        :type encoding: str\n        :param overwrite: If true, file is overwritten.\n        :type overwrite: bool\n        :return: The number of bytes written or lt 0 if error.\n        :rtype int\n        \"\"\"\n\n        # Go\n        rd = None\n        try:\n            # Open (text : open return a io.BufferedReader)\n            if not overwrite:\n                rd = codecs.open(file_name, \"a+\", encoding, \"strict\", -1)\n            else:\n                rd = codecs.open(file_name, \"w\", encoding, \"strict\", -1)\n\n            # Read everything\n            # CAUTION : 2.7 return None :(\n            return rd.write(text_buffer)\n        except IOError as e:\n            # Exception...\n            logger.warning(\"append_text_to_file : IOError, ex=%s\", SolBase.extostr(e))\n            return -1\n        except Exception as e:\n            logger.warning(\"append_text_to_file : Exception, ex=%s\", SolBase.extostr(e))\n            return -1\n        finally:\n            # Close if not None...\n            if rd:\n                rd.close()", "signature": "@staticmethod\ndef append_text_to_file(file_name, text_buffer, encoding, overwrite=False):", "completion_path": "pysolbase/FileUtility.py"}
{"ce_id": "62b8bbbfe0d34b282c18120f", "namespace": "62b8bbbfe0d34b282c18120f", "namespace_real": "pysolbase.FileUtility.file_to_textbuffer", "real_proj_path": "champax---pysolbase/", "type": "class", "class_name": "FileUtility", "function_name": "file_to_textbuffer", "contexts_above": "\"\"\"\n# -*- coding: utf-8 -*-\n# ===============================================================================\n#\n# Copyright (C) 2013/2017 Laurent Labatut / Laurent Champagnac\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA\n# ===============================================================================\n\"\"\"\n\n# Import\nimport logging\n\nimport os\nimport codecs\n\nfrom pysolbase.SolBase import SolBase\n\nlogger = logging.getLogger(__name__)\n\n\nclass FileUtility(object):\n    \"\"\"\n    File utility\n    \"\"\"\n\n    @staticmethod\n    def is_path_exist(path_name):\n        \"\"\"\n        Check if a path (file or dir) name exist.\n        :param path_name: Path name.\n        :type path_name text_type\n        :return: Return true (exist), false (do not exist, or invalid file name)\n        :rtype bool\n        \"\"\"\n\n        # Check\n        if path_name is None:\n            logger.warning(\"is_path_exist : file_name is None\")\n            return False\n        elif not isinstance(path_name, str):\n            logger.warning(\"is_path_exist : path_name not a text_type, className=%s\", SolBase.get_classname(path_name))\n            return False\n\n        # Go\n        return os.path.exists(path_name)\n\n    @staticmethod\n    def is_file_exist(file_name):\n        \"\"\"\n        Check if file name exist.\n        :param file_name: File name.\n        :type file_name: str\n        :return: Return true (exist), false (do not exist, or invalid file name)\n        :rtype bool\n        \"\"\"\n\n        # Check\n        if file_name is None:\n            logger.warning(\"is_file_exist : file_name is None\")\n            return False\n        elif not isinstance(file_name, str):\n            logger.warning(\"is_file_exist : file_name not a text_type, className=%s\", SolBase.get_classname(file_name))\n            return False\n\n        # Go\n        return os.path.isfile(file_name)\n\n    @staticmethod\n    def is_dir_exist(dir_name):\n        \"\"\"\n        Check if dir name exist.\n        :param dir_name: Directory name.\n        :type dir_name: str\n        :return: Return true (exist), false (do not exist, or invalid file name)\n        :rtype bool\n        \"\"\"\n\n        # Check\n        if dir_name is None:\n            logger.warning(\"is_dir_exist : file_name is None\")\n            return False\n        elif not isinstance(dir_name, str):\n            logger.warning(\"is_dir_exist : file_name not a text_type, className=%s\", SolBase.get_classname(dir_name))\n            return False\n\n        # Go\n        return os.path.isdir(dir_name)\n\n    @staticmethod\n    def get_file_size(file_name):\n        \"\"\"\n        Return a file size in bytes.\n        :param file_name: File name.\n        :type file_name: str\n        :return: An integer, gt-eq 0 if file exist, lt 0 if error.\n        :rtype int\n        \"\"\"\n        if not FileUtility.is_file_exist(file_name):\n            return -1\n        else:\n            return os.path.getsize(file_name)\n\n    @classmethod\n    def get_current_dir(cls):\n        \"\"\"\n        Return the current directory.\n        :return: A String\n        :rtype text_type\n        \"\"\"\n\n        return os.getcwd()\n\n    @staticmethod\n    def file_to_binary(file_name):\n        \"\"\"\n        Load a file toward a binary buffer.\n        :param file_name: File name.\n        :type file_name: str\n        :return: Return the binary buffer or None in case of error.\n        :rtype: bytes,None\n        \"\"\"\n\n        # Check\n        if not FileUtility.is_file_exist(file_name):\n            logger.warning(\"file_to_binary : file_name not exist, file_name=%s\", file_name)\n            return None\n\n        # Go\n        rd = None\n        try:\n            # Open (binary : open return a io.BufferedReader)\n            rd = open(file_name, \"rb\")\n\n            # Read everything\n            return rd.read()\n        except IOError as e:\n            # Exception...\n            logger.warning(\"IOError, ex=%s\", SolBase.extostr(e))\n            return None\n        except Exception as e:\n            logger.warning(\"Exception, ex=%s\", SolBase.extostr(e))\n            return None\n        finally:\n            # Close if not None...\n            if rd:\n                rd.close()\n\n    @staticmethod", "contexts_below": "    @staticmethod\n     def append_binary_to_file(file_name, bin_buf):\n         \"\"\"\n         Write to the specified filename, the provided binary buffer.\n         Create the file if required.\n         :param file_name:  File name.\n         :type file_name: str\n         :param bin_buf: Binary buffer to write.\n         :type bin_buf: bytes\n         :return: The number of bytes written or lt 0 if error.\n         :rtype int\n         \"\"\"\n \n         # Go\n         rd = None\n         try:\n             # Open (text : open return a io.BufferedReader)\n             rd = open(file_name, \"ab+\")\n \n             # Read everything\n             return rd.write(bin_buf)\n         except IOError as e:\n             # Exception...\n             logger.warning(\"append_binary_to_file : IOError, ex=%s\", SolBase.extostr(e))\n             return -1\n         except Exception as e:\n             logger.warning(\"append_binary_to_file : Exception, ex=%s\", SolBase.extostr(e))\n             return -1\n         finally:\n             # Close if not None...\n             if rd:\n                 rd.close()\n \n     @staticmethod\n     def append_text_to_file(file_name, text_buffer, encoding, overwrite=False):\n         \"\"\"\n         Write to the specified filename, the provided binary buffer\n         Create the file if required.\n         :param file_name:  File name.\n         :type file_name: str\n         :param text_buffer: Text buffer to write.\n         :type text_buffer: str\n         :param encoding: The encoding to use.\n         :type encoding: str\n         :param overwrite: If true, file is overwritten.\n         :type overwrite: bool\n         :return: The number of bytes written or lt 0 if error.\n         :rtype int\n         \"\"\"\n \n         # Go\n         rd = None\n         try:\n             # Open (text : open return a io.BufferedReader)\n             if not overwrite:\n                 rd = codecs.open(file_name, \"a+\", encoding, \"strict\", -1)\n             else:\n                 rd = codecs.open(file_name, \"w\", encoding, \"strict\", -1)\n \n             # Read everything\n             # CAUTION : 2.7 return None :(\n             return rd.write(text_buffer)\n         except IOError as e:\n             # Exception...\n             logger.warning(\"append_text_to_file : IOError, ex=%s\", SolBase.extostr(e))\n             return -1\n         except Exception as e:\n             logger.warning(\"append_text_to_file : Exception, ex=%s\", SolBase.extostr(e))\n             return -1\n         finally:\n             # Close if not None...\n             if rd:\n                 rd.close()\n ", "input_code": "@staticmethod\ndef file_to_textbuffer(file_name, encoding):\n\"\"\"\nLoad a file toward a text buffer (UTF-8), using the specify encoding while reading.\nCAUTION : This will read the whole file IN MEMORY.\n:param file_name: File name.\n:type file_name: str\n:param encoding: Encoding to use.\n:type encoding: str\n:return: A text buffer or None in case of error.\n:rtype str\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @staticmethod\n    def file_to_textbuffer(file_name, encoding):\n        \"\"\"\n        Load a file toward a text buffer (UTF-8), using the specify encoding while reading.\n        CAUTION : This will read the whole file IN MEMORY.\n        :param file_name: File name.\n        :type file_name: str\n        :param encoding: Encoding to use.\n        :type encoding: str\n        :return: A text buffer or None in case of error.\n        :rtype str\n        \"\"\"\n\n        # Check\n        if not FileUtility.is_file_exist(file_name):\n            logger.warning(\"file_to_textbuffer : file_name not exist, file_name=%s\", file_name)\n            return None\n\n        # Go\n        rd = None\n        try:\n            # Open (text : open return a io.BufferedReader)\n            rd = codecs.open(file_name, \"r\", encoding, \"strict\", -1)\n\n            # Read everything\n            return rd.read()\n        except IOError as e:\n            # Exception...\n            logger.warning(\"file_to_binary : IOError, ex=%s\", SolBase.extostr(e))\n            return None\n        except Exception as e:\n            logger.warning(\"file_to_binary : Exception, ex=%s\", SolBase.extostr(e))\n            return None\n        finally:\n            # Close if not None...\n            if rd:\n                rd.close()", "signature": "@staticmethod\ndef file_to_textbuffer(file_name, encoding):", "completion_path": "pysolbase/FileUtility.py"}
{"ce_id": "62b8bbbce0d34b282c18120d", "namespace": "62b8bbbce0d34b282c18120d", "namespace_real": "pysolbase.FileUtility.is_file_exist", "real_proj_path": "champax---pysolbase/", "type": "class", "class_name": "FileUtility", "function_name": "is_file_exist", "contexts_above": "\"\"\"\n# -*- coding: utf-8 -*-\n# ===============================================================================\n#\n# Copyright (C) 2013/2017 Laurent Labatut / Laurent Champagnac\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA\n# ===============================================================================\n\"\"\"\n\n# Import\nimport logging\n\nimport os\nimport codecs\n\nfrom pysolbase.SolBase import SolBase\n\nlogger = logging.getLogger(__name__)\n\n\nclass FileUtility(object):\n    \"\"\"\n    File utility\n    \"\"\"\n\n    @staticmethod\n    def is_path_exist(path_name):\n        \"\"\"\n        Check if a path (file or dir) name exist.\n        :param path_name: Path name.\n        :type path_name text_type\n        :return: Return true (exist), false (do not exist, or invalid file name)\n        :rtype bool\n        \"\"\"\n\n        # Check\n        if path_name is None:\n            logger.warning(\"is_path_exist : file_name is None\")\n            return False\n        elif not isinstance(path_name, str):\n            logger.warning(\"is_path_exist : path_name not a text_type, className=%s\", SolBase.get_classname(path_name))\n            return False\n\n        # Go\n        return os.path.exists(path_name)\n\n    @staticmethod", "contexts_below": "    @staticmethod\n     def is_dir_exist(dir_name):\n         \"\"\"\n         Check if dir name exist.\n         :param dir_name: Directory name.\n         :type dir_name: str\n         :return: Return true (exist), false (do not exist, or invalid file name)\n         :rtype bool\n         \"\"\"\n \n         # Check\n         if dir_name is None:\n             logger.warning(\"is_dir_exist : file_name is None\")\n             return False\n         elif not isinstance(dir_name, str):\n             logger.warning(\"is_dir_exist : file_name not a text_type, className=%s\", SolBase.get_classname(dir_name))\n             return False\n \n         # Go\n         return os.path.isdir(dir_name)\n \n     @staticmethod\n     def get_file_size(file_name):\n         \"\"\"\n         Return a file size in bytes.\n         :param file_name: File name.\n         :type file_name: str\n         :return: An integer, gt-eq 0 if file exist, lt 0 if error.\n         :rtype int\n         \"\"\"\n         if not FileUtility.is_file_exist(file_name):\n             return -1\n         else:\n             return os.path.getsize(file_name)\n \n     @classmethod\n     def get_current_dir(cls):\n         \"\"\"\n         Return the current directory.\n         :return: A String\n         :rtype text_type\n         \"\"\"\n \n         return os.getcwd()\n \n     @staticmethod\n     def file_to_binary(file_name):\n         \"\"\"\n         Load a file toward a binary buffer.\n         :param file_name: File name.\n         :type file_name: str\n         :return: Return the binary buffer or None in case of error.\n         :rtype: bytes,None\n         \"\"\"\n \n         # Check\n         if not FileUtility.is_file_exist(file_name):\n             logger.warning(\"file_to_binary : file_name not exist, file_name=%s\", file_name)\n             return None\n \n         # Go\n         rd = None\n         try:\n             # Open (binary : open return a io.BufferedReader)\n             rd = open(file_name, \"rb\")\n \n             # Read everything\n             return rd.read()\n         except IOError as e:\n             # Exception...\n             logger.warning(\"IOError, ex=%s\", SolBase.extostr(e))\n             return None\n         except Exception as e:\n             logger.warning(\"Exception, ex=%s\", SolBase.extostr(e))\n             return None\n         finally:\n             # Close if not None...\n             if rd:\n                 rd.close()\n \n     @staticmethod\n     def file_to_textbuffer(file_name, encoding):\n         \"\"\"\n         Load a file toward a text buffer (UTF-8), using the specify encoding while reading.\n         CAUTION : This will read the whole file IN MEMORY.\n         :param file_name: File name.\n         :type file_name: str\n         :param encoding: Encoding to use.\n         :type encoding: str\n         :return: A text buffer or None in case of error.\n         :rtype str\n         \"\"\"\n \n         # Check\n         if not FileUtility.is_file_exist(file_name):\n             logger.warning(\"file_to_textbuffer : file_name not exist, file_name=%s\", file_name)\n             return None\n \n         # Go\n         rd = None\n         try:\n             # Open (text : open return a io.BufferedReader)\n             rd = codecs.open(file_name, \"r\", encoding, \"strict\", -1)\n \n             # Read everything\n             return rd.read()\n         except IOError as e:\n             # Exception...\n             logger.warning(\"file_to_binary : IOError, ex=%s\", SolBase.extostr(e))\n             return None\n         except Exception as e:\n             logger.warning(\"file_to_binary : Exception, ex=%s\", SolBase.extostr(e))\n             return None\n         finally:\n             # Close if not None...\n             if rd:\n                 rd.close()\n \n     @staticmethod\n     def append_binary_to_file(file_name, bin_buf):\n         \"\"\"\n         Write to the specified filename, the provided binary buffer.\n         Create the file if required.\n         :param file_name:  File name.\n         :type file_name: str\n         :param bin_buf: Binary buffer to write.\n         :type bin_buf: bytes\n         :return: The number of bytes written or lt 0 if error.\n         :rtype int\n         \"\"\"\n \n         # Go\n         rd = None\n         try:\n             # Open (text : open return a io.BufferedReader)\n             rd = open(file_name, \"ab+\")\n \n             # Read everything\n             return rd.write(bin_buf)\n         except IOError as e:\n             # Exception...\n             logger.warning(\"append_binary_to_file : IOError, ex=%s\", SolBase.extostr(e))\n             return -1\n         except Exception as e:\n             logger.warning(\"append_binary_to_file : Exception, ex=%s\", SolBase.extostr(e))\n             return -1\n         finally:\n             # Close if not None...\n             if rd:\n                 rd.close()\n \n     @staticmethod\n     def append_text_to_file(file_name, text_buffer, encoding, overwrite=False):\n         \"\"\"\n         Write to the specified filename, the provided binary buffer\n         Create the file if required.\n         :param file_name:  File name.\n         :type file_name: str\n         :param text_buffer: Text buffer to write.\n         :type text_buffer: str\n         :param encoding: The encoding to use.\n         :type encoding: str\n         :param overwrite: If true, file is overwritten.\n         :type overwrite: bool\n         :return: The number of bytes written or lt 0 if error.\n         :rtype int\n         \"\"\"\n \n         # Go\n         rd = None\n         try:\n             # Open (text : open return a io.BufferedReader)\n             if not overwrite:\n                 rd = codecs.open(file_name, \"a+\", encoding, \"strict\", -1)\n             else:\n                 rd = codecs.open(file_name, \"w\", encoding, \"strict\", -1)\n \n             # Read everything\n             # CAUTION : 2.7 return None :(\n             return rd.write(text_buffer)\n         except IOError as e:\n             # Exception...\n             logger.warning(\"append_text_to_file : IOError, ex=%s\", SolBase.extostr(e))\n             return -1\n         except Exception as e:\n             logger.warning(\"append_text_to_file : Exception, ex=%s\", SolBase.extostr(e))\n             return -1\n         finally:\n             # Close if not None...\n             if rd:\n                 rd.close()\n ", "input_code": "@staticmethod\ndef is_file_exist(file_name):\n\"\"\"\nCheck if file name exist.\n:param file_name: File name.\n:type file_name: str\n:return: Return true (exist), false (do not exist, or invalid file name)\n:rtype bool\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @staticmethod\n    def is_file_exist(file_name):\n        \"\"\"\n        Check if file name exist.\n        :param file_name: File name.\n        :type file_name: str\n        :return: Return true (exist), false (do not exist, or invalid file name)\n        :rtype bool\n        \"\"\"\n\n        # Check\n        if file_name is None:\n            logger.warning(\"is_file_exist : file_name is None\")\n            return False\n        elif not isinstance(file_name, str):\n            logger.warning(\"is_file_exist : file_name not a text_type, className=%s\", SolBase.get_classname(file_name))\n            return False\n\n        # Go\n        return os.path.isfile(file_name)", "signature": "@staticmethod\ndef is_file_exist(file_name):", "completion_path": "pysolbase/FileUtility.py"}
{"ce_id": "62b8b99de0d34b282c1811f8", "namespace": "62b8b99de0d34b282c1811f8", "namespace_real": "pysolbase.SolBase._reset_logging", "real_proj_path": "champax---pysolbase/", "type": "class", "class_name": "SolBase", "function_name": "_reset_logging", "contexts_above": "\"\"\"\n# -*- coding: utf-8 -*-\n# ===============================================================================\n#\n# Copyright (C) 2013/2017 Laurent Labatut / Laurent Champagnac\n#\n#\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA\n# ===============================================================================\n\"\"\"\nimport ast\nimport logging\nimport os\nimport platform\nimport sys\nimport time\nimport traceback\nfrom logging.config import dictConfig\nfrom logging.handlers import WatchedFileHandler, TimedRotatingFileHandler, SysLogHandler\nfrom threading import Lock\n\nimport gevent\nimport pytz\nfrom datetime import datetime\n\nfrom gevent import monkey, config\nfrom yaml import load, SafeLoader\n\nfrom pysolbase.ContextFilter import ContextFilter\n\nlogger = logging.getLogger(__name__)\nlifecyclelogger = logging.getLogger(\"lifecycle\")\n\n\nclass SolBase(object):\n    \"\"\"\n    Base utilities & helpers.\n    \"\"\"\n\n    # ===============================\n    # STATIC STUFF\n    # ===============================\n\n    # Component name (mainly for rsyslog)\n    _compo_name = \"CompoNotSet\"\n\n    # Global init stuff\n    _voodoo_initialized = False\n    _voodoo_lock = Lock()\n\n    # Logging stuff\n    _logging_initialized = False\n    _logging_lock = Lock()\n\n    # Fork stuff\n    _master_process = True\n\n    # ===============================\n    # DATE & MS\n    # ===============================\n\n    @classmethod\n    def mscurrent(cls):\n        \"\"\"\n        Return current millis since epoch\n        :return float\n        :rtype float\n        \"\"\"\n        return time.time() * 1000.0\n\n    @classmethod\n    def securrent(cls):\n        \"\"\"\n        Return current seconds since epoch\n        :return float\n        :rtype float\n        \"\"\"\n        return time.time()\n\n    @classmethod\n    def msdiff(cls, ms_start, ms_end=None):\n        \"\"\"\n        Get difference in millis between current millis and provided millis.\n        :param ms_start: Start millis\n        :type ms_start: float\n        :param ms_end: End millis (will use current if not provided)\n        :type ms_end: float\n        :return float\n        :rtype float\n        \"\"\"\n\n        if not ms_end:\n            ms_end = cls.mscurrent()\n\n        return ms_end - ms_start\n\n    @classmethod\n    def datecurrent(cls, erase_mode=0):\n        \"\"\"\n        Return current date (UTC)\n        :param erase_mode: Erase mode (0=nothing, 1=remove microseconds but keep millis, 2=remove millis completely)\n        :return datetime.datetime\n        :rtype datetime.datetime\n        \"\"\"\n\n        if erase_mode == 0:\n            return datetime.utcnow()\n        elif erase_mode == 1:\n            # Force precision loss (keep millis, kick micro)\n            dt = datetime.utcnow()\n            return dt.replace(microsecond=int((dt.microsecond * 0.001) * 1000))\n        elif erase_mode == 2:\n            return datetime.utcnow().replace(microsecond=0)\n\n    @classmethod\n    def datediff(cls, dt_start, dt_end=None):\n        \"\"\"\n        Get difference in millis between two datetime\n        :param dt_start: Start datetime\n        :type dt_start: datetime.datetime\n        :param dt_end: End datetime (will use current utc if not provided)\n        :type dt_end: datetime.datetime\n        :return float\n        :rtype float\n        \"\"\"\n\n        # Fix\n        if not dt_end:\n            dt_end = cls.datecurrent()\n\n        # Get delta\n        delta = dt_end - dt_start\n        return ((delta.days * 86400 + delta.seconds) * 1000) + (delta.microseconds * 0.001)\n\n    # ==========================================\n    # EPOCH / DT\n    # ==========================================\n\n    DT_EPOCH = datetime.utcfromtimestamp(0)\n\n    @classmethod\n    def dt_to_epoch(cls, dt):\n        \"\"\"\n        Convert a datetime (UTC required) to a unix time since epoch, as seconds, as integer.\n        Note that millis precision is lost.\n        :param dt: datetime\n        :type dt: datetime\n        :return int\n        :rtype int\n        \"\"\"\n\n        return int((dt - cls.DT_EPOCH).total_seconds())\n\n    @classmethod\n    def epoch_to_dt(cls, epoch):\n        \"\"\"\n        Convert an epoch float or int to datetime (UTC)\n        :param epoch: float,int\n        :type epoch: float,int\n        :return datetime\n        :rtype datetime\n        \"\"\"\n\n        return datetime.utcfromtimestamp(epoch)\n\n    @classmethod\n    def dt_is_naive(cls, dt):\n        \"\"\"\n        Return true if dt is naive\n        :param dt: datetime.datetime\n        :type dt: datetime.datetime\n        :return bool\n        :rtype bool\n        \"\"\"\n\n        # Naive : no tzinfo\n        if not dt.tzinfo:\n            return True\n\n        # Aware\n        return False\n\n    @classmethod\n    def dt_ensure_utc_aware(cls, dt):\n        \"\"\"\n        Switch dt to utc time zone. If dt is naive, assume utc, otherwise, convert it to utc timezone.\n        Return an AWARE timezone (utc switched) datetime,\n        :param dt: datetime.datetime\n        :type dt:datetime.datetime\n        :return datetime.datetime\n        :rtype datetime.datetime\n        \"\"\"\n\n        # If naive, add utc\n        if cls.dt_is_naive(dt):\n            return dt.replace(tzinfo=pytz.utc)\n        else:\n            # Not naive, go utc, keep aware\n            return dt.astimezone(pytz.utc)\n\n    @classmethod\n    def dt_ensure_utc_naive(cls, dt):\n        \"\"\"\n        Ensure dt is naive. Return dt, switched to UTC (if applicable), and naive.\n        :param dt: datetime.datetime\n        :type dt:datetime.datetime\n        :return datetime.datetime\n        :rtype datetime.datetime\n        \"\"\"\n\n        dt = cls.dt_ensure_utc_aware(dt)\n        return dt.replace(tzinfo=None)\n\n    # ===============================\n    # COMPO NAME (FOR RSYSLOG)\n    # ===============================\n\n    @classmethod\n    def set_compo_name(cls, compo_name):\n        \"\"\"\n        Set the component name. Useful for rsyslog.\n        :param compo_name: The component name or None. If None, method do nothing.\n        :type compo_name: str,None\n        \"\"\"\n\n        if compo_name:\n            cls._compo_name = compo_name\n            lifecyclelogger.debug(\"compo_name now set to=%s\", cls._compo_name)\n\n    @classmethod\n    def get_compo_name(cls):\n        \"\"\"\n        Get current component name.\n        :return str\n        :rtype str\n        \"\"\"\n\n        return cls._compo_name\n\n    @classmethod\n    def get_machine_name(cls):\n        \"\"\"\n        Get machine name\n        :return: Machine name\n        :rtype: str\n        \"\"\"\n\n        return platform.uname()[1]\n\n    # ===============================\n    # MISC\n    # ===============================\n\n    @classmethod\n    def sleep(cls, sleep_ms):\n        \"\"\"\n        Sleep for specified ms.\n        Also used as gevent context switch in code, since it rely on gevent.sleep.\n        :param sleep_ms: Millis to sleep.\n        :type sleep_ms: int\n        :return Nothing.\n        \"\"\"\n        ms = sleep_ms * 0.001\n\n        # gevent 1.3 : ms is not fully respected (100 can be 80-100)\n        gevent.sleep(ms)\n\n    # ===============================\n    # EXCEPTION HELPER\n    # ===============================\n\n    @classmethod\n    def extostr(cls, e, max_level=30, max_path_level=5):\n        \"\"\"\n        Format an exception.\n        :param e: Any exception instance.\n        :type e: Exception\n        :param max_level: Maximum call stack level (default 30)\n        :type max_level: int\n        :param max_path_level: Maximum path level (default 5)\n        :type max_path_level: int\n        :return The exception readable string\n        :rtype str\n        \"\"\"\n\n        # Go\n        list_frame = None\n        try:\n            out_buffer = \"\"\n\n            # Class type\n            out_buffer += \"e.cls:[{0}]\".format(e.__class__.__name__)\n\n            # To string\n            try:\n                ex_buf = str(e)\n            except UnicodeEncodeError:\n                ex_buf = repr(str(e))\n            except Exception as e:\n                logger.warning(\"Exception, e=%s\", e)\n                raise\n            out_buffer += \", e.bytes:[{0}]\".format(ex_buf)\n\n            # Traceback\n            si = sys.exc_info()\n\n            # Raw frame\n            # tuple : (file, lineno, method, code)\n            raw_frame = traceback.extract_tb(si[2])\n            raw_frame.reverse()\n\n            # Go to last tb_next\n            last_tb_next = None\n            cur_tb = si[2]\n            while cur_tb:\n                last_tb_next = cur_tb\n                cur_tb = cur_tb.tb_next\n\n            # Skip frame up to current raw frame count\n            list_frame = list()\n            cur_count = -1\n            skip_count = len(raw_frame)\n            if last_tb_next:\n                cur_frame = last_tb_next.tb_frame\n            else:\n                cur_frame = None\n            while cur_frame:\n                cur_count += 1\n                if cur_count < skip_count:\n                    cur_frame = cur_frame.f_back\n                else:\n                    # Need : tuple : (file, lineno, method, code)\n                    raw_frame.append((cur_frame.f_code.co_filename, cur_frame.f_lineno, cur_frame.f_code.co_name, \"\"))\n                    cur_frame = cur_frame.f_back\n\n            # Build it\n            cur_idx = 0\n            out_buffer += \", e.cs=[\"\n            for tu in raw_frame:\n                line = tu[1]\n                cur_file = tu[0]\n                method = tu[2]\n\n                # Handle max path level\n                ar_token = cur_file.rsplit(os.sep, max_path_level)\n                if len(ar_token) > max_path_level:\n                    # Remove head\n                    ar_token.pop(0)\n                    # Join\n                    cur_file = \"...\" + os.sep.join(ar_token)\n\n                # Format\n                out_buffer += \"in:{0}#{1}@{2} \".format(method, cur_file, line)\n\n                # Loop\n                cur_idx += 1\n                if cur_idx >= max_level:\n                    out_buffer += \"...\"\n                    break\n\n            # Close\n            out_buffer += \"]\"\n\n            # Ok\n            return out_buffer\n        finally:\n            if list_frame:\n                del list_frame\n\n    # ===============================\n    # VOODOO INIT\n    # ===============================\n\n    @classmethod\n    def _reset(cls):\n        \"\"\"\n        For unittest only\n        \"\"\"\n\n        cls._logging_initialized = False\n        cls._voodoo_initialized = False\n\n    @classmethod\n    def voodoo_init(cls, aggressive=True, init_logging=True):\n        \"\"\"\n        Global initialization, to call asap.\n        Apply gevent stuff & default logging configuration.\n        :param aggressive: bool\n        :type aggressive: bool\n        :param init_logging: If True, logging_init is called.\n        :type init_logging: bool\n        :return Nothing.\n        \"\"\"\n\n        try:\n            # Check\n            if cls._voodoo_initialized:\n                return\n\n            # Lock\n            with cls._voodoo_lock:\n                # Re-check\n                if cls._voodoo_initialized:\n                    return\n\n                # Fire the voodoo magic :)\n                lifecyclelogger.debug(\"Voodoo : gevent : entering, aggressive=%s\", aggressive)\n                monkey.patch_all(aggressive=aggressive)\n                lifecyclelogger.debug(\"Voodoo : gevent : entering\")\n\n                # Gevent 1.3 : by default, gevent keep tracks of spawn call stack\n                # This may lead to memory leak, if a method spawn itself in loop (timer mode)\n                # We disable this\n                config.track_greenlet_tree = False\n\n                # Initialize log level to INFO\n                if init_logging:\n                    lifecyclelogger.debug(\"Voodoo : logging : entering\")\n                    cls.logging_init()\n                    lifecyclelogger.debug(\"Voodoo : logging : done\")\n\n                # Done\n                cls._voodoo_initialized = True\n        finally:\n            # If whenever init_logging if set AND it is NOT initialized => we must init it\n            # => we may have been called previously with init_logging=false, but monkey patch is SET and logging not initialized\n            # => so it must be init now\n            if init_logging and not cls._logging_initialized:\n                lifecyclelogger.debug(\"Voodoo : logging : not yet init : entering\")\n                cls.logging_init()\n                lifecyclelogger.debug(\"Voodoo : logging : not yet init : done\")\n\n    # ===============================\n    # LOGGING\n    # ===============================\n\n    @classmethod\n    def logging_init(cls, log_level=\"INFO\", force_reset=False, log_callback=None,\n                     log_to_file=None,\n                     log_to_syslog=True,\n                     log_to_syslog_facility=SysLogHandler.LOG_LOCAL0,\n                     log_to_console=True,\n                     log_to_file_mode=\"watched_file\",\n                     context_filter=None):\n        \"\"\"\n        Initialize logging sub system with default settings (console, pre-formatted output)\n        :param log_to_console: if True to console\n        :type log_to_console: bool\n        :param log_level: The log level to set. Any value in \"DEBUG\", \"INFO\", \"WARN\", \"ERROR\", \"CRITICAL\"\n        :type log_level: str\n        :param force_reset: If true, logging system is reset.\n        :type force_reset: bool\n        :param log_to_file: If specified, log to file\n        :type log_to_file: str,None\n        :param log_to_syslog: If specified, log to syslog\n        :type log_to_syslog: bool\n        :param log_to_syslog_facility: Syslog facility.\n        :type log_to_syslog_facility: int\n        :param log_to_file_mode: str \"watched_file\" for WatchedFileHandler, \"time_file\" for TimedRotatingFileHandler (or time_file_seconds for unittest)\n        :type log_to_file_mode: str\n        :param log_callback: Callback for unittest\n        :param context_filter: Context filter. If None, pysolbase.ContextFilter.ContextFilter is used. If used instance has an attr \"filter\", it is added to all handlers and \"%(kfilter)s\" will be populated by all thread context key/values, using filter method call. Refer to our ContextFilter default implementation for details.\n        :type context_filter: None,object\n        :return Nothing.\n        \"\"\"\n\n        if cls._logging_initialized and not force_reset:\n            return\n\n        with cls._logging_lock:\n            if cls._logging_initialized and not force_reset:\n                return\n\n            # Reset\n            cls._reset_logging()\n\n            # Default\n            logging.basicConfig(level=log_level)\n\n            # Filter\n            if context_filter:\n                c_filter = context_filter\n            else:\n                c_filter = ContextFilter()\n\n            # Format begin\n            s_f = \"%(asctime)s | %(levelname)s | %(module)s@%(funcName)s@%(lineno)d | %(message)s \"\n\n            # Browse\n            if hasattr(c_filter, \"filter\"):\n                # Push generic field\n                # We expect it to be formatted like our pysolbase.ContextFilter.ContextFilter#filter method.\n                s_f += \"|%(kfilter)s\"\n\n            # Format end\n            s_f += \"| %(thread)d:%(threadName)s | %(process)d:%(processName)s\"\n\n            # Formatter\n            f = logging.Formatter(s_f)\n\n            # Console handler\n            c = None\n            if log_to_console:\n                # This can be overriden by unittest, we use __stdout__\n                c = logging.StreamHandler(sys.__stdout__)\n                c.setLevel(logging.getLevelName(log_level))\n                c.setFormatter(f)\n\n            # File handler to /tmp\n            cf = None\n            if log_to_file:\n                if log_to_file_mode == \"watched_file\":\n                    cf = WatchedFileHandler(log_to_file, encoding=\"utf-8\")\n                    cf.setLevel(logging.getLevelName(log_level))\n                    cf.setFormatter(f)\n                elif log_to_file_mode == \"time_file\":\n                    cf = TimedRotatingFileHandler(log_to_file, encoding=\"utf-8\", utc=True, when=\"D\", interval=1, backupCount=7)\n                    cf.setLevel(logging.getLevelName(log_level))\n                    cf.setFormatter(f)\n                elif log_to_file_mode == \"time_file_seconds\":\n                    # For unittest only\n                    cf = TimedRotatingFileHandler(log_to_file, encoding=\"utf-8\", utc=True, when=\"S\", interval=1, backupCount=7)\n                    cf.setLevel(logging.getLevelName(log_level))\n                    cf.setFormatter(f)\n                else:\n                    logger.warning(\"Invalid log_to_file_mode=%s\", log_to_file_mode)\n\n            # Syslog handler\n            syslog = None\n            if log_to_syslog:\n                try:\n                    from pysolbase.SysLogger import SysLogger\n\n                    syslog = SysLogger(log_callback=log_callback, facility=log_to_syslog_facility)\n                    syslog.setLevel(logging.getLevelName(log_level))\n                    syslog.setFormatter(f)\n                except Exception as e:\n                    # This will fail on WINDOWS (no attr AF_UNIX)\n                    logger.debug(\"Unable to import SysLogger, e=%s\", SolBase.extostr(e))\n                    syslog = False\n\n            # Initialize\n            root = logging.getLogger()\n            root.setLevel(logging.getLevelName(log_level))\n            root.handlers = []\n            if log_to_console:\n                c.addFilter(c_filter)\n                root.addHandler(c)\n            if log_to_file and cf:\n                cf.addFilter(c_filter)\n                root.addHandler(cf)\n            if log_to_syslog and syslog:\n                syslog.addFilter(c_filter)\n                root.addHandler(syslog)\n\n            # Done\n            cls._logging_initialized = True\n            if force_reset:\n                lifecyclelogger.info(\"Logging : initialized from memory, log_level=%s, force_reset=%s\", log_level, force_reset)\n            else:\n                lifecyclelogger.debug(\"Logging : initialized from memory, log_level=%s, force_reset=%s\", log_level, force_reset)\n\n    @classmethod\n    def _register_filter(cls, c_filter):\n        \"\"\"\n        Register filter across the whole logging (root and all loggers)\n        Notice : addFilter is protected against duplicates add\n        :param c_filter: pysolbase.ContextFilter.ContextFilter\n        :type c_filter: pysolbase.ContextFilter.ContextFilter\n        \"\"\"\n\n        # Initialize\n        root = logging.getLogger()\n        for h in list(root.handlers):\n            h.addFilter(c_filter)\n\n        # Browse all loggers and set\n        for name in logging.root.manager.loggerDict:\n            cur_logger = logging.getLogger(name)\n            for h in list(cur_logger.handlers):\n                h.addFilter(c_filter)\n\n    @classmethod", "contexts_below": "    @classmethod\n     def logging_initfromfile(cls, config_file_name, force_reset=False, context_filter=None):\n         \"\"\"\n         Initialize logging system from a configuration file, with optional reset.\n         :param config_file_name: Configuration file name\n         :type config_file_name: str\n         :param force_reset: If true, logging system is reset.\n         :type force_reset: bool\n         :param context_filter: Context filter. If None, pysolbase.ContextFilter.ContextFilter is used. If used instance has an attr \"filter\", it is added to all handlers and \"%(kfilter)s\" will be populated by all thread context key/values, using filter method call. Refer to our ContextFilter default implementation for details.\n         :type context_filter: None,object\n         :return Nothing.\n         \"\"\"\n \n         if cls._logging_initialized and not force_reset:\n             return\n \n         with cls._logging_lock:\n             if cls._logging_initialized and not force_reset:\n                 return\n \n             try:\n                 # Filter\n                 if context_filter:\n                     c_filter = context_filter\n                 else:\n                     c_filter = ContextFilter()\n \n                 # Reset\n                 cls._reset_logging()\n \n                 # Load\n                 logger.debug(\"Logging : yaml config_file_name=%s\", config_file_name)\n                 with open(config_file_name, 'r') as f:\n                     d = load(f, Loader=SafeLoader)\n                     dictConfig(d)\n \n                 # Register filter\n                 if c_filter:\n                     cls._register_filter(c_filter)\n \n                 if force_reset:\n                     lifecyclelogger.info(\"Logging : initialized from yaml file, config_file_name=%s\", config_file_name)\n                 else:\n                     lifecyclelogger.debug(\"Logging : initialized from yaml file, config_file_name=%s\", config_file_name)\n             except Exception:\n                 raise\n \n     @classmethod\n     def context_set(cls, k, v):\n         \"\"\"\n         Set thread/greenlet context value\n \n         This is a wrapper to pysolbase.ContextFilter.ContextFilter#set_value\n         and will work only if ContextFilter is defined (which is by default)\n         :param k: key name\n         :type k: basestring\n         :param v: value\n         :type v: object\n         \"\"\"\n \n         ContextFilter.set_value(k, v)\n \n     # ===============================\n     # FORK STUFF\n     # ===============================\n \n     @classmethod\n     def get_master_process(cls):\n         \"\"\"\n         Return True if we are the master process, False otherwise.\n         :return bool\n         :rtype bool\n         \"\"\"\n         return cls._master_process\n \n     @classmethod\n     def set_master_process(cls, b):\n         \"\"\"\n         Set is we are a fork master or not\n         :param b: True if we are master process, False if we are a child process.\n         :type b: bool\n         :return Nothing\n         \"\"\"\n \n         logger.debug(\"Switching _masterProcess to %s\", b)\n         cls._master_process = b\n \n     # ===============================\n     # BINARY STUFF\n     # ===============================\n \n     @classmethod\n     def binary_to_unicode(cls, bin_buf, encoding=\"utf-8\"):\n         \"\"\"\n         Binary buffer to str, using the specified encoding\n         :param bin_buf: Binary buffer\n         :type bin_buf: bytes\n         :param encoding: Encoding to use\n         :type encoding: str\n         :return str\n         :rtype str\n         \"\"\"\n \n         return bin_buf.decode(encoding)\n \n     @classmethod\n     def unicode_to_binary(cls, unicode_buf, encoding=\"utf-8\"):\n         \"\"\"\n         Unicode to binary buffer, using the specified encoding\n         :param unicode_buf: String to convert.\n         :type unicode_buf: str\n         :param encoding: Encoding to use.\n         :type encoding: str\n         :return bytes\n         :rtype bytes\n         \"\"\"\n \n         return unicode_buf.encode(encoding)\n \n     @classmethod\n     def fix_paths_for_popen(cls):\n         \"\"\"\n         Fix path and env for popen calls toward current project\n         Mainly used for unittests, which requires current env to be propagated while testing command line invocation within same project\n         \"\"\"\n \n         # Merge all\n         ar_p_path = sys.path\n         if os.environ.get(\"PYTHONPATH\"):\n             ar_p_path.extend(os.environ.get(\"PYTHONPATH\").split(\":\"))\n         if os.environ.get(\"PATH\"):\n             ar_p_path.extend(os.environ.get(\"PATH\").split(\":\"))\n \n         # Join\n         new_path = \":\".join(ar_p_path)\n \n         # Re-Assign\n         os.environ[\"PATH\"] = new_path\n         os.environ[\"PYTHONPATH\"] = new_path\n \n     # ===============================\n     # CONVERSIONS\n     # ===============================\n \n     @classmethod\n     def to_int(cls, v):\n         \"\"\"\n         Convert to int\n         :param v: int,str\n         :type v: int,str\n         :return: int\n         :rtype int\n         \"\"\"\n \n         if isinstance(v, int):\n             return v\n         else:\n             return int(v)\n \n     @classmethod\n     def to_bool(cls, v):\n         \"\"\"\n         Convert to bool\n         :param v: bool,str\n         :type v: bool,str\n         :return: bool\n         :rtype bool\n         \"\"\"\n \n         if isinstance(v, bool):\n             return v\n         else:\n             return ast.literal_eval(v)\n \n     @classmethod\n     def get_classname(cls, my_instance):\n         \"\"\"\n         Return the class name of my_instance, or \"Instance.None\".\n         :param cls: Our class.\n         :param my_instance: Instance to use.\n         :return: Return the class name of my_instance, or \"Instance.None\" in case of error/None value.\n         \"\"\"\n         if my_instance is None:\n             return \"Instance.None\"\n         else:\n             return my_instance.__class__.__name__\n \n     @classmethod\n     def get_pathseparator(cls):\n         \"\"\"\n         Return the path separator.\n         https://docs.python.org/library/os.html#os.sep\n         :param cls: Our class\n         :return: The path separator (string)\n         \"\"\"\n         return os.sep\n \n     @classmethod\n     def is_bool(cls, my_bool):\n         \"\"\"\n         Return true if the provided my_bool is a boolean.\n         :param cls: Our class.\n         :param my_bool: A boolean..\n         :return: Return true if the provided my_bool is a boolean. False otherwise.\n         \"\"\"\n         if my_bool is None:\n             return False\n         else:\n             return isinstance(my_bool, bool)\n \n     @classmethod\n     def is_int(cls, my_int):\n         \"\"\"\n         Return true if the provided my_int is a integer.\n         :param cls: Our class.\n         :param my_int: An integer..\n         :return: Return true if the provided my_int is a integer. False otherwise.\n         \"\"\"\n         if my_int is None:\n             return False\n         # Caution, boolean is an integer...\n         elif SolBase.is_bool(my_int):\n             return False\n         else:\n             return isinstance(my_int, int)\n \n     @classmethod\n     def get_current_pid_as_string(cls):\n         \"\"\"\n         Return the current pids as string.\n         :param cls: Our class.\n         :return: A String\n         \"\"\"\n         try:\n             return \"pid={0}, ppid={1}\".format(os.getpid(), os.getppid())\n         except AttributeError:\n             return \"pid={0}\".format(os.getpid())\n \n     # =====================================================\n     # HELPER FOR SOCKET CLOSING\n     # =====================================================\n \n     @classmethod\n     def safe_close_socket(cls, soc_to_close):\n         \"\"\"\n         Safe close a socket\n         :param soc_to_close: socket\n         :type soc_to_close: socket.socket\n         \"\"\"\n \n         if soc_to_close is None:\n             return\n \n         try:\n             soc_to_close.shutdown(2)\n         except Exception as e:\n             logger.debug(\"Socket shutdown ex=%s\", SolBase.extostr(e))\n \n         try:\n             soc_to_close.close()\n         except Exception as e:\n             logger.debug(\"Socket close ex=%s\", SolBase.extostr(e))\n \n         try:\n             del soc_to_close\n         except Exception as e:\n             logger.debug(\"Socket del ex=%s\", SolBase.extostr(e))\n ", "input_code": "@classmethod\ndef _reset_logging(cls):\n\"\"\"\nReset\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @classmethod\n    def _reset_logging(cls):\n        \"\"\"\n        Reset\n        \"\"\"\n\n        # Found no way to fully reset the logging stuff while running\n        # We reset root and all loggers to INFO, and kick handlers\n\n        # Initialize\n        root = logging.getLogger()\n        root.setLevel(logging.getLevelName(\"INFO\"))\n        for h in root.handlers:\n            # noinspection PyBroadException\n            try:\n                h.close()\n            except:\n                pass\n        root.handlers = []\n\n        # Browse all loggers and set\n        for name in logging.root.manager.loggerDict:\n            cur_logger = logging.getLogger(name)\n            cur_logger.setLevel(logging.getLevelName(\"INFO\"))\n            for h in cur_logger.handlers:\n                # noinspection PyBroadException\n                try:\n                    h.close()\n                except:\n                    pass\n            cur_logger.handlers = []", "signature": "@classmethod\ndef _reset_logging(cls):", "completion_path": "pysolbase/SolBase.py"}
{"ce_id": "62b8b59feb7e40a82d2d1291", "namespace": "62b8b59feb7e40a82d2d1291", "namespace_real": "src.zope.interface.tests.test_declarations._getTargetClass", "real_proj_path": "pexip---os-zope/", "type": "class", "class_name": "test_declarations", "function_name": "_getTargetClass", "contexts_above": "##############################################################################\n#\n# Copyright (c) 2003 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"Test the new API for making and checking interface declarations\n\"\"\"\nimport unittest\n\nfrom zope.interface._compat import _skip_under_py3k\nfrom zope.interface._compat import PYTHON3\nfrom zope.interface.tests import OptimizationTestMixin\nfrom zope.interface.tests import MissingSomeAttrs\nfrom zope.interface.tests.test_interface import NameAndModuleComparisonTestsMixin\n\n# pylint:disable=inherit-non-class,too-many-lines,protected-access\n# pylint:disable=blacklisted-name,attribute-defined-outside-init\n\nclass _Py3ClassAdvice(object):\n\n    def _run_generated_code(self, code, globs, locs,\n                            fails_under_py3k=True,\n                           ):\n        # pylint:disable=exec-used,no-member\n        import warnings\n        with warnings.catch_warnings(record=True) as log:\n            warnings.resetwarnings()\n            if not PYTHON3:\n                exec(code, globs, locs)\n                self.assertEqual(len(log), 0) # no longer warn\n                return True\n\n            try:\n                exec(code, globs, locs)\n            except TypeError:\n                return False\n            else:\n                if fails_under_py3k:\n                    self.fail(\"Didn't raise TypeError\")\n            return None\n\n\nclass NamedTests(unittest.TestCase):\n\n    def test_class(self):\n        from zope.interface.declarations import named\n\n        @named(u'foo')\n        class Foo(object):\n            pass\n\n        self.assertEqual(Foo.__component_name__, u'foo') # pylint:disable=no-member\n\n    def test_function(self):\n        from zope.interface.declarations import named\n\n        @named(u'foo')\n        def doFoo(o):\n            raise NotImplementedError()\n\n        self.assertEqual(doFoo.__component_name__, u'foo')\n\n    def test_instance(self):\n        from zope.interface.declarations import named\n\n        class Foo(object):\n            pass\n        foo = Foo()\n        named(u'foo')(foo)\n\n        self.assertEqual(foo.__component_name__, u'foo') # pylint:disable=no-member\n\n\nclass EmptyDeclarationTests(unittest.TestCase):\n    # Tests that should pass for all objects that are empty\n    # declarations. This includes a Declaration explicitly created\n    # that way, and the empty ImmutableDeclaration.\n    def _getEmpty(self):\n        from zope.interface.declarations import Declaration\n        return Declaration()\n\n    def test___iter___empty(self):\n        decl = self._getEmpty()\n        self.assertEqual(list(decl), [])\n\n    def test_flattened_empty(self):\n        from zope.interface.interface import Interface\n        decl = self._getEmpty()\n        self.assertEqual(list(decl.flattened()), [Interface])\n\n    def test___contains___empty(self):\n        from zope.interface.interface import Interface\n        decl = self._getEmpty()\n        self.assertNotIn(Interface, decl)\n\n    def test_extends_empty(self):\n        from zope.interface.interface import Interface\n        decl = self._getEmpty()\n        self.assertTrue(decl.extends(Interface))\n        self.assertTrue(decl.extends(Interface, strict=True))\n\n    def test_interfaces_empty(self):\n        decl = self._getEmpty()\n        l = list(decl.interfaces())\n        self.assertEqual(l, [])\n\n    def test___sro___(self):\n        from zope.interface.interface import Interface\n        decl = self._getEmpty()\n        self.assertEqual(decl.__sro__, (decl, Interface,))\n\n    def test___iro___(self):\n        from zope.interface.interface import Interface\n        decl = self._getEmpty()\n        self.assertEqual(decl.__iro__, (Interface,))\n\n    def test_get(self):\n        decl = self._getEmpty()\n        self.assertIsNone(decl.get('attr'))\n        self.assertEqual(decl.get('abc', 'def'), 'def')\n        # It's a positive cache only (when it even exists)\n        # so this added nothing.\n        self.assertFalse(decl._v_attrs)\n\n    def test_changed_w_existing__v_attrs(self):\n        decl = self._getEmpty()\n        decl._v_attrs = object()\n        decl.changed(decl)\n        self.assertFalse(decl._v_attrs)\n\n\nclass DeclarationTests(EmptyDeclarationTests):\n\n    def _getTargetClass(self):\n        from zope.interface.declarations import Declaration\n        return Declaration\n\n    def _makeOne(self, *args, **kw):\n        return self._getTargetClass()(*args, **kw)\n\n    def test_ctor_no_bases(self):\n        decl = self._makeOne()\n        self.assertEqual(list(decl.__bases__), [])\n\n    def test_ctor_w_interface_in_bases(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        decl = self._makeOne(IFoo)\n        self.assertEqual(list(decl.__bases__), [IFoo])\n\n    def test_ctor_w_implements_in_bases(self):\n        from zope.interface.declarations import Implements\n        impl = Implements()\n        decl = self._makeOne(impl)\n        self.assertEqual(list(decl.__bases__), [impl])\n\n    def test_changed_wo_existing__v_attrs(self):\n        decl = self._makeOne()\n        decl.changed(decl) # doesn't raise\n        self.assertIsNone(decl._v_attrs)\n\n    def test___contains__w_self(self):\n        decl = self._makeOne()\n        self.assertNotIn(decl, decl)\n\n    def test___contains__w_unrelated_iface(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        decl = self._makeOne()\n        self.assertNotIn(IFoo, decl)\n\n    def test___contains__w_base_interface(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        decl = self._makeOne(IFoo)\n        self.assertIn(IFoo, decl)\n\n    def test___iter___single_base(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        decl = self._makeOne(IFoo)\n        self.assertEqual(list(decl), [IFoo])\n\n    def test___iter___multiple_bases(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        IBar = InterfaceClass('IBar')\n        decl = self._makeOne(IFoo, IBar)\n        self.assertEqual(list(decl), [IFoo, IBar])\n\n    def test___iter___inheritance(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        IBar = InterfaceClass('IBar', (IFoo,))\n        decl = self._makeOne(IBar)\n        self.assertEqual(list(decl), [IBar]) #IBar.interfaces() omits bases\n\n    def test___iter___w_nested_sequence_overlap(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        IBar = InterfaceClass('IBar')\n        decl = self._makeOne(IBar, (IFoo, IBar))\n        self.assertEqual(list(decl), [IBar, IFoo])\n\n    def test_flattened_single_base(self):\n        from zope.interface.interface import Interface\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        decl = self._makeOne(IFoo)\n        self.assertEqual(list(decl.flattened()), [IFoo, Interface])\n\n    def test_flattened_multiple_bases(self):\n        from zope.interface.interface import Interface\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        IBar = InterfaceClass('IBar')\n        decl = self._makeOne(IFoo, IBar)\n        self.assertEqual(list(decl.flattened()), [IFoo, IBar, Interface])\n\n    def test_flattened_inheritance(self):\n        from zope.interface.interface import Interface\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        IBar = InterfaceClass('IBar', (IFoo,))\n        decl = self._makeOne(IBar)\n        self.assertEqual(list(decl.flattened()), [IBar, IFoo, Interface])\n\n    def test_flattened_w_nested_sequence_overlap(self):\n        from zope.interface.interface import Interface\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        IBar = InterfaceClass('IBar')\n        # This is the same as calling ``Declaration(IBar, IFoo, IBar)``\n        # which doesn't make much sense, but here it is. In older\n        # versions of zope.interface, the __iro__ would have been\n        # IFoo, IBar, Interface, which especially makes no sense.\n        decl = self._makeOne(IBar, (IFoo, IBar))\n        # Note that decl.__iro__ has IFoo first.\n        self.assertEqual(list(decl.flattened()), [IBar, IFoo, Interface])\n\n    def test___sub___unrelated_interface(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        IBar = InterfaceClass('IBar')\n        before = self._makeOne(IFoo)\n        after = before - IBar\n        self.assertIsInstance(after, self._getTargetClass())\n        self.assertEqual(list(after), [IFoo])\n\n    def test___sub___related_interface(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        before = self._makeOne(IFoo)\n        after = before - IFoo\n        self.assertEqual(list(after), [])\n\n    def test___sub___related_interface_by_inheritance(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        IBar = InterfaceClass('IBar', (IFoo,))\n        before = self._makeOne(IBar)\n        after = before - IBar\n        self.assertEqual(list(after), [])\n\n    def test___add___unrelated_interface(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        IBar = InterfaceClass('IBar')\n        before = self._makeOne(IFoo)\n        after = before + IBar\n        self.assertIsInstance(after, self._getTargetClass())\n        self.assertEqual(list(after), [IFoo, IBar])\n\n    def test___add___related_interface(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        IBar = InterfaceClass('IBar')\n        IBaz = InterfaceClass('IBaz')\n        before = self._makeOne(IFoo, IBar)\n        other = self._makeOne(IBar, IBaz)\n        after = before + other\n        self.assertEqual(list(after), [IFoo, IBar, IBaz])\n\n\nclass TestImmutableDeclaration(EmptyDeclarationTests):\n\n    def _getTargetClass(self):\n        from zope.interface.declarations import _ImmutableDeclaration\n        return _ImmutableDeclaration\n\n    def _getEmpty(self):\n        from zope.interface.declarations import _empty\n        return _empty\n\n    def test_pickle(self):\n        import pickle\n        copied = pickle.loads(pickle.dumps(self._getEmpty()))\n        self.assertIs(copied, self._getEmpty())\n\n    def test_singleton(self):\n        self.assertIs(\n            self._getTargetClass()(),\n            self._getEmpty()\n        )\n\n    def test__bases__(self):\n        self.assertEqual(self._getEmpty().__bases__, ())\n\n    def test_change__bases__(self):\n        empty = self._getEmpty()\n        empty.__bases__ = ()\n        self.assertEqual(self._getEmpty().__bases__, ())\n\n        with self.assertRaises(TypeError):\n            empty.__bases__ = (1,)\n\n    def test_dependents(self):\n        empty = self._getEmpty()\n        deps = empty.dependents\n        self.assertEqual({}, deps)\n        # Doesn't change the return.\n        deps[1] = 2\n        self.assertEqual({}, empty.dependents)\n\n    def test_changed(self):\n        # Does nothing, has no visible side-effects\n        self._getEmpty().changed(None)\n\n    def test_extends_always_false(self):\n        self.assertFalse(self._getEmpty().extends(self))\n        self.assertFalse(self._getEmpty().extends(self, strict=True))\n        self.assertFalse(self._getEmpty().extends(self, strict=False))\n\n    def test_get_always_default(self):\n        self.assertIsNone(self._getEmpty().get('name'))\n        self.assertEqual(self._getEmpty().get('name', 42), 42)\n\n    def test_v_attrs(self):\n        decl = self._getEmpty()\n        self.assertEqual(decl._v_attrs, {})\n\n        decl._v_attrs['attr'] = 42\n        self.assertEqual(decl._v_attrs, {})\n        self.assertIsNone(decl.get('attr'))\n\n        attrs = decl._v_attrs = {}\n        attrs['attr'] = 42\n        self.assertEqual(decl._v_attrs, {})\n        self.assertIsNone(decl.get('attr'))\n\n\nclass TestImplements(NameAndModuleComparisonTestsMixin,\n                     unittest.TestCase):\n\n    def _getTargetClass(self):\n        from zope.interface.declarations import Implements\n        return Implements\n\n    def _makeOne(self, *args, **kw):\n        return self._getTargetClass()(*args, **kw)\n\n    def _makeOneToCompare(self):\n        from zope.interface.declarations import implementedBy\n        class A(object):\n            pass\n\n        return implementedBy(A)\n\n    def test_ctor_no_bases(self):\n        impl = self._makeOne()\n        self.assertEqual(impl.inherit, None)\n        self.assertEqual(impl.declared, ())\n        self.assertEqual(impl.__name__, '?')\n        self.assertEqual(list(impl.__bases__), [])\n\n    def test___repr__(self):\n        impl = self._makeOne()\n        impl.__name__ = 'Testing'\n        self.assertEqual(repr(impl), '<implementedBy Testing>')\n\n    def test___reduce__(self):\n        from zope.interface.declarations import implementedBy\n        impl = self._makeOne()\n        self.assertEqual(impl.__reduce__(), (implementedBy, (None,)))\n\n    def test_sort(self):\n        from zope.interface.declarations import implementedBy\n        class A(object):\n            pass\n        class B(object):\n            pass\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n\n        self.assertEqual(implementedBy(A), implementedBy(A))\n        self.assertEqual(hash(implementedBy(A)), hash(implementedBy(A)))\n        self.assertTrue(implementedBy(A) < None)\n        self.assertTrue(None > implementedBy(A)) # pylint:disable=misplaced-comparison-constant\n        self.assertTrue(implementedBy(A) < implementedBy(B))\n        self.assertTrue(implementedBy(A) > IFoo)\n        self.assertTrue(implementedBy(A) <= implementedBy(B))\n        self.assertTrue(implementedBy(A) >= IFoo)\n        self.assertTrue(implementedBy(A) != IFoo)\n\n    def test_proxy_equality(self):\n        # https://github.com/zopefoundation/zope.interface/issues/55\n        class Proxy(object):\n            def __init__(self, wrapped):\n                self._wrapped = wrapped\n\n            def __getattr__(self, name):\n                raise NotImplementedError()\n\n            def __eq__(self, other):\n                return self._wrapped == other\n\n            def __ne__(self, other):\n                return self._wrapped != other\n\n        from zope.interface.declarations import implementedBy\n        class A(object):\n            pass\n\n        class B(object):\n            pass\n\n        implementedByA = implementedBy(A)\n        implementedByB = implementedBy(B)\n        proxy = Proxy(implementedByA)\n\n        # The order of arguments to the operators matters,\n        # test both\n        self.assertTrue(implementedByA == implementedByA) # pylint:disable=comparison-with-itself\n        self.assertTrue(implementedByA != implementedByB)\n        self.assertTrue(implementedByB != implementedByA)\n\n        self.assertTrue(proxy == implementedByA)\n        self.assertTrue(implementedByA == proxy)\n        self.assertFalse(proxy != implementedByA)\n        self.assertFalse(implementedByA != proxy)\n\n        self.assertTrue(proxy != implementedByB)\n        self.assertTrue(implementedByB != proxy)\n\n    def test_changed_deletes_super_cache(self):\n        impl = self._makeOne()\n        self.assertIsNone(impl._super_cache)\n        self.assertNotIn('_super_cache', impl.__dict__)\n\n        impl._super_cache = 42\n        self.assertIn('_super_cache', impl.__dict__)\n\n        impl.changed(None)\n        self.assertIsNone(impl._super_cache)\n        self.assertNotIn('_super_cache', impl.__dict__)\n\n    def test_changed_does_not_add_super_cache(self):\n        impl = self._makeOne()\n        self.assertIsNone(impl._super_cache)\n        self.assertNotIn('_super_cache', impl.__dict__)\n\n        impl.changed(None)\n        self.assertIsNone(impl._super_cache)\n        self.assertNotIn('_super_cache', impl.__dict__)\n\n\nclass Test_implementedByFallback(unittest.TestCase):\n\n    def _getTargetClass(self):\n        # pylint:disable=no-name-in-module\n        from zope.interface.declarations import implementedByFallback\n        return implementedByFallback\n\n    _getFallbackClass = _getTargetClass\n\n    def _callFUT(self, *args, **kw):\n        return self._getTargetClass()(*args, **kw)\n\n    def test_dictless_wo_existing_Implements_wo_registrations(self):\n        class Foo(object):\n            __slots__ = ('__implemented__',)\n        foo = Foo()\n        foo.__implemented__ = None\n        self.assertEqual(list(self._callFUT(foo)), [])\n\n    def test_dictless_wo_existing_Implements_cant_assign___implemented__(self):\n        class Foo(object):\n            def _get_impl(self):\n                raise NotImplementedError()\n            def _set_impl(self, val):\n                raise TypeError\n            __implemented__ = property(_get_impl, _set_impl)\n            def __call__(self):\n                # act like a factory\n                raise NotImplementedError()\n        foo = Foo()\n        self.assertRaises(TypeError, self._callFUT, foo)\n\n    def test_dictless_wo_existing_Implements_w_registrations(self):\n        from zope.interface import declarations\n        class Foo(object):\n            __slots__ = ('__implemented__',)\n        foo = Foo()\n        foo.__implemented__ = None\n        reg = object()\n        with _MonkeyDict(declarations,\n                         'BuiltinImplementationSpecifications') as specs:\n            specs[foo] = reg\n            self.assertTrue(self._callFUT(foo) is reg)\n\n    def test_dictless_w_existing_Implements(self):\n        from zope.interface.declarations import Implements\n        impl = Implements()\n        class Foo(object):\n            __slots__ = ('__implemented__',)\n        foo = Foo()\n        foo.__implemented__ = impl\n        self.assertTrue(self._callFUT(foo) is impl)\n\n    def test_dictless_w_existing_not_Implements(self):\n        from zope.interface.interface import InterfaceClass\n        class Foo(object):\n            __slots__ = ('__implemented__',)\n        foo = Foo()\n        IFoo = InterfaceClass('IFoo')\n        foo.__implemented__ = (IFoo,)\n        self.assertEqual(list(self._callFUT(foo)), [IFoo])\n\n    def test_w_existing_attr_as_Implements(self):\n        from zope.interface.declarations import Implements\n        impl = Implements()\n        class Foo(object):\n            __implemented__ = impl\n        self.assertTrue(self._callFUT(Foo) is impl)\n\n    def test_builtins_added_to_cache(self):\n        from zope.interface import declarations\n        from zope.interface.declarations import Implements\n        from zope.interface._compat import _BUILTINS\n        with _MonkeyDict(declarations,\n                         'BuiltinImplementationSpecifications') as specs:\n            self.assertEqual(list(self._callFUT(tuple)), [])\n            self.assertEqual(list(self._callFUT(list)), [])\n            self.assertEqual(list(self._callFUT(dict)), [])\n            for typ in (tuple, list, dict):\n                spec = specs[typ]\n                self.assertIsInstance(spec, Implements)\n                self.assertEqual(repr(spec),\n                                 '<implementedBy %s.%s>'\n                                 % (_BUILTINS, typ.__name__))\n\n    def test_builtins_w_existing_cache(self):\n        from zope.interface import declarations\n        t_spec, l_spec, d_spec = object(), object(), object()\n        with _MonkeyDict(declarations,\n                         'BuiltinImplementationSpecifications') as specs:\n            specs[tuple] = t_spec\n            specs[list] = l_spec\n            specs[dict] = d_spec\n            self.assertTrue(self._callFUT(tuple) is t_spec)\n            self.assertTrue(self._callFUT(list) is l_spec)\n            self.assertTrue(self._callFUT(dict) is d_spec)\n\n    def test_oldstyle_class_no_assertions(self):\n        # TODO: Figure out P3 story\n        class Foo:\n            pass\n        self.assertEqual(list(self._callFUT(Foo)), [])\n\n    def test_no_assertions(self):\n        # TODO: Figure out P3 story\n        class Foo(object):\n            pass\n        self.assertEqual(list(self._callFUT(Foo)), [])\n\n    def test_w_None_no_bases_not_factory(self):\n        class Foo(object):\n            __implemented__ = None\n        foo = Foo()\n        self.assertRaises(TypeError, self._callFUT, foo)\n\n    def test_w_None_no_bases_w_factory(self):\n        from zope.interface.declarations import objectSpecificationDescriptor\n        class Foo(object):\n            __implemented__ = None\n            def __call__(self):\n                raise NotImplementedError()\n\n        foo = Foo()\n        foo.__name__ = 'foo'\n        spec = self._callFUT(foo)\n        self.assertEqual(spec.__name__,\n                         'zope.interface.tests.test_declarations.foo')\n        self.assertIs(spec.inherit, foo)\n        self.assertIs(foo.__implemented__, spec)\n        self.assertIs(foo.__providedBy__, objectSpecificationDescriptor) # pylint:disable=no-member\n        self.assertNotIn('__provides__', foo.__dict__)\n\n    def test_w_None_no_bases_w_class(self):\n        from zope.interface.declarations import ClassProvides\n        class Foo(object):\n            __implemented__ = None\n        spec = self._callFUT(Foo)\n        self.assertEqual(spec.__name__,\n                         'zope.interface.tests.test_declarations.Foo')\n        self.assertIs(spec.inherit, Foo)\n        self.assertIs(Foo.__implemented__, spec)\n        self.assertIsInstance(Foo.__providedBy__, ClassProvides) # pylint:disable=no-member\n        self.assertIsInstance(Foo.__provides__, ClassProvides) # pylint:disable=no-member\n        self.assertEqual(Foo.__provides__, Foo.__providedBy__) # pylint:disable=no-member\n\n    def test_w_existing_Implements(self):\n        from zope.interface.declarations import Implements\n        impl = Implements()\n        class Foo(object):\n            __implemented__ = impl\n        self.assertTrue(self._callFUT(Foo) is impl)\n\n    def test_super_when_base_implements_interface(self):\n        from zope.interface import Interface\n        from zope.interface.declarations import implementer\n\n        class IBase(Interface):\n            pass\n\n        class IDerived(IBase):\n            pass\n\n        @implementer(IBase)\n        class Base(object):\n            pass\n\n        @implementer(IDerived)\n        class Derived(Base):\n            pass\n\n        self.assertEqual(list(self._callFUT(Derived)), [IDerived, IBase])\n        sup = super(Derived, Derived)\n        self.assertEqual(list(self._callFUT(sup)), [IBase])\n\n    def test_super_when_base_implements_interface_diamond(self):\n        from zope.interface import Interface\n        from zope.interface.declarations import implementer\n\n        class IBase(Interface):\n            pass\n\n        class IDerived(IBase):\n            pass\n\n        @implementer(IBase)\n        class Base(object):\n            pass\n\n        class Child1(Base):\n            pass\n\n        class Child2(Base):\n            pass\n\n        @implementer(IDerived)\n        class Derived(Child1, Child2):\n            pass\n\n        self.assertEqual(list(self._callFUT(Derived)), [IDerived, IBase])\n        sup = super(Derived, Derived)\n        self.assertEqual(list(self._callFUT(sup)), [IBase])\n\n    def test_super_when_parent_implements_interface_diamond(self):\n        from zope.interface import Interface\n        from zope.interface.declarations import implementer\n\n        class IBase(Interface):\n            pass\n\n        class IDerived(IBase):\n            pass\n\n\n        class Base(object):\n            pass\n\n        class Child1(Base):\n            pass\n\n        @implementer(IBase)\n        class Child2(Base):\n            pass\n\n        @implementer(IDerived)\n        class Derived(Child1, Child2):\n            pass\n\n        self.assertEqual(Derived.__mro__, (Derived, Child1, Child2, Base, object))\n        self.assertEqual(list(self._callFUT(Derived)), [IDerived, IBase])\n        sup = super(Derived, Derived)\n        fut = self._callFUT(sup)\n        self.assertEqual(list(fut), [IBase])\n        self.assertIsNone(fut._dependents)\n\n    def test_super_when_base_doesnt_implement_interface(self):\n        from zope.interface import Interface\n        from zope.interface.declarations import implementer\n\n        class IBase(Interface):\n            pass\n\n        class IDerived(IBase):\n            pass\n\n        class Base(object):\n            pass\n\n        @implementer(IDerived)\n        class Derived(Base):\n            pass\n\n        self.assertEqual(list(self._callFUT(Derived)), [IDerived])\n\n        sup = super(Derived, Derived)\n        self.assertEqual(list(self._callFUT(sup)), [])\n\n    def test_super_when_base_is_object(self):\n        from zope.interface import Interface\n        from zope.interface.declarations import implementer\n\n        class IBase(Interface):\n            pass\n\n        class IDerived(IBase):\n            pass\n\n        @implementer(IDerived)\n        class Derived(object):\n            pass\n\n        self.assertEqual(list(self._callFUT(Derived)), [IDerived])\n\n        sup = super(Derived, Derived)\n        self.assertEqual(list(self._callFUT(sup)), [])\n    def test_super_multi_level_multi_inheritance(self):\n        from zope.interface.declarations import implementer\n        from zope.interface import Interface\n\n        class IBase(Interface):\n            pass\n\n        class IM1(Interface):\n            pass\n\n        class IM2(Interface):\n            pass\n\n        class IDerived(IBase):\n            pass\n\n        class IUnrelated(Interface):\n            pass\n\n        @implementer(IBase)\n        class Base(object):\n            pass\n\n        @implementer(IM1)\n        class M1(Base):\n            pass\n\n        @implementer(IM2)\n        class M2(Base):\n            pass\n\n        @implementer(IDerived, IUnrelated)\n        class Derived(M1, M2):\n            pass\n\n        d = Derived\n        sd = super(Derived, Derived)\n        sm1 = super(M1, Derived)\n        sm2 = super(M2, Derived)\n\n        self.assertEqual(list(self._callFUT(d)),\n                         [IDerived, IUnrelated, IM1, IBase, IM2])\n        self.assertEqual(list(self._callFUT(sd)),\n                         [IM1, IBase, IM2])\n        self.assertEqual(list(self._callFUT(sm1)),\n                         [IM2, IBase])\n        self.assertEqual(list(self._callFUT(sm2)),\n                         [IBase])\n\n\nclass Test_implementedBy(Test_implementedByFallback,\n                         OptimizationTestMixin):\n    # Repeat tests for C optimizations\n\n    def _getTargetClass(self):\n        from zope.interface.declarations import implementedBy\n        return implementedBy\n\n\nclass _ImplementsTestMixin(object):\n    FUT_SETS_PROVIDED_BY = True\n\n    def _callFUT(self, cls, iface):\n        # Declare that *cls* implements *iface*; return *cls*\n        raise NotImplementedError\n\n    def _check_implementer(self, Foo,\n                           orig_spec=None,\n                           spec_name=__name__ + '.Foo',\n                           inherit=\"not given\"):\n        from zope.interface.declarations import ClassProvides\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n\n        returned = self._callFUT(Foo, IFoo)\n\n        self.assertIs(returned, Foo)\n        spec = Foo.__implemented__\n        if orig_spec is not None:\n            self.assertIs(spec, orig_spec)\n\n        self.assertEqual(spec.__name__,\n                         spec_name)\n        inherit = Foo if inherit == \"not given\" else inherit\n        self.assertIs(spec.inherit, inherit)\n        self.assertIs(Foo.__implemented__, spec)\n        if self.FUT_SETS_PROVIDED_BY:\n            self.assertIsInstance(Foo.__providedBy__, ClassProvides)\n            self.assertIsInstance(Foo.__provides__, ClassProvides)\n            self.assertEqual(Foo.__provides__, Foo.__providedBy__)\n\n        return Foo, IFoo\n\n    def test_oldstyle_class(self):\n        # This only matters on Python 2\n        class Foo:\n            pass\n        self._check_implementer(Foo)\n\n    def test_newstyle_class(self):\n        class Foo(object):\n            pass\n        self._check_implementer(Foo)\n\nclass Test_classImplementsOnly(_ImplementsTestMixin, unittest.TestCase):\n    FUT_SETS_PROVIDED_BY = False\n\n    def _callFUT(self, cls, iface):\n        from zope.interface.declarations import classImplementsOnly\n        classImplementsOnly(cls, iface)\n        return cls\n\n    def test_w_existing_Implements(self):\n        from zope.interface.declarations import Implements\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        IBar = InterfaceClass('IBar')\n        impl = Implements(IFoo)\n        impl.declared = (IFoo,)\n        class Foo(object):\n            __implemented__ = impl\n        impl.inherit = Foo\n        self._callFUT(Foo, IBar)\n        # Same spec, now different values\n        self.assertTrue(Foo.__implemented__ is impl)\n        self.assertEqual(impl.inherit, None)\n        self.assertEqual(impl.declared, (IBar,))\n\n    def test_oldstyle_class(self):\n        from zope.interface.declarations import Implements\n        from zope.interface.interface import InterfaceClass\n        IBar = InterfaceClass('IBar')\n        old_spec = Implements(IBar)\n\n        class Foo:\n            __implemented__ = old_spec\n        self._check_implementer(Foo, old_spec, '?', inherit=None)\n\n    def test_newstyle_class(self):\n        from zope.interface.declarations import Implements\n        from zope.interface.interface import InterfaceClass\n        IBar = InterfaceClass('IBar')\n        old_spec = Implements(IBar)\n\n        class Foo(object):\n            __implemented__ = old_spec\n        self._check_implementer(Foo, old_spec, '?', inherit=None)\n\n\n    def test_redundant_with_super_still_implements(self):\n        Base, IBase = self._check_implementer(\n            type('Foo', (object,), {}),\n            inherit=None,\n        )\n\n        class Child(Base):\n            pass\n\n        self._callFUT(Child, IBase)\n        self.assertTrue(IBase.implementedBy(Child))\n\n\nclass Test_classImplements(_ImplementsTestMixin, unittest.TestCase):\n\n    def _callFUT(self, cls, iface):\n        from zope.interface.declarations import classImplements\n        result = classImplements(cls, iface) # pylint:disable=assignment-from-no-return\n        self.assertIsNone(result)\n        return cls\n\n    def __check_implementer_redundant(self, Base):\n        # If we @implementer exactly what was already present, we write\n        # no declared attributes on the parent (we still set everything, though)\n        Base, IBase = self._check_implementer(Base)\n\n        class Child(Base):\n            pass\n\n        returned = self._callFUT(Child, IBase)\n        self.assertIn('__implemented__', returned.__dict__)\n        self.assertNotIn('__providedBy__', returned.__dict__)\n        self.assertIn('__provides__', returned.__dict__)\n\n        spec = Child.__implemented__\n        self.assertEqual(spec.declared, ())\n        self.assertEqual(spec.inherit, Child)\n\n        self.assertTrue(IBase.providedBy(Child()))\n\n    def test_redundant_implementer_empty_class_declarations_newstyle(self):\n        self.__check_implementer_redundant(type('Foo', (object,), {}))\n\n    def test_redundant_implementer_empty_class_declarations_oldstyle(self):\n        # This only matters on Python 2\n        class Foo:\n            pass\n        self.__check_implementer_redundant(Foo)\n\n    def test_redundant_implementer_Interface(self):\n        from zope.interface import Interface\n        from zope.interface import implementedBy\n        from zope.interface import ro\n        from zope.interface.tests.test_ro import C3Setting\n\n        class Foo(object):\n            pass\n\n        with C3Setting(ro.C3.STRICT_IRO, False):\n            self._callFUT(Foo, Interface)\n            self.assertEqual(list(implementedBy(Foo)), [Interface])\n\n            class Baz(Foo):\n                pass\n\n            self._callFUT(Baz, Interface)\n            self.assertEqual(list(implementedBy(Baz)), [Interface])\n\n    def _order_for_two(self, applied_first, applied_second):\n        return (applied_first, applied_second)\n\n    def test_w_existing_Implements(self):\n        from zope.interface.declarations import Implements\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        IBar = InterfaceClass('IBar')\n        impl = Implements(IFoo)\n        impl.declared = (IFoo,)\n        class Foo(object):\n            __implemented__ = impl\n        impl.inherit = Foo\n        self._callFUT(Foo, IBar)\n        # Same spec, now different values\n        self.assertIs(Foo.__implemented__, impl)\n        self.assertEqual(impl.inherit, Foo)\n        self.assertEqual(impl.declared,\n                         self._order_for_two(IFoo, IBar))\n\n    def test_w_existing_Implements_w_bases(self):\n        from zope.interface.declarations import Implements\n        from zope.interface.interface import InterfaceClass\n        IRoot = InterfaceClass('IRoot')\n        ISecondRoot = InterfaceClass('ISecondRoot')\n        IExtendsRoot = InterfaceClass('IExtendsRoot', (IRoot,))\n\n        impl_root = Implements.named('Root', IRoot)\n        impl_root.declared = (IRoot,)\n\n        class Root1(object):\n            __implemented__ = impl_root\n        class Root2(object):\n            __implemented__ = impl_root\n\n        impl_extends_root = Implements.named('ExtendsRoot1', IExtendsRoot)\n        impl_extends_root.declared = (IExtendsRoot,)\n        class ExtendsRoot(Root1, Root2):\n            __implemented__ = impl_extends_root\n        impl_extends_root.inherit = ExtendsRoot\n\n        self._callFUT(ExtendsRoot, ISecondRoot)\n        # Same spec, now different values\n        self.assertIs(ExtendsRoot.__implemented__, impl_extends_root)\n        self.assertEqual(impl_extends_root.inherit, ExtendsRoot)\n        self.assertEqual(impl_extends_root.declared,\n                         self._order_for_two(IExtendsRoot, ISecondRoot,))\n        self.assertEqual(impl_extends_root.__bases__,\n                         self._order_for_two(IExtendsRoot, ISecondRoot) + (impl_root,))\n\n\nclass Test_classImplementsFirst(Test_classImplements):\n\n    def _callFUT(self, cls, iface):\n        from zope.interface.declarations import classImplementsFirst\n        result = classImplementsFirst(cls, iface) # pylint:disable=assignment-from-no-return\n        self.assertIsNone(result)\n        return cls\n\n    def _order_for_two(self, applied_first, applied_second):\n        return (applied_second, applied_first)\n\n\nclass Test__implements_advice(unittest.TestCase):\n\n    def _callFUT(self, *args, **kw):\n        from zope.interface.declarations import _implements_advice\n        return _implements_advice(*args, **kw)\n\n    def test_no_existing_implements(self):\n        from zope.interface.declarations import classImplements\n        from zope.interface.declarations import Implements\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        class Foo(object):\n            __implements_advice_data__ = ((IFoo,), classImplements)\n        self._callFUT(Foo)\n        self.assertNotIn('__implements_advice_data__', Foo.__dict__)\n        self.assertIsInstance(Foo.__implemented__, Implements) # pylint:disable=no-member\n        self.assertEqual(list(Foo.__implemented__), [IFoo]) # pylint:disable=no-member\n\n\nclass Test_implementer(Test_classImplements):\n\n    def _getTargetClass(self):\n        from zope.interface.declarations import implementer\n        return implementer\n\n    def _makeOne(self, *args, **kw):\n        return self._getTargetClass()(*args, **kw)\n\n    def _callFUT(self, cls, *ifaces):\n        decorator = self._makeOne(*ifaces)\n        return decorator(cls)\n\n    def test_nonclass_cannot_assign_attr(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        decorator = self._makeOne(IFoo)\n        self.assertRaises(TypeError, decorator, object())\n\n    def test_nonclass_can_assign_attr(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        class Foo(object):\n            pass\n        foo = Foo()\n        decorator = self._makeOne(IFoo)\n        returned = decorator(foo)\n        self.assertTrue(returned is foo)\n        spec = foo.__implemented__ # pylint:disable=no-member\n        self.assertEqual(spec.__name__, 'zope.interface.tests.test_declarations.?')\n        self.assertIsNone(spec.inherit,)\n        self.assertIs(foo.__implemented__, spec) # pylint:disable=no-member\n\n    def test_does_not_leak_on_unique_classes(self):\n        # Make sure nothing is hanging on to the class or Implements\n        # object after they go out of scope. There was briefly a bug\n        # in 5.x that caused SpecificationBase._bases (in C) to not be\n        # traversed or cleared.\n        # https://github.com/zopefoundation/zope.interface/issues/216\n        import gc\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n\n        begin_count = len(gc.get_objects())\n\n        for _ in range(1900):\n            class TestClass(object):\n                pass\n\n            self._callFUT(TestClass, IFoo)\n\n        gc.collect()\n\n        end_count = len(gc.get_objects())\n\n        # How many new objects might still be around? In all currently\n        # tested interpreters, there aren't any, so our counts should\n        # match exactly. When the bug existed, in a steady state, the loop\n        # would grow by two objects each iteration\n        fudge_factor = 0\n        self.assertLessEqual(end_count, begin_count + fudge_factor)\n\n\n\nclass Test_implementer_only(Test_classImplementsOnly):\n\n    def _getTargetClass(self):\n        from zope.interface.declarations import implementer_only\n        return implementer_only\n\n    def _makeOne(self, *args, **kw):\n        return self._getTargetClass()(*args, **kw)\n\n    def _callFUT(self, cls, iface):\n        decorator = self._makeOne(iface)\n        return decorator(cls)\n\n    def test_function(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        decorator = self._makeOne(IFoo)\n        def _function():\n            raise NotImplementedError()\n        self.assertRaises(ValueError, decorator, _function)\n\n    def test_method(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass('IFoo')\n        decorator = self._makeOne(IFoo)\n        class Bar:\n            def _method(self):\n                raise NotImplementedError()\n        self.assertRaises(ValueError, decorator, Bar._method)\n\n\n\n# Test '_implements' by way of 'implements{,Only}', its only callers.\n\nclass Test_implementsOnly(unittest.TestCase, _Py3ClassAdvice):\n\n    def test_simple(self):\n        import warnings\n        from zope.interface.declarations import implementsOnly\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        globs = {'implementsOnly': implementsOnly,\n                 'IFoo': IFoo,\n                }\n        locs = {}\n        CODE = \"\\n\".join([\n            'class Foo(object):'\n            '    implementsOnly(IFoo)',\n            ])\n        with warnings.catch_warnings(record=True) as log:\n            warnings.resetwarnings()\n            try:\n                exec(CODE, globs, locs)  # pylint:disable=exec-used\n            except TypeError:\n                self.assertTrue(PYTHON3, \"Must be Python 3\")\n            else:\n                if PYTHON3:\n                    self.fail(\"Didn't raise TypeError\")\n                Foo = locs['Foo']\n                spec = Foo.__implemented__\n                self.assertEqual(list(spec), [IFoo])\n                self.assertEqual(len(log), 0) # no longer warn\n\n    def test_called_once_from_class_w_bases(self):\n        from zope.interface.declarations import implements\n        from zope.interface.declarations import implementsOnly\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        IBar = InterfaceClass(\"IBar\")\n        globs = {'implements': implements,\n                 'implementsOnly': implementsOnly,\n                 'IFoo': IFoo,\n                 'IBar': IBar,\n                }\n        locs = {}\n        CODE = \"\\n\".join([\n            'class Foo(object):',\n            '    implements(IFoo)',\n            'class Bar(Foo):'\n            '    implementsOnly(IBar)',\n            ])\n        if self._run_generated_code(CODE, globs, locs):\n            Bar = locs['Bar']\n            spec = Bar.__implemented__\n            self.assertEqual(list(spec), [IBar])\n\n\nclass Test_implements(unittest.TestCase, _Py3ClassAdvice):\n\n    def test_called_from_function(self):\n        import warnings\n        from zope.interface.declarations import implements\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        globs = {'implements': implements, 'IFoo': IFoo}\n        locs = {}\n        CODE = \"\\n\".join([\n            'def foo():',\n            '    implements(IFoo)'\n            ])\n        if self._run_generated_code(CODE, globs, locs, False):\n            foo = locs['foo']\n            with warnings.catch_warnings(record=True) as log:\n                warnings.resetwarnings()\n                self.assertRaises(TypeError, foo)\n                self.assertEqual(len(log), 0) # no longer warn\n\n    def test_called_twice_from_class(self):\n        import warnings\n        from zope.interface.declarations import implements\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        IBar = InterfaceClass(\"IBar\")\n        globs = {'implements': implements, 'IFoo': IFoo, 'IBar': IBar}\n        locs = {}\n        CODE = \"\\n\".join([\n            'class Foo(object):',\n            '    implements(IFoo)',\n            '    implements(IBar)',\n            ])\n        with warnings.catch_warnings(record=True) as log:\n            warnings.resetwarnings()\n            try:\n                exec(CODE, globs, locs)  # pylint:disable=exec-used\n            except TypeError:\n                if not PYTHON3:\n                    self.assertEqual(len(log), 0) # no longer warn\n            else:\n                self.fail(\"Didn't raise TypeError\")\n\n    def test_called_once_from_class(self):\n        from zope.interface.declarations import implements\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        globs = {'implements': implements, 'IFoo': IFoo}\n        locs = {}\n        CODE = \"\\n\".join([\n            'class Foo(object):',\n            '    implements(IFoo)',\n            ])\n        if self._run_generated_code(CODE, globs, locs):\n            Foo = locs['Foo']\n            spec = Foo.__implemented__\n            self.assertEqual(list(spec), [IFoo])\n\n\nclass ProvidesClassTests(unittest.TestCase):\n\n    def _getTargetClass(self):\n        from zope.interface.declarations import ProvidesClass\n        return ProvidesClass\n\n    def _makeOne(self, *args, **kw):\n        return self._getTargetClass()(*args, **kw)\n\n    def test_simple_class_one_interface(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        class Foo(object):\n            pass\n        spec = self._makeOne(Foo, IFoo)\n        self.assertEqual(list(spec), [IFoo])\n\n    def test___reduce__(self):\n        from zope.interface.declarations import Provides # the function\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        class Foo(object):\n            pass\n        spec = self._makeOne(Foo, IFoo)\n        klass, args = spec.__reduce__()\n        self.assertTrue(klass is Provides)\n        self.assertEqual(args, (Foo, IFoo))\n\n    def test___get___class(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        class Foo(object):\n            pass\n        spec = self._makeOne(Foo, IFoo)\n        Foo.__provides__ = spec\n        self.assertTrue(Foo.__provides__ is spec)\n\n    def test___get___instance(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        class Foo(object):\n            pass\n        spec = self._makeOne(Foo, IFoo)\n        Foo.__provides__ = spec\n        def _test():\n            foo = Foo()\n            return foo.__provides__\n        self.assertRaises(AttributeError, _test)\n\n    def test__repr__(self):\n        inst = self._makeOne(type(self))\n        self.assertEqual(\n            repr(inst),\n            \"<zope.interface.Provides for %r>\"  % type(self)\n        )\n\n\nclass Test_Provides(unittest.TestCase):\n\n    def _callFUT(self, *args, **kw):\n        from zope.interface.declarations import Provides\n        return Provides(*args, **kw)\n\n    def test_no_cached_spec(self):\n        from zope.interface import declarations\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        cache = {}\n        class Foo(object):\n            pass\n        with _Monkey(declarations, InstanceDeclarations=cache):\n            spec = self._callFUT(Foo, IFoo)\n        self.assertEqual(list(spec), [IFoo])\n        self.assertTrue(cache[(Foo, IFoo)] is spec)\n\n    def test_w_cached_spec(self):\n        from zope.interface import declarations\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        prior = object()\n        class Foo(object):\n            pass\n        cache = {(Foo, IFoo): prior}\n        with _Monkey(declarations, InstanceDeclarations=cache):\n            spec = self._callFUT(Foo, IFoo)\n        self.assertTrue(spec is prior)\n\n\nclass Test_directlyProvides(unittest.TestCase):\n\n    def _callFUT(self, *args, **kw):\n        from zope.interface.declarations import directlyProvides\n        return directlyProvides(*args, **kw)\n\n    def test_w_normal_object(self):\n        from zope.interface.declarations import ProvidesClass\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        class Foo(object):\n            pass\n        obj = Foo()\n        self._callFUT(obj, IFoo)\n        self.assertIsInstance(obj.__provides__, ProvidesClass) # pylint:disable=no-member\n        self.assertEqual(list(obj.__provides__), [IFoo]) # pylint:disable=no-member\n\n    def test_w_class(self):\n        from zope.interface.declarations import ClassProvides\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        class Foo(object):\n            pass\n        self._callFUT(Foo, IFoo)\n        self.assertIsInstance(Foo.__provides__, ClassProvides) # pylint:disable=no-member\n        self.assertEqual(list(Foo.__provides__), [IFoo]) # pylint:disable=no-member\n\n    @_skip_under_py3k\n    def test_w_non_descriptor_aware_metaclass(self):\n        # There are no non-descriptor-aware types in Py3k\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        class MetaClass(type):\n            def __getattribute__(cls, name):\n                # Emulate metaclass whose base is not the type object.\n                if name == '__class__':\n                    return cls\n                # Under certain circumstances, the implementedByFallback\n                # can get here for __dict__\n                return type.__getattribute__(cls, name) # pragma: no cover\n\n        class Foo(object):\n            __metaclass__ = MetaClass\n        obj = Foo()\n        self.assertRaises(TypeError, self._callFUT, obj, IFoo)\n\n    def test_w_classless_object(self):\n        from zope.interface.declarations import ProvidesClass\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        the_dict = {}\n        class Foo(object):\n            def __getattribute__(self, name):\n                # Emulate object w/o any class\n                if name == '__class__':\n                    return None\n                raise NotImplementedError(name)\n            def __setattr__(self, name, value):\n                the_dict[name] = value\n        obj = Foo()\n        self._callFUT(obj, IFoo)\n        self.assertIsInstance(the_dict['__provides__'], ProvidesClass)\n        self.assertEqual(list(the_dict['__provides__']), [IFoo])\n\n\nclass Test_alsoProvides(unittest.TestCase):\n\n    def _callFUT(self, *args, **kw):\n        from zope.interface.declarations import alsoProvides\n        return alsoProvides(*args, **kw)\n\n    def test_wo_existing_provides(self):\n        from zope.interface.declarations import ProvidesClass\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        class Foo(object):\n            pass\n        obj = Foo()\n        self._callFUT(obj, IFoo)\n        self.assertIsInstance(obj.__provides__, ProvidesClass) # pylint:disable=no-member\n        self.assertEqual(list(obj.__provides__), [IFoo]) # pylint:disable=no-member\n\n    def test_w_existing_provides(self):\n        from zope.interface.declarations import directlyProvides\n        from zope.interface.declarations import ProvidesClass\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        IBar = InterfaceClass(\"IBar\")\n        class Foo(object):\n            pass\n        obj = Foo()\n        directlyProvides(obj, IFoo)\n        self._callFUT(obj, IBar)\n        self.assertIsInstance(obj.__provides__, ProvidesClass) # pylint:disable=no-member\n        self.assertEqual(list(obj.__provides__), [IFoo, IBar]) # pylint:disable=no-member\n\n\nclass Test_noLongerProvides(unittest.TestCase):\n\n    def _callFUT(self, *args, **kw):\n        from zope.interface.declarations import noLongerProvides\n        return noLongerProvides(*args, **kw)\n\n    def test_wo_existing_provides(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        class Foo(object):\n            pass\n        obj = Foo()\n        self._callFUT(obj, IFoo)\n        self.assertEqual(list(obj.__provides__), []) # pylint:disable=no-member\n\n    def test_w_existing_provides_hit(self):\n        from zope.interface.declarations import directlyProvides\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        class Foo(object):\n            pass\n        obj = Foo()\n        directlyProvides(obj, IFoo)\n        self._callFUT(obj, IFoo)\n        self.assertEqual(list(obj.__provides__), []) # pylint:disable=no-member\n\n    def test_w_existing_provides_miss(self):\n        from zope.interface.declarations import directlyProvides\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        IBar = InterfaceClass(\"IBar\")\n        class Foo(object):\n            pass\n        obj = Foo()\n        directlyProvides(obj, IFoo)\n        self._callFUT(obj, IBar)\n        self.assertEqual(list(obj.__provides__), [IFoo]) # pylint:disable=no-member\n\n    def test_w_iface_implemented_by_class(self):\n        from zope.interface.declarations import implementer\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        @implementer(IFoo)\n        class Foo(object):\n            pass\n        obj = Foo()\n        self.assertRaises(ValueError, self._callFUT, obj, IFoo)\n\n\nclass ClassProvidesBaseFallbackTests(unittest.TestCase):\n\n    def _getTargetClass(self):\n        # pylint:disable=no-name-in-module\n        from zope.interface.declarations import ClassProvidesBaseFallback\n        return ClassProvidesBaseFallback\n\n    def _makeOne(self, klass, implements):\n        # Don't instantiate directly:  the C version can't have attributes\n        # assigned.\n        class Derived(self._getTargetClass()):\n            def __init__(self, k, i):\n                self._cls = k\n                self._implements = i\n        return Derived(klass, implements)\n\n    def test_w_same_class_via_class(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        class Foo(object):\n            pass\n        cpbp = Foo.__provides__ = self._makeOne(Foo, IFoo)\n        self.assertTrue(Foo.__provides__ is cpbp)\n\n    def test_w_same_class_via_instance(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        class Foo(object):\n            pass\n        foo = Foo()\n        Foo.__provides__ = self._makeOne(Foo, IFoo)\n        self.assertIs(foo.__provides__, IFoo)\n\n    def test_w_different_class(self):\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        class Foo(object):\n            pass\n        class Bar(Foo):\n            pass\n        bar = Bar()\n        Foo.__provides__ = self._makeOne(Foo, IFoo)\n        self.assertRaises(AttributeError, getattr, Bar, '__provides__')\n        self.assertRaises(AttributeError, getattr, bar, '__provides__')\n\n\nclass ClassProvidesBaseTests(OptimizationTestMixin,\n                             ClassProvidesBaseFallbackTests):\n    # Repeat tests for C optimizations\n\n    def _getTargetClass(self):\n        from zope.interface.declarations import ClassProvidesBase\n        return ClassProvidesBase\n\n    def _getFallbackClass(self):\n        # pylint:disable=no-name-in-module\n        from zope.interface.declarations import ClassProvidesBaseFallback\n        return ClassProvidesBaseFallback\n\n\nclass ClassProvidesTests(unittest.TestCase):\n\n    def _getTargetClass(self):\n        from zope.interface.declarations import ClassProvides\n        return ClassProvides\n\n    def _makeOne(self, *args, **kw):\n        return self._getTargetClass()(*args, **kw)\n\n    def test_w_simple_metaclass(self):\n        from zope.interface.declarations import implementer\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        IBar = InterfaceClass(\"IBar\")\n        @implementer(IFoo)\n        class Foo(object):\n            pass\n        cp = Foo.__provides__ = self._makeOne(Foo, type(Foo), IBar)\n        self.assertTrue(Foo.__provides__ is cp)\n        self.assertEqual(list(Foo().__provides__), [IFoo])\n\n    def test___reduce__(self):\n        from zope.interface.declarations import implementer\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        IBar = InterfaceClass(\"IBar\")\n        @implementer(IFoo)\n        class Foo(object):\n            pass\n        cp = Foo.__provides__ = self._makeOne(Foo, type(Foo), IBar)\n        self.assertEqual(cp.__reduce__(),\n                         (self._getTargetClass(), (Foo, type(Foo), IBar)))\n\n    def test__repr__(self):\n        inst = self._makeOne(type(self), type)\n        self.assertEqual(\n            repr(inst),\n            \"<zope.interface.declarations.ClassProvides for %r>\"  % type(self)\n        )\n\nclass Test_directlyProvidedBy(unittest.TestCase):\n\n    def _callFUT(self, *args, **kw):\n        from zope.interface.declarations import directlyProvidedBy\n        return directlyProvidedBy(*args, **kw)\n\n    def test_wo_declarations_in_class_or_instance(self):\n        class Foo(object):\n            pass\n        foo = Foo()\n        self.assertEqual(list(self._callFUT(foo)), [])\n\n    def test_w_declarations_in_class_but_not_instance(self):\n        from zope.interface.declarations import implementer\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        @implementer(IFoo)\n        class Foo(object):\n            pass\n        foo = Foo()\n        self.assertEqual(list(self._callFUT(foo)), [])\n\n    def test_w_declarations_in_instance_but_not_class(self):\n        from zope.interface.declarations import directlyProvides\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        class Foo(object):\n            pass\n        foo = Foo()\n        directlyProvides(foo, IFoo)\n        self.assertEqual(list(self._callFUT(foo)), [IFoo])\n\n    def test_w_declarations_in_instance_and_class(self):\n        from zope.interface.declarations import directlyProvides\n        from zope.interface.declarations import implementer\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        IBar = InterfaceClass(\"IBar\")\n        @implementer(IFoo)\n        class Foo(object):\n            pass\n        foo = Foo()\n        directlyProvides(foo, IBar)\n        self.assertEqual(list(self._callFUT(foo)), [IBar])\n\n\nclass Test_classProvides(unittest.TestCase, _Py3ClassAdvice):\n    # pylint:disable=exec-used\n\n    def test_called_from_function(self):\n        import warnings\n        from zope.interface.declarations import classProvides\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        globs = {'classProvides': classProvides, 'IFoo': IFoo}\n        locs = {}\n        CODE = \"\\n\".join([\n            'def foo():',\n            '    classProvides(IFoo)'\n            ])\n        exec(CODE, globs, locs)\n        foo = locs['foo']\n        with warnings.catch_warnings(record=True) as log:\n            warnings.resetwarnings()\n            self.assertRaises(TypeError, foo)\n            if not PYTHON3:\n                self.assertEqual(len(log), 0) # no longer warn\n\n    def test_called_twice_from_class(self):\n        import warnings\n        from zope.interface.declarations import classProvides\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        IBar = InterfaceClass(\"IBar\")\n        globs = {'classProvides': classProvides, 'IFoo': IFoo, 'IBar': IBar}\n        locs = {}\n        CODE = \"\\n\".join([\n            'class Foo(object):',\n            '    classProvides(IFoo)',\n            '    classProvides(IBar)',\n            ])\n        with warnings.catch_warnings(record=True) as log:\n            warnings.resetwarnings()\n            try:\n                exec(CODE, globs, locs)\n            except TypeError:\n                if not PYTHON3:\n                    self.assertEqual(len(log), 0) # no longer warn\n            else:\n                self.fail(\"Didn't raise TypeError\")\n\n    def test_called_once_from_class(self):\n        from zope.interface.declarations import classProvides\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        globs = {'classProvides': classProvides, 'IFoo': IFoo}\n        locs = {}\n        CODE = \"\\n\".join([\n            'class Foo(object):',\n            '    classProvides(IFoo)',\n            ])\n        if self._run_generated_code(CODE, globs, locs):\n            Foo = locs['Foo']\n            spec = Foo.__providedBy__\n            self.assertEqual(list(spec), [IFoo])\n\n# Test _classProvides_advice through classProvides, its only caller.\n\n\nclass Test_provider(unittest.TestCase):\n\n    def _getTargetClass(self):\n        from zope.interface.declarations import provider\n        return provider\n\n    def _makeOne(self, *args, **kw):\n        return self._getTargetClass()(*args, **kw)\n\n    def test_w_class(self):\n        from zope.interface.declarations import ClassProvides\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        @self._makeOne(IFoo)\n        class Foo(object):\n            pass\n        self.assertIsInstance(Foo.__provides__, ClassProvides) # pylint:disable=no-member\n        self.assertEqual(list(Foo.__provides__), [IFoo]) # pylint:disable=no-member\n\n\nclass Test_moduleProvides(unittest.TestCase):\n    # pylint:disable=exec-used\n\n    def test_called_from_function(self):\n        from zope.interface.declarations import moduleProvides\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        globs = {'__name__': 'zope.interface.tests.foo',\n                 'moduleProvides': moduleProvides, 'IFoo': IFoo}\n        locs = {}\n        CODE = \"\\n\".join([\n            'def foo():',\n            '    moduleProvides(IFoo)'\n            ])\n        exec(CODE, globs, locs)\n        foo = locs['foo']\n        self.assertRaises(TypeError, foo)\n\n    def test_called_from_class(self):\n        from zope.interface.declarations import moduleProvides\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        globs = {'__name__': 'zope.interface.tests.foo',\n                 'moduleProvides': moduleProvides, 'IFoo': IFoo}\n        locs = {}\n        CODE = \"\\n\".join([\n            'class Foo(object):',\n            '    moduleProvides(IFoo)',\n            ])\n        with self.assertRaises(TypeError):\n            exec(CODE, globs, locs)\n\n    def test_called_once_from_module_scope(self):\n        from zope.interface.declarations import moduleProvides\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        globs = {'__name__': 'zope.interface.tests.foo',\n                 'moduleProvides': moduleProvides, 'IFoo': IFoo}\n        CODE = \"\\n\".join([\n            'moduleProvides(IFoo)',\n            ])\n        exec(CODE, globs)\n        spec = globs['__provides__']\n        self.assertEqual(list(spec), [IFoo])\n\n    def test_called_twice_from_module_scope(self):\n        from zope.interface.declarations import moduleProvides\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        globs = {'__name__': 'zope.interface.tests.foo',\n                 'moduleProvides': moduleProvides, 'IFoo': IFoo}\n\n        CODE = \"\\n\".join([\n            'moduleProvides(IFoo)',\n            'moduleProvides(IFoo)',\n            ])\n        with self.assertRaises(TypeError):\n            exec(CODE, globs)\n\n\nclass Test_getObjectSpecificationFallback(unittest.TestCase):\n\n    def _getFallbackClass(self):\n        # pylint:disable=no-name-in-module\n        from zope.interface.declarations import getObjectSpecificationFallback\n        return getObjectSpecificationFallback\n\n    _getTargetClass = _getFallbackClass\n\n    def _callFUT(self, *args, **kw):\n        return self._getTargetClass()(*args, **kw)\n\n    def test_wo_existing_provides_classless(self):\n        the_dict = {}\n        class Foo(object):\n            def __getattribute__(self, name):\n                # Emulate object w/o any class\n                if name == '__class__':\n                    raise AttributeError(name)\n                try:\n                    return the_dict[name]\n                except KeyError:\n                    raise AttributeError(name)\n            def __setattr__(self, name, value):\n                raise NotImplementedError()\n        foo = Foo()\n        spec = self._callFUT(foo)\n        self.assertEqual(list(spec), [])\n\n    def test_existing_provides_is_spec(self):\n        from zope.interface.declarations import directlyProvides\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        def foo():\n            raise NotImplementedError()\n        directlyProvides(foo, IFoo)\n        spec = self._callFUT(foo)\n        self.assertIs(spec, foo.__provides__) # pylint:disable=no-member\n\n    def test_existing_provides_is_not_spec(self):\n        def foo():\n            raise NotImplementedError()\n        foo.__provides__ = object() # not a valid spec\n        spec = self._callFUT(foo)\n        self.assertEqual(list(spec), [])\n\n    def test_existing_provides(self):\n        from zope.interface.declarations import directlyProvides\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        class Foo(object):\n            pass\n        foo = Foo()\n        directlyProvides(foo, IFoo)\n        spec = self._callFUT(foo)\n        self.assertEqual(list(spec), [IFoo])\n\n    def test_wo_provides_on_class_w_implements(self):\n        from zope.interface.declarations import implementer\n        from zope.interface.interface import InterfaceClass\n        IFoo = InterfaceClass(\"IFoo\")\n        @implementer(IFoo)\n        class Foo(object):\n            pass\n        foo = Foo()\n        spec = self._callFUT(foo)\n        self.assertEqual(list(spec), [IFoo])\n\n    def test_wo_provides_on_class_wo_implements(self):\n        class Foo(object):\n            pass\n        foo = Foo()\n        spec = self._callFUT(foo)\n        self.assertEqual(list(spec), [])\n\n    def test_catches_only_AttributeError_on_provides(self):\n        MissingSomeAttrs.test_raises(self, self._callFUT, expected_missing='__provides__')\n\n    def test_catches_only_AttributeError_on_class(self):\n        MissingSomeAttrs.test_raises(self, self._callFUT, expected_missing='__class__',\n                                     __provides__=None)\n\n    def test_raises_AttributeError_when_provides_fails_type_check_AttributeError(self):\n        # isinstance(ob.__provides__, SpecificationBase) is not\n        # protected inside any kind of block.\n\n        class Foo(object):\n            __provides__ = MissingSomeAttrs(AttributeError)\n\n        # isinstance() ignores AttributeError on __class__\n        self._callFUT(Foo())\n\n    def test_raises_AttributeError_when_provides_fails_type_check_RuntimeError(self):\n        # isinstance(ob.__provides__, SpecificationBase) is not\n        # protected inside any kind of block.\n        class Foo(object):\n            __provides__ = MissingSomeAttrs(RuntimeError)\n\n        if PYTHON3:\n            with self.assertRaises(RuntimeError) as exc:\n                self._callFUT(Foo())\n\n            self.assertEqual('__class__', exc.exception.args[0])\n        else:\n            # Python 2 catches everything.\n            self._callFUT(Foo())\n\n\nclass Test_getObjectSpecification(Test_getObjectSpecificationFallback,\n                                  OptimizationTestMixin):\n    # Repeat tests for C optimizations\n", "contexts_below": "\n class Test_providedByFallback(unittest.TestCase):\n \n     def _getFallbackClass(self):\n         # pylint:disable=no-name-in-module\n         from zope.interface.declarations import providedByFallback\n         return providedByFallback\n \n     _getTargetClass = _getFallbackClass\n \n     def _callFUT(self, *args, **kw):\n         return self._getTargetClass()(*args, **kw)\n \n     def test_wo_providedBy_on_class_wo_implements(self):\n         class Foo(object):\n             pass\n         foo = Foo()\n         spec = self._callFUT(foo)\n         self.assertEqual(list(spec), [])\n \n     def test_w_providedBy_valid_spec(self):\n         from zope.interface.declarations import Provides\n         from zope.interface.interface import InterfaceClass\n         IFoo = InterfaceClass(\"IFoo\")\n         class Foo(object):\n             pass\n         foo = Foo()\n         foo.__providedBy__ = Provides(Foo, IFoo)\n         spec = self._callFUT(foo)\n         self.assertEqual(list(spec), [IFoo])\n \n     def test_w_providedBy_invalid_spec(self):\n         class Foo(object):\n             pass\n         foo = Foo()\n         foo.__providedBy__ = object()\n         spec = self._callFUT(foo)\n         self.assertEqual(list(spec), [])\n \n     def test_w_providedBy_invalid_spec_class_w_implements(self):\n         from zope.interface.declarations import implementer\n         from zope.interface.interface import InterfaceClass\n         IFoo = InterfaceClass(\"IFoo\")\n         @implementer(IFoo)\n         class Foo(object):\n             pass\n         foo = Foo()\n         foo.__providedBy__ = object()\n         spec = self._callFUT(foo)\n         self.assertEqual(list(spec), [IFoo])\n \n     def test_w_providedBy_invalid_spec_w_provides_no_provides_on_class(self):\n         class Foo(object):\n             pass\n         foo = Foo()\n         foo.__providedBy__ = object()\n         expected = foo.__provides__ = object()\n         spec = self._callFUT(foo)\n         self.assertTrue(spec is expected)\n \n     def test_w_providedBy_invalid_spec_w_provides_diff_provides_on_class(self):\n         class Foo(object):\n             pass\n         foo = Foo()\n         foo.__providedBy__ = object()\n         expected = foo.__provides__ = object()\n         Foo.__provides__ = object()\n         spec = self._callFUT(foo)\n         self.assertTrue(spec is expected)\n \n     def test_w_providedBy_invalid_spec_w_provides_same_provides_on_class(self):\n         from zope.interface.declarations import implementer\n         from zope.interface.interface import InterfaceClass\n         IFoo = InterfaceClass(\"IFoo\")\n         @implementer(IFoo)\n         class Foo(object):\n             pass\n         foo = Foo()\n         foo.__providedBy__ = object()\n         foo.__provides__ = Foo.__provides__ = object()\n         spec = self._callFUT(foo)\n         self.assertEqual(list(spec), [IFoo])\n \n     def test_super_when_base_implements_interface(self):\n         from zope.interface import Interface\n         from zope.interface.declarations import implementer\n \n         class IBase(Interface):\n             pass\n \n         class IDerived(IBase):\n             pass\n \n         @implementer(IBase)\n         class Base(object):\n             pass\n \n         @implementer(IDerived)\n         class Derived(Base):\n             pass\n \n         derived = Derived()\n         self.assertEqual(list(self._callFUT(derived)), [IDerived, IBase])\n \n         sup = super(Derived, derived)\n         fut = self._callFUT(sup)\n         self.assertIsNone(fut._dependents)\n         self.assertEqual(list(fut), [IBase])\n \n     def test_super_when_base_doesnt_implement_interface(self):\n         from zope.interface import Interface\n         from zope.interface.declarations import implementer\n \n         class IBase(Interface):\n             pass\n \n         class IDerived(IBase):\n             pass\n \n         class Base(object):\n             pass\n \n         @implementer(IDerived)\n         class Derived(Base):\n             pass\n \n         derived = Derived()\n         self.assertEqual(list(self._callFUT(derived)), [IDerived])\n \n         sup = super(Derived, derived)\n         self.assertEqual(list(self._callFUT(sup)), [])\n \n     def test_super_when_base_is_object(self):\n         from zope.interface import Interface\n         from zope.interface.declarations import implementer\n \n         class IBase(Interface):\n             pass\n \n         class IDerived(IBase):\n             pass\n \n         @implementer(IDerived)\n         class Derived(object):\n             pass\n \n         derived = Derived()\n         self.assertEqual(list(self._callFUT(derived)), [IDerived])\n \n         sup = super(Derived, derived)\n         fut = self._callFUT(sup)\n         self.assertIsNone(fut._dependents)\n         self.assertEqual(list(fut), [])\n \n     def test_super_when_object_directly_provides(self):\n         from zope.interface import Interface\n         from zope.interface.declarations import implementer\n         from zope.interface.declarations import directlyProvides\n \n         class IBase(Interface):\n             pass\n \n         class IDerived(IBase):\n             pass\n \n         @implementer(IBase)\n         class Base(object):\n             pass\n \n         class Derived(Base):\n             pass\n \n         derived = Derived()\n         self.assertEqual(list(self._callFUT(derived)), [IBase])\n \n         directlyProvides(derived, IDerived)\n         self.assertEqual(list(self._callFUT(derived)), [IDerived, IBase])\n \n         sup = super(Derived, derived)\n         fut = self._callFUT(sup)\n         self.assertIsNone(fut._dependents)\n         self.assertEqual(list(fut), [IBase])\n \n     def test_super_multi_level_multi_inheritance(self):\n         from zope.interface.declarations import implementer\n         from zope.interface import Interface\n \n         class IBase(Interface):\n             pass\n \n         class IM1(Interface):\n             pass\n \n         class IM2(Interface):\n             pass\n \n         class IDerived(IBase):\n             pass\n \n         class IUnrelated(Interface):\n             pass\n \n         @implementer(IBase)\n         class Base(object):\n             pass\n \n         @implementer(IM1)\n         class M1(Base):\n             pass\n \n         @implementer(IM2)\n         class M2(Base):\n             pass\n \n         @implementer(IDerived, IUnrelated)\n         class Derived(M1, M2):\n             pass\n \n         d = Derived()\n         sd = super(Derived, d)\n         sm1 = super(M1, d)\n         sm2 = super(M2, d)\n \n         self.assertEqual(list(self._callFUT(d)),\n                          [IDerived, IUnrelated, IM1, IBase, IM2])\n         self.assertEqual(list(self._callFUT(sd)),\n                          [IM1, IBase, IM2])\n         self.assertEqual(list(self._callFUT(sm1)),\n                          [IM2, IBase])\n         self.assertEqual(list(self._callFUT(sm2)),\n                          [IBase])\n \n     def test_catches_only_AttributeError_on_providedBy(self):\n         MissingSomeAttrs.test_raises(self, self._callFUT,\n                                      expected_missing='__providedBy__',\n                                      __class__=object)\n \n     def test_catches_only_AttributeError_on_class(self):\n         # isinstance() tries to get the __class__, which is non-obvious,\n         # so it must be protected too.\n         PY3 = str is not bytes\n         MissingSomeAttrs.test_raises(self, self._callFUT,\n                                      expected_missing='__class__' if PY3 else '__providedBy__')\n \n \n \n class Test_providedBy(Test_providedByFallback,\n                       OptimizationTestMixin):\n     # Repeat tests for C optimizations\n \n     def _getTargetClass(self):\n         from zope.interface.declarations import providedBy\n         return providedBy\n \n \n class ObjectSpecificationDescriptorFallbackTests(unittest.TestCase):\n \n     def _getFallbackClass(self):\n         # pylint:disable=no-name-in-module\n         from zope.interface.declarations \\\n             import ObjectSpecificationDescriptorFallback\n         return ObjectSpecificationDescriptorFallback\n \n     _getTargetClass = _getFallbackClass\n \n     def _makeOne(self, *args, **kw):\n         return self._getTargetClass()(*args, **kw)\n \n     def test_accessed_via_class(self):\n         from zope.interface.declarations import Provides\n         from zope.interface.interface import InterfaceClass\n         IFoo = InterfaceClass(\"IFoo\")\n         class Foo(object):\n             pass\n         Foo.__provides__ = Provides(Foo, IFoo)\n         Foo.__providedBy__ = self._makeOne()\n         self.assertEqual(list(Foo.__providedBy__), [IFoo])\n \n     def test_accessed_via_inst_wo_provides(self):\n         from zope.interface.declarations import implementer\n         from zope.interface.declarations import Provides\n         from zope.interface.interface import InterfaceClass\n         IFoo = InterfaceClass(\"IFoo\")\n         IBar = InterfaceClass(\"IBar\")\n         @implementer(IFoo)\n         class Foo(object):\n             pass\n         Foo.__provides__ = Provides(Foo, IBar)\n         Foo.__providedBy__ = self._makeOne()\n         foo = Foo()\n         self.assertEqual(list(foo.__providedBy__), [IFoo])\n \n     def test_accessed_via_inst_w_provides(self):\n         from zope.interface.declarations import directlyProvides\n         from zope.interface.declarations import implementer\n         from zope.interface.declarations import Provides\n         from zope.interface.interface import InterfaceClass\n         IFoo = InterfaceClass(\"IFoo\")\n         IBar = InterfaceClass(\"IBar\")\n         IBaz = InterfaceClass(\"IBaz\")\n         @implementer(IFoo)\n         class Foo(object):\n             pass\n         Foo.__provides__ = Provides(Foo, IBar)\n         Foo.__providedBy__ = self._makeOne()\n         foo = Foo()\n         directlyProvides(foo, IBaz)\n         self.assertEqual(list(foo.__providedBy__), [IBaz, IFoo])\n \n \n class ObjectSpecificationDescriptorTests(\n         ObjectSpecificationDescriptorFallbackTests,\n         OptimizationTestMixin):\n     # Repeat tests for C optimizations\n \n     def _getTargetClass(self):\n         from zope.interface.declarations import ObjectSpecificationDescriptor\n         return ObjectSpecificationDescriptor\n \n \n # Test _normalizeargs through its callers.\n \n \n class _Monkey(object):\n     # context-manager for replacing module names in the scope of a test.\n     def __init__(self, module, **kw):\n         self.module = module\n         self.to_restore = {key: getattr(module, key) for key in kw}\n         for key, value in kw.items():\n             setattr(module, key, value)\n \n     def __enter__(self):\n         return self\n \n     def __exit__(self, exc_type, exc_val, exc_tb):\n         for key, value in self.to_restore.items():\n             setattr(self.module, key, value)\n \n \n class _MonkeyDict(object):\n     # context-manager for restoring a dict w/in a module in the scope of a test.\n     def __init__(self, module, attrname, **kw):\n         self.module = module\n         self.target = getattr(module, attrname)\n         self.to_restore = self.target.copy()\n         self.target.clear()\n         self.target.update(kw)\n \n     def __enter__(self):\n         return self.target\n \n     def __exit__(self, exc_type, exc_val, exc_tb):\n         self.target.clear()\n         self.target.update(self.to_restore)\n ", "input_code": "def _getTargetClass(self):\n\"\"\"\nDefine this to return the implementation in use,\nwithout the 'Py' or 'Fallback' suffix.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def _getTargetClass(self):\n        from zope.interface.declarations import getObjectSpecification\n        return getObjectSpecification", "signature": "def _getTargetClass(self):", "completion_path": "src/zope/interface/tests/test_declarations.py"}
{"ce_id": "62b8b590eb7e40a82d2d1275", "namespace": "62b8b590eb7e40a82d2d1275", "namespace_real": "src.zope.interface.ro._legacy_mergeOrderings", "real_proj_path": "pexip---os-zope/", "type": "function", "class_name": null, "function_name": "_legacy_mergeOrderings", "contexts_above": "##############################################################################\n#\n# Copyright (c) 2003 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"\nCompute a resolution order for an object and its bases.\n\n.. versionchanged:: 5.0\n   The resolution order is now based on the same C3 order that Python\n   uses for classes. In complex instances of multiple inheritance, this\n   may result in a different ordering.\n\n   In older versions, the ordering wasn't required to be C3 compliant,\n   and for backwards compatibility, it still isn't. If the ordering\n   isn't C3 compliant (if it is *inconsistent*), zope.interface will\n   make a best guess to try to produce a reasonable resolution order.\n   Still (just as before), the results in such cases may be\n   surprising.\n\n.. rubric:: Environment Variables\n\nDue to the change in 5.0, certain environment variables can be used to control errors\nand warnings about inconsistent resolution orders. They are listed in priority order, with\nvariables at the bottom generally overriding variables above them.\n\nZOPE_INTERFACE_WARN_BAD_IRO\n    If this is set to \"1\", then if there is at least one inconsistent resolution\n    order discovered, a warning (:class:`InconsistentResolutionOrderWarning`) will\n    be issued. Use the usual warning mechanisms to control this behaviour. The warning\n    text will contain additional information on debugging.\nZOPE_INTERFACE_TRACK_BAD_IRO\n    If this is set to \"1\", then zope.interface will log information about each\n    inconsistent resolution order discovered, and keep those details in memory in this module\n    for later inspection.\nZOPE_INTERFACE_STRICT_IRO\n    If this is set to \"1\", any attempt to use :func:`ro` that would produce a non-C3\n    ordering will fail by raising :class:`InconsistentResolutionOrderError`.\n\nThere are two environment variables that are independent.\n\nZOPE_INTERFACE_LOG_CHANGED_IRO\n    If this is set to \"1\", then if the C3 resolution order is different from\n    the legacy resolution order for any given object, a message explaining the differences\n    will be logged. This is intended to be used for debugging complicated IROs.\nZOPE_INTERFACE_USE_LEGACY_IRO\n    If this is set to \"1\", then the C3 resolution order will *not* be used. The\n    legacy IRO will be used instead. This is a temporary measure and will be removed in the\n    future. It is intended to help during the transition.\n    It implies ``ZOPE_INTERFACE_LOG_CHANGED_IRO``.\n\"\"\"\nfrom __future__ import print_function\n__docformat__ = 'restructuredtext'\n\n__all__ = [\n    'ro',\n    'InconsistentResolutionOrderError',\n    'InconsistentResolutionOrderWarning',\n]\n\n__logger = None\n\ndef _logger():\n    global __logger # pylint:disable=global-statement\n    if __logger is None:\n        import logging\n        __logger = logging.getLogger(__name__)\n    return __logger\n", "contexts_below": "def _legacy_flatten(begin):\n     result = [begin]\n     i = 0\n     for ob in iter(result):\n         i += 1\n         # The recursive calls can be avoided by inserting the base classes\n         # into the dynamically growing list directly after the currently\n         # considered object;  the iterator makes sure this will keep working\n         # in the future, since it cannot rely on the length of the list\n         # by definition.\n         result[i:i] = ob.__bases__\n     return result\n \n def _legacy_ro(ob):\n     return _legacy_mergeOrderings([_legacy_flatten(ob)])\n \n ###\n # Compare base objects using identity, not equality. This matches what\n # the CPython MRO algorithm does, and is *much* faster to boot: that,\n # plus some other small tweaks makes the difference between 25s and 6s\n # in loading 446 plone/zope interface.py modules (1925 InterfaceClass,\n # 1200 Implements, 1100 ClassProvides objects)\n ###\n \n \n class InconsistentResolutionOrderWarning(PendingDeprecationWarning):\n     \"\"\"\n     The warning issued when an invalid IRO is requested.\n     \"\"\"\n \n class InconsistentResolutionOrderError(TypeError):\n     \"\"\"\n     The error raised when an invalid IRO is requested in strict mode.\n     \"\"\"\n \n     def __init__(self, c3, base_tree_remaining):\n         self.C = c3.leaf\n         base_tree = c3.base_tree\n         self.base_ros = {\n             base: base_tree[i + 1]\n             for i, base in enumerate(self.C.__bases__)\n         }\n         # Unfortunately, this doesn't necessarily directly match\n         # up to any transformation on C.__bases__, because\n         # if any were fully used up, they were removed already.\n         self.base_tree_remaining = base_tree_remaining\n \n         TypeError.__init__(self)\n \n     def __str__(self):\n         import pprint\n         return \"%s: For object %r.\\nBase ROs:\\n%s\\nConflict Location:\\n%s\" % (\n             self.__class__.__name__,\n             self.C,\n             pprint.pformat(self.base_ros),\n             pprint.pformat(self.base_tree_remaining),\n         )\n \n \n class _NamedBool(int): # cannot actually inherit bool\n \n     def __new__(cls, val, name):\n         inst = super(cls, _NamedBool).__new__(cls, val)\n         inst.__name__ = name\n         return inst\n \n \n class _ClassBoolFromEnv(object):\n     \"\"\"\n     Non-data descriptor that reads a transformed environment variable\n     as a boolean, and caches the result in the class.\n     \"\"\"\n \n     def __get__(self, inst, klass):\n         import os\n         for cls in klass.__mro__:\n             my_name = None\n             for k in dir(klass):\n                 if k in cls.__dict__ and cls.__dict__[k] is self:\n                     my_name = k\n                     break\n             if my_name is not None:\n                 break\n         else: # pragma: no cover\n             raise RuntimeError(\"Unable to find self\")\n \n         env_name = 'ZOPE_INTERFACE_' + my_name\n         val = os.environ.get(env_name, '') == '1'\n         val = _NamedBool(val, my_name)\n         setattr(klass, my_name, val)\n         setattr(klass, 'ORIG_' + my_name, self)\n         return val\n \n \n class _StaticMRO(object):\n     # A previously resolved MRO, supplied by the caller.\n     # Used in place of calculating it.\n \n     had_inconsistency = None # We don't know...\n \n     def __init__(self, C, mro):\n         self.leaf = C\n         self.__mro = tuple(mro)\n \n     def mro(self):\n         return list(self.__mro)\n \n \n class C3(object):\n     # Holds the shared state during computation of an MRO.\n \n     @staticmethod\n     def resolver(C, strict, base_mros):\n         strict = strict if strict is not None else C3.STRICT_IRO\n         factory = C3\n         if strict:\n             factory = _StrictC3\n         elif C3.TRACK_BAD_IRO:\n             factory = _TrackingC3\n \n         memo = {}\n         base_mros = base_mros or {}\n         for base, mro in base_mros.items():\n             assert base in C.__bases__\n             memo[base] = _StaticMRO(base, mro)\n \n         return factory(C, memo)\n \n     __mro = None\n     __legacy_ro = None\n     direct_inconsistency = False\n \n     def __init__(self, C, memo):\n         self.leaf = C\n         self.memo = memo\n         kind = self.__class__\n \n         base_resolvers = []\n         for base in C.__bases__:\n             if base not in memo:\n                 resolver = kind(base, memo)\n                 memo[base] = resolver\n             base_resolvers.append(memo[base])\n \n         self.base_tree = [\n             [C]\n         ] + [\n             memo[base].mro() for base in C.__bases__\n         ] + [\n             list(C.__bases__)\n         ]\n \n         self.bases_had_inconsistency = any(base.had_inconsistency for base in base_resolvers)\n \n         if len(C.__bases__) == 1:\n             self.__mro = [C] + memo[C.__bases__[0]].mro()\n \n     @property\n     def had_inconsistency(self):\n         return self.direct_inconsistency or self.bases_had_inconsistency\n \n     @property\n     def legacy_ro(self):\n         if self.__legacy_ro is None:\n             self.__legacy_ro = tuple(_legacy_ro(self.leaf))\n         return list(self.__legacy_ro)\n \n     TRACK_BAD_IRO = _ClassBoolFromEnv()\n     STRICT_IRO = _ClassBoolFromEnv()\n     WARN_BAD_IRO = _ClassBoolFromEnv()\n     LOG_CHANGED_IRO = _ClassBoolFromEnv()\n     USE_LEGACY_IRO = _ClassBoolFromEnv()\n     BAD_IROS = ()\n \n     def _warn_iro(self):\n         if not self.WARN_BAD_IRO:\n             # For the initial release, one must opt-in to see the warning.\n             # In the future (2021?) seeing at least the first warning will\n             # be the default\n             return\n         import warnings\n         warnings.warn(\n             \"An inconsistent resolution order is being requested. \"\n             \"(Interfaces should follow the Python class rules known as C3.) \"\n             \"For backwards compatibility, zope.interface will allow this, \"\n             \"making the best guess it can to produce as meaningful an order as possible. \"\n             \"In the future this might be an error. Set the warning filter to error, or set \"\n             \"the environment variable 'ZOPE_INTERFACE_TRACK_BAD_IRO' to '1' and examine \"\n             \"ro.C3.BAD_IROS to debug, or set 'ZOPE_INTERFACE_STRICT_IRO' to raise exceptions.\",\n             InconsistentResolutionOrderWarning,\n         )\n \n     @staticmethod\n     def _can_choose_base(base, base_tree_remaining):\n         # From C3:\n         # nothead = [s for s in nonemptyseqs if cand in s[1:]]\n         for bases in base_tree_remaining:\n             if not bases or bases[0] is base:\n                 continue\n \n             for b in bases:\n                 if b is base:\n                     return False\n         return True\n \n     @staticmethod\n     def _nonempty_bases_ignoring(base_tree, ignoring):\n         return list(filter(None, [\n             [b for b in bases if b is not ignoring]\n             for bases\n             in base_tree\n         ]))\n \n     def _choose_next_base(self, base_tree_remaining):\n         \"\"\"\n         Return the next base.\n \n         The return value will either fit the C3 constraints or be our best\n         guess about what to do. If we cannot guess, this may raise an exception.\n         \"\"\"\n         base = self._find_next_C3_base(base_tree_remaining)\n         if base is not None:\n             return base\n         return self._guess_next_base(base_tree_remaining)\n \n     def _find_next_C3_base(self, base_tree_remaining):\n         \"\"\"\n         Return the next base that fits the constraints, or ``None`` if there isn't one.\n         \"\"\"\n         for bases in base_tree_remaining:\n             base = bases[0]\n             if self._can_choose_base(base, base_tree_remaining):\n                 return base\n         return None\n \n     class _UseLegacyRO(Exception):\n         pass\n \n     def _guess_next_base(self, base_tree_remaining):\n         # Narf. We may have an inconsistent order (we won't know for\n         # sure until we check all the bases). Python cannot create\n         # classes like this:\n         #\n         # class B1:\n         #   pass\n         # class B2(B1):\n         #   pass\n         # class C(B1, B2): # -> TypeError; this is like saying C(B1, B2, B1).\n         #  pass\n         #\n         # However, older versions of zope.interface were fine with this order.\n         # A good example is ``providedBy(IOError())``. Because of the way\n         # ``classImplements`` works, it winds up with ``__bases__`` ==\n         # ``[IEnvironmentError, IIOError, IOSError, <implementedBy Exception>]``\n         # (on Python 3). But ``IEnvironmentError`` is a base of both ``IIOError``\n         # and ``IOSError``. Previously, we would get a resolution order of\n         # ``[IIOError, IOSError, IEnvironmentError, IStandardError, IException, Interface]``\n         # but the standard Python algorithm would forbid creating that order entirely.\n \n         # Unlike Python's MRO, we attempt to resolve the issue. A few\n         # heuristics have been tried. One was:\n         #\n         # Strip off the first (highest priority) base of each direct\n         # base one at a time and seeing if we can come to an agreement\n         # with the other bases. (We're trying for a partial ordering\n         # here.) This often resolves cases (such as the IOSError case\n         # above), and frequently produces the same ordering as the\n         # legacy MRO did. If we looked at all the highest priority\n         # bases and couldn't find any partial ordering, then we strip\n         # them *all* out and begin the C3 step again. We take care not\n         # to promote a common root over all others.\n         #\n         # If we only did the first part, stripped off the first\n         # element of the first item, we could resolve simple cases.\n         # But it tended to fail badly. If we did the whole thing, it\n         # could be extremely painful from a performance perspective\n         # for deep/wide things like Zope's OFS.SimpleItem.Item. Plus,\n         # anytime you get ExtensionClass.Base into the mix, you're\n         # likely to wind up in trouble, because it messes with the MRO\n         # of classes. Sigh.\n         #\n         # So now, we fall back to the old linearization (fast to compute).\n         self._warn_iro()\n         self.direct_inconsistency = InconsistentResolutionOrderError(self, base_tree_remaining)\n         raise self._UseLegacyRO\n \n     def _merge(self):\n         # Returns a merged *list*.\n         result = self.__mro = []\n         base_tree_remaining = self.base_tree\n         base = None\n         while 1:\n             # Take last picked base out of the base tree wherever it is.\n             # This differs slightly from the standard Python MRO and is needed\n             # because we have no other step that prevents duplicates\n             # from coming in (e.g., in the inconsistent fallback path)\n             base_tree_remaining = self._nonempty_bases_ignoring(base_tree_remaining, base)\n \n             if not base_tree_remaining:\n                 return result\n             try:\n                 base = self._choose_next_base(base_tree_remaining)\n             except self._UseLegacyRO:\n                 self.__mro = self.legacy_ro\n                 return self.legacy_ro\n \n             result.append(base)\n \n     def mro(self):\n         if self.__mro is None:\n             self.__mro = tuple(self._merge())\n         return list(self.__mro)\n \n \n class _StrictC3(C3):\n     __slots__ = ()\n     def _guess_next_base(self, base_tree_remaining):\n         raise InconsistentResolutionOrderError(self, base_tree_remaining)\n \n \n class _TrackingC3(C3):\n     __slots__ = ()\n     def _guess_next_base(self, base_tree_remaining):\n         import traceback\n         bad_iros = C3.BAD_IROS\n         if self.leaf not in bad_iros:\n             if bad_iros == ():\n                 import weakref\n                 # This is a race condition, but it doesn't matter much.\n                 bad_iros = C3.BAD_IROS = weakref.WeakKeyDictionary()\n             bad_iros[self.leaf] = t = (\n                 InconsistentResolutionOrderError(self, base_tree_remaining),\n                 traceback.format_stack()\n             )\n             _logger().warning(\"Tracking inconsistent IRO: %s\", t[0])\n         return C3._guess_next_base(self, base_tree_remaining)\n \n \n class _ROComparison(object):\n     # Exists to compute and print a pretty string comparison\n     # for differing ROs.\n     # Since we're used in a logging context, and may actually never be printed,\n     # this is a class so we can defer computing the diff until asked.\n \n     # Components we use to build up the comparison report\n     class Item(object):\n         prefix = '  '\n         def __init__(self, item):\n             self.item = item\n         def __str__(self):\n             return \"%s%s\" % (\n                 self.prefix,\n                 self.item,\n             )\n \n     class Deleted(Item):\n         prefix = '- '\n \n     class Inserted(Item):\n         prefix = '+ '\n \n     Empty = str\n \n     class ReplacedBy(object): # pragma: no cover\n         prefix = '- '\n         suffix = ''\n         def __init__(self, chunk, total_count):\n             self.chunk = chunk\n             self.total_count = total_count\n \n         def __iter__(self):\n             lines = [\n                 self.prefix + str(item) + self.suffix\n                 for item in self.chunk\n             ]\n             while len(lines) < self.total_count:\n                 lines.append('')\n \n             return iter(lines)\n \n     class Replacing(ReplacedBy):\n         prefix = \"+ \"\n         suffix = ''\n \n \n     _c3_report = None\n     _legacy_report = None\n \n     def __init__(self, c3, c3_ro, legacy_ro):\n         self.c3 = c3\n         self.c3_ro = c3_ro\n         self.legacy_ro = legacy_ro\n \n     def __move(self, from_, to_, chunk, operation):\n         for x in chunk:\n             to_.append(operation(x))\n             from_.append(self.Empty())\n \n     def _generate_report(self):\n         if self._c3_report is None:\n             import difflib\n             # The opcodes we get describe how to turn 'a' into 'b'. So\n             # the old one (legacy) needs to be first ('a')\n             matcher = difflib.SequenceMatcher(None, self.legacy_ro, self.c3_ro)\n             # The reports are equal length sequences. We're going for a\n             # side-by-side diff.\n             self._c3_report = c3_report = []\n             self._legacy_report = legacy_report = []\n             for opcode, leg1, leg2, c31, c32 in matcher.get_opcodes():\n                 c3_chunk = self.c3_ro[c31:c32]\n                 legacy_chunk = self.legacy_ro[leg1:leg2]\n \n                 if opcode == 'equal':\n                     # Guaranteed same length\n                     c3_report.extend((self.Item(x) for x in c3_chunk))\n                     legacy_report.extend(self.Item(x) for x in legacy_chunk)\n                 if opcode == 'delete':\n                     # Guaranteed same length\n                     assert not c3_chunk\n                     self.__move(c3_report, legacy_report, legacy_chunk, self.Deleted)\n                 if opcode == 'insert':\n                     # Guaranteed same length\n                     assert not legacy_chunk\n                     self.__move(legacy_report, c3_report, c3_chunk, self.Inserted)\n                 if opcode == 'replace': # pragma: no cover (How do you make it output this?)\n                     # Either side could be longer.\n                     chunk_size = max(len(c3_chunk), len(legacy_chunk))\n                     c3_report.extend(self.Replacing(c3_chunk, chunk_size))\n                     legacy_report.extend(self.ReplacedBy(legacy_chunk, chunk_size))\n \n         return self._c3_report, self._legacy_report\n \n     @property\n     def _inconsistent_label(self):\n         inconsistent = []\n         if self.c3.direct_inconsistency:\n             inconsistent.append('direct')\n         if self.c3.bases_had_inconsistency:\n             inconsistent.append('bases')\n         return '+'.join(inconsistent) if inconsistent else 'no'\n \n     def __str__(self):\n         c3_report, legacy_report = self._generate_report()\n         assert len(c3_report) == len(legacy_report)\n \n         left_lines = [str(x) for x in legacy_report]\n         right_lines = [str(x) for x in c3_report]\n \n         # We have the same number of lines in the report; this is not\n         # necessarily the same as the number of items in either RO.\n         assert len(left_lines) == len(right_lines)\n \n         padding = ' ' * 2\n         max_left = max(len(x) for x in left_lines)\n         max_right = max(len(x) for x in right_lines)\n \n         left_title = 'Legacy RO (len=%s)' % (len(self.legacy_ro),)\n \n         right_title = 'C3 RO (len=%s; inconsistent=%s)' % (\n             len(self.c3_ro),\n             self._inconsistent_label,\n         )\n         lines = [\n             (padding + left_title.ljust(max_left) + padding + right_title.ljust(max_right)),\n             padding + '=' * (max_left + len(padding) + max_right)\n         ]\n         lines += [\n             padding + left.ljust(max_left) + padding + right\n             for left, right in zip(left_lines, right_lines)\n         ]\n \n         return '\\n'.join(lines)\n \n \n # Set to `Interface` once it is defined. This is used to\n # avoid logging false positives about changed ROs.\n _ROOT = None\n \n def ro(C, strict=None, base_mros=None, log_changed_ro=None, use_legacy_ro=None):\n     \"\"\"\n     ro(C) -> list\n \n     Compute the precedence list (mro) according to C3.\n \n     :return: A fresh `list` object.\n \n     .. versionchanged:: 5.0.0\n        Add the *strict*, *log_changed_ro* and *use_legacy_ro*\n        keyword arguments. These are provisional and likely to be\n        removed in the future. They are most useful for testing.\n     \"\"\"\n     # The ``base_mros`` argument is for internal optimization and\n     # not documented.\n     resolver = C3.resolver(C, strict, base_mros)\n     mro = resolver.mro()\n \n     log_changed = log_changed_ro if log_changed_ro is not None else resolver.LOG_CHANGED_IRO\n     use_legacy = use_legacy_ro if use_legacy_ro is not None else resolver.USE_LEGACY_IRO\n \n     if log_changed or use_legacy:\n         legacy_ro = resolver.legacy_ro\n         assert isinstance(legacy_ro, list)\n         assert isinstance(mro, list)\n         changed = legacy_ro != mro\n         if changed:\n             # Did only Interface move? The fix for issue #8 made that\n             # somewhat common. It's almost certainly not a problem, though,\n             # so allow ignoring it.\n             legacy_without_root = [x for x in legacy_ro if x is not _ROOT]\n             mro_without_root = [x for x in mro if x is not _ROOT]\n             changed = legacy_without_root != mro_without_root\n \n         if changed:\n             comparison = _ROComparison(resolver, mro, legacy_ro)\n             _logger().warning(\n                 \"Object %r has different legacy and C3 MROs:\\n%s\",\n                 C, comparison\n             )\n         if resolver.had_inconsistency and legacy_ro == mro:\n             comparison = _ROComparison(resolver, mro, legacy_ro)\n             _logger().warning(\n                 \"Object %r had inconsistent IRO and used the legacy RO:\\n%s\"\n                 \"\\nInconsistency entered at:\\n%s\",\n                 C, comparison, resolver.direct_inconsistency\n             )\n         if use_legacy:\n             return legacy_ro\n \n     return mro\n \n \n def is_consistent(C):\n     \"\"\"\n     Check if the resolution order for *C*, as computed by :func:`ro`, is consistent\n     according to C3.\n     \"\"\"\n     return not C3.resolver(C, False, None).had_inconsistency\n ", "input_code": "def _legacy_mergeOrderings(orderings):\n\"\"\"\nMerge multiple orderings so that within-ordering order is preserved\n\nOrderings are constrained in such a way that if an object appears\nin two or more orderings, then the suffix that begins with the\nobject must be in both orderings.\n\nFor example:\n\n>>> _mergeOrderings([\n... ['x', 'y', 'z'],\n... ['q', 'z'],\n... [1, 3, 5],\n... ['z']\n... ])\n['x', 'y', 'q', 1, 3, 5, 'z']\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _legacy_mergeOrderings(orderings):\n    \"\"\"Merge multiple orderings so that within-ordering order is preserved\n\n    Orderings are constrained in such a way that if an object appears\n    in two or more orderings, then the suffix that begins with the\n    object must be in both orderings.\n\n    For example:\n\n    >>> _mergeOrderings([\n    ... ['x', 'y', 'z'],\n    ... ['q', 'z'],\n    ... [1, 3, 5],\n    ... ['z']\n    ... ])\n    ['x', 'y', 'q', 1, 3, 5, 'z']\n\n    \"\"\"\n\n    seen = set()\n    result = []\n    for ordering in reversed(orderings):\n        for o in reversed(ordering):\n            if o not in seen:\n                seen.add(o)\n                result.insert(0, o)\n\n    return result", "signature": "def _legacy_mergeOrderings(orderings):", "completion_path": "src/zope/interface/ro.py"}
{"ce_id": "62b8b58deb7e40a82d2d1269", "namespace": "62b8b58deb7e40a82d2d1269", "namespace_real": "src.zope.interface.declarations.directlyProvidedBy", "real_proj_path": "pexip---os-zope/", "type": "function", "class_name": null, "function_name": "directlyProvidedBy", "contexts_above": "##############################################################################\n# Copyright (c) 2003 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n##############################################################################\n\"\"\"Implementation of interface declarations\n\nThere are three flavors of declarations:\n\n  - Declarations are used to simply name declared interfaces.\n\n  - ImplementsDeclarations are used to express the interfaces that a\n    class implements (that instances of the class provides).\n\n    Implements specifications support inheriting interfaces.\n\n  - ProvidesDeclarations are used to express interfaces directly\n    provided by objects.\n\n\"\"\"\n__docformat__ = 'restructuredtext'\n\nimport sys\nfrom types import FunctionType\nfrom types import MethodType\nfrom types import ModuleType\nimport weakref\n\nfrom zope.interface.advice import addClassAdvisor\nfrom zope.interface.interface import Interface\nfrom zope.interface.interface import InterfaceClass\nfrom zope.interface.interface import SpecificationBase\nfrom zope.interface.interface import Specification\nfrom zope.interface.interface import NameAndModuleComparisonMixin\nfrom zope.interface._compat import CLASS_TYPES as DescriptorAwareMetaClasses\nfrom zope.interface._compat import PYTHON3\nfrom zope.interface._compat import _use_c_impl\n\n__all__ = [\n    # None. The public APIs of this module are\n    # re-exported from zope.interface directly.\n]\n\n# pylint:disable=too-many-lines\n\n# Registry of class-implementation specifications\nBuiltinImplementationSpecifications = {}\n\n_ADVICE_ERROR = ('Class advice impossible in Python3.  '\n                 'Use the @%s class decorator instead.')\n\n_ADVICE_WARNING = ('The %s API is deprecated, and will not work in Python3  '\n                   'Use the @%s class decorator instead.')\n\ndef _next_super_class(ob):\n    # When ``ob`` is an instance of ``super``, return\n    # the next class in the MRO that we should actually be\n    # looking at. Watch out for diamond inheritance!\n    self_class = ob.__self_class__\n    class_that_invoked_super = ob.__thisclass__\n    complete_mro = self_class.__mro__\n    next_class = complete_mro[complete_mro.index(class_that_invoked_super) + 1]\n    return next_class\n\nclass named(object):\n\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self, ob):\n        ob.__component_name__ = self.name\n        return ob\n\n\nclass Declaration(Specification):\n    \"\"\"Interface declarations\"\"\"\n\n    __slots__ = ()\n\n    def __init__(self, *bases):\n        Specification.__init__(self, _normalizeargs(bases))\n\n    def __contains__(self, interface):\n        \"\"\"Test whether an interface is in the specification\n        \"\"\"\n\n        return self.extends(interface) and interface in self.interfaces()\n\n    def __iter__(self):\n        \"\"\"Return an iterator for the interfaces in the specification\n        \"\"\"\n        return self.interfaces()\n\n    def flattened(self):\n        \"\"\"Return an iterator of all included and extended interfaces\n        \"\"\"\n        return iter(self.__iro__)\n\n    def __sub__(self, other):\n        \"\"\"Remove interfaces from a specification\n        \"\"\"\n        return Declaration(*[\n            i for i in self.interfaces()\n            if not [\n                j\n                for j in other.interfaces()\n                if i.extends(j, 0) # non-strict extends\n            ]\n        ])\n\n    def __add__(self, other):\n        \"\"\"Add two specifications or a specification and an interface\n        \"\"\"\n        seen = {}\n        result = []\n        for i in self.interfaces():\n            seen[i] = 1\n            result.append(i)\n        for i in other.interfaces():\n            if i not in seen:\n                seen[i] = 1\n                result.append(i)\n\n        return Declaration(*result)\n\n    __radd__ = __add__\n\n\nclass _ImmutableDeclaration(Declaration):\n    # A Declaration that is immutable. Used as a singleton to\n    # return empty answers for things like ``implementedBy``.\n    # We have to define the actual singleton after normalizeargs\n    # is defined, and that in turn is defined after InterfaceClass and\n    # Implements.\n\n    __slots__ = ()\n\n    __instance = None\n\n    def __new__(cls):\n        if _ImmutableDeclaration.__instance is None:\n            _ImmutableDeclaration.__instance = object.__new__(cls)\n        return _ImmutableDeclaration.__instance\n\n    def __reduce__(self):\n        return \"_empty\"\n\n    @property\n    def __bases__(self):\n        return ()\n\n    @__bases__.setter\n    def __bases__(self, new_bases):\n        # We expect the superclass constructor to set ``self.__bases__ = ()``.\n        # Rather than attempt to special case that in the constructor and allow\n        # setting __bases__ only at that time, it's easier to just allow setting\n        # the empty tuple at any time. That makes ``x.__bases__ = x.__bases__`` a nice\n        # no-op too. (Skipping the superclass constructor altogether is a recipe\n        # for maintenance headaches.)\n        if new_bases != ():\n            raise TypeError(\"Cannot set non-empty bases on shared empty Declaration.\")\n\n    # As the immutable empty declaration, we cannot be changed.\n    # This means there's no logical reason for us to have dependents\n    # or subscriptions: we'll never notify them. So there's no need for\n    # us to keep track of any of that.\n    @property\n    def dependents(self):\n        return {}\n\n    changed = subscribe = unsubscribe = lambda self, _ignored: None\n\n    def interfaces(self):\n        # An empty iterator\n        return iter(())\n\n    def extends(self, interface, strict=True):\n        return interface is self._ROOT\n\n    def get(self, name, default=None):\n        return default\n\n    def weakref(self, callback=None):\n        # We're a singleton, we never go away. So there's no need to return\n        # distinct weakref objects here; their callbacks will never\n        # be called. Instead, we only need to return a callable that\n        # returns ourself. The easiest one is to return _ImmutableDeclaration\n        # itself; testing on Python 3.8 shows that's faster than a function that\n        # returns _empty. (Remember, one goal is to avoid allocating any\n        # object, and that includes a method.)\n        return _ImmutableDeclaration\n\n    @property\n    def _v_attrs(self):\n        # _v_attrs is not a public, documented property, but some client\n        # code uses it anyway as a convenient place to cache things. To keep\n        # the empty declaration truly immutable, we must ignore that. That includes\n        # ignoring assignments as well.\n        return {}\n\n    @_v_attrs.setter\n    def _v_attrs(self, new_attrs):\n        pass\n\n\n##############################################################################\n#\n# Implementation specifications\n#\n# These specify interfaces implemented by instances of classes\n\nclass Implements(NameAndModuleComparisonMixin,\n                 Declaration):\n    # Inherit from NameAndModuleComparisonMixin to be\n    # mutually comparable with InterfaceClass objects.\n    # (The two must be mutually comparable to be able to work in e.g., BTrees.)\n    # Instances of this class generally don't have a __module__ other than\n    # `zope.interface.declarations`, whereas they *do* have a __name__ that is the\n    # fully qualified name of the object they are representing.\n\n    # Note, though, that equality and hashing are still identity based. This\n    # accounts for things like nested objects that have the same name (typically\n    # only in tests) and is consistent with pickling. As far as comparisons to InterfaceClass\n    # goes, we'll never have equal name and module to those, so we're still consistent there.\n    # Instances of this class are essentially intended to be unique and are\n    # heavily cached (note how our __reduce__ handles this) so having identity\n    # based hash and eq should also work.\n\n    # We want equality and hashing to be based on identity. However, we can't actually\n    # implement __eq__/__ne__ to do this because sometimes we get wrapped in a proxy.\n    # We need to let the proxy types implement these methods so they can handle unwrapping\n    # and then rely on: (1) the interpreter automatically changing `implements == proxy` into\n    # `proxy == implements` (which will call proxy.__eq__ to do the unwrapping) and then\n    # (2) the default equality and hashing semantics being identity based.\n\n    # class whose specification should be used as additional base\n    inherit = None\n\n    # interfaces actually declared for a class\n    declared = ()\n\n    # Weak cache of {class: <implements>} for super objects.\n    # Created on demand. These are rare, as of 5.0 anyway. Using a class\n    # level default doesn't take space in instances. Using _v_attrs would be\n    # another place to store this without taking space unless needed.\n    _super_cache = None\n\n    __name__ = '?'\n\n    @classmethod\n    def named(cls, name, *bases):\n        # Implementation method: Produce an Implements interface with\n        # a fully fleshed out __name__ before calling the constructor, which\n        # sets bases to the given interfaces and which may pass this object to\n        # other objects (e.g., to adjust dependents). If they're sorting or comparing\n        # by name, this needs to be set.\n        inst = cls.__new__(cls)\n        inst.__name__ = name\n        inst.__init__(*bases)\n        return inst\n\n    def changed(self, originally_changed):\n        try:\n            del self._super_cache\n        except AttributeError:\n            pass\n        return super(Implements, self).changed(originally_changed)\n\n    def __repr__(self):\n        return '<implementedBy %s>' % (self.__name__)\n\n    def __reduce__(self):\n        return implementedBy, (self.inherit, )\n\n\ndef _implements_name(ob):\n    # Return the __name__ attribute to be used by its __implemented__\n    # property.\n    # This must be stable for the \"same\" object across processes\n    # because it is used for sorting. It needn't be unique, though, in cases\n    # like nested classes named Foo created by different functions, because\n    # equality and hashing is still based on identity.\n    # It might be nice to use __qualname__ on Python 3, but that would produce\n    # different values between Py2 and Py3.\n    return (getattr(ob, '__module__', '?') or '?') + \\\n        '.' + (getattr(ob, '__name__', '?') or '?')\n\n\ndef _implementedBy_super(sup):\n    # TODO: This is now simple enough we could probably implement\n    # in C if needed.\n\n    # If the class MRO is strictly linear, we could just\n    # follow the normal algorithm for the next class in the\n    # search order (e.g., just return\n    # ``implemented_by_next``). But when diamond inheritance\n    # or mixins + interface declarations are present, we have\n    # to consider the whole MRO and compute a new Implements\n    # that excludes the classes being skipped over but\n    # includes everything else.\n    implemented_by_self = implementedBy(sup.__self_class__)\n    cache = implemented_by_self._super_cache # pylint:disable=protected-access\n    if cache is None:\n        cache = implemented_by_self._super_cache = weakref.WeakKeyDictionary()\n\n    key = sup.__thisclass__\n    try:\n        return cache[key]\n    except KeyError:\n        pass\n\n    next_cls = _next_super_class(sup)\n    # For ``implementedBy(cls)``:\n    # .__bases__ is .declared + [implementedBy(b) for b in cls.__bases__]\n    # .inherit is cls\n\n    implemented_by_next = implementedBy(next_cls)\n    mro = sup.__self_class__.__mro__\n    ix_next_cls = mro.index(next_cls)\n    classes_to_keep = mro[ix_next_cls:]\n    new_bases = [implementedBy(c) for c in classes_to_keep]\n\n    new = Implements.named(\n        implemented_by_self.__name__ + ':' + implemented_by_next.__name__,\n        *new_bases\n    )\n    new.inherit = implemented_by_next.inherit\n    new.declared = implemented_by_next.declared\n    # I don't *think* that new needs to subscribe to ``implemented_by_self``;\n    # it auto-subscribed to its bases, and that should be good enough.\n    cache[key] = new\n\n    return new\n\n\n@_use_c_impl\ndef implementedBy(cls): # pylint:disable=too-many-return-statements,too-many-branches\n    \"\"\"Return the interfaces implemented for a class' instances\n\n      The value returned is an `~zope.interface.interfaces.IDeclaration`.\n    \"\"\"\n    try:\n        if isinstance(cls, super):\n            # Yes, this needs to be inside the try: block. Some objects\n            # like security proxies even break isinstance.\n            return _implementedBy_super(cls)\n\n        spec = cls.__dict__.get('__implemented__')\n    except AttributeError:\n\n        # we can't get the class dict. This is probably due to a\n        # security proxy.  If this is the case, then probably no\n        # descriptor was installed for the class.\n\n        # We don't want to depend directly on zope.security in\n        # zope.interface, but we'll try to make reasonable\n        # accommodations in an indirect way.\n\n        # We'll check to see if there's an implements:\n\n        spec = getattr(cls, '__implemented__', None)\n        if spec is None:\n            # There's no spec stred in the class. Maybe its a builtin:\n            spec = BuiltinImplementationSpecifications.get(cls)\n            if spec is not None:\n                return spec\n            return _empty\n\n        if spec.__class__ == Implements:\n            # we defaulted to _empty or there was a spec. Good enough.\n            # Return it.\n            return spec\n\n        # TODO: need old style __implements__ compatibility?\n        # Hm, there's an __implemented__, but it's not a spec. Must be\n        # an old-style declaration. Just compute a spec for it\n        return Declaration(*_normalizeargs((spec, )))\n\n    if isinstance(spec, Implements):\n        return spec\n\n    if spec is None:\n        spec = BuiltinImplementationSpecifications.get(cls)\n        if spec is not None:\n            return spec\n\n    # TODO: need old style __implements__ compatibility?\n    spec_name = _implements_name(cls)\n    if spec is not None:\n        # old-style __implemented__ = foo declaration\n        spec = (spec, ) # tuplefy, as it might be just an int\n        spec = Implements.named(spec_name, *_normalizeargs(spec))\n        spec.inherit = None    # old-style implies no inherit\n        del cls.__implemented__ # get rid of the old-style declaration\n    else:\n        try:\n            bases = cls.__bases__\n        except AttributeError:\n            if not callable(cls):\n                raise TypeError(\"ImplementedBy called for non-factory\", cls)\n            bases = ()\n\n        spec = Implements.named(spec_name, *[implementedBy(c) for c in bases])\n        spec.inherit = cls\n\n    try:\n        cls.__implemented__ = spec\n        if not hasattr(cls, '__providedBy__'):\n            cls.__providedBy__ = objectSpecificationDescriptor\n\n        if (isinstance(cls, DescriptorAwareMetaClasses)\n                and '__provides__' not in cls.__dict__):\n            # Make sure we get a __provides__ descriptor\n            cls.__provides__ = ClassProvides(\n                cls,\n                getattr(cls, '__class__', type(cls)),\n                )\n\n    except TypeError:\n        if not isinstance(cls, type):\n            raise TypeError(\"ImplementedBy called for non-type\", cls)\n        BuiltinImplementationSpecifications[cls] = spec\n\n    return spec\n\n\ndef classImplementsOnly(cls, *interfaces):\n    \"\"\"\n    Declare the only interfaces implemented by instances of a class\n\n    The arguments after the class are one or more interfaces or interface\n    specifications (`~zope.interface.interfaces.IDeclaration` objects).\n\n    The interfaces given (including the interfaces in the specifications)\n    replace any previous declarations, *including* inherited definitions. If you\n    wish to preserve inherited declarations, you can pass ``implementedBy(cls)``\n    in *interfaces*. This can be used to alter the interface resolution order.\n    \"\"\"\n    spec = implementedBy(cls)\n    # Clear out everything inherited. It's important to\n    # also clear the bases right now so that we don't improperly discard\n    # interfaces that are already implemented by *old* bases that we're\n    # about to get rid of.\n    spec.declared = ()\n    spec.inherit = None\n    spec.__bases__ = ()\n    _classImplements_ordered(spec, interfaces, ())\n\n\ndef classImplements(cls, *interfaces):\n    \"\"\"\n    Declare additional interfaces implemented for instances of a class\n\n    The arguments after the class are one or more interfaces or\n    interface specifications (`~zope.interface.interfaces.IDeclaration` objects).\n\n    The interfaces given (including the interfaces in the specifications)\n    are added to any interfaces previously declared. An effort is made to\n    keep a consistent C3 resolution order, but this cannot be guaranteed.\n\n    .. versionchanged:: 5.0.0\n       Each individual interface in *interfaces* may be added to either the\n       beginning or end of the list of interfaces declared for *cls*,\n       based on inheritance, in order to try to maintain a consistent\n       resolution order. Previously, all interfaces were added to the end.\n    .. versionchanged:: 5.1.0\n       If *cls* is already declared to implement an interface (or derived interface)\n       in *interfaces* through inheritance, the interface is ignored. Previously, it\n       would redundantly be made direct base of *cls*, which often produced inconsistent\n       interface resolution orders. Now, the order will be consistent, but may change.\n       Also, if the ``__bases__`` of the *cls* are later changed, the *cls* will no\n       longer be considered to implement such an interface (changing the ``__bases__`` of *cls*\n       has never been supported).\n    \"\"\"\n    spec = implementedBy(cls)\n    interfaces = tuple(_normalizeargs(interfaces))\n\n    before = []\n    after = []\n\n    # Take steps to try to avoid producing an invalid resolution\n    # order, while still allowing for BWC (in the past, we always\n    # appended)\n    for iface in interfaces:\n        for b in spec.declared:\n            if iface.extends(b):\n                before.append(iface)\n                break\n        else:\n            after.append(iface)\n    _classImplements_ordered(spec, tuple(before), tuple(after))\n\n\ndef classImplementsFirst(cls, iface):\n    \"\"\"\n    Declare that instances of *cls* additionally provide *iface*.\n\n    The second argument is an interface or interface specification.\n    It is added as the highest priority (first in the IRO) interface;\n    no attempt is made to keep a consistent resolution order.\n\n    .. versionadded:: 5.0.0\n    \"\"\"\n    spec = implementedBy(cls)\n    _classImplements_ordered(spec, (iface,), ())\n\n\ndef _classImplements_ordered(spec, before=(), after=()):\n    # Elide everything already inherited.\n    # Except, if it is the root, and we don't already declare anything else\n    # that would imply it, allow the root through. (TODO: When we disallow non-strict\n    # IRO, this part of the check can be removed because it's not possible to re-declare\n    # like that.)\n    before = [\n        x\n        for x in before\n        if not spec.isOrExtends(x) or (x is Interface and not spec.declared)\n    ]\n    after = [\n        x\n        for x in after\n        if not spec.isOrExtends(x) or (x is Interface and not spec.declared)\n    ]\n\n    # eliminate duplicates\n    new_declared = []\n    seen = set()\n    for l in before, spec.declared, after:\n        for b in l:\n            if b not in seen:\n                new_declared.append(b)\n                seen.add(b)\n\n    spec.declared = tuple(new_declared)\n\n    # compute the bases\n    bases = new_declared # guaranteed no dupes\n\n    if spec.inherit is not None:\n        for c in spec.inherit.__bases__:\n            b = implementedBy(c)\n            if b not in seen:\n                seen.add(b)\n                bases.append(b)\n\n    spec.__bases__ = tuple(bases)\n\n\ndef _implements_advice(cls):\n    interfaces, do_classImplements = cls.__dict__['__implements_advice_data__']\n    del cls.__implements_advice_data__\n    do_classImplements(cls, *interfaces)\n    return cls\n\n\nclass implementer(object):\n    \"\"\"\n    Declare the interfaces implemented by instances of a class.\n\n    This function is called as a class decorator.\n\n    The arguments are one or more interfaces or interface\n    specifications (`~zope.interface.interfaces.IDeclaration`\n    objects).\n\n    The interfaces given (including the interfaces in the\n    specifications) are added to any interfaces previously declared,\n    unless the interface is already implemented.\n\n    Previous declarations include declarations for base classes unless\n    implementsOnly was used.\n\n    This function is provided for convenience. It provides a more\n    convenient way to call `classImplements`. For example::\n\n        @implementer(I1)\n        class C(object):\n            pass\n\n    is equivalent to calling::\n\n        classImplements(C, I1)\n\n    after the class has been created.\n\n    .. seealso:: `classImplements`\n       The change history provided there applies to this function too.\n    \"\"\"\n    __slots__ = ('interfaces',)\n\n    def __init__(self, *interfaces):\n        self.interfaces = interfaces\n\n    def __call__(self, ob):\n        if isinstance(ob, DescriptorAwareMetaClasses):\n            # This is the common branch for new-style (object) and\n            # on Python 2 old-style classes.\n            classImplements(ob, *self.interfaces)\n            return ob\n\n        spec_name = _implements_name(ob)\n        spec = Implements.named(spec_name, *self.interfaces)\n        try:\n            ob.__implemented__ = spec\n        except AttributeError:\n            raise TypeError(\"Can't declare implements\", ob)\n        return ob\n\nclass implementer_only(object):\n    \"\"\"Declare the only interfaces implemented by instances of a class\n\n      This function is called as a class decorator.\n\n      The arguments are one or more interfaces or interface\n      specifications (`~zope.interface.interfaces.IDeclaration` objects).\n\n      Previous declarations including declarations for base classes\n      are overridden.\n\n      This function is provided for convenience. It provides a more\n      convenient way to call `classImplementsOnly`. For example::\n\n        @implementer_only(I1)\n        class C(object): pass\n\n      is equivalent to calling::\n\n        classImplementsOnly(I1)\n\n      after the class has been created.\n      \"\"\"\n\n    def __init__(self, *interfaces):\n        self.interfaces = interfaces\n\n    def __call__(self, ob):\n        if isinstance(ob, (FunctionType, MethodType)):\n            # XXX Does this decorator make sense for anything but classes?\n            # I don't think so. There can be no inheritance of interfaces\n            # on a method or function....\n            raise ValueError('The implementer_only decorator is not '\n                             'supported for methods or functions.')\n\n        # Assume it's a class:\n        classImplementsOnly(ob, *self.interfaces)\n        return ob\n\ndef _implements(name, interfaces, do_classImplements):\n    # This entire approach is invalid under Py3K.  Don't even try to fix\n    # the coverage for this block there. :(\n    frame = sys._getframe(2) # pylint:disable=protected-access\n    locals = frame.f_locals # pylint:disable=redefined-builtin\n\n    # Try to make sure we were called from a class def. In 2.2.0 we can't\n    # check for __module__ since it doesn't seem to be added to the locals\n    # until later on.\n    if locals is frame.f_globals or '__module__' not in locals:\n        raise TypeError(name+\" can be used only from a class definition.\")\n\n    if '__implements_advice_data__' in locals:\n        raise TypeError(name+\" can be used only once in a class definition.\")\n\n    locals['__implements_advice_data__'] = interfaces, do_classImplements\n    addClassAdvisor(_implements_advice, depth=3)\n\ndef implements(*interfaces):\n    \"\"\"\n    Declare interfaces implemented by instances of a class.\n\n    .. deprecated:: 5.0\n        This only works for Python 2. The `implementer` decorator\n        is preferred for all versions.\n\n    This function is called in a class definition.\n\n    The arguments are one or more interfaces or interface\n    specifications (`~zope.interface.interfaces.IDeclaration`\n    objects).\n\n    The interfaces given (including the interfaces in the\n    specifications) are added to any interfaces previously declared.\n\n    Previous declarations include declarations for base classes unless\n    `implementsOnly` was used.\n\n    This function is provided for convenience. It provides a more\n    convenient way to call `classImplements`. For example::\n\n        implements(I1)\n\n    is equivalent to calling::\n\n        classImplements(C, I1)\n\n    after the class has been created.\n    \"\"\"\n    # This entire approach is invalid under Py3K.  Don't even try to fix\n    # the coverage for this block there. :(\n    if PYTHON3:\n        raise TypeError(_ADVICE_ERROR % 'implementer')\n    _implements(\"implements\", interfaces, classImplements)\n\ndef implementsOnly(*interfaces):\n    \"\"\"Declare the only interfaces implemented by instances of a class\n\n      This function is called in a class definition.\n\n      The arguments are one or more interfaces or interface\n      specifications (`~zope.interface.interfaces.IDeclaration` objects).\n\n      Previous declarations including declarations for base classes\n      are overridden.\n\n      This function is provided for convenience. It provides a more\n      convenient way to call `classImplementsOnly`. For example::\n\n        implementsOnly(I1)\n\n      is equivalent to calling::\n\n        classImplementsOnly(I1)\n\n      after the class has been created.\n    \"\"\"\n    # This entire approach is invalid under Py3K.  Don't even try to fix\n    # the coverage for this block there. :(\n    if PYTHON3:\n        raise TypeError(_ADVICE_ERROR % 'implementer_only')\n    _implements(\"implementsOnly\", interfaces, classImplementsOnly)\n\n##############################################################################\n#\n# Instance declarations\n\nclass Provides(Declaration):  # Really named ProvidesClass\n    \"\"\"Implement ``__provides__``, the instance-specific specification\n\n    When an object is pickled, we pickle the interfaces that it implements.\n    \"\"\"\n\n    def __init__(self, cls, *interfaces):\n        self.__args = (cls, ) + interfaces\n        self._cls = cls\n        Declaration.__init__(self, *(interfaces + (implementedBy(cls), )))\n\n    def __repr__(self):\n        return \"<%s.%s for %s>\" % (\n            self.__class__.__module__,\n            self.__class__.__name__,\n            self._cls,\n        )\n\n    def __reduce__(self):\n        return Provides, self.__args\n\n    __module__ = 'zope.interface'\n\n    def __get__(self, inst, cls):\n        \"\"\"Make sure that a class __provides__ doesn't leak to an instance\n        \"\"\"\n        if inst is None and cls is self._cls:\n            # We were accessed through a class, so we are the class'\n            # provides spec. Just return this object, but only if we are\n            # being called on the same class that we were defined for:\n            return self\n\n        raise AttributeError('__provides__')\n\nProvidesClass = Provides\n\n# Registry of instance declarations\n# This is a memory optimization to allow objects to share specifications.\nInstanceDeclarations = weakref.WeakValueDictionary()\n\ndef Provides(*interfaces): # pylint:disable=function-redefined\n    \"\"\"Cache instance declarations\n\n      Instance declarations are shared among instances that have the same\n      declaration. The declarations are cached in a weak value dictionary.\n    \"\"\"\n    spec = InstanceDeclarations.get(interfaces)\n    if spec is None:\n        spec = ProvidesClass(*interfaces)\n        InstanceDeclarations[interfaces] = spec\n\n    return spec\n\nProvides.__safe_for_unpickling__ = True\n\n\ndef directlyProvides(object, *interfaces): # pylint:disable=redefined-builtin\n    \"\"\"Declare interfaces declared directly for an object\n\n      The arguments after the object are one or more interfaces or interface\n      specifications (`~zope.interface.interfaces.IDeclaration` objects).\n\n      The interfaces given (including the interfaces in the specifications)\n      replace interfaces previously declared for the object.\n    \"\"\"\n    cls = getattr(object, '__class__', None)\n    if cls is not None and getattr(cls, '__class__', None) is cls:\n        # It's a meta class (well, at least it it could be an extension class)\n        # Note that we can't get here from Py3k tests:  there is no normal\n        # class which isn't descriptor aware.\n        if not isinstance(object,\n                          DescriptorAwareMetaClasses):\n            raise TypeError(\"Attempt to make an interface declaration on a \"\n                            \"non-descriptor-aware class\")\n\n    interfaces = _normalizeargs(interfaces)\n    if cls is None:\n        cls = type(object)\n\n    issub = False\n    for damc in DescriptorAwareMetaClasses:\n        if issubclass(cls, damc):\n            issub = True\n            break\n    if issub:\n        # we have a class or type.  We'll use a special descriptor\n        # that provides some extra caching\n        object.__provides__ = ClassProvides(object, cls, *interfaces)\n    else:\n        object.__provides__ = Provides(cls, *interfaces)\n\n\ndef alsoProvides(object, *interfaces): # pylint:disable=redefined-builtin\n    \"\"\"Declare interfaces declared directly for an object\n\n    The arguments after the object are one or more interfaces or interface\n    specifications (`~zope.interface.interfaces.IDeclaration` objects).\n\n    The interfaces given (including the interfaces in the specifications) are\n    added to the interfaces previously declared for the object.\n    \"\"\"\n    directlyProvides(object, directlyProvidedBy(object), *interfaces)\n\n\ndef noLongerProvides(object, interface): # pylint:disable=redefined-builtin\n    \"\"\" Removes a directly provided interface from an object.\n    \"\"\"\n    directlyProvides(object, directlyProvidedBy(object) - interface)\n    if interface.providedBy(object):\n        raise ValueError(\"Can only remove directly provided interfaces.\")\n\n\n@_use_c_impl\nclass ClassProvidesBase(SpecificationBase):\n\n    __slots__ = (\n        '_cls',\n        '_implements',\n    )\n\n    def __get__(self, inst, cls):\n        # member slots are set by subclass\n        # pylint:disable=no-member\n        if cls is self._cls:\n            # We only work if called on the class we were defined for\n\n            if inst is None:\n                # We were accessed through a class, so we are the class'\n                # provides spec. Just return this object as is:\n                return self\n\n            return self._implements\n\n        raise AttributeError('__provides__')\n\n\nclass ClassProvides(Declaration, ClassProvidesBase):\n    \"\"\"Special descriptor for class ``__provides__``\n\n    The descriptor caches the implementedBy info, so that\n    we can get declarations for objects without instance-specific\n    interfaces a bit quicker.\n    \"\"\"\n\n    __slots__ = (\n        '__args',\n    )\n\n    def __init__(self, cls, metacls, *interfaces):\n        self._cls = cls\n        self._implements = implementedBy(cls)\n        self.__args = (cls, metacls, ) + interfaces\n        Declaration.__init__(self, *(interfaces + (implementedBy(metacls), )))\n\n    def __repr__(self):\n        return \"<%s.%s for %s>\" % (\n            self.__class__.__module__,\n            self.__class__.__name__,\n            self._cls,\n        )\n\n    def __reduce__(self):\n        return self.__class__, self.__args\n\n    # Copy base-class method for speed\n    __get__ = ClassProvidesBase.__get__\n\n", "contexts_below": "\n def classProvides(*interfaces):\n     \"\"\"Declare interfaces provided directly by a class\n \n       This function is called in a class definition.\n \n       The arguments are one or more interfaces or interface specifications\n       (`~zope.interface.interfaces.IDeclaration` objects).\n \n       The given interfaces (including the interfaces in the specifications)\n       are used to create the class's direct-object interface specification.\n       An error will be raised if the module class has an direct interface\n       specification. In other words, it is an error to call this function more\n       than once in a class definition.\n \n       Note that the given interfaces have nothing to do with the interfaces\n       implemented by instances of the class.\n \n       This function is provided for convenience. It provides a more convenient\n       way to call `directlyProvides` for a class. For example::\n \n         classProvides(I1)\n \n       is equivalent to calling::\n \n         directlyProvides(theclass, I1)\n \n       after the class has been created.\n     \"\"\"\n     # This entire approach is invalid under Py3K.  Don't even try to fix\n     # the coverage for this block there. :(\n \n     if PYTHON3:\n         raise TypeError(_ADVICE_ERROR % 'provider')\n \n     frame = sys._getframe(1) # pylint:disable=protected-access\n     locals = frame.f_locals # pylint:disable=redefined-builtin\n \n     # Try to make sure we were called from a class def\n     if (locals is frame.f_globals) or ('__module__' not in locals):\n         raise TypeError(\"classProvides can be used only from a \"\n                         \"class definition.\")\n \n     if '__provides__' in locals:\n         raise TypeError(\n             \"classProvides can only be used once in a class definition.\")\n \n     locals[\"__provides__\"] = _normalizeargs(interfaces)\n \n     addClassAdvisor(_classProvides_advice, depth=2)\n \n def _classProvides_advice(cls):\n     # This entire approach is invalid under Py3K.  Don't even try to fix\n     # the coverage for this block there. :(\n     interfaces = cls.__dict__['__provides__']\n     del cls.__provides__\n     directlyProvides(cls, *interfaces)\n     return cls\n \n \n class provider(object):\n     \"\"\"Class decorator version of classProvides\"\"\"\n \n     def __init__(self, *interfaces):\n         self.interfaces = interfaces\n \n     def __call__(self, ob):\n         directlyProvides(ob, *self.interfaces)\n         return ob\n \n \n def moduleProvides(*interfaces):\n     \"\"\"Declare interfaces provided by a module\n \n     This function is used in a module definition.\n \n     The arguments are one or more interfaces or interface specifications\n     (`~zope.interface.interfaces.IDeclaration` objects).\n \n     The given interfaces (including the interfaces in the specifications) are\n     used to create the module's direct-object interface specification.  An\n     error will be raised if the module already has an interface specification.\n     In other words, it is an error to call this function more than once in a\n     module definition.\n \n     This function is provided for convenience. It provides a more convenient\n     way to call directlyProvides. For example::\n \n       moduleImplements(I1)\n \n     is equivalent to::\n \n       directlyProvides(sys.modules[__name__], I1)\n     \"\"\"\n     frame = sys._getframe(1) # pylint:disable=protected-access\n     locals = frame.f_locals # pylint:disable=redefined-builtin\n \n     # Try to make sure we were called from a class def\n     if (locals is not frame.f_globals) or ('__name__' not in locals):\n         raise TypeError(\n             \"moduleProvides can only be used from a module definition.\")\n \n     if '__provides__' in locals:\n         raise TypeError(\n             \"moduleProvides can only be used once in a module definition.\")\n \n     locals[\"__provides__\"] = Provides(ModuleType,\n                                       *_normalizeargs(interfaces))\n \n \n ##############################################################################\n #\n # Declaration querying support\n \n # XXX:  is this a fossil?  Nobody calls it, no unit tests exercise it, no\n #       doctests import it, and the package __init__ doesn't import it.\n #       (Answer: Versions of zope.container prior to 4.4.0 called this.)\n def ObjectSpecification(direct, cls):\n     \"\"\"Provide object specifications\n \n     These combine information for the object and for it's classes.\n     \"\"\"\n     return Provides(cls, direct) # pragma: no cover fossil\n \n @_use_c_impl\n def getObjectSpecification(ob):\n     try:\n         provides = ob.__provides__\n     except AttributeError:\n         provides = None\n \n     if provides is not None:\n         if isinstance(provides, SpecificationBase):\n             return provides\n \n     try:\n         cls = ob.__class__\n     except AttributeError:\n         # We can't get the class, so just consider provides\n         return _empty\n     return implementedBy(cls)\n \n \n @_use_c_impl\n def providedBy(ob):\n     \"\"\"\n     Return the interfaces provided by *ob*.\n \n     If *ob* is a :class:`super` object, then only interfaces implemented\n     by the remainder of the classes in the method resolution order are\n     considered. Interfaces directly provided by the object underlying *ob*\n     are not.\n     \"\"\"\n     # Here we have either a special object, an old-style declaration\n     # or a descriptor\n \n     # Try to get __providedBy__\n     try:\n         if isinstance(ob, super): # Some objects raise errors on isinstance()\n             return implementedBy(ob)\n \n         r = ob.__providedBy__\n     except AttributeError:\n         # Not set yet. Fall back to lower-level thing that computes it\n         return getObjectSpecification(ob)\n \n     try:\n         # We might have gotten a descriptor from an instance of a\n         # class (like an ExtensionClass) that doesn't support\n         # descriptors.  We'll make sure we got one by trying to get\n         # the only attribute, which all specs have.\n         r.extends\n     except AttributeError:\n \n         # The object's class doesn't understand descriptors.\n         # Sigh. We need to get an object descriptor, but we have to be\n         # careful.  We want to use the instance's __provides__, if\n         # there is one, but only if it didn't come from the class.\n \n         try:\n             r = ob.__provides__\n         except AttributeError:\n             # No __provides__, so just fall back to implementedBy\n             return implementedBy(ob.__class__)\n \n         # We need to make sure we got the __provides__ from the\n         # instance. We'll do this by making sure we don't get the same\n         # thing from the class:\n \n         try:\n             cp = ob.__class__.__provides__\n         except AttributeError:\n             # The ob doesn't have a class or the class has no\n             # provides, assume we're done:\n             return r\n \n         if r is cp:\n             # Oops, we got the provides from the class. This means\n             # the object doesn't have it's own. We should use implementedBy\n             return implementedBy(ob.__class__)\n \n     return r\n \n \n @_use_c_impl\n class ObjectSpecificationDescriptor(object):\n     \"\"\"Implement the `__providedBy__` attribute\n \n     The `__providedBy__` attribute computes the interfaces provided by\n     an object.\n     \"\"\"\n \n     def __get__(self, inst, cls):\n         \"\"\"Get an object specification for an object\n         \"\"\"\n         if inst is None:\n             return getObjectSpecification(cls)\n \n         provides = getattr(inst, '__provides__', None)\n         if provides is not None:\n             return provides\n \n         return implementedBy(cls)\n \n \n ##############################################################################\n \n def _normalizeargs(sequence, output=None):\n     \"\"\"Normalize declaration arguments\n \n     Normalization arguments might contain Declarions, tuples, or single\n     interfaces.\n \n     Anything but individial interfaces or implements specs will be expanded.\n     \"\"\"\n     if output is None:\n         output = []\n \n     cls = sequence.__class__\n     if InterfaceClass in cls.__mro__ or Implements in cls.__mro__:\n         output.append(sequence)\n     else:\n         for v in sequence:\n             _normalizeargs(v, output)\n \n     return output\n \n _empty = _ImmutableDeclaration()\n \n objectSpecificationDescriptor = ObjectSpecificationDescriptor()\n ", "input_code": "def directlyProvidedBy(object):\n\"\"\"\nReturn the interfaces directly provided by the given object\n\nThe value returned is an `~zope.interface.interfaces.IDeclaration`.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def directlyProvidedBy(object): # pylint:disable=redefined-builtin\n    \"\"\"Return the interfaces directly provided by the given object\n\n    The value returned is an `~zope.interface.interfaces.IDeclaration`.\n    \"\"\"\n    provides = getattr(object, \"__provides__\", None)\n    if (\n            provides is None # no spec\n            # We might have gotten the implements spec, as an\n            # optimization. If so, it's like having only one base, that we\n            # lop off to exclude class-supplied declarations:\n            or isinstance(provides, Implements)\n    ):\n        return _empty\n\n    # Strip off the class part of the spec:\n    return Declaration(provides.__bases__[:-1])", "signature": "def directlyProvidedBy(object):", "completion_path": "src/zope/interface/declarations.py"}
{"ce_id": "62b8b559eb7e40a82d2d11f8", "namespace": "62b8b559eb7e40a82d2d11f8", "namespace_real": "src.zope.interface.advice.minimalBases", "real_proj_path": "pexip---os-zope/", "type": "function", "class_name": null, "function_name": "minimalBases", "contexts_above": "##############################################################################\n#\n# Copyright (c) 2003 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"Class advice.\n\nThis module was adapted from 'protocols.advice', part of the Python\nEnterprise Application Kit (PEAK).  Please notify the PEAK authors\n(pje@telecommunity.com and tsarna@sarna.org) if bugs are found or\nZope-specific changes are required, so that the PEAK version of this module\ncan be kept in sync.\n\nPEAK is a Python application framework that interoperates with (but does\nnot require) Zope 3 and Twisted.  It provides tools for manipulating UML\nmodels, object-relational persistence, aspect-oriented programming, and more.\nVisit the PEAK home page at http://peak.telecommunity.com for more information.\n\"\"\"\n\nfrom types import FunctionType\ntry:\n    from types import ClassType\nexcept ImportError:\n    __python3 = True\nelse:\n    __python3 = False\n\n__all__ = [\n    'addClassAdvisor',\n    'determineMetaclass',\n    'getFrameInfo',\n    'isClassAdvisor',\n    'minimalBases',\n]\n\nimport sys\n\ndef getFrameInfo(frame):\n    \"\"\"Return (kind,module,locals,globals) for a frame\n\n    'kind' is one of \"exec\", \"module\", \"class\", \"function call\", or \"unknown\".\n    \"\"\"\n\n    f_locals = frame.f_locals\n    f_globals = frame.f_globals\n\n    sameNamespace = f_locals is f_globals\n    hasModule = '__module__' in f_locals\n    hasName = '__name__' in f_globals\n\n    sameName = hasModule and hasName\n    sameName = sameName and f_globals['__name__']==f_locals['__module__']\n\n    module = hasName and sys.modules.get(f_globals['__name__']) or None\n\n    namespaceIsModule = module and module.__dict__ is f_globals\n\n    if not namespaceIsModule:\n        # some kind of funky exec\n        kind = \"exec\"\n    elif sameNamespace and not hasModule:\n        kind = \"module\"\n    elif sameName and not sameNamespace:\n        kind = \"class\"\n    elif not sameNamespace:\n        kind = \"function call\"\n    else: # pragma: no cover\n        # How can you have f_locals is f_globals, and have '__module__' set?\n        # This is probably module-level code, but with a '__module__' variable.\n        kind = \"unknown\"\n    return kind, module, f_locals, f_globals\n\n\ndef addClassAdvisor(callback, depth=2):\n    \"\"\"Set up 'callback' to be passed the containing class upon creation\n\n    This function is designed to be called by an \"advising\" function executed\n    in a class suite.  The \"advising\" function supplies a callback that it\n    wishes to have executed when the containing class is created.  The\n    callback will be given one argument: the newly created containing class.\n    The return value of the callback will be used in place of the class, so\n    the callback should return the input if it does not wish to replace the\n    class.\n\n    The optional 'depth' argument to this function determines the number of\n    frames between this function and the targeted class suite.  'depth'\n    defaults to 2, since this skips this function's frame and one calling\n    function frame.  If you use this function from a function called directly\n    in the class suite, the default will be correct, otherwise you will need\n    to determine the correct depth yourself.\n\n    This function works by installing a special class factory function in\n    place of the '__metaclass__' of the containing class.  Therefore, only\n    callbacks *after* the last '__metaclass__' assignment in the containing\n    class will be executed.  Be sure that classes using \"advising\" functions\n    declare any '__metaclass__' *first*, to ensure all callbacks are run.\"\"\"\n    # This entire approach is invalid under Py3K.  Don't even try to fix\n    # the coverage for this block there. :(\n    if __python3: # pragma: no cover\n        raise TypeError('Class advice impossible in Python3')\n\n    frame = sys._getframe(depth)\n    kind, module, caller_locals, caller_globals = getFrameInfo(frame)\n\n    # This causes a problem when zope interfaces are used from doctest.\n    # In these cases, kind == \"exec\".\n    #\n    #if kind != \"class\":\n    #    raise SyntaxError(\n    #        \"Advice must be in the body of a class statement\"\n    #    )\n\n    previousMetaclass = caller_locals.get('__metaclass__')\n    if __python3:   # pragma: no cover\n        defaultMetaclass  = caller_globals.get('__metaclass__', type)\n    else:\n        defaultMetaclass  = caller_globals.get('__metaclass__', ClassType)\n\n\n    def advise(name, bases, cdict):\n\n        if '__metaclass__' in cdict:\n            del cdict['__metaclass__']\n\n        if previousMetaclass is None:\n            if bases:\n                # find best metaclass or use global __metaclass__ if no bases\n                meta = determineMetaclass(bases)\n            else:\n                meta = defaultMetaclass\n\n        elif isClassAdvisor(previousMetaclass):\n            # special case: we can't compute the \"true\" metaclass here,\n            # so we need to invoke the previous metaclass and let it\n            # figure it out for us (and apply its own advice in the process)\n            meta = previousMetaclass\n\n        else:\n            meta = determineMetaclass(bases, previousMetaclass)\n\n        newClass = meta(name,bases,cdict)\n\n        # this lets the callback replace the class completely, if it wants to\n        return callback(newClass)\n\n    # introspection data only, not used by inner function\n    advise.previousMetaclass = previousMetaclass\n    advise.callback = callback\n\n    # install the advisor\n    caller_locals['__metaclass__'] = advise\n\n\ndef isClassAdvisor(ob):\n    \"\"\"True if 'ob' is a class advisor function\"\"\"\n    return isinstance(ob,FunctionType) and hasattr(ob,'previousMetaclass')\n\n\ndef determineMetaclass(bases, explicit_mc=None):\n    \"\"\"Determine metaclass from 1+ bases and optional explicit __metaclass__\"\"\"\n\n    meta = [getattr(b,'__class__',type(b)) for b in bases]\n\n    if explicit_mc is not None:\n        # The explicit metaclass needs to be verified for compatibility\n        # as well, and allowed to resolve the incompatible bases, if any\n        meta.append(explicit_mc)\n\n    if len(meta)==1:\n        # easy case\n        return meta[0]\n\n    candidates = minimalBases(meta) # minimal set of metaclasses\n\n    if not candidates: # pragma: no cover\n        # they're all \"classic\" classes\n        assert(not __python3) # This should not happen under Python 3\n        return ClassType\n\n    elif len(candidates)>1:\n        # We could auto-combine, but for now we won't...\n        raise TypeError(\"Incompatible metatypes\",bases)\n\n    # Just one, return it\n    return candidates[0]\n\n", "contexts_below": "", "input_code": "def minimalBases(classes):\n\"\"\"\nReduce a list of base classes to its ordered minimum equivalent\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def minimalBases(classes):\n    \"\"\"Reduce a list of base classes to its ordered minimum equivalent\"\"\"\n\n    if not __python3: # pragma: no cover\n        classes = [c for c in classes if c is not ClassType]\n    candidates = []\n\n    for m in classes:\n        for n in classes:\n            if issubclass(n,m) and m is not n:\n                break\n        else:\n            # m has no subclasses in 'classes'\n            if m in candidates:\n                candidates.remove(m)    # ensure that we're later in the list\n            candidates.append(m)\n\n    return candidates", "signature": "def minimalBases(classes):", "completion_path": "src/zope/interface/advice.py"}
{"ce_id": "62b8b4b9eb7e40a82d2d1134", "namespace": "62b8b4b9eb7e40a82d2d1134", "namespace_real": "src.zope.interface.interface.namesAndDescriptions", "real_proj_path": "pexip---os-zope/", "type": "class", "class_name": "interface", "function_name": "namesAndDescriptions", "contexts_above": "##############################################################################\n#\n# Copyright (c) 2001, 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"Interface object implementation\n\"\"\"\n# pylint:disable=protected-access\nimport sys\nfrom types import MethodType\nfrom types import FunctionType\nimport weakref\n\nfrom zope.interface._compat import _use_c_impl\nfrom zope.interface._compat import PYTHON2 as PY2\nfrom zope.interface.exceptions import Invalid\nfrom zope.interface.ro import ro as calculate_ro\nfrom zope.interface import ro\n\n__all__ = [\n    # Most of the public API from this module is directly exported\n    # from zope.interface. The only remaining public API intended to\n    # be imported from here should be those few things documented as\n    # such.\n    'InterfaceClass',\n    'Specification',\n    'adapter_hooks',\n]\n\nCO_VARARGS = 4\nCO_VARKEYWORDS = 8\n# Put in the attrs dict of an interface by ``taggedValue`` and ``invariants``\nTAGGED_DATA = '__interface_tagged_values__'\n# Put in the attrs dict of an interface by ``interfacemethod``\nINTERFACE_METHODS = '__interface_methods__'\n\n_decorator_non_return = object()\n_marker = object()\n\n\n\ndef invariant(call):\n    f_locals = sys._getframe(1).f_locals\n    tags = f_locals.setdefault(TAGGED_DATA, {})\n    invariants = tags.setdefault('invariants', [])\n    invariants.append(call)\n    return _decorator_non_return\n\n\ndef taggedValue(key, value):\n    \"\"\"Attaches a tagged value to an interface at definition time.\"\"\"\n    f_locals = sys._getframe(1).f_locals\n    tagged_values = f_locals.setdefault(TAGGED_DATA, {})\n    tagged_values[key] = value\n    return _decorator_non_return\n\n\nclass Element(object):\n    \"\"\"\n    Default implementation of `zope.interface.interfaces.IElement`.\n    \"\"\"\n\n    # We can't say this yet because we don't have enough\n    # infrastructure in place.\n    #\n    #implements(IElement)\n\n    def __init__(self, __name__, __doc__=''): # pylint:disable=redefined-builtin\n        if not __doc__ and __name__.find(' ') >= 0:\n            __doc__ = __name__\n            __name__ = None\n\n        self.__name__ = __name__\n        self.__doc__ = __doc__\n        # Tagged values are rare, especially on methods or attributes.\n        # Deferring the allocation can save substantial memory.\n        self.__tagged_values = None\n\n    def getName(self):\n        \"\"\" Returns the name of the object. \"\"\"\n        return self.__name__\n\n    def getDoc(self):\n        \"\"\" Returns the documentation for the object. \"\"\"\n        return self.__doc__\n\n    ###\n    # Tagged values.\n    #\n    # Direct tagged values are set only in this instance. Others\n    # may be inherited (for those subclasses that have that concept).\n    ###\n\n    def getTaggedValue(self, tag):\n        \"\"\" Returns the value associated with 'tag'. \"\"\"\n        if not self.__tagged_values:\n            raise KeyError(tag)\n        return self.__tagged_values[tag]\n\n    def queryTaggedValue(self, tag, default=None):\n        \"\"\" Returns the value associated with 'tag'. \"\"\"\n        return self.__tagged_values.get(tag, default) if self.__tagged_values else default\n\n    def getTaggedValueTags(self):\n        \"\"\" Returns a collection of all tags. \"\"\"\n        return self.__tagged_values.keys() if self.__tagged_values else ()\n\n    def setTaggedValue(self, tag, value):\n        \"\"\" Associates 'value' with 'key'. \"\"\"\n        if self.__tagged_values is None:\n            self.__tagged_values = {}\n        self.__tagged_values[tag] = value\n\n    queryDirectTaggedValue = queryTaggedValue\n    getDirectTaggedValue = getTaggedValue\n    getDirectTaggedValueTags = getTaggedValueTags\n\n\nSpecificationBasePy = object # filled by _use_c_impl.\n\n\n@_use_c_impl\nclass SpecificationBase(object):\n    # This object is the base of the inheritance hierarchy for ClassProvides:\n    #\n    # ClassProvides < ClassProvidesBase, Declaration\n    # Declaration < Specification < SpecificationBase\n    # ClassProvidesBase < SpecificationBase\n    #\n    # In order to have compatible instance layouts, we need to declare\n    # the storage used by Specification and Declaration here (and\n    # those classes must have ``__slots__ = ()``); fortunately this is\n    # not a waste of space because those are the only two inheritance\n    # trees. These all translate into tp_members in C.\n    __slots__ = (\n        # Things used here.\n        '_implied',\n        # Things used in Specification.\n        '_dependents',\n        '_bases',\n        '_v_attrs',\n        '__iro__',\n        '__sro__',\n        '__weakref__',\n    )\n\n    def providedBy(self, ob):\n        \"\"\"Is the interface implemented by an object\n        \"\"\"\n        spec = providedBy(ob)\n        return self in spec._implied\n\n    def implementedBy(self, cls):\n        \"\"\"Test whether the specification is implemented by a class or factory.\n\n        Raise TypeError if argument is neither a class nor a callable.\n        \"\"\"\n        spec = implementedBy(cls)\n        return self in spec._implied\n\n    def isOrExtends(self, interface):\n        \"\"\"Is the interface the same as or extend the given interface\n        \"\"\"\n        return interface in self._implied # pylint:disable=no-member\n\n    __call__ = isOrExtends\n\n\nclass NameAndModuleComparisonMixin(object):\n    # Internal use. Implement the basic sorting operators (but not (in)equality\n    # or hashing). Subclasses must provide ``__name__`` and ``__module__``\n    # attributes. Subclasses will be mutually comparable; but because equality\n    # and hashing semantics are missing from this class, take care in how\n    # you define those two attributes: If you stick with the default equality\n    # and hashing (identity based) you should make sure that all possible ``__name__``\n    # and ``__module__`` pairs are unique ACROSS ALL SUBCLASSES. (Actually, pretty\n    # much the same thing goes if you define equality and hashing to be based on\n    # those two attributes: they must still be consistent ACROSS ALL SUBCLASSES.)\n\n    # pylint:disable=assigning-non-slot\n    __slots__ = ()\n\n    def _compare(self, other):\n        \"\"\"\n        Compare *self* to *other* based on ``__name__`` and ``__module__``.\n\n        Return 0 if they are equal, return 1 if *self* is\n        greater than *other*, and return -1 if *self* is less than\n        *other*.\n\n        If *other* does not have ``__name__`` or ``__module__``, then\n        return ``NotImplemented``.\n\n        .. caution::\n           This allows comparison to things well outside the type hierarchy,\n           perhaps not symmetrically.\n\n           For example, ``class Foo(object)`` and ``class Foo(Interface)``\n           in the same file would compare equal, depending on the order of\n           operands. Writing code like this by hand would be unusual, but it could\n           happen with dynamic creation of types and interfaces.\n\n        None is treated as a pseudo interface that implies the loosest\n        contact possible, no contract. For that reason, all interfaces\n        sort before None.\n        \"\"\"\n        if other is self:\n            return 0\n\n        if other is None:\n            return -1\n\n        n1 = (self.__name__, self.__module__)\n        try:\n            n2 = (other.__name__, other.__module__)\n        except AttributeError:\n            return NotImplemented\n\n        # This spelling works under Python3, which doesn't have cmp().\n        return (n1 > n2) - (n1 < n2)\n\n    def __lt__(self, other):\n        c = self._compare(other)\n        if c is NotImplemented:\n            return c\n        return c < 0\n\n    def __le__(self, other):\n        c = self._compare(other)\n        if c is NotImplemented:\n            return c\n        return c <= 0\n\n    def __gt__(self, other):\n        c = self._compare(other)\n        if c is NotImplemented:\n            return c\n        return c > 0\n\n    def __ge__(self, other):\n        c = self._compare(other)\n        if c is NotImplemented:\n            return c\n        return c >= 0\n\n\n@_use_c_impl\nclass InterfaceBase(NameAndModuleComparisonMixin, SpecificationBasePy):\n    \"\"\"Base class that wants to be replaced with a C base :)\n    \"\"\"\n\n    __slots__ = (\n        '__name__',\n        '__ibmodule__',\n        '_v_cached_hash',\n    )\n\n    def __init__(self, name=None, module=None):\n        self.__name__ = name\n        self.__ibmodule__ = module\n\n    def _call_conform(self, conform):\n        raise NotImplementedError\n\n    @property\n    def __module_property__(self):\n        # This is for _InterfaceMetaClass\n        return self.__ibmodule__\n\n    def __call__(self, obj, alternate=_marker):\n        \"\"\"Adapt an object to the interface\n        \"\"\"\n        try:\n            conform = obj.__conform__\n        except AttributeError:\n            conform = None\n\n        if conform is not None:\n            adapter = self._call_conform(conform)\n            if adapter is not None:\n                return adapter\n\n        adapter = self.__adapt__(obj)\n\n        if adapter is not None:\n            return adapter\n        if alternate is not _marker:\n            return alternate\n        raise TypeError(\"Could not adapt\", obj, self)\n\n    def __adapt__(self, obj):\n        \"\"\"Adapt an object to the receiver\n        \"\"\"\n        if self.providedBy(obj):\n            return obj\n\n        for hook in adapter_hooks:\n            adapter = hook(self, obj)\n            if adapter is not None:\n                return adapter\n\n        return None\n\n    def __hash__(self):\n        # pylint:disable=assigning-non-slot,attribute-defined-outside-init\n        try:\n            return self._v_cached_hash\n        except AttributeError:\n            self._v_cached_hash = hash((self.__name__, self.__module__))\n        return self._v_cached_hash\n\n    def __eq__(self, other):\n        c = self._compare(other)\n        if c is NotImplemented:\n            return c\n        return c == 0\n\n    def __ne__(self, other):\n        if other is self:\n            return False\n\n        c = self._compare(other)\n        if c is NotImplemented:\n            return c\n        return c != 0\n\nadapter_hooks = _use_c_impl([], 'adapter_hooks')\n\n\nclass Specification(SpecificationBase):\n    \"\"\"Specifications\n\n    An interface specification is used to track interface declarations\n    and component registrations.\n\n    This class is a base class for both interfaces themselves and for\n    interface specifications (declarations).\n\n    Specifications are mutable.  If you reassign their bases, their\n    relations with other specifications are adjusted accordingly.\n    \"\"\"\n    __slots__ = ()\n\n    # The root of all Specifications. This will be assigned `Interface`,\n    # once it is defined.\n    _ROOT = None\n\n    # Copy some base class methods for speed\n    isOrExtends = SpecificationBase.isOrExtends\n    providedBy = SpecificationBase.providedBy\n\n    def __init__(self, bases=()):\n        # There are many leaf interfaces with no dependents,\n        # and a few with very many. It's a heavily left-skewed\n        # distribution. In a survey of Plone and Zope related packages\n        # that loaded 2245 InterfaceClass objects and 2235 ClassProvides\n        # instances, there were a total of 7000 Specification objects created.\n        # 4700 had 0 dependents, 1400 had 1, 382 had 2 and so on. Only one\n        # for <type> had 1664. So there's savings to be had deferring\n        # the creation of dependents.\n        self._dependents = None # type: weakref.WeakKeyDictionary\n        self._bases = ()\n        self._implied = {}\n        self._v_attrs = None\n        self.__iro__ = ()\n        self.__sro__ = ()\n\n        self.__bases__ = tuple(bases)\n\n    @property\n    def dependents(self):\n        if self._dependents is None:\n            self._dependents = weakref.WeakKeyDictionary()\n        return self._dependents\n\n    def subscribe(self, dependent):\n        self._dependents[dependent] = self.dependents.get(dependent, 0) + 1\n\n    def unsubscribe(self, dependent):\n        try:\n            n = self._dependents[dependent]\n        except TypeError:\n            raise KeyError(dependent)\n        n -= 1\n        if not n:\n            del self.dependents[dependent]\n        else:\n            assert n > 0\n            self.dependents[dependent] = n\n\n    def __setBases(self, bases):\n        # Remove ourselves as a dependent of our old bases\n        for b in self.__bases__:\n            b.unsubscribe(self)\n\n        # Register ourselves as a dependent of our new bases\n        self._bases = bases\n        for b in bases:\n            b.subscribe(self)\n\n        self.changed(self)\n\n    __bases__ = property(\n        lambda self: self._bases,\n        __setBases,\n        )\n\n    def _calculate_sro(self):\n        \"\"\"\n        Calculate and return the resolution order for this object, using its ``__bases__``.\n\n        Ensures that ``Interface`` is always the last (lowest priority) element.\n        \"\"\"\n        # We'd like to make Interface the lowest priority as a\n        # property of the resolution order algorithm. That almost\n        # works out naturally, but it fails when class inheritance has\n        # some bases that DO implement an interface, and some that DO\n        # NOT. In such a mixed scenario, you wind up with a set of\n        # bases to consider that look like this: [[..., Interface],\n        # [..., object], ...]. Depending on the order if inheritance,\n        # Interface can wind up before or after object, and that can\n        # happen at any point in the tree, meaning Interface can wind\n        # up somewhere in the middle of the order. Since Interface is\n        # treated as something that everything winds up implementing\n        # anyway (a catch-all for things like adapters), having it high up\n        # the order is bad. It's also bad to have it at the end, just before\n        # some concrete class: concrete classes should be HIGHER priority than\n        # interfaces (because there's only one class, but many implementations).\n        #\n        # One technically nice way to fix this would be to have\n        # ``implementedBy(object).__bases__ = (Interface,)``\n        #\n        # But: (1) That fails for old-style classes and (2) that causes\n        # everything to appear to *explicitly* implement Interface, when up\n        # to this point it's been an implicit virtual sort of relationship.\n        #\n        # So we force the issue by mutating the resolution order.\n\n        # Note that we let C3 use pre-computed __sro__ for our bases.\n        # This requires that by the time this method is invoked, our bases\n        # have settled their SROs. Thus, ``changed()`` must first\n        # update itself before telling its descendents of changes.\n        sro = calculate_ro(self, base_mros={\n            b: b.__sro__\n            for b in self.__bases__\n        })\n        root = self._ROOT\n        if root is not None and sro and sro[-1] is not root:\n            # In one dataset of 1823 Interface objects, 1117 ClassProvides objects,\n            # sro[-1] was root 4496 times, and only not root 118 times. So it's\n            # probably worth checking.\n\n            # Once we don't have to deal with old-style classes,\n            # we can add a check and only do this if base_count > 1,\n            # if we tweak the bootstrapping for ``<implementedBy object>``\n            sro = [\n                x\n                for x in sro\n                if x is not root\n            ]\n            sro.append(root)\n\n        return sro\n\n    def changed(self, originally_changed):\n        \"\"\"\n        We, or something we depend on, have changed.\n\n        By the time this is called, the things we depend on,\n        such as our bases, should themselves be stable.\n        \"\"\"\n        self._v_attrs = None\n\n        implied = self._implied\n        implied.clear()\n\n        ancestors = self._calculate_sro()\n        self.__sro__ = tuple(ancestors)\n        self.__iro__ = tuple([ancestor for ancestor in ancestors\n                              if isinstance(ancestor, InterfaceClass)\n                              ])\n\n        for ancestor in ancestors:\n            # We directly imply our ancestors:\n            implied[ancestor] = ()\n\n        # Now, advise our dependents of change\n        # (being careful not to create the WeakKeyDictionary if not needed):\n        for dependent in tuple(self._dependents.keys() if self._dependents else ()):\n            dependent.changed(originally_changed)\n\n        # Just in case something called get() at some point\n        # during that process and we have a cycle of some sort\n        # make sure we didn't cache incomplete results.\n        self._v_attrs = None\n\n    def interfaces(self):\n        \"\"\"Return an iterator for the interfaces in the specification.\n        \"\"\"\n        seen = {}\n        for base in self.__bases__:\n            for interface in base.interfaces():\n                if interface not in seen:\n                    seen[interface] = 1\n                    yield interface\n\n    def extends(self, interface, strict=True):\n        \"\"\"Does the specification extend the given interface?\n\n        Test whether an interface in the specification extends the\n        given interface\n        \"\"\"\n        return ((interface in self._implied)\n                and\n                ((not strict) or (self != interface))\n                )\n\n    def weakref(self, callback=None):\n        return weakref.ref(self, callback)\n\n    def get(self, name, default=None):\n        \"\"\"Query for an attribute description\n        \"\"\"\n        attrs = self._v_attrs\n        if attrs is None:\n            attrs = self._v_attrs = {}\n        attr = attrs.get(name)\n        if attr is None:\n            for iface in self.__iro__:\n                attr = iface.direct(name)\n                if attr is not None:\n                    attrs[name] = attr\n                    break\n\n        return default if attr is None else attr\n\n\nclass _InterfaceMetaClass(type):\n    # Handling ``__module__`` on ``InterfaceClass`` is tricky. We need\n    # to be able to read it on a type and get the expected string. We\n    # also need to be able to set it on an instance and get the value\n    # we set. So far so good. But what gets tricky is that we'd like\n    # to store the value in the C structure (``InterfaceBase.__ibmodule__``) for\n    # direct access during equality, sorting, and hashing. \"No\n    # problem, you think, I'll just use a property\" (well, the C\n    # equivalents, ``PyMemberDef`` or ``PyGetSetDef``).\n    #\n    # Except there is a problem. When a subclass is created, the\n    # metaclass (``type``) always automatically puts the expected\n    # string in the class's dictionary under ``__module__``, thus\n    # overriding the property inherited from the superclass. Writing\n    # ``Subclass.__module__`` still works, but\n    # ``Subclass().__module__`` fails.\n    #\n    # There are multiple ways to work around this:\n    #\n    # (1) Define ``InterfaceBase.__getattribute__`` to watch for\n    # ``__module__`` and return the C storage.\n    #\n    # This works, but slows down *all* attribute access (except,\n    # ironically, to ``__module__``) by about 25% (40ns becomes 50ns)\n    # (when implemented in C). Since that includes methods like\n    # ``providedBy``, that's probably not acceptable.\n    #\n    # All the other methods involve modifying subclasses. This can be\n    # done either on the fly in some cases, as instances are\n    # constructed, or by using a metaclass. These next few can be done on the fly.\n    #\n    # (2) Make ``__module__`` a descriptor in each subclass dictionary.\n    # It can't be a straight up ``@property`` descriptor, though, because accessing\n    # it on the class returns a ``property`` object, not the desired string.\n    #\n    # (3) Implement a data descriptor (``__get__`` and ``__set__``)\n    # that is both a subclass of string, and also does the redirect of\n    # ``__module__`` to ``__ibmodule__`` and does the correct thing\n    # with the ``instance`` argument to ``__get__`` is None (returns\n    # the class's value.) (Why must it be a subclass of string? Because\n    # when it' s in the class's dict, it's defined on an *instance* of the\n    # metaclass; descriptors in an instance's dict aren't honored --- their\n    # ``__get__`` is never invoked --- so it must also *be* the value we want\n    # returned.)\n    #\n    # This works, preserves the ability to read and write\n    # ``__module__``, and eliminates any penalty accessing other\n    # attributes. But it slows down accessing ``__module__`` of\n    # instances by 200% (40ns to 124ns), requires editing class dicts on the fly\n    # (in InterfaceClass.__init__), thus slightly slowing down all interface creation,\n    # and is ugly.\n    #\n    # (4) As in the last step, but make it a non-data descriptor (no ``__set__``).\n    #\n    # If you then *also* store a copy of ``__ibmodule__`` in\n    # ``__module__`` in the instance's dict, reading works for both\n    # class and instance and is full speed for instances. But the cost\n    # is storage space, and you can't write to it anymore, not without\n    # things getting out of sync.\n    #\n    # (Actually, ``__module__`` was never meant to be writable. Doing\n    # so would break BTrees and normal dictionaries, as well as the\n    # repr, maybe more.)\n    #\n    # That leaves us with a metaclass. (Recall that a class is an\n    # instance of its metaclass, so properties/descriptors defined in\n    # the metaclass are used when accessing attributes on the\n    # instance/class. We'll use that to define ``__module__``.) Here\n    # we can have our cake and eat it too: no extra storage, and\n    # C-speed access to the underlying storage. The only substantial\n    # cost is that metaclasses tend to make people's heads hurt. (But\n    # still less than the descriptor-is-string, hopefully.)\n\n    __slots__ = ()\n\n    def __new__(cls, name, bases, attrs):\n        # Figure out what module defined the interface.\n        # This is copied from ``InterfaceClass.__init__``;\n        # reviewers aren't sure how AttributeError or KeyError\n        # could be raised.\n        __module__ = sys._getframe(1).f_globals['__name__']\n        # Get the C optimized __module__ accessor and give it\n        # to the new class.\n        moduledescr = InterfaceBase.__dict__['__module__']\n        if isinstance(moduledescr, str):\n            # We're working with the Python implementation,\n            # not the C version\n            moduledescr = InterfaceBase.__dict__['__module_property__']\n        attrs['__module__'] = moduledescr\n        kind = type.__new__(cls, name, bases, attrs)\n        kind.__module = __module__\n        return kind\n\n    @property\n    def __module__(cls):\n        return cls.__module\n\n    def __repr__(cls):\n        return \"<class '%s.%s'>\" % (\n            cls.__module,\n            cls.__name__,\n        )\n\n\n_InterfaceClassBase = _InterfaceMetaClass(\n    'InterfaceClass',\n    # From least specific to most specific.\n    (InterfaceBase, Specification, Element),\n    {'__slots__': ()}\n)\n\n\ndef interfacemethod(func):\n    \"\"\"\n    Convert a method specification to an actual method of the interface.\n\n    This is a decorator that functions like `staticmethod` et al.\n\n    The primary use of this decorator is to allow interface definitions to\n    define the ``__adapt__`` method, but other interface methods can be\n    overridden this way too.\n\n    .. seealso:: `zope.interface.interfaces.IInterfaceDeclaration.interfacemethod`\n    \"\"\"\n    f_locals = sys._getframe(1).f_locals\n    methods = f_locals.setdefault(INTERFACE_METHODS, {})\n    methods[func.__name__] = func\n    return _decorator_non_return\n\n\nclass InterfaceClass(_InterfaceClassBase):\n    \"\"\"\n    Prototype (scarecrow) Interfaces Implementation.\n\n    Note that it is not possible to change the ``__name__`` or ``__module__``\n    after an instance of this object has been constructed.\n    \"\"\"\n\n    # We can't say this yet because we don't have enough\n    # infrastructure in place.\n    #\n    #implements(IInterface)\n\n    def __new__(cls, name=None, bases=(), attrs=None, __doc__=None, # pylint:disable=redefined-builtin\n                __module__=None):\n        assert isinstance(bases, tuple)\n        attrs = attrs or {}\n        needs_custom_class = attrs.pop(INTERFACE_METHODS, None)\n        if needs_custom_class:\n            needs_custom_class.update(\n                {'__classcell__': attrs.pop('__classcell__')}\n                if '__classcell__' in attrs\n                else {}\n            )\n            if '__adapt__' in needs_custom_class:\n                # We need to tell the C code to call this.\n                needs_custom_class['_CALL_CUSTOM_ADAPT'] = 1\n\n            if issubclass(cls, _InterfaceClassWithCustomMethods):\n                cls_bases = (cls,)\n            elif cls is InterfaceClass:\n                cls_bases = (_InterfaceClassWithCustomMethods,)\n            else:\n                cls_bases = (cls, _InterfaceClassWithCustomMethods)\n\n            cls = type(cls)( # pylint:disable=self-cls-assignment\n                name + \"<WithCustomMethods>\",\n                cls_bases,\n                needs_custom_class\n            )\n        elif PY2 and bases and len(bases) > 1:\n            bases_with_custom_methods = tuple(\n                type(b)\n                for b in bases\n                if issubclass(type(b), _InterfaceClassWithCustomMethods)\n            )\n\n            # If we have a subclass of InterfaceClass in *bases*,\n            # Python 3 is smart enough to pass that as *cls*, but Python\n            # 2 just passes whatever the first base in *bases* is. This means that if\n            # we have multiple inheritance, and one of our bases has already defined\n            # a custom method like ``__adapt__``, we do the right thing automatically\n            # and extend it on Python 3, but not necessarily on Python 2. To fix this, we need\n            # to run the MRO algorithm and get the most derived base manually.\n            # Note that this only works for consistent resolution orders\n            if bases_with_custom_methods:\n                cls = type( # pylint:disable=self-cls-assignment\n                    name + \"<WithCustomMethods>\",\n                    bases_with_custom_methods,\n                    {}\n                ).__mro__[1] # Not the class we created, the most derived.\n\n        return _InterfaceClassBase.__new__(cls)\n\n    def __init__(self, name, bases=(), attrs=None, __doc__=None,  # pylint:disable=redefined-builtin\n                 __module__=None):\n        # We don't call our metaclass parent directly\n        # pylint:disable=non-parent-init-called\n        # pylint:disable=super-init-not-called\n        if not all(isinstance(base, InterfaceClass) for base in bases):\n            raise TypeError('Expected base interfaces')\n\n        if attrs is None:\n            attrs = {}\n\n        if __module__ is None:\n            __module__ = attrs.get('__module__')\n            if isinstance(__module__, str):\n                del attrs['__module__']\n            else:\n                try:\n                    # Figure out what module defined the interface.\n                    # This is how cPython figures out the module of\n                    # a class, but of course it does it in C. :-/\n                    __module__ = sys._getframe(1).f_globals['__name__']\n                except (AttributeError, KeyError): # pragma: no cover\n                    pass\n\n        InterfaceBase.__init__(self, name, __module__)\n        # These asserts assisted debugging the metaclass\n        # assert '__module__' not in self.__dict__\n        # assert self.__ibmodule__ is self.__module__ is __module__\n\n        d = attrs.get('__doc__')\n        if d is not None:\n            if not isinstance(d, Attribute):\n                if __doc__ is None:\n                    __doc__ = d\n                del attrs['__doc__']\n\n        if __doc__ is None:\n            __doc__ = ''\n\n        Element.__init__(self, name, __doc__)\n\n        tagged_data = attrs.pop(TAGGED_DATA, None)\n        if tagged_data is not None:\n            for key, val in tagged_data.items():\n                self.setTaggedValue(key, val)\n\n        Specification.__init__(self, bases)\n        self.__attrs = self.__compute_attrs(attrs)\n\n        self.__identifier__ = \"%s.%s\" % (__module__, name)\n\n    def __compute_attrs(self, attrs):\n        # Make sure that all recorded attributes (and methods) are of type\n        # `Attribute` and `Method`\n        def update_value(aname, aval):\n            if isinstance(aval, Attribute):\n                aval.interface = self\n                if not aval.__name__:\n                    aval.__name__ = aname\n            elif isinstance(aval, FunctionType):\n                aval = fromFunction(aval, self, name=aname)\n            else:\n                raise InvalidInterface(\"Concrete attribute, \" + aname)\n            return aval\n\n        return {\n            aname: update_value(aname, aval)\n            for aname, aval in attrs.items()\n            if aname not in (\n                # __locals__: Python 3 sometimes adds this.\n                '__locals__',\n                # __qualname__: PEP 3155 (Python 3.3+)\n                '__qualname__',\n                # __annotations__: PEP 3107 (Python 3.0+)\n                '__annotations__',\n            )\n            and aval is not _decorator_non_return\n        }\n\n    def interfaces(self):\n        \"\"\"Return an iterator for the interfaces in the specification.\n        \"\"\"\n        yield self\n\n    def getBases(self):\n        return self.__bases__\n\n    def isEqualOrExtendedBy(self, other):\n        \"\"\"Same interface or extends?\"\"\"\n        return self == other or other.extends(self)\n\n    def names(self, all=False): # pylint:disable=redefined-builtin\n        \"\"\"Return the attribute names defined by the interface.\"\"\"\n        if not all:\n            return self.__attrs.keys()\n\n        r = self.__attrs.copy()\n\n        for base in self.__bases__:\n            r.update(dict.fromkeys(base.names(all)))\n\n        return r.keys()\n\n    def __iter__(self):\n        return iter(self.names(all=True))\n", "contexts_below": "    def getDescriptionFor(self, name):\n         \"\"\"Return the attribute description for the given name.\"\"\"\n         r = self.get(name)\n         if r is not None:\n             return r\n \n         raise KeyError(name)\n \n     __getitem__ = getDescriptionFor\n \n     def __contains__(self, name):\n         return self.get(name) is not None\n \n     def direct(self, name):\n         return self.__attrs.get(name)\n \n     def queryDescriptionFor(self, name, default=None):\n         return self.get(name, default)\n \n     def validateInvariants(self, obj, errors=None):\n         \"\"\"validate object to defined invariants.\"\"\"\n \n         for iface in self.__iro__:\n             for invariant in iface.queryDirectTaggedValue('invariants', ()):\n                 try:\n                     invariant(obj)\n                 except Invalid as error:\n                      if errors is not None:\n                          errors.append(error)\n                      else:\n                          raise\n \n         if errors:\n             raise Invalid(errors)\n \n     def queryTaggedValue(self, tag, default=None):\n         \"\"\"\n         Queries for the value associated with *tag*, returning it from the nearest\n         interface in the ``__iro__``.\n \n         If not found, returns *default*.\n         \"\"\"\n         for iface in self.__iro__:\n             value = iface.queryDirectTaggedValue(tag, _marker)\n             if value is not _marker:\n                 return value\n         return default\n \n     def getTaggedValue(self, tag):\n         \"\"\" Returns the value associated with 'tag'. \"\"\"\n         value = self.queryTaggedValue(tag, default=_marker)\n         if value is _marker:\n             raise KeyError(tag)\n         return value\n \n     def getTaggedValueTags(self):\n         \"\"\" Returns a list of all tags. \"\"\"\n         keys = set()\n         for base in self.__iro__:\n             keys.update(base.getDirectTaggedValueTags())\n         return keys\n \n     def __repr__(self):  # pragma: no cover\n         try:\n             return self._v_repr\n         except AttributeError:\n             name = self.__name__\n             m = self.__ibmodule__\n             if m:\n                 name = '%s.%s' % (m, name)\n             r = \"<%s %s>\" % (self.__class__.__name__, name)\n             self._v_repr = r # pylint:disable=attribute-defined-outside-init\n             return r\n \n     def _call_conform(self, conform):\n         try:\n             return conform(self)\n         except TypeError: # pragma: no cover\n             # We got a TypeError. It might be an error raised by\n             # the __conform__ implementation, or *we* may have\n             # made the TypeError by calling an unbound method\n             # (object is a class).  In the later case, we behave\n             # as though there is no __conform__ method. We can\n             # detect this case by checking whether there is more\n             # than one traceback object in the traceback chain:\n             if sys.exc_info()[2].tb_next is not None:\n                 # There is more than one entry in the chain, so\n                 # reraise the error:\n                 raise\n             # This clever trick is from Phillip Eby\n \n         return None # pragma: no cover\n \n     def __reduce__(self):\n         return self.__name__\n \n Interface = InterfaceClass(\"Interface\", __module__='zope.interface')\n # Interface is the only member of its own SRO.\n Interface._calculate_sro = lambda: (Interface,)\n Interface.changed(Interface)\n assert Interface.__sro__ == (Interface,)\n Specification._ROOT = Interface\n ro._ROOT = Interface\n \n class _InterfaceClassWithCustomMethods(InterfaceClass):\n     \"\"\"\n     Marker class for interfaces with custom methods that override InterfaceClass methods.\n     \"\"\"\n \n \n class Attribute(Element):\n     \"\"\"Attribute descriptions\n     \"\"\"\n \n     # We can't say this yet because we don't have enough\n     # infrastructure in place.\n     #\n     # implements(IAttribute)\n \n     interface = None\n \n     def _get_str_info(self):\n         \"\"\"Return extra data to put at the end of __str__.\"\"\"\n         return \"\"\n \n     def __str__(self):\n         of = ''\n         if self.interface is not None:\n             of = self.interface.__module__ + '.' + self.interface.__name__ + '.'\n         # self.__name__ may be None during construction (e.g., debugging)\n         return of + (self.__name__ or '<unknown>') + self._get_str_info()\n \n     def __repr__(self):\n         return \"<%s.%s object at 0x%x %s>\" % (\n             type(self).__module__,\n             type(self).__name__,\n             id(self),\n             self\n         )\n \n \n class Method(Attribute):\n     \"\"\"Method interfaces\n \n     The idea here is that you have objects that describe methods.\n     This provides an opportunity for rich meta-data.\n     \"\"\"\n \n     # We can't say this yet because we don't have enough\n     # infrastructure in place.\n     #\n     # implements(IMethod)\n \n     positional = required = ()\n     _optional = varargs = kwargs = None\n     def _get_optional(self):\n         if self._optional is None:\n             return {}\n         return self._optional\n     def _set_optional(self, opt):\n         self._optional = opt\n     def _del_optional(self):\n         self._optional = None\n     optional = property(_get_optional, _set_optional, _del_optional)\n \n     def __call__(self, *args, **kw):\n         raise BrokenImplementation(self.interface, self.__name__)\n \n     def getSignatureInfo(self):\n         return {'positional': self.positional,\n                 'required': self.required,\n                 'optional': self.optional,\n                 'varargs': self.varargs,\n                 'kwargs': self.kwargs,\n                 }\n \n     def getSignatureString(self):\n         sig = []\n         for v in self.positional:\n             sig.append(v)\n             if v in self.optional.keys():\n                 sig[-1] += \"=\" + repr(self.optional[v])\n         if self.varargs:\n             sig.append(\"*\" + self.varargs)\n         if self.kwargs:\n             sig.append(\"**\" + self.kwargs)\n \n         return \"(%s)\" % \", \".join(sig)\n \n     _get_str_info = getSignatureString\n \n \n def fromFunction(func, interface=None, imlevel=0, name=None):\n     name = name or func.__name__\n     method = Method(name, func.__doc__)\n     defaults = getattr(func, '__defaults__', None) or ()\n     code = func.__code__\n     # Number of positional arguments\n     na = code.co_argcount - imlevel\n     names = code.co_varnames[imlevel:]\n     opt = {}\n     # Number of required arguments\n     defaults_count = len(defaults)\n     if not defaults_count:\n         # PyPy3 uses ``__defaults_count__`` for builtin methods\n         # like ``dict.pop``. Surprisingly, these don't have recorded\n         # ``__defaults__``\n         defaults_count = getattr(func, '__defaults_count__', 0)\n \n     nr = na - defaults_count\n     if nr < 0:\n         defaults = defaults[-nr:]\n         nr = 0\n \n     # Determine the optional arguments.\n     opt.update(dict(zip(names[nr:], defaults)))\n \n     method.positional = names[:na]\n     method.required = names[:nr]\n     method.optional = opt\n \n     argno = na\n \n     # Determine the function's variable argument's name (i.e. *args)\n     if code.co_flags & CO_VARARGS:\n         method.varargs = names[argno]\n         argno = argno + 1\n     else:\n         method.varargs = None\n \n     # Determine the function's keyword argument's name (i.e. **kw)\n     if code.co_flags & CO_VARKEYWORDS:\n         method.kwargs = names[argno]\n     else:\n         method.kwargs = None\n \n     method.interface = interface\n \n     for key, value in func.__dict__.items():\n         method.setTaggedValue(key, value)\n \n     return method\n \n \n def fromMethod(meth, interface=None, name=None):\n     if isinstance(meth, MethodType):\n         func = meth.__func__\n     else:\n         func = meth\n     return fromFunction(func, interface, imlevel=1, name=name)\n \n \n # Now we can create the interesting interfaces and wire them up:\n def _wire():\n     from zope.interface.declarations import classImplements\n     # From lest specific to most specific.\n     from zope.interface.interfaces import IElement\n     classImplements(Element, IElement)\n \n     from zope.interface.interfaces import IAttribute\n     classImplements(Attribute, IAttribute)\n \n     from zope.interface.interfaces import IMethod\n     classImplements(Method, IMethod)\n \n     from zope.interface.interfaces import ISpecification\n     classImplements(Specification, ISpecification)\n \n     from zope.interface.interfaces import IInterface\n     classImplements(InterfaceClass, IInterface)\n \n \n # We import this here to deal with module dependencies.\n # pylint:disable=wrong-import-position\n from zope.interface.declarations import implementedBy\n from zope.interface.declarations import providedBy\n from zope.interface.exceptions import InvalidInterface\n from zope.interface.exceptions import BrokenImplementation\n \n # This ensures that ``Interface`` winds up in the flattened()\n # list of the immutable declaration. It correctly overrides changed()\n # as a no-op, so we bypass that.\n from zope.interface.declarations import _empty\n Specification.changed(_empty, _empty)\n ", "input_code": "def namesAndDescriptions(self, all=False):\n\"\"\"\nReturn attribute names and descriptions defined by interface.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def namesAndDescriptions(self, all=False): # pylint:disable=redefined-builtin\n        \"\"\"Return attribute names and descriptions defined by interface.\"\"\"\n        if not all:\n            return self.__attrs.items()\n\n        r = {}\n        for base in self.__bases__[::-1]:\n            r.update(dict(base.namesAndDescriptions(all)))\n\n        r.update(self.__attrs)\n\n        return r.items()", "signature": "def namesAndDescriptions(self, all=False):", "completion_path": "src/zope/interface/interface.py"}
{"ce_id": "62b8b416eb7e40a82d2d1129", "namespace": "62b8b416eb7e40a82d2d1129", "namespace_real": "src.zope.interface.interface.names", "real_proj_path": "pexip---os-zope/", "type": "class", "class_name": "interface", "function_name": "names", "contexts_above": "##############################################################################\n#\n# Copyright (c) 2001, 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"Interface object implementation\n\"\"\"\n# pylint:disable=protected-access\nimport sys\nfrom types import MethodType\nfrom types import FunctionType\nimport weakref\n\nfrom zope.interface._compat import _use_c_impl\nfrom zope.interface._compat import PYTHON2 as PY2\nfrom zope.interface.exceptions import Invalid\nfrom zope.interface.ro import ro as calculate_ro\nfrom zope.interface import ro\n\n__all__ = [\n    # Most of the public API from this module is directly exported\n    # from zope.interface. The only remaining public API intended to\n    # be imported from here should be those few things documented as\n    # such.\n    'InterfaceClass',\n    'Specification',\n    'adapter_hooks',\n]\n\nCO_VARARGS = 4\nCO_VARKEYWORDS = 8\n# Put in the attrs dict of an interface by ``taggedValue`` and ``invariants``\nTAGGED_DATA = '__interface_tagged_values__'\n# Put in the attrs dict of an interface by ``interfacemethod``\nINTERFACE_METHODS = '__interface_methods__'\n\n_decorator_non_return = object()\n_marker = object()\n\n\n\ndef invariant(call):\n    f_locals = sys._getframe(1).f_locals\n    tags = f_locals.setdefault(TAGGED_DATA, {})\n    invariants = tags.setdefault('invariants', [])\n    invariants.append(call)\n    return _decorator_non_return\n\n\ndef taggedValue(key, value):\n    \"\"\"Attaches a tagged value to an interface at definition time.\"\"\"\n    f_locals = sys._getframe(1).f_locals\n    tagged_values = f_locals.setdefault(TAGGED_DATA, {})\n    tagged_values[key] = value\n    return _decorator_non_return\n\n\nclass Element(object):\n    \"\"\"\n    Default implementation of `zope.interface.interfaces.IElement`.\n    \"\"\"\n\n    # We can't say this yet because we don't have enough\n    # infrastructure in place.\n    #\n    #implements(IElement)\n\n    def __init__(self, __name__, __doc__=''): # pylint:disable=redefined-builtin\n        if not __doc__ and __name__.find(' ') >= 0:\n            __doc__ = __name__\n            __name__ = None\n\n        self.__name__ = __name__\n        self.__doc__ = __doc__\n        # Tagged values are rare, especially on methods or attributes.\n        # Deferring the allocation can save substantial memory.\n        self.__tagged_values = None\n\n    def getName(self):\n        \"\"\" Returns the name of the object. \"\"\"\n        return self.__name__\n\n    def getDoc(self):\n        \"\"\" Returns the documentation for the object. \"\"\"\n        return self.__doc__\n\n    ###\n    # Tagged values.\n    #\n    # Direct tagged values are set only in this instance. Others\n    # may be inherited (for those subclasses that have that concept).\n    ###\n\n    def getTaggedValue(self, tag):\n        \"\"\" Returns the value associated with 'tag'. \"\"\"\n        if not self.__tagged_values:\n            raise KeyError(tag)\n        return self.__tagged_values[tag]\n\n    def queryTaggedValue(self, tag, default=None):\n        \"\"\" Returns the value associated with 'tag'. \"\"\"\n        return self.__tagged_values.get(tag, default) if self.__tagged_values else default\n\n    def getTaggedValueTags(self):\n        \"\"\" Returns a collection of all tags. \"\"\"\n        return self.__tagged_values.keys() if self.__tagged_values else ()\n\n    def setTaggedValue(self, tag, value):\n        \"\"\" Associates 'value' with 'key'. \"\"\"\n        if self.__tagged_values is None:\n            self.__tagged_values = {}\n        self.__tagged_values[tag] = value\n\n    queryDirectTaggedValue = queryTaggedValue\n    getDirectTaggedValue = getTaggedValue\n    getDirectTaggedValueTags = getTaggedValueTags\n\n\nSpecificationBasePy = object # filled by _use_c_impl.\n\n\n@_use_c_impl\nclass SpecificationBase(object):\n    # This object is the base of the inheritance hierarchy for ClassProvides:\n    #\n    # ClassProvides < ClassProvidesBase, Declaration\n    # Declaration < Specification < SpecificationBase\n    # ClassProvidesBase < SpecificationBase\n    #\n    # In order to have compatible instance layouts, we need to declare\n    # the storage used by Specification and Declaration here (and\n    # those classes must have ``__slots__ = ()``); fortunately this is\n    # not a waste of space because those are the only two inheritance\n    # trees. These all translate into tp_members in C.\n    __slots__ = (\n        # Things used here.\n        '_implied',\n        # Things used in Specification.\n        '_dependents',\n        '_bases',\n        '_v_attrs',\n        '__iro__',\n        '__sro__',\n        '__weakref__',\n    )\n\n    def providedBy(self, ob):\n        \"\"\"Is the interface implemented by an object\n        \"\"\"\n        spec = providedBy(ob)\n        return self in spec._implied\n\n    def implementedBy(self, cls):\n        \"\"\"Test whether the specification is implemented by a class or factory.\n\n        Raise TypeError if argument is neither a class nor a callable.\n        \"\"\"\n        spec = implementedBy(cls)\n        return self in spec._implied\n\n    def isOrExtends(self, interface):\n        \"\"\"Is the interface the same as or extend the given interface\n        \"\"\"\n        return interface in self._implied # pylint:disable=no-member\n\n    __call__ = isOrExtends\n\n\nclass NameAndModuleComparisonMixin(object):\n    # Internal use. Implement the basic sorting operators (but not (in)equality\n    # or hashing). Subclasses must provide ``__name__`` and ``__module__``\n    # attributes. Subclasses will be mutually comparable; but because equality\n    # and hashing semantics are missing from this class, take care in how\n    # you define those two attributes: If you stick with the default equality\n    # and hashing (identity based) you should make sure that all possible ``__name__``\n    # and ``__module__`` pairs are unique ACROSS ALL SUBCLASSES. (Actually, pretty\n    # much the same thing goes if you define equality and hashing to be based on\n    # those two attributes: they must still be consistent ACROSS ALL SUBCLASSES.)\n\n    # pylint:disable=assigning-non-slot\n    __slots__ = ()\n\n    def _compare(self, other):\n        \"\"\"\n        Compare *self* to *other* based on ``__name__`` and ``__module__``.\n\n        Return 0 if they are equal, return 1 if *self* is\n        greater than *other*, and return -1 if *self* is less than\n        *other*.\n\n        If *other* does not have ``__name__`` or ``__module__``, then\n        return ``NotImplemented``.\n\n        .. caution::\n           This allows comparison to things well outside the type hierarchy,\n           perhaps not symmetrically.\n\n           For example, ``class Foo(object)`` and ``class Foo(Interface)``\n           in the same file would compare equal, depending on the order of\n           operands. Writing code like this by hand would be unusual, but it could\n           happen with dynamic creation of types and interfaces.\n\n        None is treated as a pseudo interface that implies the loosest\n        contact possible, no contract. For that reason, all interfaces\n        sort before None.\n        \"\"\"\n        if other is self:\n            return 0\n\n        if other is None:\n            return -1\n\n        n1 = (self.__name__, self.__module__)\n        try:\n            n2 = (other.__name__, other.__module__)\n        except AttributeError:\n            return NotImplemented\n\n        # This spelling works under Python3, which doesn't have cmp().\n        return (n1 > n2) - (n1 < n2)\n\n    def __lt__(self, other):\n        c = self._compare(other)\n        if c is NotImplemented:\n            return c\n        return c < 0\n\n    def __le__(self, other):\n        c = self._compare(other)\n        if c is NotImplemented:\n            return c\n        return c <= 0\n\n    def __gt__(self, other):\n        c = self._compare(other)\n        if c is NotImplemented:\n            return c\n        return c > 0\n\n    def __ge__(self, other):\n        c = self._compare(other)\n        if c is NotImplemented:\n            return c\n        return c >= 0\n\n\n@_use_c_impl\nclass InterfaceBase(NameAndModuleComparisonMixin, SpecificationBasePy):\n    \"\"\"Base class that wants to be replaced with a C base :)\n    \"\"\"\n\n    __slots__ = (\n        '__name__',\n        '__ibmodule__',\n        '_v_cached_hash',\n    )\n\n    def __init__(self, name=None, module=None):\n        self.__name__ = name\n        self.__ibmodule__ = module\n\n    def _call_conform(self, conform):\n        raise NotImplementedError\n\n    @property\n    def __module_property__(self):\n        # This is for _InterfaceMetaClass\n        return self.__ibmodule__\n\n    def __call__(self, obj, alternate=_marker):\n        \"\"\"Adapt an object to the interface\n        \"\"\"\n        try:\n            conform = obj.__conform__\n        except AttributeError:\n            conform = None\n\n        if conform is not None:\n            adapter = self._call_conform(conform)\n            if adapter is not None:\n                return adapter\n\n        adapter = self.__adapt__(obj)\n\n        if adapter is not None:\n            return adapter\n        if alternate is not _marker:\n            return alternate\n        raise TypeError(\"Could not adapt\", obj, self)\n\n    def __adapt__(self, obj):\n        \"\"\"Adapt an object to the receiver\n        \"\"\"\n        if self.providedBy(obj):\n            return obj\n\n        for hook in adapter_hooks:\n            adapter = hook(self, obj)\n            if adapter is not None:\n                return adapter\n\n        return None\n\n    def __hash__(self):\n        # pylint:disable=assigning-non-slot,attribute-defined-outside-init\n        try:\n            return self._v_cached_hash\n        except AttributeError:\n            self._v_cached_hash = hash((self.__name__, self.__module__))\n        return self._v_cached_hash\n\n    def __eq__(self, other):\n        c = self._compare(other)\n        if c is NotImplemented:\n            return c\n        return c == 0\n\n    def __ne__(self, other):\n        if other is self:\n            return False\n\n        c = self._compare(other)\n        if c is NotImplemented:\n            return c\n        return c != 0\n\nadapter_hooks = _use_c_impl([], 'adapter_hooks')\n\n\nclass Specification(SpecificationBase):\n    \"\"\"Specifications\n\n    An interface specification is used to track interface declarations\n    and component registrations.\n\n    This class is a base class for both interfaces themselves and for\n    interface specifications (declarations).\n\n    Specifications are mutable.  If you reassign their bases, their\n    relations with other specifications are adjusted accordingly.\n    \"\"\"\n    __slots__ = ()\n\n    # The root of all Specifications. This will be assigned `Interface`,\n    # once it is defined.\n    _ROOT = None\n\n    # Copy some base class methods for speed\n    isOrExtends = SpecificationBase.isOrExtends\n    providedBy = SpecificationBase.providedBy\n\n    def __init__(self, bases=()):\n        # There are many leaf interfaces with no dependents,\n        # and a few with very many. It's a heavily left-skewed\n        # distribution. In a survey of Plone and Zope related packages\n        # that loaded 2245 InterfaceClass objects and 2235 ClassProvides\n        # instances, there were a total of 7000 Specification objects created.\n        # 4700 had 0 dependents, 1400 had 1, 382 had 2 and so on. Only one\n        # for <type> had 1664. So there's savings to be had deferring\n        # the creation of dependents.\n        self._dependents = None # type: weakref.WeakKeyDictionary\n        self._bases = ()\n        self._implied = {}\n        self._v_attrs = None\n        self.__iro__ = ()\n        self.__sro__ = ()\n\n        self.__bases__ = tuple(bases)\n\n    @property\n    def dependents(self):\n        if self._dependents is None:\n            self._dependents = weakref.WeakKeyDictionary()\n        return self._dependents\n\n    def subscribe(self, dependent):\n        self._dependents[dependent] = self.dependents.get(dependent, 0) + 1\n\n    def unsubscribe(self, dependent):\n        try:\n            n = self._dependents[dependent]\n        except TypeError:\n            raise KeyError(dependent)\n        n -= 1\n        if not n:\n            del self.dependents[dependent]\n        else:\n            assert n > 0\n            self.dependents[dependent] = n\n\n    def __setBases(self, bases):\n        # Remove ourselves as a dependent of our old bases\n        for b in self.__bases__:\n            b.unsubscribe(self)\n\n        # Register ourselves as a dependent of our new bases\n        self._bases = bases\n        for b in bases:\n            b.subscribe(self)\n\n        self.changed(self)\n\n    __bases__ = property(\n        lambda self: self._bases,\n        __setBases,\n        )\n\n    def _calculate_sro(self):\n        \"\"\"\n        Calculate and return the resolution order for this object, using its ``__bases__``.\n\n        Ensures that ``Interface`` is always the last (lowest priority) element.\n        \"\"\"\n        # We'd like to make Interface the lowest priority as a\n        # property of the resolution order algorithm. That almost\n        # works out naturally, but it fails when class inheritance has\n        # some bases that DO implement an interface, and some that DO\n        # NOT. In such a mixed scenario, you wind up with a set of\n        # bases to consider that look like this: [[..., Interface],\n        # [..., object], ...]. Depending on the order if inheritance,\n        # Interface can wind up before or after object, and that can\n        # happen at any point in the tree, meaning Interface can wind\n        # up somewhere in the middle of the order. Since Interface is\n        # treated as something that everything winds up implementing\n        # anyway (a catch-all for things like adapters), having it high up\n        # the order is bad. It's also bad to have it at the end, just before\n        # some concrete class: concrete classes should be HIGHER priority than\n        # interfaces (because there's only one class, but many implementations).\n        #\n        # One technically nice way to fix this would be to have\n        # ``implementedBy(object).__bases__ = (Interface,)``\n        #\n        # But: (1) That fails for old-style classes and (2) that causes\n        # everything to appear to *explicitly* implement Interface, when up\n        # to this point it's been an implicit virtual sort of relationship.\n        #\n        # So we force the issue by mutating the resolution order.\n\n        # Note that we let C3 use pre-computed __sro__ for our bases.\n        # This requires that by the time this method is invoked, our bases\n        # have settled their SROs. Thus, ``changed()`` must first\n        # update itself before telling its descendents of changes.\n        sro = calculate_ro(self, base_mros={\n            b: b.__sro__\n            for b in self.__bases__\n        })\n        root = self._ROOT\n        if root is not None and sro and sro[-1] is not root:\n            # In one dataset of 1823 Interface objects, 1117 ClassProvides objects,\n            # sro[-1] was root 4496 times, and only not root 118 times. So it's\n            # probably worth checking.\n\n            # Once we don't have to deal with old-style classes,\n            # we can add a check and only do this if base_count > 1,\n            # if we tweak the bootstrapping for ``<implementedBy object>``\n            sro = [\n                x\n                for x in sro\n                if x is not root\n            ]\n            sro.append(root)\n\n        return sro\n\n    def changed(self, originally_changed):\n        \"\"\"\n        We, or something we depend on, have changed.\n\n        By the time this is called, the things we depend on,\n        such as our bases, should themselves be stable.\n        \"\"\"\n        self._v_attrs = None\n\n        implied = self._implied\n        implied.clear()\n\n        ancestors = self._calculate_sro()\n        self.__sro__ = tuple(ancestors)\n        self.__iro__ = tuple([ancestor for ancestor in ancestors\n                              if isinstance(ancestor, InterfaceClass)\n                              ])\n\n        for ancestor in ancestors:\n            # We directly imply our ancestors:\n            implied[ancestor] = ()\n\n        # Now, advise our dependents of change\n        # (being careful not to create the WeakKeyDictionary if not needed):\n        for dependent in tuple(self._dependents.keys() if self._dependents else ()):\n            dependent.changed(originally_changed)\n\n        # Just in case something called get() at some point\n        # during that process and we have a cycle of some sort\n        # make sure we didn't cache incomplete results.\n        self._v_attrs = None\n\n    def interfaces(self):\n        \"\"\"Return an iterator for the interfaces in the specification.\n        \"\"\"\n        seen = {}\n        for base in self.__bases__:\n            for interface in base.interfaces():\n                if interface not in seen:\n                    seen[interface] = 1\n                    yield interface\n\n    def extends(self, interface, strict=True):\n        \"\"\"Does the specification extend the given interface?\n\n        Test whether an interface in the specification extends the\n        given interface\n        \"\"\"\n        return ((interface in self._implied)\n                and\n                ((not strict) or (self != interface))\n                )\n\n    def weakref(self, callback=None):\n        return weakref.ref(self, callback)\n\n    def get(self, name, default=None):\n        \"\"\"Query for an attribute description\n        \"\"\"\n        attrs = self._v_attrs\n        if attrs is None:\n            attrs = self._v_attrs = {}\n        attr = attrs.get(name)\n        if attr is None:\n            for iface in self.__iro__:\n                attr = iface.direct(name)\n                if attr is not None:\n                    attrs[name] = attr\n                    break\n\n        return default if attr is None else attr\n\n\nclass _InterfaceMetaClass(type):\n    # Handling ``__module__`` on ``InterfaceClass`` is tricky. We need\n    # to be able to read it on a type and get the expected string. We\n    # also need to be able to set it on an instance and get the value\n    # we set. So far so good. But what gets tricky is that we'd like\n    # to store the value in the C structure (``InterfaceBase.__ibmodule__``) for\n    # direct access during equality, sorting, and hashing. \"No\n    # problem, you think, I'll just use a property\" (well, the C\n    # equivalents, ``PyMemberDef`` or ``PyGetSetDef``).\n    #\n    # Except there is a problem. When a subclass is created, the\n    # metaclass (``type``) always automatically puts the expected\n    # string in the class's dictionary under ``__module__``, thus\n    # overriding the property inherited from the superclass. Writing\n    # ``Subclass.__module__`` still works, but\n    # ``Subclass().__module__`` fails.\n    #\n    # There are multiple ways to work around this:\n    #\n    # (1) Define ``InterfaceBase.__getattribute__`` to watch for\n    # ``__module__`` and return the C storage.\n    #\n    # This works, but slows down *all* attribute access (except,\n    # ironically, to ``__module__``) by about 25% (40ns becomes 50ns)\n    # (when implemented in C). Since that includes methods like\n    # ``providedBy``, that's probably not acceptable.\n    #\n    # All the other methods involve modifying subclasses. This can be\n    # done either on the fly in some cases, as instances are\n    # constructed, or by using a metaclass. These next few can be done on the fly.\n    #\n    # (2) Make ``__module__`` a descriptor in each subclass dictionary.\n    # It can't be a straight up ``@property`` descriptor, though, because accessing\n    # it on the class returns a ``property`` object, not the desired string.\n    #\n    # (3) Implement a data descriptor (``__get__`` and ``__set__``)\n    # that is both a subclass of string, and also does the redirect of\n    # ``__module__`` to ``__ibmodule__`` and does the correct thing\n    # with the ``instance`` argument to ``__get__`` is None (returns\n    # the class's value.) (Why must it be a subclass of string? Because\n    # when it' s in the class's dict, it's defined on an *instance* of the\n    # metaclass; descriptors in an instance's dict aren't honored --- their\n    # ``__get__`` is never invoked --- so it must also *be* the value we want\n    # returned.)\n    #\n    # This works, preserves the ability to read and write\n    # ``__module__``, and eliminates any penalty accessing other\n    # attributes. But it slows down accessing ``__module__`` of\n    # instances by 200% (40ns to 124ns), requires editing class dicts on the fly\n    # (in InterfaceClass.__init__), thus slightly slowing down all interface creation,\n    # and is ugly.\n    #\n    # (4) As in the last step, but make it a non-data descriptor (no ``__set__``).\n    #\n    # If you then *also* store a copy of ``__ibmodule__`` in\n    # ``__module__`` in the instance's dict, reading works for both\n    # class and instance and is full speed for instances. But the cost\n    # is storage space, and you can't write to it anymore, not without\n    # things getting out of sync.\n    #\n    # (Actually, ``__module__`` was never meant to be writable. Doing\n    # so would break BTrees and normal dictionaries, as well as the\n    # repr, maybe more.)\n    #\n    # That leaves us with a metaclass. (Recall that a class is an\n    # instance of its metaclass, so properties/descriptors defined in\n    # the metaclass are used when accessing attributes on the\n    # instance/class. We'll use that to define ``__module__``.) Here\n    # we can have our cake and eat it too: no extra storage, and\n    # C-speed access to the underlying storage. The only substantial\n    # cost is that metaclasses tend to make people's heads hurt. (But\n    # still less than the descriptor-is-string, hopefully.)\n\n    __slots__ = ()\n\n    def __new__(cls, name, bases, attrs):\n        # Figure out what module defined the interface.\n        # This is copied from ``InterfaceClass.__init__``;\n        # reviewers aren't sure how AttributeError or KeyError\n        # could be raised.\n        __module__ = sys._getframe(1).f_globals['__name__']\n        # Get the C optimized __module__ accessor and give it\n        # to the new class.\n        moduledescr = InterfaceBase.__dict__['__module__']\n        if isinstance(moduledescr, str):\n            # We're working with the Python implementation,\n            # not the C version\n            moduledescr = InterfaceBase.__dict__['__module_property__']\n        attrs['__module__'] = moduledescr\n        kind = type.__new__(cls, name, bases, attrs)\n        kind.__module = __module__\n        return kind\n\n    @property\n    def __module__(cls):\n        return cls.__module\n\n    def __repr__(cls):\n        return \"<class '%s.%s'>\" % (\n            cls.__module,\n            cls.__name__,\n        )\n\n\n_InterfaceClassBase = _InterfaceMetaClass(\n    'InterfaceClass',\n    # From least specific to most specific.\n    (InterfaceBase, Specification, Element),\n    {'__slots__': ()}\n)\n\n\ndef interfacemethod(func):\n    \"\"\"\n    Convert a method specification to an actual method of the interface.\n\n    This is a decorator that functions like `staticmethod` et al.\n\n    The primary use of this decorator is to allow interface definitions to\n    define the ``__adapt__`` method, but other interface methods can be\n    overridden this way too.\n\n    .. seealso:: `zope.interface.interfaces.IInterfaceDeclaration.interfacemethod`\n    \"\"\"\n    f_locals = sys._getframe(1).f_locals\n    methods = f_locals.setdefault(INTERFACE_METHODS, {})\n    methods[func.__name__] = func\n    return _decorator_non_return\n\n\nclass InterfaceClass(_InterfaceClassBase):\n    \"\"\"\n    Prototype (scarecrow) Interfaces Implementation.\n\n    Note that it is not possible to change the ``__name__`` or ``__module__``\n    after an instance of this object has been constructed.\n    \"\"\"\n\n    # We can't say this yet because we don't have enough\n    # infrastructure in place.\n    #\n    #implements(IInterface)\n\n    def __new__(cls, name=None, bases=(), attrs=None, __doc__=None, # pylint:disable=redefined-builtin\n                __module__=None):\n        assert isinstance(bases, tuple)\n        attrs = attrs or {}\n        needs_custom_class = attrs.pop(INTERFACE_METHODS, None)\n        if needs_custom_class:\n            needs_custom_class.update(\n                {'__classcell__': attrs.pop('__classcell__')}\n                if '__classcell__' in attrs\n                else {}\n            )\n            if '__adapt__' in needs_custom_class:\n                # We need to tell the C code to call this.\n                needs_custom_class['_CALL_CUSTOM_ADAPT'] = 1\n\n            if issubclass(cls, _InterfaceClassWithCustomMethods):\n                cls_bases = (cls,)\n            elif cls is InterfaceClass:\n                cls_bases = (_InterfaceClassWithCustomMethods,)\n            else:\n                cls_bases = (cls, _InterfaceClassWithCustomMethods)\n\n            cls = type(cls)( # pylint:disable=self-cls-assignment\n                name + \"<WithCustomMethods>\",\n                cls_bases,\n                needs_custom_class\n            )\n        elif PY2 and bases and len(bases) > 1:\n            bases_with_custom_methods = tuple(\n                type(b)\n                for b in bases\n                if issubclass(type(b), _InterfaceClassWithCustomMethods)\n            )\n\n            # If we have a subclass of InterfaceClass in *bases*,\n            # Python 3 is smart enough to pass that as *cls*, but Python\n            # 2 just passes whatever the first base in *bases* is. This means that if\n            # we have multiple inheritance, and one of our bases has already defined\n            # a custom method like ``__adapt__``, we do the right thing automatically\n            # and extend it on Python 3, but not necessarily on Python 2. To fix this, we need\n            # to run the MRO algorithm and get the most derived base manually.\n            # Note that this only works for consistent resolution orders\n            if bases_with_custom_methods:\n                cls = type( # pylint:disable=self-cls-assignment\n                    name + \"<WithCustomMethods>\",\n                    bases_with_custom_methods,\n                    {}\n                ).__mro__[1] # Not the class we created, the most derived.\n\n        return _InterfaceClassBase.__new__(cls)\n\n    def __init__(self, name, bases=(), attrs=None, __doc__=None,  # pylint:disable=redefined-builtin\n                 __module__=None):\n        # We don't call our metaclass parent directly\n        # pylint:disable=non-parent-init-called\n        # pylint:disable=super-init-not-called\n        if not all(isinstance(base, InterfaceClass) for base in bases):\n            raise TypeError('Expected base interfaces')\n\n        if attrs is None:\n            attrs = {}\n\n        if __module__ is None:\n            __module__ = attrs.get('__module__')\n            if isinstance(__module__, str):\n                del attrs['__module__']\n            else:\n                try:\n                    # Figure out what module defined the interface.\n                    # This is how cPython figures out the module of\n                    # a class, but of course it does it in C. :-/\n                    __module__ = sys._getframe(1).f_globals['__name__']\n                except (AttributeError, KeyError): # pragma: no cover\n                    pass\n\n        InterfaceBase.__init__(self, name, __module__)\n        # These asserts assisted debugging the metaclass\n        # assert '__module__' not in self.__dict__\n        # assert self.__ibmodule__ is self.__module__ is __module__\n\n        d = attrs.get('__doc__')\n        if d is not None:\n            if not isinstance(d, Attribute):\n                if __doc__ is None:\n                    __doc__ = d\n                del attrs['__doc__']\n\n        if __doc__ is None:\n            __doc__ = ''\n\n        Element.__init__(self, name, __doc__)\n\n        tagged_data = attrs.pop(TAGGED_DATA, None)\n        if tagged_data is not None:\n            for key, val in tagged_data.items():\n                self.setTaggedValue(key, val)\n\n        Specification.__init__(self, bases)\n        self.__attrs = self.__compute_attrs(attrs)\n\n        self.__identifier__ = \"%s.%s\" % (__module__, name)\n\n    def __compute_attrs(self, attrs):\n        # Make sure that all recorded attributes (and methods) are of type\n        # `Attribute` and `Method`\n        def update_value(aname, aval):\n            if isinstance(aval, Attribute):\n                aval.interface = self\n                if not aval.__name__:\n                    aval.__name__ = aname\n            elif isinstance(aval, FunctionType):\n                aval = fromFunction(aval, self, name=aname)\n            else:\n                raise InvalidInterface(\"Concrete attribute, \" + aname)\n            return aval\n\n        return {\n            aname: update_value(aname, aval)\n            for aname, aval in attrs.items()\n            if aname not in (\n                # __locals__: Python 3 sometimes adds this.\n                '__locals__',\n                # __qualname__: PEP 3155 (Python 3.3+)\n                '__qualname__',\n                # __annotations__: PEP 3107 (Python 3.0+)\n                '__annotations__',\n            )\n            and aval is not _decorator_non_return\n        }\n\n    def interfaces(self):\n        \"\"\"Return an iterator for the interfaces in the specification.\n        \"\"\"\n        yield self\n\n    def getBases(self):\n        return self.__bases__\n\n    def isEqualOrExtendedBy(self, other):\n        \"\"\"Same interface or extends?\"\"\"\n        return self == other or other.extends(self)\n", "contexts_below": "    def __iter__(self):\n         return iter(self.names(all=True))\n \n     def namesAndDescriptions(self, all=False): # pylint:disable=redefined-builtin\n         \"\"\"Return attribute names and descriptions defined by interface.\"\"\"\n         if not all:\n             return self.__attrs.items()\n \n         r = {}\n         for base in self.__bases__[::-1]:\n             r.update(dict(base.namesAndDescriptions(all)))\n \n         r.update(self.__attrs)\n \n         return r.items()\n \n     def getDescriptionFor(self, name):\n         \"\"\"Return the attribute description for the given name.\"\"\"\n         r = self.get(name)\n         if r is not None:\n             return r\n \n         raise KeyError(name)\n \n     __getitem__ = getDescriptionFor\n \n     def __contains__(self, name):\n         return self.get(name) is not None\n \n     def direct(self, name):\n         return self.__attrs.get(name)\n \n     def queryDescriptionFor(self, name, default=None):\n         return self.get(name, default)\n \n     def validateInvariants(self, obj, errors=None):\n         \"\"\"validate object to defined invariants.\"\"\"\n \n         for iface in self.__iro__:\n             for invariant in iface.queryDirectTaggedValue('invariants', ()):\n                 try:\n                     invariant(obj)\n                 except Invalid as error:\n                      if errors is not None:\n                          errors.append(error)\n                      else:\n                          raise\n \n         if errors:\n             raise Invalid(errors)\n \n     def queryTaggedValue(self, tag, default=None):\n         \"\"\"\n         Queries for the value associated with *tag*, returning it from the nearest\n         interface in the ``__iro__``.\n \n         If not found, returns *default*.\n         \"\"\"\n         for iface in self.__iro__:\n             value = iface.queryDirectTaggedValue(tag, _marker)\n             if value is not _marker:\n                 return value\n         return default\n \n     def getTaggedValue(self, tag):\n         \"\"\" Returns the value associated with 'tag'. \"\"\"\n         value = self.queryTaggedValue(tag, default=_marker)\n         if value is _marker:\n             raise KeyError(tag)\n         return value\n \n     def getTaggedValueTags(self):\n         \"\"\" Returns a list of all tags. \"\"\"\n         keys = set()\n         for base in self.__iro__:\n             keys.update(base.getDirectTaggedValueTags())\n         return keys\n \n     def __repr__(self):  # pragma: no cover\n         try:\n             return self._v_repr\n         except AttributeError:\n             name = self.__name__\n             m = self.__ibmodule__\n             if m:\n                 name = '%s.%s' % (m, name)\n             r = \"<%s %s>\" % (self.__class__.__name__, name)\n             self._v_repr = r # pylint:disable=attribute-defined-outside-init\n             return r\n \n     def _call_conform(self, conform):\n         try:\n             return conform(self)\n         except TypeError: # pragma: no cover\n             # We got a TypeError. It might be an error raised by\n             # the __conform__ implementation, or *we* may have\n             # made the TypeError by calling an unbound method\n             # (object is a class).  In the later case, we behave\n             # as though there is no __conform__ method. We can\n             # detect this case by checking whether there is more\n             # than one traceback object in the traceback chain:\n             if sys.exc_info()[2].tb_next is not None:\n                 # There is more than one entry in the chain, so\n                 # reraise the error:\n                 raise\n             # This clever trick is from Phillip Eby\n \n         return None # pragma: no cover\n \n     def __reduce__(self):\n         return self.__name__\n \n Interface = InterfaceClass(\"Interface\", __module__='zope.interface')\n # Interface is the only member of its own SRO.\n Interface._calculate_sro = lambda: (Interface,)\n Interface.changed(Interface)\n assert Interface.__sro__ == (Interface,)\n Specification._ROOT = Interface\n ro._ROOT = Interface\n \n class _InterfaceClassWithCustomMethods(InterfaceClass):\n     \"\"\"\n     Marker class for interfaces with custom methods that override InterfaceClass methods.\n     \"\"\"\n \n \n class Attribute(Element):\n     \"\"\"Attribute descriptions\n     \"\"\"\n \n     # We can't say this yet because we don't have enough\n     # infrastructure in place.\n     #\n     # implements(IAttribute)\n \n     interface = None\n \n     def _get_str_info(self):\n         \"\"\"Return extra data to put at the end of __str__.\"\"\"\n         return \"\"\n \n     def __str__(self):\n         of = ''\n         if self.interface is not None:\n             of = self.interface.__module__ + '.' + self.interface.__name__ + '.'\n         # self.__name__ may be None during construction (e.g., debugging)\n         return of + (self.__name__ or '<unknown>') + self._get_str_info()\n \n     def __repr__(self):\n         return \"<%s.%s object at 0x%x %s>\" % (\n             type(self).__module__,\n             type(self).__name__,\n             id(self),\n             self\n         )\n \n \n class Method(Attribute):\n     \"\"\"Method interfaces\n \n     The idea here is that you have objects that describe methods.\n     This provides an opportunity for rich meta-data.\n     \"\"\"\n \n     # We can't say this yet because we don't have enough\n     # infrastructure in place.\n     #\n     # implements(IMethod)\n \n     positional = required = ()\n     _optional = varargs = kwargs = None\n     def _get_optional(self):\n         if self._optional is None:\n             return {}\n         return self._optional\n     def _set_optional(self, opt):\n         self._optional = opt\n     def _del_optional(self):\n         self._optional = None\n     optional = property(_get_optional, _set_optional, _del_optional)\n \n     def __call__(self, *args, **kw):\n         raise BrokenImplementation(self.interface, self.__name__)\n \n     def getSignatureInfo(self):\n         return {'positional': self.positional,\n                 'required': self.required,\n                 'optional': self.optional,\n                 'varargs': self.varargs,\n                 'kwargs': self.kwargs,\n                 }\n \n     def getSignatureString(self):\n         sig = []\n         for v in self.positional:\n             sig.append(v)\n             if v in self.optional.keys():\n                 sig[-1] += \"=\" + repr(self.optional[v])\n         if self.varargs:\n             sig.append(\"*\" + self.varargs)\n         if self.kwargs:\n             sig.append(\"**\" + self.kwargs)\n \n         return \"(%s)\" % \", \".join(sig)\n \n     _get_str_info = getSignatureString\n \n \n def fromFunction(func, interface=None, imlevel=0, name=None):\n     name = name or func.__name__\n     method = Method(name, func.__doc__)\n     defaults = getattr(func, '__defaults__', None) or ()\n     code = func.__code__\n     # Number of positional arguments\n     na = code.co_argcount - imlevel\n     names = code.co_varnames[imlevel:]\n     opt = {}\n     # Number of required arguments\n     defaults_count = len(defaults)\n     if not defaults_count:\n         # PyPy3 uses ``__defaults_count__`` for builtin methods\n         # like ``dict.pop``. Surprisingly, these don't have recorded\n         # ``__defaults__``\n         defaults_count = getattr(func, '__defaults_count__', 0)\n \n     nr = na - defaults_count\n     if nr < 0:\n         defaults = defaults[-nr:]\n         nr = 0\n \n     # Determine the optional arguments.\n     opt.update(dict(zip(names[nr:], defaults)))\n \n     method.positional = names[:na]\n     method.required = names[:nr]\n     method.optional = opt\n \n     argno = na\n \n     # Determine the function's variable argument's name (i.e. *args)\n     if code.co_flags & CO_VARARGS:\n         method.varargs = names[argno]\n         argno = argno + 1\n     else:\n         method.varargs = None\n \n     # Determine the function's keyword argument's name (i.e. **kw)\n     if code.co_flags & CO_VARKEYWORDS:\n         method.kwargs = names[argno]\n     else:\n         method.kwargs = None\n \n     method.interface = interface\n \n     for key, value in func.__dict__.items():\n         method.setTaggedValue(key, value)\n \n     return method\n \n \n def fromMethod(meth, interface=None, name=None):\n     if isinstance(meth, MethodType):\n         func = meth.__func__\n     else:\n         func = meth\n     return fromFunction(func, interface, imlevel=1, name=name)\n \n \n # Now we can create the interesting interfaces and wire them up:\n def _wire():\n     from zope.interface.declarations import classImplements\n     # From lest specific to most specific.\n     from zope.interface.interfaces import IElement\n     classImplements(Element, IElement)\n \n     from zope.interface.interfaces import IAttribute\n     classImplements(Attribute, IAttribute)\n \n     from zope.interface.interfaces import IMethod\n     classImplements(Method, IMethod)\n \n     from zope.interface.interfaces import ISpecification\n     classImplements(Specification, ISpecification)\n \n     from zope.interface.interfaces import IInterface\n     classImplements(InterfaceClass, IInterface)\n \n \n # We import this here to deal with module dependencies.\n # pylint:disable=wrong-import-position\n from zope.interface.declarations import implementedBy\n from zope.interface.declarations import providedBy\n from zope.interface.exceptions import InvalidInterface\n from zope.interface.exceptions import BrokenImplementation\n \n # This ensures that ``Interface`` winds up in the flattened()\n # list of the immutable declaration. It correctly overrides changed()\n # as a no-op, so we bypass that.\n from zope.interface.declarations import _empty\n Specification.changed(_empty, _empty)\n ", "input_code": "def names(self, all=False):\n\"\"\"\nReturn the attribute names defined by the interface.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def names(self, all=False): # pylint:disable=redefined-builtin\n        \"\"\"Return the attribute names defined by the interface.\"\"\"\n        if not all:\n            return self.__attrs.keys()\n\n        r = self.__attrs.copy()\n\n        for base in self.__bases__:\n            r.update(dict.fromkeys(base.names(all)))\n\n        return r.keys()", "signature": "def names(self, all=False):", "completion_path": "src/zope/interface/interface.py"}
{"ce_id": "62b8b3d6eb7e40a82d2d111c", "namespace": "62b8b3d6eb7e40a82d2d111c", "namespace_real": "src.zope.interface.declarations._normalizeargs", "real_proj_path": "pexip---os-zope/", "type": "function", "class_name": null, "function_name": "_normalizeargs", "contexts_above": "##############################################################################\n# Copyright (c) 2003 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n##############################################################################\n\"\"\"Implementation of interface declarations\n\nThere are three flavors of declarations:\n\n  - Declarations are used to simply name declared interfaces.\n\n  - ImplementsDeclarations are used to express the interfaces that a\n    class implements (that instances of the class provides).\n\n    Implements specifications support inheriting interfaces.\n\n  - ProvidesDeclarations are used to express interfaces directly\n    provided by objects.\n\n\"\"\"\n__docformat__ = 'restructuredtext'\n\nimport sys\nfrom types import FunctionType\nfrom types import MethodType\nfrom types import ModuleType\nimport weakref\n\nfrom zope.interface.advice import addClassAdvisor\nfrom zope.interface.interface import Interface\nfrom zope.interface.interface import InterfaceClass\nfrom zope.interface.interface import SpecificationBase\nfrom zope.interface.interface import Specification\nfrom zope.interface.interface import NameAndModuleComparisonMixin\nfrom zope.interface._compat import CLASS_TYPES as DescriptorAwareMetaClasses\nfrom zope.interface._compat import PYTHON3\nfrom zope.interface._compat import _use_c_impl\n\n__all__ = [\n    # None. The public APIs of this module are\n    # re-exported from zope.interface directly.\n]\n\n# pylint:disable=too-many-lines\n\n# Registry of class-implementation specifications\nBuiltinImplementationSpecifications = {}\n\n_ADVICE_ERROR = ('Class advice impossible in Python3.  '\n                 'Use the @%s class decorator instead.')\n\n_ADVICE_WARNING = ('The %s API is deprecated, and will not work in Python3  '\n                   'Use the @%s class decorator instead.')\n\ndef _next_super_class(ob):\n    # When ``ob`` is an instance of ``super``, return\n    # the next class in the MRO that we should actually be\n    # looking at. Watch out for diamond inheritance!\n    self_class = ob.__self_class__\n    class_that_invoked_super = ob.__thisclass__\n    complete_mro = self_class.__mro__\n    next_class = complete_mro[complete_mro.index(class_that_invoked_super) + 1]\n    return next_class\n\nclass named(object):\n\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self, ob):\n        ob.__component_name__ = self.name\n        return ob\n\n\nclass Declaration(Specification):\n    \"\"\"Interface declarations\"\"\"\n\n    __slots__ = ()\n\n    def __init__(self, *bases):\n        Specification.__init__(self, _normalizeargs(bases))\n\n    def __contains__(self, interface):\n        \"\"\"Test whether an interface is in the specification\n        \"\"\"\n\n        return self.extends(interface) and interface in self.interfaces()\n\n    def __iter__(self):\n        \"\"\"Return an iterator for the interfaces in the specification\n        \"\"\"\n        return self.interfaces()\n\n    def flattened(self):\n        \"\"\"Return an iterator of all included and extended interfaces\n        \"\"\"\n        return iter(self.__iro__)\n\n    def __sub__(self, other):\n        \"\"\"Remove interfaces from a specification\n        \"\"\"\n        return Declaration(*[\n            i for i in self.interfaces()\n            if not [\n                j\n                for j in other.interfaces()\n                if i.extends(j, 0) # non-strict extends\n            ]\n        ])\n\n    def __add__(self, other):\n        \"\"\"Add two specifications or a specification and an interface\n        \"\"\"\n        seen = {}\n        result = []\n        for i in self.interfaces():\n            seen[i] = 1\n            result.append(i)\n        for i in other.interfaces():\n            if i not in seen:\n                seen[i] = 1\n                result.append(i)\n\n        return Declaration(*result)\n\n    __radd__ = __add__\n\n\nclass _ImmutableDeclaration(Declaration):\n    # A Declaration that is immutable. Used as a singleton to\n    # return empty answers for things like ``implementedBy``.\n    # We have to define the actual singleton after normalizeargs\n    # is defined, and that in turn is defined after InterfaceClass and\n    # Implements.\n\n    __slots__ = ()\n\n    __instance = None\n\n    def __new__(cls):\n        if _ImmutableDeclaration.__instance is None:\n            _ImmutableDeclaration.__instance = object.__new__(cls)\n        return _ImmutableDeclaration.__instance\n\n    def __reduce__(self):\n        return \"_empty\"\n\n    @property\n    def __bases__(self):\n        return ()\n\n    @__bases__.setter\n    def __bases__(self, new_bases):\n        # We expect the superclass constructor to set ``self.__bases__ = ()``.\n        # Rather than attempt to special case that in the constructor and allow\n        # setting __bases__ only at that time, it's easier to just allow setting\n        # the empty tuple at any time. That makes ``x.__bases__ = x.__bases__`` a nice\n        # no-op too. (Skipping the superclass constructor altogether is a recipe\n        # for maintenance headaches.)\n        if new_bases != ():\n            raise TypeError(\"Cannot set non-empty bases on shared empty Declaration.\")\n\n    # As the immutable empty declaration, we cannot be changed.\n    # This means there's no logical reason for us to have dependents\n    # or subscriptions: we'll never notify them. So there's no need for\n    # us to keep track of any of that.\n    @property\n    def dependents(self):\n        return {}\n\n    changed = subscribe = unsubscribe = lambda self, _ignored: None\n\n    def interfaces(self):\n        # An empty iterator\n        return iter(())\n\n    def extends(self, interface, strict=True):\n        return interface is self._ROOT\n\n    def get(self, name, default=None):\n        return default\n\n    def weakref(self, callback=None):\n        # We're a singleton, we never go away. So there's no need to return\n        # distinct weakref objects here; their callbacks will never\n        # be called. Instead, we only need to return a callable that\n        # returns ourself. The easiest one is to return _ImmutableDeclaration\n        # itself; testing on Python 3.8 shows that's faster than a function that\n        # returns _empty. (Remember, one goal is to avoid allocating any\n        # object, and that includes a method.)\n        return _ImmutableDeclaration\n\n    @property\n    def _v_attrs(self):\n        # _v_attrs is not a public, documented property, but some client\n        # code uses it anyway as a convenient place to cache things. To keep\n        # the empty declaration truly immutable, we must ignore that. That includes\n        # ignoring assignments as well.\n        return {}\n\n    @_v_attrs.setter\n    def _v_attrs(self, new_attrs):\n        pass\n\n\n##############################################################################\n#\n# Implementation specifications\n#\n# These specify interfaces implemented by instances of classes\n\nclass Implements(NameAndModuleComparisonMixin,\n                 Declaration):\n    # Inherit from NameAndModuleComparisonMixin to be\n    # mutually comparable with InterfaceClass objects.\n    # (The two must be mutually comparable to be able to work in e.g., BTrees.)\n    # Instances of this class generally don't have a __module__ other than\n    # `zope.interface.declarations`, whereas they *do* have a __name__ that is the\n    # fully qualified name of the object they are representing.\n\n    # Note, though, that equality and hashing are still identity based. This\n    # accounts for things like nested objects that have the same name (typically\n    # only in tests) and is consistent with pickling. As far as comparisons to InterfaceClass\n    # goes, we'll never have equal name and module to those, so we're still consistent there.\n    # Instances of this class are essentially intended to be unique and are\n    # heavily cached (note how our __reduce__ handles this) so having identity\n    # based hash and eq should also work.\n\n    # We want equality and hashing to be based on identity. However, we can't actually\n    # implement __eq__/__ne__ to do this because sometimes we get wrapped in a proxy.\n    # We need to let the proxy types implement these methods so they can handle unwrapping\n    # and then rely on: (1) the interpreter automatically changing `implements == proxy` into\n    # `proxy == implements` (which will call proxy.__eq__ to do the unwrapping) and then\n    # (2) the default equality and hashing semantics being identity based.\n\n    # class whose specification should be used as additional base\n    inherit = None\n\n    # interfaces actually declared for a class\n    declared = ()\n\n    # Weak cache of {class: <implements>} for super objects.\n    # Created on demand. These are rare, as of 5.0 anyway. Using a class\n    # level default doesn't take space in instances. Using _v_attrs would be\n    # another place to store this without taking space unless needed.\n    _super_cache = None\n\n    __name__ = '?'\n\n    @classmethod\n    def named(cls, name, *bases):\n        # Implementation method: Produce an Implements interface with\n        # a fully fleshed out __name__ before calling the constructor, which\n        # sets bases to the given interfaces and which may pass this object to\n        # other objects (e.g., to adjust dependents). If they're sorting or comparing\n        # by name, this needs to be set.\n        inst = cls.__new__(cls)\n        inst.__name__ = name\n        inst.__init__(*bases)\n        return inst\n\n    def changed(self, originally_changed):\n        try:\n            del self._super_cache\n        except AttributeError:\n            pass\n        return super(Implements, self).changed(originally_changed)\n\n    def __repr__(self):\n        return '<implementedBy %s>' % (self.__name__)\n\n    def __reduce__(self):\n        return implementedBy, (self.inherit, )\n\n\ndef _implements_name(ob):\n    # Return the __name__ attribute to be used by its __implemented__\n    # property.\n    # This must be stable for the \"same\" object across processes\n    # because it is used for sorting. It needn't be unique, though, in cases\n    # like nested classes named Foo created by different functions, because\n    # equality and hashing is still based on identity.\n    # It might be nice to use __qualname__ on Python 3, but that would produce\n    # different values between Py2 and Py3.\n    return (getattr(ob, '__module__', '?') or '?') + \\\n        '.' + (getattr(ob, '__name__', '?') or '?')\n\n\ndef _implementedBy_super(sup):\n    # TODO: This is now simple enough we could probably implement\n    # in C if needed.\n\n    # If the class MRO is strictly linear, we could just\n    # follow the normal algorithm for the next class in the\n    # search order (e.g., just return\n    # ``implemented_by_next``). But when diamond inheritance\n    # or mixins + interface declarations are present, we have\n    # to consider the whole MRO and compute a new Implements\n    # that excludes the classes being skipped over but\n    # includes everything else.\n    implemented_by_self = implementedBy(sup.__self_class__)\n    cache = implemented_by_self._super_cache # pylint:disable=protected-access\n    if cache is None:\n        cache = implemented_by_self._super_cache = weakref.WeakKeyDictionary()\n\n    key = sup.__thisclass__\n    try:\n        return cache[key]\n    except KeyError:\n        pass\n\n    next_cls = _next_super_class(sup)\n    # For ``implementedBy(cls)``:\n    # .__bases__ is .declared + [implementedBy(b) for b in cls.__bases__]\n    # .inherit is cls\n\n    implemented_by_next = implementedBy(next_cls)\n    mro = sup.__self_class__.__mro__\n    ix_next_cls = mro.index(next_cls)\n    classes_to_keep = mro[ix_next_cls:]\n    new_bases = [implementedBy(c) for c in classes_to_keep]\n\n    new = Implements.named(\n        implemented_by_self.__name__ + ':' + implemented_by_next.__name__,\n        *new_bases\n    )\n    new.inherit = implemented_by_next.inherit\n    new.declared = implemented_by_next.declared\n    # I don't *think* that new needs to subscribe to ``implemented_by_self``;\n    # it auto-subscribed to its bases, and that should be good enough.\n    cache[key] = new\n\n    return new\n\n\n@_use_c_impl\ndef implementedBy(cls): # pylint:disable=too-many-return-statements,too-many-branches\n    \"\"\"Return the interfaces implemented for a class' instances\n\n      The value returned is an `~zope.interface.interfaces.IDeclaration`.\n    \"\"\"\n    try:\n        if isinstance(cls, super):\n            # Yes, this needs to be inside the try: block. Some objects\n            # like security proxies even break isinstance.\n            return _implementedBy_super(cls)\n\n        spec = cls.__dict__.get('__implemented__')\n    except AttributeError:\n\n        # we can't get the class dict. This is probably due to a\n        # security proxy.  If this is the case, then probably no\n        # descriptor was installed for the class.\n\n        # We don't want to depend directly on zope.security in\n        # zope.interface, but we'll try to make reasonable\n        # accommodations in an indirect way.\n\n        # We'll check to see if there's an implements:\n\n        spec = getattr(cls, '__implemented__', None)\n        if spec is None:\n            # There's no spec stred in the class. Maybe its a builtin:\n            spec = BuiltinImplementationSpecifications.get(cls)\n            if spec is not None:\n                return spec\n            return _empty\n\n        if spec.__class__ == Implements:\n            # we defaulted to _empty or there was a spec. Good enough.\n            # Return it.\n            return spec\n\n        # TODO: need old style __implements__ compatibility?\n        # Hm, there's an __implemented__, but it's not a spec. Must be\n        # an old-style declaration. Just compute a spec for it\n        return Declaration(*_normalizeargs((spec, )))\n\n    if isinstance(spec, Implements):\n        return spec\n\n    if spec is None:\n        spec = BuiltinImplementationSpecifications.get(cls)\n        if spec is not None:\n            return spec\n\n    # TODO: need old style __implements__ compatibility?\n    spec_name = _implements_name(cls)\n    if spec is not None:\n        # old-style __implemented__ = foo declaration\n        spec = (spec, ) # tuplefy, as it might be just an int\n        spec = Implements.named(spec_name, *_normalizeargs(spec))\n        spec.inherit = None    # old-style implies no inherit\n        del cls.__implemented__ # get rid of the old-style declaration\n    else:\n        try:\n            bases = cls.__bases__\n        except AttributeError:\n            if not callable(cls):\n                raise TypeError(\"ImplementedBy called for non-factory\", cls)\n            bases = ()\n\n        spec = Implements.named(spec_name, *[implementedBy(c) for c in bases])\n        spec.inherit = cls\n\n    try:\n        cls.__implemented__ = spec\n        if not hasattr(cls, '__providedBy__'):\n            cls.__providedBy__ = objectSpecificationDescriptor\n\n        if (isinstance(cls, DescriptorAwareMetaClasses)\n                and '__provides__' not in cls.__dict__):\n            # Make sure we get a __provides__ descriptor\n            cls.__provides__ = ClassProvides(\n                cls,\n                getattr(cls, '__class__', type(cls)),\n                )\n\n    except TypeError:\n        if not isinstance(cls, type):\n            raise TypeError(\"ImplementedBy called for non-type\", cls)\n        BuiltinImplementationSpecifications[cls] = spec\n\n    return spec\n\n\ndef classImplementsOnly(cls, *interfaces):\n    \"\"\"\n    Declare the only interfaces implemented by instances of a class\n\n    The arguments after the class are one or more interfaces or interface\n    specifications (`~zope.interface.interfaces.IDeclaration` objects).\n\n    The interfaces given (including the interfaces in the specifications)\n    replace any previous declarations, *including* inherited definitions. If you\n    wish to preserve inherited declarations, you can pass ``implementedBy(cls)``\n    in *interfaces*. This can be used to alter the interface resolution order.\n    \"\"\"\n    spec = implementedBy(cls)\n    # Clear out everything inherited. It's important to\n    # also clear the bases right now so that we don't improperly discard\n    # interfaces that are already implemented by *old* bases that we're\n    # about to get rid of.\n    spec.declared = ()\n    spec.inherit = None\n    spec.__bases__ = ()\n    _classImplements_ordered(spec, interfaces, ())\n\n\ndef classImplements(cls, *interfaces):\n    \"\"\"\n    Declare additional interfaces implemented for instances of a class\n\n    The arguments after the class are one or more interfaces or\n    interface specifications (`~zope.interface.interfaces.IDeclaration` objects).\n\n    The interfaces given (including the interfaces in the specifications)\n    are added to any interfaces previously declared. An effort is made to\n    keep a consistent C3 resolution order, but this cannot be guaranteed.\n\n    .. versionchanged:: 5.0.0\n       Each individual interface in *interfaces* may be added to either the\n       beginning or end of the list of interfaces declared for *cls*,\n       based on inheritance, in order to try to maintain a consistent\n       resolution order. Previously, all interfaces were added to the end.\n    .. versionchanged:: 5.1.0\n       If *cls* is already declared to implement an interface (or derived interface)\n       in *interfaces* through inheritance, the interface is ignored. Previously, it\n       would redundantly be made direct base of *cls*, which often produced inconsistent\n       interface resolution orders. Now, the order will be consistent, but may change.\n       Also, if the ``__bases__`` of the *cls* are later changed, the *cls* will no\n       longer be considered to implement such an interface (changing the ``__bases__`` of *cls*\n       has never been supported).\n    \"\"\"\n    spec = implementedBy(cls)\n    interfaces = tuple(_normalizeargs(interfaces))\n\n    before = []\n    after = []\n\n    # Take steps to try to avoid producing an invalid resolution\n    # order, while still allowing for BWC (in the past, we always\n    # appended)\n    for iface in interfaces:\n        for b in spec.declared:\n            if iface.extends(b):\n                before.append(iface)\n                break\n        else:\n            after.append(iface)\n    _classImplements_ordered(spec, tuple(before), tuple(after))\n\n\ndef classImplementsFirst(cls, iface):\n    \"\"\"\n    Declare that instances of *cls* additionally provide *iface*.\n\n    The second argument is an interface or interface specification.\n    It is added as the highest priority (first in the IRO) interface;\n    no attempt is made to keep a consistent resolution order.\n\n    .. versionadded:: 5.0.0\n    \"\"\"\n    spec = implementedBy(cls)\n    _classImplements_ordered(spec, (iface,), ())\n\n\ndef _classImplements_ordered(spec, before=(), after=()):\n    # Elide everything already inherited.\n    # Except, if it is the root, and we don't already declare anything else\n    # that would imply it, allow the root through. (TODO: When we disallow non-strict\n    # IRO, this part of the check can be removed because it's not possible to re-declare\n    # like that.)\n    before = [\n        x\n        for x in before\n        if not spec.isOrExtends(x) or (x is Interface and not spec.declared)\n    ]\n    after = [\n        x\n        for x in after\n        if not spec.isOrExtends(x) or (x is Interface and not spec.declared)\n    ]\n\n    # eliminate duplicates\n    new_declared = []\n    seen = set()\n    for l in before, spec.declared, after:\n        for b in l:\n            if b not in seen:\n                new_declared.append(b)\n                seen.add(b)\n\n    spec.declared = tuple(new_declared)\n\n    # compute the bases\n    bases = new_declared # guaranteed no dupes\n\n    if spec.inherit is not None:\n        for c in spec.inherit.__bases__:\n            b = implementedBy(c)\n            if b not in seen:\n                seen.add(b)\n                bases.append(b)\n\n    spec.__bases__ = tuple(bases)\n\n\ndef _implements_advice(cls):\n    interfaces, do_classImplements = cls.__dict__['__implements_advice_data__']\n    del cls.__implements_advice_data__\n    do_classImplements(cls, *interfaces)\n    return cls\n\n\nclass implementer(object):\n    \"\"\"\n    Declare the interfaces implemented by instances of a class.\n\n    This function is called as a class decorator.\n\n    The arguments are one or more interfaces or interface\n    specifications (`~zope.interface.interfaces.IDeclaration`\n    objects).\n\n    The interfaces given (including the interfaces in the\n    specifications) are added to any interfaces previously declared,\n    unless the interface is already implemented.\n\n    Previous declarations include declarations for base classes unless\n    implementsOnly was used.\n\n    This function is provided for convenience. It provides a more\n    convenient way to call `classImplements`. For example::\n\n        @implementer(I1)\n        class C(object):\n            pass\n\n    is equivalent to calling::\n\n        classImplements(C, I1)\n\n    after the class has been created.\n\n    .. seealso:: `classImplements`\n       The change history provided there applies to this function too.\n    \"\"\"\n    __slots__ = ('interfaces',)\n\n    def __init__(self, *interfaces):\n        self.interfaces = interfaces\n\n    def __call__(self, ob):\n        if isinstance(ob, DescriptorAwareMetaClasses):\n            # This is the common branch for new-style (object) and\n            # on Python 2 old-style classes.\n            classImplements(ob, *self.interfaces)\n            return ob\n\n        spec_name = _implements_name(ob)\n        spec = Implements.named(spec_name, *self.interfaces)\n        try:\n            ob.__implemented__ = spec\n        except AttributeError:\n            raise TypeError(\"Can't declare implements\", ob)\n        return ob\n\nclass implementer_only(object):\n    \"\"\"Declare the only interfaces implemented by instances of a class\n\n      This function is called as a class decorator.\n\n      The arguments are one or more interfaces or interface\n      specifications (`~zope.interface.interfaces.IDeclaration` objects).\n\n      Previous declarations including declarations for base classes\n      are overridden.\n\n      This function is provided for convenience. It provides a more\n      convenient way to call `classImplementsOnly`. For example::\n\n        @implementer_only(I1)\n        class C(object): pass\n\n      is equivalent to calling::\n\n        classImplementsOnly(I1)\n\n      after the class has been created.\n      \"\"\"\n\n    def __init__(self, *interfaces):\n        self.interfaces = interfaces\n\n    def __call__(self, ob):\n        if isinstance(ob, (FunctionType, MethodType)):\n            # XXX Does this decorator make sense for anything but classes?\n            # I don't think so. There can be no inheritance of interfaces\n            # on a method or function....\n            raise ValueError('The implementer_only decorator is not '\n                             'supported for methods or functions.')\n\n        # Assume it's a class:\n        classImplementsOnly(ob, *self.interfaces)\n        return ob\n\ndef _implements(name, interfaces, do_classImplements):\n    # This entire approach is invalid under Py3K.  Don't even try to fix\n    # the coverage for this block there. :(\n    frame = sys._getframe(2) # pylint:disable=protected-access\n    locals = frame.f_locals # pylint:disable=redefined-builtin\n\n    # Try to make sure we were called from a class def. In 2.2.0 we can't\n    # check for __module__ since it doesn't seem to be added to the locals\n    # until later on.\n    if locals is frame.f_globals or '__module__' not in locals:\n        raise TypeError(name+\" can be used only from a class definition.\")\n\n    if '__implements_advice_data__' in locals:\n        raise TypeError(name+\" can be used only once in a class definition.\")\n\n    locals['__implements_advice_data__'] = interfaces, do_classImplements\n    addClassAdvisor(_implements_advice, depth=3)\n\ndef implements(*interfaces):\n    \"\"\"\n    Declare interfaces implemented by instances of a class.\n\n    .. deprecated:: 5.0\n        This only works for Python 2. The `implementer` decorator\n        is preferred for all versions.\n\n    This function is called in a class definition.\n\n    The arguments are one or more interfaces or interface\n    specifications (`~zope.interface.interfaces.IDeclaration`\n    objects).\n\n    The interfaces given (including the interfaces in the\n    specifications) are added to any interfaces previously declared.\n\n    Previous declarations include declarations for base classes unless\n    `implementsOnly` was used.\n\n    This function is provided for convenience. It provides a more\n    convenient way to call `classImplements`. For example::\n\n        implements(I1)\n\n    is equivalent to calling::\n\n        classImplements(C, I1)\n\n    after the class has been created.\n    \"\"\"\n    # This entire approach is invalid under Py3K.  Don't even try to fix\n    # the coverage for this block there. :(\n    if PYTHON3:\n        raise TypeError(_ADVICE_ERROR % 'implementer')\n    _implements(\"implements\", interfaces, classImplements)\n\ndef implementsOnly(*interfaces):\n    \"\"\"Declare the only interfaces implemented by instances of a class\n\n      This function is called in a class definition.\n\n      The arguments are one or more interfaces or interface\n      specifications (`~zope.interface.interfaces.IDeclaration` objects).\n\n      Previous declarations including declarations for base classes\n      are overridden.\n\n      This function is provided for convenience. It provides a more\n      convenient way to call `classImplementsOnly`. For example::\n\n        implementsOnly(I1)\n\n      is equivalent to calling::\n\n        classImplementsOnly(I1)\n\n      after the class has been created.\n    \"\"\"\n    # This entire approach is invalid under Py3K.  Don't even try to fix\n    # the coverage for this block there. :(\n    if PYTHON3:\n        raise TypeError(_ADVICE_ERROR % 'implementer_only')\n    _implements(\"implementsOnly\", interfaces, classImplementsOnly)\n\n##############################################################################\n#\n# Instance declarations\n\nclass Provides(Declaration):  # Really named ProvidesClass\n    \"\"\"Implement ``__provides__``, the instance-specific specification\n\n    When an object is pickled, we pickle the interfaces that it implements.\n    \"\"\"\n\n    def __init__(self, cls, *interfaces):\n        self.__args = (cls, ) + interfaces\n        self._cls = cls\n        Declaration.__init__(self, *(interfaces + (implementedBy(cls), )))\n\n    def __repr__(self):\n        return \"<%s.%s for %s>\" % (\n            self.__class__.__module__,\n            self.__class__.__name__,\n            self._cls,\n        )\n\n    def __reduce__(self):\n        return Provides, self.__args\n\n    __module__ = 'zope.interface'\n\n    def __get__(self, inst, cls):\n        \"\"\"Make sure that a class __provides__ doesn't leak to an instance\n        \"\"\"\n        if inst is None and cls is self._cls:\n            # We were accessed through a class, so we are the class'\n            # provides spec. Just return this object, but only if we are\n            # being called on the same class that we were defined for:\n            return self\n\n        raise AttributeError('__provides__')\n\nProvidesClass = Provides\n\n# Registry of instance declarations\n# This is a memory optimization to allow objects to share specifications.\nInstanceDeclarations = weakref.WeakValueDictionary()\n\ndef Provides(*interfaces): # pylint:disable=function-redefined\n    \"\"\"Cache instance declarations\n\n      Instance declarations are shared among instances that have the same\n      declaration. The declarations are cached in a weak value dictionary.\n    \"\"\"\n    spec = InstanceDeclarations.get(interfaces)\n    if spec is None:\n        spec = ProvidesClass(*interfaces)\n        InstanceDeclarations[interfaces] = spec\n\n    return spec\n\nProvides.__safe_for_unpickling__ = True\n\n\ndef directlyProvides(object, *interfaces): # pylint:disable=redefined-builtin\n    \"\"\"Declare interfaces declared directly for an object\n\n      The arguments after the object are one or more interfaces or interface\n      specifications (`~zope.interface.interfaces.IDeclaration` objects).\n\n      The interfaces given (including the interfaces in the specifications)\n      replace interfaces previously declared for the object.\n    \"\"\"\n    cls = getattr(object, '__class__', None)\n    if cls is not None and getattr(cls, '__class__', None) is cls:\n        # It's a meta class (well, at least it it could be an extension class)\n        # Note that we can't get here from Py3k tests:  there is no normal\n        # class which isn't descriptor aware.\n        if not isinstance(object,\n                          DescriptorAwareMetaClasses):\n            raise TypeError(\"Attempt to make an interface declaration on a \"\n                            \"non-descriptor-aware class\")\n\n    interfaces = _normalizeargs(interfaces)\n    if cls is None:\n        cls = type(object)\n\n    issub = False\n    for damc in DescriptorAwareMetaClasses:\n        if issubclass(cls, damc):\n            issub = True\n            break\n    if issub:\n        # we have a class or type.  We'll use a special descriptor\n        # that provides some extra caching\n        object.__provides__ = ClassProvides(object, cls, *interfaces)\n    else:\n        object.__provides__ = Provides(cls, *interfaces)\n\n\ndef alsoProvides(object, *interfaces): # pylint:disable=redefined-builtin\n    \"\"\"Declare interfaces declared directly for an object\n\n    The arguments after the object are one or more interfaces or interface\n    specifications (`~zope.interface.interfaces.IDeclaration` objects).\n\n    The interfaces given (including the interfaces in the specifications) are\n    added to the interfaces previously declared for the object.\n    \"\"\"\n    directlyProvides(object, directlyProvidedBy(object), *interfaces)\n\n\ndef noLongerProvides(object, interface): # pylint:disable=redefined-builtin\n    \"\"\" Removes a directly provided interface from an object.\n    \"\"\"\n    directlyProvides(object, directlyProvidedBy(object) - interface)\n    if interface.providedBy(object):\n        raise ValueError(\"Can only remove directly provided interfaces.\")\n\n\n@_use_c_impl\nclass ClassProvidesBase(SpecificationBase):\n\n    __slots__ = (\n        '_cls',\n        '_implements',\n    )\n\n    def __get__(self, inst, cls):\n        # member slots are set by subclass\n        # pylint:disable=no-member\n        if cls is self._cls:\n            # We only work if called on the class we were defined for\n\n            if inst is None:\n                # We were accessed through a class, so we are the class'\n                # provides spec. Just return this object as is:\n                return self\n\n            return self._implements\n\n        raise AttributeError('__provides__')\n\n\nclass ClassProvides(Declaration, ClassProvidesBase):\n    \"\"\"Special descriptor for class ``__provides__``\n\n    The descriptor caches the implementedBy info, so that\n    we can get declarations for objects without instance-specific\n    interfaces a bit quicker.\n    \"\"\"\n\n    __slots__ = (\n        '__args',\n    )\n\n    def __init__(self, cls, metacls, *interfaces):\n        self._cls = cls\n        self._implements = implementedBy(cls)\n        self.__args = (cls, metacls, ) + interfaces\n        Declaration.__init__(self, *(interfaces + (implementedBy(metacls), )))\n\n    def __repr__(self):\n        return \"<%s.%s for %s>\" % (\n            self.__class__.__module__,\n            self.__class__.__name__,\n            self._cls,\n        )\n\n    def __reduce__(self):\n        return self.__class__, self.__args\n\n    # Copy base-class method for speed\n    __get__ = ClassProvidesBase.__get__\n\n\ndef directlyProvidedBy(object): # pylint:disable=redefined-builtin\n    \"\"\"Return the interfaces directly provided by the given object\n\n    The value returned is an `~zope.interface.interfaces.IDeclaration`.\n    \"\"\"\n    provides = getattr(object, \"__provides__\", None)\n    if (\n            provides is None # no spec\n            # We might have gotten the implements spec, as an\n            # optimization. If so, it's like having only one base, that we\n            # lop off to exclude class-supplied declarations:\n            or isinstance(provides, Implements)\n    ):\n        return _empty\n\n    # Strip off the class part of the spec:\n    return Declaration(provides.__bases__[:-1])\n\n\ndef classProvides(*interfaces):\n    \"\"\"Declare interfaces provided directly by a class\n\n      This function is called in a class definition.\n\n      The arguments are one or more interfaces or interface specifications\n      (`~zope.interface.interfaces.IDeclaration` objects).\n\n      The given interfaces (including the interfaces in the specifications)\n      are used to create the class's direct-object interface specification.\n      An error will be raised if the module class has an direct interface\n      specification. In other words, it is an error to call this function more\n      than once in a class definition.\n\n      Note that the given interfaces have nothing to do with the interfaces\n      implemented by instances of the class.\n\n      This function is provided for convenience. It provides a more convenient\n      way to call `directlyProvides` for a class. For example::\n\n        classProvides(I1)\n\n      is equivalent to calling::\n\n        directlyProvides(theclass, I1)\n\n      after the class has been created.\n    \"\"\"\n    # This entire approach is invalid under Py3K.  Don't even try to fix\n    # the coverage for this block there. :(\n\n    if PYTHON3:\n        raise TypeError(_ADVICE_ERROR % 'provider')\n\n    frame = sys._getframe(1) # pylint:disable=protected-access\n    locals = frame.f_locals # pylint:disable=redefined-builtin\n\n    # Try to make sure we were called from a class def\n    if (locals is frame.f_globals) or ('__module__' not in locals):\n        raise TypeError(\"classProvides can be used only from a \"\n                        \"class definition.\")\n\n    if '__provides__' in locals:\n        raise TypeError(\n            \"classProvides can only be used once in a class definition.\")\n\n    locals[\"__provides__\"] = _normalizeargs(interfaces)\n\n    addClassAdvisor(_classProvides_advice, depth=2)\n\ndef _classProvides_advice(cls):\n    # This entire approach is invalid under Py3K.  Don't even try to fix\n    # the coverage for this block there. :(\n    interfaces = cls.__dict__['__provides__']\n    del cls.__provides__\n    directlyProvides(cls, *interfaces)\n    return cls\n\n\nclass provider(object):\n    \"\"\"Class decorator version of classProvides\"\"\"\n\n    def __init__(self, *interfaces):\n        self.interfaces = interfaces\n\n    def __call__(self, ob):\n        directlyProvides(ob, *self.interfaces)\n        return ob\n\n\ndef moduleProvides(*interfaces):\n    \"\"\"Declare interfaces provided by a module\n\n    This function is used in a module definition.\n\n    The arguments are one or more interfaces or interface specifications\n    (`~zope.interface.interfaces.IDeclaration` objects).\n\n    The given interfaces (including the interfaces in the specifications) are\n    used to create the module's direct-object interface specification.  An\n    error will be raised if the module already has an interface specification.\n    In other words, it is an error to call this function more than once in a\n    module definition.\n\n    This function is provided for convenience. It provides a more convenient\n    way to call directlyProvides. For example::\n\n      moduleImplements(I1)\n\n    is equivalent to::\n\n      directlyProvides(sys.modules[__name__], I1)\n    \"\"\"\n    frame = sys._getframe(1) # pylint:disable=protected-access\n    locals = frame.f_locals # pylint:disable=redefined-builtin\n\n    # Try to make sure we were called from a class def\n    if (locals is not frame.f_globals) or ('__name__' not in locals):\n        raise TypeError(\n            \"moduleProvides can only be used from a module definition.\")\n\n    if '__provides__' in locals:\n        raise TypeError(\n            \"moduleProvides can only be used once in a module definition.\")\n\n    locals[\"__provides__\"] = Provides(ModuleType,\n                                      *_normalizeargs(interfaces))\n\n\n##############################################################################\n#\n# Declaration querying support\n\n# XXX:  is this a fossil?  Nobody calls it, no unit tests exercise it, no\n#       doctests import it, and the package __init__ doesn't import it.\n#       (Answer: Versions of zope.container prior to 4.4.0 called this.)\ndef ObjectSpecification(direct, cls):\n    \"\"\"Provide object specifications\n\n    These combine information for the object and for it's classes.\n    \"\"\"\n    return Provides(cls, direct) # pragma: no cover fossil\n\n@_use_c_impl\ndef getObjectSpecification(ob):\n    try:\n        provides = ob.__provides__\n    except AttributeError:\n        provides = None\n\n    if provides is not None:\n        if isinstance(provides, SpecificationBase):\n            return provides\n\n    try:\n        cls = ob.__class__\n    except AttributeError:\n        # We can't get the class, so just consider provides\n        return _empty\n    return implementedBy(cls)\n\n\n@_use_c_impl\ndef providedBy(ob):\n    \"\"\"\n    Return the interfaces provided by *ob*.\n\n    If *ob* is a :class:`super` object, then only interfaces implemented\n    by the remainder of the classes in the method resolution order are\n    considered. Interfaces directly provided by the object underlying *ob*\n    are not.\n    \"\"\"\n    # Here we have either a special object, an old-style declaration\n    # or a descriptor\n\n    # Try to get __providedBy__\n    try:\n        if isinstance(ob, super): # Some objects raise errors on isinstance()\n            return implementedBy(ob)\n\n        r = ob.__providedBy__\n    except AttributeError:\n        # Not set yet. Fall back to lower-level thing that computes it\n        return getObjectSpecification(ob)\n\n    try:\n        # We might have gotten a descriptor from an instance of a\n        # class (like an ExtensionClass) that doesn't support\n        # descriptors.  We'll make sure we got one by trying to get\n        # the only attribute, which all specs have.\n        r.extends\n    except AttributeError:\n\n        # The object's class doesn't understand descriptors.\n        # Sigh. We need to get an object descriptor, but we have to be\n        # careful.  We want to use the instance's __provides__, if\n        # there is one, but only if it didn't come from the class.\n\n        try:\n            r = ob.__provides__\n        except AttributeError:\n            # No __provides__, so just fall back to implementedBy\n            return implementedBy(ob.__class__)\n\n        # We need to make sure we got the __provides__ from the\n        # instance. We'll do this by making sure we don't get the same\n        # thing from the class:\n\n        try:\n            cp = ob.__class__.__provides__\n        except AttributeError:\n            # The ob doesn't have a class or the class has no\n            # provides, assume we're done:\n            return r\n\n        if r is cp:\n            # Oops, we got the provides from the class. This means\n            # the object doesn't have it's own. We should use implementedBy\n            return implementedBy(ob.__class__)\n\n    return r\n\n\n@_use_c_impl\nclass ObjectSpecificationDescriptor(object):\n    \"\"\"Implement the `__providedBy__` attribute\n\n    The `__providedBy__` attribute computes the interfaces provided by\n    an object.\n    \"\"\"\n\n    def __get__(self, inst, cls):\n        \"\"\"Get an object specification for an object\n        \"\"\"\n        if inst is None:\n            return getObjectSpecification(cls)\n\n        provides = getattr(inst, '__provides__', None)\n        if provides is not None:\n            return provides\n\n        return implementedBy(cls)\n\n\n##############################################################################\n", "contexts_below": "_empty = _ImmutableDeclaration()\n \n objectSpecificationDescriptor = ObjectSpecificationDescriptor()\n ", "input_code": "def _normalizeargs(sequence, output=None):\n\"\"\"\nNormalize declaration arguments\n\nNormalization arguments might contain Declarions, tuples, or single\ninterfaces.\n\nAnything but individial interfaces or implements specs will be expanded.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _normalizeargs(sequence, output=None):\n    \"\"\"Normalize declaration arguments\n\n    Normalization arguments might contain Declarions, tuples, or single\n    interfaces.\n\n    Anything but individial interfaces or implements specs will be expanded.\n    \"\"\"\n    if output is None:\n        output = []\n\n    cls = sequence.__class__\n    if InterfaceClass in cls.__mro__ or Implements in cls.__mro__:\n        output.append(sequence)\n    else:\n        for v in sequence:\n            _normalizeargs(v, output)\n\n    return output", "signature": "def _normalizeargs(sequence, output=None):", "completion_path": "src/zope/interface/declarations.py"}
{"ce_id": "62b8b3d5eb7e40a82d2d1110", "namespace": "62b8b3d5eb7e40a82d2d1110", "namespace_real": "src.zope.interface._compat._c_optimizations_available", "real_proj_path": "pexip---os-zope/", "type": "function", "class_name": null, "function_name": "_c_optimizations_available", "contexts_above": "##############################################################################\n#\n# Copyright (c) 2006 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"\nSupport functions for dealing with differences in platforms, including Python\nversions and implementations.\n\nThis file should have no imports from the rest of zope.interface because it is\nused during early bootstrapping.\n\"\"\"\nimport os\nimport sys\nimport types\n\nif sys.version_info[0] < 3:\n\n    def _normalize_name(name):\n        if isinstance(name, basestring):\n            return unicode(name)\n        raise TypeError(\"name must be a regular or unicode string\")\n\n    CLASS_TYPES = (type, types.ClassType)\n    STRING_TYPES = (basestring,)\n\n    _BUILTINS = '__builtin__'\n\n    PYTHON3 = False\n    PYTHON2 = True\n\nelse:\n\n    def _normalize_name(name):\n        if isinstance(name, bytes):\n            name = str(name, 'ascii')\n        if isinstance(name, str):\n            return name\n        raise TypeError(\"name must be a string or ASCII-only bytes\")\n\n    CLASS_TYPES = (type,)\n    STRING_TYPES = (str,)\n\n    _BUILTINS = 'builtins'\n\n    PYTHON3 = True\n    PYTHON2 = False\n\nPYPY = hasattr(sys, 'pypy_version_info')\nPYPY2 = PYTHON2 and PYPY\n\ndef _skip_under_py3k(test_method):\n    import unittest\n    return unittest.skipIf(sys.version_info[0] >= 3, \"Only on Python 2\")(test_method)\n\n\ndef _skip_under_py2(test_method):\n    import unittest\n    return unittest.skipIf(sys.version_info[0] < 3, \"Only on Python 3\")(test_method)\n\n\ndef _c_optimizations_required():\n    \"\"\"\n    Return a true value if the C optimizations are required.\n\n    This uses the ``PURE_PYTHON`` variable as documented in `_use_c_impl`.\n    \"\"\"\n    pure_env = os.environ.get('PURE_PYTHON')\n    require_c = pure_env == \"0\"\n    return require_c\n\n", "contexts_below": "\n def _c_optimizations_ignored():\n     \"\"\"\n     The opposite of `_c_optimizations_required`.\n     \"\"\"\n     pure_env = os.environ.get('PURE_PYTHON')\n     return pure_env is not None and pure_env != \"0\"\n \n \n def _should_attempt_c_optimizations():\n     \"\"\"\n     Return a true value if we should attempt to use the C optimizations.\n \n     This takes into account whether we're on PyPy and the value of the\n     ``PURE_PYTHON`` environment variable, as defined in `_use_c_impl`.\n     \"\"\"\n     is_pypy = hasattr(sys, 'pypy_version_info')\n \n     if _c_optimizations_required():\n         return True\n     if is_pypy:\n         return False\n     return not _c_optimizations_ignored()\n \n \n def _use_c_impl(py_impl, name=None, globs=None):\n     \"\"\"\n     Decorator. Given an object implemented in Python, with a name like\n     ``Foo``, import the corresponding C implementation from\n     ``zope.interface._zope_interface_coptimizations`` with the name\n     ``Foo`` and use it instead.\n \n     If the ``PURE_PYTHON`` environment variable is set to any value\n     other than ``\"0\"``, or we're on PyPy, ignore the C implementation\n     and return the Python version. If the C implementation cannot be\n     imported, return the Python version. If ``PURE_PYTHON`` is set to\n     0, *require* the C implementation (let the ImportError propagate);\n     note that PyPy can import the C implementation in this case (and all\n     tests pass).\n \n     In all cases, the Python version is kept available. in the module\n     globals with the name ``FooPy`` and the name ``FooFallback`` (both\n     conventions have been used; the C implementation of some functions\n     looks for the ``Fallback`` version, as do some of the Sphinx\n     documents).\n \n     Example::\n \n         @_use_c_impl\n         class Foo(object):\n             ...\n     \"\"\"\n     name = name or py_impl.__name__\n     globs = globs or sys._getframe(1).f_globals\n \n     def find_impl():\n         if not _should_attempt_c_optimizations():\n             return py_impl\n \n         c_opt = _c_optimizations_available()\n         if not c_opt: # pragma: no cover (only Jython doesn't build extensions)\n             return py_impl\n \n         __traceback_info__ = c_opt\n         return getattr(c_opt, name)\n \n     c_impl = find_impl()\n     # Always make available by the FooPy name and FooFallback\n     # name (for testing and documentation)\n     globs[name + 'Py'] = py_impl\n     globs[name + 'Fallback'] = py_impl\n \n     return c_impl\n ", "input_code": "def _c_optimizations_available():\n\"\"\"\nReturn the C optimization module, if available, otherwise\na false value.\n\nIf the optimizations are required but not available, this\nraises the ImportError.\n\nThis does not say whether they should be used or not.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _c_optimizations_available():\n    \"\"\"\n    Return the C optimization module, if available, otherwise\n    a false value.\n\n    If the optimizations are required but not available, this\n    raises the ImportError.\n\n    This does not say whether they should be used or not.\n    \"\"\"\n    catch = () if _c_optimizations_required() else (ImportError,)\n    try:\n        from zope.interface import _zope_interface_coptimizations as c_opt\n        return c_opt\n    except catch: # pragma: no cover (only Jython doesn't build extensions)\n        return False", "signature": "def _c_optimizations_available():", "completion_path": "src/zope/interface/_compat.py"}
{"ce_id": "62b8b3d4eb7e40a82d2d110f", "namespace": "62b8b3d4eb7e40a82d2d110f", "namespace_real": "src.zope.interface._compat._should_attempt_c_optimizations", "real_proj_path": "pexip---os-zope/", "type": "function", "class_name": null, "function_name": "_should_attempt_c_optimizations", "contexts_above": "##############################################################################\n#\n# Copyright (c) 2006 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"\nSupport functions for dealing with differences in platforms, including Python\nversions and implementations.\n\nThis file should have no imports from the rest of zope.interface because it is\nused during early bootstrapping.\n\"\"\"\nimport os\nimport sys\nimport types\n\nif sys.version_info[0] < 3:\n\n    def _normalize_name(name):\n        if isinstance(name, basestring):\n            return unicode(name)\n        raise TypeError(\"name must be a regular or unicode string\")\n\n    CLASS_TYPES = (type, types.ClassType)\n    STRING_TYPES = (basestring,)\n\n    _BUILTINS = '__builtin__'\n\n    PYTHON3 = False\n    PYTHON2 = True\n\nelse:\n\n    def _normalize_name(name):\n        if isinstance(name, bytes):\n            name = str(name, 'ascii')\n        if isinstance(name, str):\n            return name\n        raise TypeError(\"name must be a string or ASCII-only bytes\")\n\n    CLASS_TYPES = (type,)\n    STRING_TYPES = (str,)\n\n    _BUILTINS = 'builtins'\n\n    PYTHON3 = True\n    PYTHON2 = False\n\nPYPY = hasattr(sys, 'pypy_version_info')\nPYPY2 = PYTHON2 and PYPY\n\ndef _skip_under_py3k(test_method):\n    import unittest\n    return unittest.skipIf(sys.version_info[0] >= 3, \"Only on Python 2\")(test_method)\n\n\ndef _skip_under_py2(test_method):\n    import unittest\n    return unittest.skipIf(sys.version_info[0] < 3, \"Only on Python 3\")(test_method)\n\n\ndef _c_optimizations_required():\n    \"\"\"\n    Return a true value if the C optimizations are required.\n\n    This uses the ``PURE_PYTHON`` variable as documented in `_use_c_impl`.\n    \"\"\"\n    pure_env = os.environ.get('PURE_PYTHON')\n    require_c = pure_env == \"0\"\n    return require_c\n\n\ndef _c_optimizations_available():\n    \"\"\"\n    Return the C optimization module, if available, otherwise\n    a false value.\n\n    If the optimizations are required but not available, this\n    raises the ImportError.\n\n    This does not say whether they should be used or not.\n    \"\"\"\n    catch = () if _c_optimizations_required() else (ImportError,)\n    try:\n        from zope.interface import _zope_interface_coptimizations as c_opt\n        return c_opt\n    except catch: # pragma: no cover (only Jython doesn't build extensions)\n        return False\n\n\ndef _c_optimizations_ignored():\n    \"\"\"\n    The opposite of `_c_optimizations_required`.\n    \"\"\"\n    pure_env = os.environ.get('PURE_PYTHON')\n    return pure_env is not None and pure_env != \"0\"\n\n", "contexts_below": "\n def _use_c_impl(py_impl, name=None, globs=None):\n     \"\"\"\n     Decorator. Given an object implemented in Python, with a name like\n     ``Foo``, import the corresponding C implementation from\n     ``zope.interface._zope_interface_coptimizations`` with the name\n     ``Foo`` and use it instead.\n \n     If the ``PURE_PYTHON`` environment variable is set to any value\n     other than ``\"0\"``, or we're on PyPy, ignore the C implementation\n     and return the Python version. If the C implementation cannot be\n     imported, return the Python version. If ``PURE_PYTHON`` is set to\n     0, *require* the C implementation (let the ImportError propagate);\n     note that PyPy can import the C implementation in this case (and all\n     tests pass).\n \n     In all cases, the Python version is kept available. in the module\n     globals with the name ``FooPy`` and the name ``FooFallback`` (both\n     conventions have been used; the C implementation of some functions\n     looks for the ``Fallback`` version, as do some of the Sphinx\n     documents).\n \n     Example::\n \n         @_use_c_impl\n         class Foo(object):\n             ...\n     \"\"\"\n     name = name or py_impl.__name__\n     globs = globs or sys._getframe(1).f_globals\n \n     def find_impl():\n         if not _should_attempt_c_optimizations():\n             return py_impl\n \n         c_opt = _c_optimizations_available()\n         if not c_opt: # pragma: no cover (only Jython doesn't build extensions)\n             return py_impl\n \n         __traceback_info__ = c_opt\n         return getattr(c_opt, name)\n \n     c_impl = find_impl()\n     # Always make available by the FooPy name and FooFallback\n     # name (for testing and documentation)\n     globs[name + 'Py'] = py_impl\n     globs[name + 'Fallback'] = py_impl\n \n     return c_impl\n ", "input_code": "def _should_attempt_c_optimizations():\n\"\"\"\nReturn a true value if we should attempt to use the C optimizations.\n\nThis takes into account whether we're on PyPy and the value of the\n``PURE_PYTHON`` environment variable, as defined in `_use_c_impl`.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _should_attempt_c_optimizations():\n    \"\"\"\n    Return a true value if we should attempt to use the C optimizations.\n\n    This takes into account whether we're on PyPy and the value of the\n    ``PURE_PYTHON`` environment variable, as defined in `_use_c_impl`.\n    \"\"\"\n    is_pypy = hasattr(sys, 'pypy_version_info')\n\n    if _c_optimizations_required():\n        return True\n    if is_pypy:\n        return False\n    return not _c_optimizations_ignored()", "signature": "def _should_attempt_c_optimizations():", "completion_path": "src/zope/interface/_compat.py"}
{"ce_id": "62b8b3d4eb7e40a82d2d110e", "namespace": "62b8b3d4eb7e40a82d2d110e", "namespace_real": "src.zope.interface._compat._c_optimizations_ignored", "real_proj_path": "pexip---os-zope/", "type": "function", "class_name": null, "function_name": "_c_optimizations_ignored", "contexts_above": "##############################################################################\n#\n# Copyright (c) 2006 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"\nSupport functions for dealing with differences in platforms, including Python\nversions and implementations.\n\nThis file should have no imports from the rest of zope.interface because it is\nused during early bootstrapping.\n\"\"\"\nimport os\nimport sys\nimport types\n\nif sys.version_info[0] < 3:\n\n    def _normalize_name(name):\n        if isinstance(name, basestring):\n            return unicode(name)\n        raise TypeError(\"name must be a regular or unicode string\")\n\n    CLASS_TYPES = (type, types.ClassType)\n    STRING_TYPES = (basestring,)\n\n    _BUILTINS = '__builtin__'\n\n    PYTHON3 = False\n    PYTHON2 = True\n\nelse:\n\n    def _normalize_name(name):\n        if isinstance(name, bytes):\n            name = str(name, 'ascii')\n        if isinstance(name, str):\n            return name\n        raise TypeError(\"name must be a string or ASCII-only bytes\")\n\n    CLASS_TYPES = (type,)\n    STRING_TYPES = (str,)\n\n    _BUILTINS = 'builtins'\n\n    PYTHON3 = True\n    PYTHON2 = False\n\nPYPY = hasattr(sys, 'pypy_version_info')\nPYPY2 = PYTHON2 and PYPY\n\ndef _skip_under_py3k(test_method):\n    import unittest\n    return unittest.skipIf(sys.version_info[0] >= 3, \"Only on Python 2\")(test_method)\n\n\ndef _skip_under_py2(test_method):\n    import unittest\n    return unittest.skipIf(sys.version_info[0] < 3, \"Only on Python 3\")(test_method)\n\n\ndef _c_optimizations_required():\n    \"\"\"\n    Return a true value if the C optimizations are required.\n\n    This uses the ``PURE_PYTHON`` variable as documented in `_use_c_impl`.\n    \"\"\"\n    pure_env = os.environ.get('PURE_PYTHON')\n    require_c = pure_env == \"0\"\n    return require_c\n\n\ndef _c_optimizations_available():\n    \"\"\"\n    Return the C optimization module, if available, otherwise\n    a false value.\n\n    If the optimizations are required but not available, this\n    raises the ImportError.\n\n    This does not say whether they should be used or not.\n    \"\"\"\n    catch = () if _c_optimizations_required() else (ImportError,)\n    try:\n        from zope.interface import _zope_interface_coptimizations as c_opt\n        return c_opt\n    except catch: # pragma: no cover (only Jython doesn't build extensions)\n        return False\n\n", "contexts_below": "\n def _should_attempt_c_optimizations():\n     \"\"\"\n     Return a true value if we should attempt to use the C optimizations.\n \n     This takes into account whether we're on PyPy and the value of the\n     ``PURE_PYTHON`` environment variable, as defined in `_use_c_impl`.\n     \"\"\"\n     is_pypy = hasattr(sys, 'pypy_version_info')\n \n     if _c_optimizations_required():\n         return True\n     if is_pypy:\n         return False\n     return not _c_optimizations_ignored()\n \n \n def _use_c_impl(py_impl, name=None, globs=None):\n     \"\"\"\n     Decorator. Given an object implemented in Python, with a name like\n     ``Foo``, import the corresponding C implementation from\n     ``zope.interface._zope_interface_coptimizations`` with the name\n     ``Foo`` and use it instead.\n \n     If the ``PURE_PYTHON`` environment variable is set to any value\n     other than ``\"0\"``, or we're on PyPy, ignore the C implementation\n     and return the Python version. If the C implementation cannot be\n     imported, return the Python version. If ``PURE_PYTHON`` is set to\n     0, *require* the C implementation (let the ImportError propagate);\n     note that PyPy can import the C implementation in this case (and all\n     tests pass).\n \n     In all cases, the Python version is kept available. in the module\n     globals with the name ``FooPy`` and the name ``FooFallback`` (both\n     conventions have been used; the C implementation of some functions\n     looks for the ``Fallback`` version, as do some of the Sphinx\n     documents).\n \n     Example::\n \n         @_use_c_impl\n         class Foo(object):\n             ...\n     \"\"\"\n     name = name or py_impl.__name__\n     globs = globs or sys._getframe(1).f_globals\n \n     def find_impl():\n         if not _should_attempt_c_optimizations():\n             return py_impl\n \n         c_opt = _c_optimizations_available()\n         if not c_opt: # pragma: no cover (only Jython doesn't build extensions)\n             return py_impl\n \n         __traceback_info__ = c_opt\n         return getattr(c_opt, name)\n \n     c_impl = find_impl()\n     # Always make available by the FooPy name and FooFallback\n     # name (for testing and documentation)\n     globs[name + 'Py'] = py_impl\n     globs[name + 'Fallback'] = py_impl\n \n     return c_impl\n ", "input_code": "def _c_optimizations_ignored():\n\"\"\"\nThe opposite of `_c_optimizations_required`.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _c_optimizations_ignored():\n    \"\"\"\n    The opposite of `_c_optimizations_required`.\n    \"\"\"\n    pure_env = os.environ.get('PURE_PYTHON')\n    return pure_env is not None and pure_env != \"0\"", "signature": "def _c_optimizations_ignored():", "completion_path": "src/zope/interface/_compat.py"}
{"ce_id": "62b8b3d4eb7e40a82d2d110d", "namespace": "62b8b3d4eb7e40a82d2d110d", "namespace_real": "src.zope.interface._compat._c_optimizations_required", "real_proj_path": "pexip---os-zope/", "type": "function", "class_name": null, "function_name": "_c_optimizations_required", "contexts_above": "##############################################################################\n#\n# Copyright (c) 2006 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"\nSupport functions for dealing with differences in platforms, including Python\nversions and implementations.\n\nThis file should have no imports from the rest of zope.interface because it is\nused during early bootstrapping.\n\"\"\"\nimport os\nimport sys\nimport types\n\nif sys.version_info[0] < 3:\n\n    def _normalize_name(name):\n        if isinstance(name, basestring):\n            return unicode(name)\n        raise TypeError(\"name must be a regular or unicode string\")\n\n    CLASS_TYPES = (type, types.ClassType)\n    STRING_TYPES = (basestring,)\n\n    _BUILTINS = '__builtin__'\n\n    PYTHON3 = False\n    PYTHON2 = True\n\nelse:\n\n    def _normalize_name(name):\n        if isinstance(name, bytes):\n            name = str(name, 'ascii')\n        if isinstance(name, str):\n            return name\n        raise TypeError(\"name must be a string or ASCII-only bytes\")\n\n    CLASS_TYPES = (type,)\n    STRING_TYPES = (str,)\n\n    _BUILTINS = 'builtins'\n\n    PYTHON3 = True\n    PYTHON2 = False\n\nPYPY = hasattr(sys, 'pypy_version_info')\nPYPY2 = PYTHON2 and PYPY\n\ndef _skip_under_py3k(test_method):\n    import unittest\n    return unittest.skipIf(sys.version_info[0] >= 3, \"Only on Python 2\")(test_method)\n\n\ndef _skip_under_py2(test_method):\n    import unittest\n    return unittest.skipIf(sys.version_info[0] < 3, \"Only on Python 3\")(test_method)\n\n", "contexts_below": "\n def _c_optimizations_available():\n     \"\"\"\n     Return the C optimization module, if available, otherwise\n     a false value.\n \n     If the optimizations are required but not available, this\n     raises the ImportError.\n \n     This does not say whether they should be used or not.\n     \"\"\"\n     catch = () if _c_optimizations_required() else (ImportError,)\n     try:\n         from zope.interface import _zope_interface_coptimizations as c_opt\n         return c_opt\n     except catch: # pragma: no cover (only Jython doesn't build extensions)\n         return False\n \n \n def _c_optimizations_ignored():\n     \"\"\"\n     The opposite of `_c_optimizations_required`.\n     \"\"\"\n     pure_env = os.environ.get('PURE_PYTHON')\n     return pure_env is not None and pure_env != \"0\"\n \n \n def _should_attempt_c_optimizations():\n     \"\"\"\n     Return a true value if we should attempt to use the C optimizations.\n \n     This takes into account whether we're on PyPy and the value of the\n     ``PURE_PYTHON`` environment variable, as defined in `_use_c_impl`.\n     \"\"\"\n     is_pypy = hasattr(sys, 'pypy_version_info')\n \n     if _c_optimizations_required():\n         return True\n     if is_pypy:\n         return False\n     return not _c_optimizations_ignored()\n \n \n def _use_c_impl(py_impl, name=None, globs=None):\n     \"\"\"\n     Decorator. Given an object implemented in Python, with a name like\n     ``Foo``, import the corresponding C implementation from\n     ``zope.interface._zope_interface_coptimizations`` with the name\n     ``Foo`` and use it instead.\n \n     If the ``PURE_PYTHON`` environment variable is set to any value\n     other than ``\"0\"``, or we're on PyPy, ignore the C implementation\n     and return the Python version. If the C implementation cannot be\n     imported, return the Python version. If ``PURE_PYTHON`` is set to\n     0, *require* the C implementation (let the ImportError propagate);\n     note that PyPy can import the C implementation in this case (and all\n     tests pass).\n \n     In all cases, the Python version is kept available. in the module\n     globals with the name ``FooPy`` and the name ``FooFallback`` (both\n     conventions have been used; the C implementation of some functions\n     looks for the ``Fallback`` version, as do some of the Sphinx\n     documents).\n \n     Example::\n \n         @_use_c_impl\n         class Foo(object):\n             ...\n     \"\"\"\n     name = name or py_impl.__name__\n     globs = globs or sys._getframe(1).f_globals\n \n     def find_impl():\n         if not _should_attempt_c_optimizations():\n             return py_impl\n \n         c_opt = _c_optimizations_available()\n         if not c_opt: # pragma: no cover (only Jython doesn't build extensions)\n             return py_impl\n \n         __traceback_info__ = c_opt\n         return getattr(c_opt, name)\n \n     c_impl = find_impl()\n     # Always make available by the FooPy name and FooFallback\n     # name (for testing and documentation)\n     globs[name + 'Py'] = py_impl\n     globs[name + 'Fallback'] = py_impl\n \n     return c_impl\n ", "input_code": "def _c_optimizations_required():\n\"\"\"\nReturn a true value if the C optimizations are required.\n\nThis uses the ``PURE_PYTHON`` variable as documented in `_use_c_impl`.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _c_optimizations_required():\n    \"\"\"\n    Return a true value if the C optimizations are required.\n\n    This uses the ``PURE_PYTHON`` variable as documented in `_use_c_impl`.\n    \"\"\"\n    pure_env = os.environ.get('PURE_PYTHON')\n    require_c = pure_env == \"0\"\n    return require_c", "signature": "def _c_optimizations_required():", "completion_path": "src/zope/interface/_compat.py"}
{"ce_id": "62b87b989a0c4fa8b80b35ee", "namespace": "62b87b989a0c4fa8b80b35ee", "namespace_real": "lena.structures.histogram.reset", "real_proj_path": "ynikitenko---lena/", "type": "class", "class_name": "histogram", "function_name": "reset", "contexts_above": "\"\"\"Histogram structure *histogram* and element *Histogram*.\"\"\"\nimport copy\n\nimport lena.context\nimport lena.core\nimport lena.flow\nimport lena.math\nfrom . import hist_functions as hf\n\n\nclass histogram():\n    \"\"\"A multidimensional histogram.\n\n    Arbitrary dimension, variable bin size and weights are supported.\n    Lower bin edge is included, upper edge is excluded.\n    Underflow and overflow values are skipped.\n    Bin content can be of arbitrary type,\n    which is defined during initialization.\n\n    Examples:\n\n    >>> # a two-dimensional histogram\n    >>> hist = histogram([[0, 1, 2], [0, 1, 2]])\n    >>> hist.fill([0, 1])\n    >>> hist.bins\n    [[0, 1], [0, 0]]\n    >>> values = [[0, 0], [1, 0], [1, 1]]\n    >>> # fill the histogram with values\n    >>> for v in values:\n    ...     hist.fill(v)\n    >>> hist.bins\n    [[1, 1], [1, 1]]\n    \"\"\"\n    # Note the differences from existing packages.\n    # Numpy 1.16 (numpy.histogram): all but the last\n    # (righthand-most) bin is half-open.\n    # This histogram class has bin limits as in ROOT\n    # (but without overflow and underflow).\n\n    # Numpy: the first element of the range must be less than or equal to the second.\n    # This histogram requires strictly increasing edges.\n    # https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html\n    # https://root.cern.ch/root/htmldoc/guides/users-guide/Histograms.html#bin-numbering\n\n    def __init__(self, edges, bins=None, initial_value=0):\n        \"\"\"*edges* is a sequence of one-dimensional arrays,\n        each containing strictly increasing bin edges.\n\n        Histogram's bins by default\n        are initialized with *initial_value*.\n        It can be any object that supports addition with *weight*\n        during *fill* (but that is not necessary\n        if you don't plan to fill the histogram).\n        If the *initial_value* is compound and requires special copying,\n        create initial bins yourself (see :func:`.init_bins`).\n\n        A histogram can be created from existing *bins* and *edges*.\n        In this case a simple check of the shape of *bins* is done\n        (raising :exc:`.LenaValueError` if failed).\n\n        **Attributes**\n\n        :attr:`edges` is a list of edges on each dimension.\n        Edges mark the borders of the bin.\n        Edges along each dimension are one-dimensional lists,\n        and the multidimensional bin is the result of all intersections\n        of one-dimensional edges.\n        For example, a 3-dimensional histogram has edges of the form\n        *[x_edges, y_edges, z_edges]*,\n        and the 0th bin has borders\n        *((x[0], x[1]), (y[0], y[1]), (z[0], z[1]))*.\n\n        Index in the edges is a tuple, where a given position corresponds\n        to a dimension, and the content at that position\n        to the bin along that dimension.\n        For example, index *(0, 1, 3)* corresponds to the bin\n        with lower edges *(x[0], y[1], z[3])*.\n\n        :attr:`bins` is a list of nested lists.\n        Same index as for edges can be used to get bin content:\n        bin at *(0, 1, 3)* can be obtained as *bins[0][1][3]*.\n        Most nested arrays correspond to highest\n        (further from x) coordinates.\n        For example, for a 3-dimensional histogram bins equal to\n        *[[[1, 1], [0, 0]], [[0, 0], [0, 0]]]*\n        mean that the only filled bins are those\n        where x and y indices are 0, and z index is 0 and 1.\n\n        :attr:`dim` is the dimension of a histogram\n        (length of its *edges* for a multidimensional histogram).\n\n        If subarrays of *edges* are not increasing\n        or if any of them has length less than 2,\n        :exc:`.LenaValueError` is raised.\n\n        .. admonition:: Programmer's note\n\n            one- and multidimensional histograms\n            have different *bins* and *edges* format.\n            To be unified, 1-dimensional edges should be\n            nested in a list (like *[[1, 2, 3]]*).\n            Instead, they are simply the x-edges list,\n            because it is more intuitive and one-dimensional histograms\n            are used more often.\n            To unify the interface for bins and edges in your code,\n            use :func:`.unify_1_md` function.\n        \"\"\"\n        # todo: allow creation of *edges* from tuples\n        # (without lena.math.mesh). Allow bin_size in this case.\n        hf.check_edges_increasing(edges)\n        self.edges = edges\n        self._scale = None\n\n        if hasattr(edges[0], \"__iter__\"):\n            self.dim = len(edges)\n        else:\n            self.dim = 1\n\n        # todo: add a kwarg no_check=False to disable bins testing\n        if bins is None:\n            self.bins = hf.init_bins(self.edges, initial_value)\n        else:\n            self.bins = bins\n            # We can't make scale for an arbitrary histogram,\n            # because it may contain compound values.\n            # self._scale = self.make_scale()\n            wrong_bins_error = lena.core.LenaValueError(\n                \"bins of incorrect shape given, {}\".format(bins)\n            )\n            if self.dim == 1:\n                if len(bins) != len(edges) - 1:\n                    raise wrong_bins_error\n            else:\n                if len(bins) != len(edges[0]) - 1:\n                    raise wrong_bins_error\n        if self.dim > 1:\n            self.ranges = [(axis[0], axis[-1]) for axis in edges]\n            self.nbins =  [len(axis) - 1 for axis in edges]\n        else:\n            self.ranges = [(edges[0], edges[-1])]\n            self.nbins = [len(edges)-1]\n\n    def __eq__(self, other):\n        \"\"\"Two histograms are equal, if and only if they have\n        equal bins and equal edges.\n\n        If *other* is not a :class:`.histogram`, return ``False``.\n\n        Note that floating numbers should be compared\n        approximately (using :func:`math.isclose`).\n        \"\"\"\n        if not isinstance(other, histogram):\n            # in Python comparison between different types is allowed\n            return False\n        return self.bins == other.bins and self.edges == other.edges\n\n    def fill(self, coord, weight=1):\n        \"\"\"Fill histogram at *coord* with the given *weight*.\n\n        Coordinates outside the histogram edges are ignored.\n        \"\"\"\n        indices = hf.get_bin_on_value(coord, self.edges)\n        subarr = self.bins\n        for ind in indices[:-1]:\n            # underflow\n            if ind < 0:\n                return\n            try:\n                subarr = subarr[ind]\n            # overflow\n            except IndexError:\n                return\n        ind = indices[-1]\n        # underflow\n        if ind < 0:\n            return\n\n        # fill\n        try:\n            subarr[ind] += weight\n        except IndexError:\n            return\n\n    def __repr__(self):\n        return \"histogram({}, bins={})\".format(self.edges, self.bins)\n\n    def scale(self, other=None, recompute=False):\n        \"\"\"Compute or set scale (integral of the histogram).\n\n        If *other* is ``None``, return scale of this histogram.\n        If its scale was not computed before,\n        it is computed and stored for subsequent use\n        (unless explicitly asked to *recompute*).\n        Note that after changing (filling) the histogram\n        one must explicitly recompute the scale\n        if it was computed before.\n\n        If a float *other* is provided, rescale self to *other*.\n\n        Histograms with scale equal to zero can't be rescaled.\n        :exc:`.LenaValueError` is raised if one tries to do that.\n        \"\"\"\n        # see graph.scale comments why this is called simply \"scale\"\n        # (not set_scale, get_scale, etc.)\n        if other is None:\n            # return scale\n            if self._scale is None or recompute:\n                self._scale = hf.integral(\n                    *hf.unify_1_md(self.bins, self.edges)\n                )\n            return self._scale\n        else:\n            # rescale from other\n            scale = self.scale()\n            if scale == 0:\n                raise lena.core.LenaValueError(\n                    \"can not rescale histogram with zero scale\"\n                )\n            self.bins = lena.math.md_map(lambda binc: binc*float(other) / scale,\n                                         self.bins)\n            self._scale = other\n            return None\n\n    def _update_context(self, context):\n        \"\"\"Update *context* with the properties of this histogram.\n\n        *context.histogram* is updated with \"dim\", \"nbins\"\n        and \"ranges\" with values for this histogram.\n        If this histogram has a computed scale, it is also added\n        to the context.\n\n        Called on \"destruction\" of the histogram structure (for example,\n        in :class:`.ToCSV`). See graph._update_context for more details.\n        \"\"\"\n\n        hist_context = {\n            \"dim\": self.dim,\n            \"nbins\": self.nbins,\n            \"ranges\": self.ranges\n        }\n\n        if self._scale is not None:\n            hist_context[\"scale\"] = self._scale\n\n        lena.context.update_recursively(context, {\"histogram\": hist_context})\n\n\nclass Histogram():\n    \"\"\"An element to produce histograms.\"\"\"\n\n    def __init__(self, edges, bins=None, make_bins=None, initial_value=0):\n        \"\"\"*edges*, *bins* and *initial_value* have the same meaning\n        as during creation of a :class:`histogram`.\n\n        *make_bins* is a function without arguments\n        that creates new bins\n        (it will be called during :meth:`__init__` and :meth:`reset`).\n        *initial_value* in this case is ignored, but bin check is made.\n        If both *bins* and *make_bins* are provided,\n        :exc:`.LenaTypeError` is raised.\n        \"\"\"\n        self._hist = histogram(edges, bins)\n\n        if make_bins is not None and bins is not None:\n            raise lena.core.LenaTypeError(\n                \"either initial bins or make_bins must be provided, \"\n                \"not both: {} and {}\".format(bins, make_bins)\n            )\n\n        # may be None\n        self._initial_bins = copy.deepcopy(bins)\n\n        # todo: bins, make_bins, initial_value look redundant\n        # and may be reconsidered when really using reset().\n        if make_bins:\n            bins = make_bins()\n        self._make_bins = make_bins\n\n        self._cur_context = {}\n\n    def fill(self, value):\n        \"\"\"Fill the histogram with *value*.\n\n        *value* can be a *(data, context)* pair. \n        Values outside the histogram edges are ignored.\n        \"\"\"\n        data, self._cur_context = lena.flow.get_data_context(value)\n        self._hist.fill(data)\n        # filling with weight is only allowed in histogram structure\n        # self._hist.fill(data, weight)\n\n    def compute(self):\n        \"\"\"Yield histogram with context.\"\"\"\n        yield (self._hist, self._cur_context)\n", "contexts_below": "", "input_code": "def reset(self):\n\"\"\"\nReset the histogram.\n\nCurrent context is reset to an empty dict.\nBins are reinitialized with the *initial_value*\nor with *make_bins()* (depending on the initialization).\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def reset(self):\n        \"\"\"Reset the histogram.\n\n        Current context is reset to an empty dict.\n        Bins are reinitialized with the *initial_value*\n        or with *make_bins()* (depending on the initialization).\n        \"\"\"\n        if self._make_bins is not None:\n            self.bins = self._make_bins()\n        elif self._initial_bins is not None:\n            self.bins = copy.deepcopy(self._initial_bins)\n        else:\n            self.bins = hf.init_bins(self.edges, self._initial_value)\n\n        self._cur_context = {}", "signature": "def reset(self):", "completion_path": "lena/structures/histogram.py"}
{"ce_id": "62b87b859a0c4fa8b80b35d7", "namespace": "62b87b859a0c4fa8b80b35d7", "namespace_real": "lena.structures.graph.to_csv", "real_proj_path": "ynikitenko---lena/", "type": "class", "class_name": "graph", "function_name": "to_csv", "contexts_above": "\"\"\"A graph is a function at given coordinates.\"\"\"\nimport copy\nimport functools\nimport operator\nimport re\nimport warnings\n\nimport lena.core\nimport lena.context\nimport lena.flow\n\n\nclass graph():\n    \"\"\"Numeric arrays of equal size.\"\"\"\n\n    def __init__(self, coords, field_names=(\"x\", \"y\"), scale=None):\n        \"\"\"This structure generally corresponds\n        to the graph of a function\n        and represents arrays of coordinates and the function values\n        of arbitrary dimensions.\n\n        *coords* is a list of one-dimensional\n        coordinate and value sequences (usually lists).\n        There is little to no distinction between them,\n        and \"values\" can also be called \"coordinates\".\n\n        *field_names* provide the meaning of these arrays.\n        For example, a 3-dimensional graph could be distinguished\n        from a 2-dimensional graph with errors by its fields\n        (\"x\", \"y\", \"z\") versus (\"x\", \"y\", \"error_y\").\n        Field names don't affect drawing graphs:\n        for that :class:`~Variable`-s should be used.\n        Default field names,\n        provided for the most used 2-dimensional graphs,\n        are \"x\" and \"y\".\n\n        *field_names* can be a string separated by whitespace\n        and/or commas or a tuple of strings, such as (\"x\", \"y\").\n        *field_names* must have as many elements\n        as *coords* and each field name must be unique.\n        Otherwise field names are arbitrary.\n        Error fields must go after all other coordinates.\n        Name of a coordinate error is \"error\\\\_\"\n        appended by coordinate name. Further error details\n        are appended after '_'. They could be arbitrary depending\n        on the problem: \"low\", \"high\", \"low_90%_cl\", etc. Example:\n        (\"E\", \"time\", \"error_E_low\", \"error_time\").\n\n        *scale* of the graph is a kind of its norm. It could be\n        the integral of the function or its other property.\n        A scale of a normalised probability density\n        function would be one.\n        An initialized *scale* is required if one needs\n        to renormalise the graph in :meth:`scale`\n        (for example, to plot it with other graphs).\n\n        Coordinates of a function graph would usually be arrays\n        of increasing values, which is not required here.\n        Neither is it checked that coordinates indeed\n        contain one-dimensional numeric values.\n        However, non-standard graphs\n        will likely lead to errors during plotting\n        and will require more programmer's work and caution,\n        so use them only if you understand what you are doing.\n\n        A graph can be iterated yielding tuples of numbers\n        for each point.\n\n        **Attributes**\n\n        :attr:`coords` is a list \\\n            of one-dimensional lists of coordinates.\n\n        :attr:`field_names`\n\n        :attr:`dim` is the dimension of the graph,\n        that is of all its coordinates without errors.\n\n        In case of incorrect initialization arguments,\n        :exc:`~.LenaTypeError` or :exc:`~.LenaValueError` is raised.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if not coords:\n            raise lena.core.LenaValueError(\n                \"coords must be a non-empty sequence \"\n                \"of coordinate sequences\"\n            )\n\n        # require coords to be of the same size\n        pt_len = len(coords[0])\n        for arr in coords[1:]:\n            if len(arr) != pt_len:\n                raise lena.core.LenaValueError(\n                    \"coords must have subsequences of equal lengths\"\n                )\n\n        # Unicode (Python 2) field names would be just bad,\n        # so we don't check for it here.\n        if isinstance(field_names, str):\n            # split(', ') won't work.\n            # From https://stackoverflow.com/a/44785447/952234:\n            # \\s stands for whitespace.\n            field_names = tuple(re.findall(r'[^,\\s]+', field_names))\n        elif not isinstance(field_names, tuple):\n            # todo: why field_names are a tuple,\n            # while coords are a list?\n            # It might be non-Pythonic to require a tuple\n            # (to prohibit a list), but it's important\n            # for comparisons and uniformity\n            raise lena.core.LenaTypeError(\n                \"field_names must be a string or a tuple\"\n            )\n\n        if len(field_names) != len(coords):\n            raise lena.core.LenaValueError(\n                \"field_names must have must have the same size as coords\"\n            )\n\n        if len(set(field_names)) != len(field_names):\n            raise lena.core.LenaValueError(\n                \"field_names contains duplicates\"\n            )\n\n        self.coords = coords\n        self._scale = scale\n\n        # field_names are better than fields,\n        # because they are unambigous (as in namedtuple).\n        self.field_names = field_names\n\n        # decided to use \"error_x_low\" (like in ROOT).\n        # Other versions were x_error (looked better than x_err),\n        # but x_err_low looked much better than x_error_low).\n        try:\n            parsed_error_names = self._parse_error_names(field_names)\n        except lena.core.LenaValueError as err:\n            raise err\n            # in Python 3\n            # raise err from None\n        self._parsed_error_names = parsed_error_names\n\n        dim = len(field_names) - len(parsed_error_names)\n        self._coord_names = field_names[:dim]\n        self.dim = dim\n\n        # todo: add subsequences of coords as attributes\n        # with field names.\n        # In case if someone wants to create a graph of another function\n        # at the same coordinates.\n        # Should a) work when we rescale the graph\n        #        b) not interfere with other fields and methods\n\n        # Probably we won't add methods __del__(n), __add__(*coords),\n        # since it might change the scale.\n\n    def __eq__(self, other):\n        \"\"\"Two graphs are equal, if and only if they have\n        equal coordinates, field names and scales.\n\n        If *other* is not a :class:`.graph`, return ``False``.\n\n        Note that floating numbers should be compared\n        approximately (using :func:`math.isclose`).\n        Therefore this comparison may give false negatives.\n        \"\"\"\n        if not isinstance(other, graph):\n            # in Python comparison between different types is allowed\n            return False\n        return (self.coords == other.coords and self._scale == other._scale\n                and self.field_names == other.field_names)\n\n    def _get_err_indices(self, coord_name):\n        \"\"\"Get error indices corresponding to a coordinate.\"\"\"\n        err_indices = []\n        dim = self.dim\n        for ind, err in enumerate(self._parsed_error_names):\n            if err[1] == coord_name:\n                err_indices.append(ind+dim)\n        return err_indices\n\n    def __iter__(self):\n        \"\"\"Iterate graph coords one by one.\"\"\"\n        for val in zip(*self.coords):\n            yield val\n\n    def __repr__(self):\n        return \"\"\"graph({}, field_names={}, scale={})\"\"\".format(\n            self.coords, self.field_names, self._scale\n        )\n\n    def scale(self, other=None):\n        \"\"\"Get or set the scale of the graph.\n\n        If *other* is ``None``, return the scale of this graph.\n\n        If a numeric *other* is provided, rescale to that value.\n        If the graph has unknown or zero scale,\n        rescaling that will raise :exc:`~.LenaValueError`.\n\n        To get meaningful results, graph's fields are used.\n        Only the last coordinate is rescaled.\n        For example, if the graph has *x* and *y* coordinates,\n        then *y* will be rescaled, and for a 3-dimensional graph\n        *z* will be rescaled.\n        All errors are rescaled together with their coordinate.\n        \"\"\"\n        # this method is called scale() for uniformity with histograms\n        # And this looks really good: explicit for computations\n        # (not a subtle graph.scale, like a constant field (which is,\n        #  however, the case in graph - but not in other structures))\n        # and easy to remember (set_scale? rescale? change_scale_to?..)\n\n        # We modify the graph in place,\n        # because that would be redundant (not optimal)\n        # to create a new graph\n        # if we only want to change the scale of the existing one.\n\n        if other is None:\n            return self._scale\n\n        if not self._scale:\n            raise lena.core.LenaValueError(\n                \"can't rescale a graph with zero or unknown scale\"\n            )\n\n        last_coord_ind = self.dim - 1\n        last_coord_name = self.field_names[last_coord_ind]\n\n        last_coord_indices = ([last_coord_ind] +\n                self._get_err_indices(last_coord_name)\n        )\n\n        # In Python 2 3/2 is 1, so we want to be safe;\n        # the downside is that integer-valued graphs\n        # will become floating, but that is doubtfully an issue.\n        # Remove when/if dropping support for Python 2.\n        rescale = float(other) / self._scale\n\n        mul = operator.mul\n        partial = functools.partial\n\n        # a version with lambda is about 50% slower:\n        # timeit.timeit('[*map(lambda val: val*2, vals)]', \\\n        #     setup='vals = list(range(45)); from operator import mul; \\\n        #     from functools import partial')\n        # 3.159\n        # same setup for\n        # timeit.timeit('[*map(partial(mul, 2), vals)]',...):\n        # 2.075\n        # \n        # [*map(...)] is very slightly faster than list(map(...)),\n        # but it's unavailable in Python 2 (and anyway less readable).\n\n        # rescale arrays of values and errors\n        for ind, arr in enumerate(self.coords):\n            if ind in last_coord_indices:\n                # Python lists are faster than arrays,\n                # https://stackoverflow.com/a/62399645/952234\n                # (because each time taking a value from an array\n                #  creates a Python object)\n                self.coords[ind] = list(map(partial(mul, rescale),\n                                            arr))\n\n        self._scale = other\n\n        # as suggested in PEP 8\n        return None\n\n    def _parse_error_names(self, field_names):\n        # field_names is a parameter for easier testing,\n        # usually object's field_names are used.\n        errors = []\n\n        # collect all error fields and check that they are\n        # strictly after other fields\n        in_error_fields = False\n        # there is at least one field\n        last_coord_ind = 0\n        for ind, field in enumerate(field_names):\n            if field.startswith(\"error_\"):\n                in_error_fields = True\n                errors.append((field, ind))\n            else:\n                last_coord_ind = ind\n                if in_error_fields:\n                    raise lena.core.LenaValueError(\n                        \"errors must go after coordinate fields\"\n                    )\n\n        coords = set(field_names[:last_coord_ind+1])\n        parsed_errors = []\n\n        for err, ind in errors:\n            err_coords = []\n            for coord in coords:\n                err_main = err[6:]  # all after \"error_\"\n                if err_main == coord or err_main.startswith(coord + \"_\"):\n                    err_coords.append(coord)\n                    err_tail = err_main[len(coord)+1:]\n            if not err_coords:\n                raise lena.core.LenaValueError(\n                    \"no coordinate corresponding to {} given\".format(err)\n                )\n            elif len(err_coords) > 1:\n                raise lena.core.LenaValueError(\n                    \"ambiguous error \" + err +\\\n                    \" corresponding to several coordinates given\"\n                )\n            # \"error\" may be redundant, but it is explicit.\n            parsed_errors.append((\"error\", err_coords[0], err_tail, ind))\n\n        return parsed_errors\n\n    def _update_context(self, context):\n        \"\"\"Update *context* with the properties of this graph.\n\n        *context.error* is appended with indices of errors.\n        Example subcontext for a graph with fields \"E,t,error_E_low\":\n        {\"error\": {\"x_low\": {\"index\": 2}}}.\n        Note that error names are called \"x\", \"y\" and \"z\"\n        (this corresponds to first three coordinates,\n        if they are present), which allows to simplify plotting.\n        Existing values are not removed\n        from *context.value* and its subcontexts.\n\n        Called on \"destruction\" of the graph (for example,\n        in :class:`.ToCSV`). By destruction we mean conversion\n        to another structure (like text) in the flow.\n        The graph object is not really destroyed in this process.\n        \"\"\"\n        # this method is private, because we encourage users to yield\n        # graphs into the flow and process them with ToCSV element\n        # (not manually).\n\n        if not self._parsed_error_names:\n            # no error fields present\n            return\n\n        dim = self.dim\n\n        xyz_coord_names = self._coord_names[:3]\n        for name, coord_name in zip([\"x\", \"y\", \"z\"], xyz_coord_names):\n            for err in self._parsed_error_names:\n                if err[1] == coord_name:\n                    error_ind = err[3]\n                    if err[2]:\n                        # add error suffix\n                        error_name = name + \"_\" + err[2]\n                    else:\n                        error_name = name\n                    lena.context.update_recursively(\n                        context,\n                        \"error.{}.index\".format(error_name),\n                        # error can correspond both to variable and\n                        # value, so we put it outside value.\n                        # \"value.error.{}.index\".format(error_name),\n                        error_ind\n                    )\n\n\n# used in deprecated Graph\ndef _rescale_value(rescale, value):\n    return rescale * lena.flow.get_data(value)\n\n\nclass Graph(object):\n    \"\"\"\n    .. deprecated:: 0.5\n       use :class:`graph`.\n       This class may be used in the future,\n       but with a changed interface.\n\n    Function at given coordinates (arbitraty dimensions).\n\n    Graph points can be set during the initialization and\n    during :meth:`fill`. It can be rescaled (producing a new :class:`Graph`).\n    A point is a tuple of *(coordinate, value)*, where both *coordinate*\n    and *value* can be tuples of numbers.\n    *Coordinate* corresponds to a point in N-dimensional space,\n    while *value* is some function's value at this point\n    (the function can take a value in M-dimensional space).\n    Coordinate and value dimensions must be the same for all points.\n\n    One can get graph points as :attr:`Graph.points` attribute.\n    They will be sorted each time before return\n    if *sort* was set to ``True``.\n    An attempt to change points\n    (use :attr:`Graph.points` on the left of '=')\n    will raise Python's :exc:`AttributeError`.\n    \"\"\"\n\n    def __init__(self, points=None, context=None, scale=None, sort=True):\n        \"\"\"*points* is an array of *(coordinate, value)* tuples.\n\n        *context* is the same as the most recent context\n        during *fill*. Use it to provide a context\n        when initializing a :class:`Graph` from existing points.\n\n        *scale* sets the scale of the graph.\n        It is used during plotting if rescaling is needed.\n\n        Graph coordinates are sorted by default.\n        This is usually needed to plot graphs of functions.\n        If you need to keep the order of insertion, set *sort* to ``False``.\n\n        By default, sorting is done using standard Python\n        lists and functions. You can disable *sort* and provide your own\n        sorting container for *points*.\n        Some implementations are compared\n        `here <http://www.grantjenks.com/docs/sortedcontainers/performance.html>`_.\n        Note that a rescaled graph uses a default list.\n\n        Note that :class:`Graph` does not reduce data.\n        All filled values will be stored in it.\n        To reduce data, use histograms.\n        \"\"\"\n        warnings.warn(\"Graph is deprecated since Lena 0.5. Use graph.\",\n                      DeprecationWarning, stacklevel=2)\n\n        self._points = points if points is not None else []\n        # todo: add some sanity checks for points\n        self._scale = scale\n        self._init_context = {\"scale\": scale}\n        if context is None:\n            self._cur_context = {}\n        elif not isinstance(context, dict):\n            raise lena.core.LenaTypeError(\n                \"context must be a dict, {} provided\".format(context)\n            )\n        else:\n            self._cur_context = context\n        self._sort = sort\n\n        # todo: probably, scale from context is not needed.\n\n        ## probably this function is not needed.\n        ## it can't be copied, graphs won't be possible to compare.\n        # *rescale_value* is a function, which can be used to scale\n        # complex graph values.\n        # It must accept a rescale parameter and the value at a data point.\n        # By default, it is multiplication of rescale and the value\n        # (which must be a number).\n        # if rescale_value is None:\n        #     self._rescale_value = _rescale_value\n        self._rescale_value = _rescale_value\n        self._update()\n\n    def fill(self, value):\n        \"\"\"Fill the graph with *value*.\n\n        *Value* can be a *(data, context)* tuple.\n        *Data* part must be a *(coordinates, value)* pair,\n        where both coordinates and value are also tuples.\n        For example, *value* can contain the principal number\n        and its precision.\n        \"\"\"\n        point, self._cur_context = lena.flow.get_data_context(value)\n        # coords, val = point\n        self._points.append(point)\n\n    def request(self):\n        \"\"\"Yield graph with context.\n\n        If *sort* was initialized ``True``, graph points will be sorted.\n        \"\"\"\n        # If flow contained *scale* it the context, it is set now.\n        self._update()\n        yield (self, self._context)\n\n    # compute method shouldn't be in this class,\n    # because it is a pure FillRequest.\n    # def compute(self):\n    #     \"\"\"Yield graph with context (as in :meth:`request`),\n    #     and :meth:`reset`.\"\"\"\n    #     self._update()\n    #     yield (self, self._context)\n    #     self.reset()\n\n    @property\n    def points(self):\n        \"\"\"Get graph points (read only).\"\"\"\n        # sort points before giving them\n        self._update()\n        return self._points\n\n    def reset(self):\n        \"\"\"Reset points to an empty list\n        and current context to an empty dict.\n        \"\"\"\n        self._points = []\n        self._cur_context = {}\n\n    def __repr__(self):\n        self._update()\n        return (\"Graph(points={}, scale={}, sort={})\"\n                .format(self._points, self._scale, self._sort))\n\n    def scale(self, other=None):\n        \"\"\"Get or set the scale.\n\n        Graph's scale comes from an external source.\n        For example, if the graph was computed from a function,\n        this may be its integral passed via context during :meth:`fill`.\n        Once the scale is set, it is stored in the graph.\n        If one attempts to use scale which was not set,\n        :exc:`.LenaAttributeError` is raised.\n\n        If *other* is None, return the scale.\n\n        If a ``float`` *other* is provided, rescale to *other*.\n        A new graph with the scale equal to *other*\n        is returned, the original one remains unchanged.\n        Note that in this case its *points* will be a simple list\n        and new graph *sort* parameter will be ``True``.\n\n        Graphs with scale equal to zero can't be rescaled. \n        Attempts to do that raise :exc:`.LenaValueError`.\n        \"\"\"\n        if other is None:\n            # return scale\n            self._update()\n            if self._scale is None:\n                raise lena.core.LenaAttributeError(\n                    \"scale must be explicitly set before using that\"\n                )\n            return self._scale\n        else:\n            # rescale from other\n            scale = self.scale()\n            if scale == 0:\n                raise lena.core.LenaValueError(\n                    \"can't rescale graph with 0 scale\"\n                )\n\n            # new_init_context = copy.deepcopy(self._init_context)\n            # new_init_context.update({\"scale\": other})\n\n            rescale = float(other) / scale\n            new_points = []\n            for coord, val in self._points:\n                # probably not needed, because tuples are immutable:\n                # make a deep copy so that new values\n                # are completely independent from old ones.\n                new_points.append((coord, self._rescale_value(rescale, val)))\n            # todo: should it inherit context?\n            # Probably yes, but watch out scale.\n            new_graph = Graph(points=new_points, scale=other,\n                              sort=self._sort)\n            return new_graph\n", "contexts_below": "    #     *context* will be added to graph context.\n     #     If it contains \"scale\", :meth:`scale` method will be available.\n     #     Otherwise, if \"scale\" is contained in the context\n     #     during :meth:`fill`, it will be used.\n     #     In this case it is assumed that this scale\n     #     is same for all values (only the last filled context is checked).\n     #     Context from flow takes precedence over the initialized one.\n \n     def _update(self):\n         \"\"\"Sort points if needed, update context.\"\"\"\n         # todo: probably remove this context_scale?\n         context_scale = self._cur_context.get(\"scale\")\n         if context_scale is not None:\n             # this complex check is fine with rescale,\n             # because that returns a new graph (this scale unchanged).\n             if self._scale is not None and self._scale != context_scale:\n                 raise lena.core.LenaRuntimeError(\n                     \"Initialization and context scale differ, \"\n                     \"{} and {} from context {}\"\n                     .format(self._scale, context_scale, self._cur_context)\n                 )\n             self._scale = context_scale\n         if self._sort:\n             self._points = sorted(self._points)\n \n         self._context = copy.deepcopy(self._cur_context)\n         self._context.update(self._init_context)\n         # why this? Not *graph.scale*?\n         self._context.update({\"scale\": self._scale})\n         # self._context.update(lena.context.make_context(self, \"_scale\"))\n \n         # todo: make this check during fill. Probably initialize self._dim\n         # with kwarg dim. (dim of coordinates or values?)\n         if self._points:\n             # check points correctness\n             points = self._points\n             def coord_dim(coord):\n                 if not hasattr(coord, \"__len__\"):\n                     return 1\n                 return len(coord)\n             first_coord = points[0][0]\n             dim = coord_dim(first_coord)\n             same_dim = all(coord_dim(point[0]) == dim for point in points)\n             if not same_dim:\n                 raise lena.core.LenaValueError(\n                     \"coordinates tuples must have same dimension, \"\n                     \"{} given\".format(points)\n                 )\n             self.dim = dim\n             self._context[\"dim\"] = self.dim\n \n     def __eq__(self, other):\n         if not isinstance(other, Graph):\n             return False\n         if self.points != other.points:\n             return False\n         if self._scale is None and other._scale is None:\n             return True\n         try:\n             result = self.scale() == other.scale()\n         except lena.core.LenaAttributeError:\n             # one scale couldn't be computed\n             return False\n         else:\n             return result\n ", "input_code": "def to_csv(self, separator=',', header=None):\n\"\"\"\n.. deprecated:: 0.5 in Lena 0.5 to_csv is not used.\n      Iterables are converted to tables.\n\nConvert graph's points to CSV.\n\n*separator* delimits values, the default is comma.\n\n*header*, if not ``None``, is the first string of the output\n(new line is added automatically).\n\nSince a graph can be multidimensional,\nfor each point first its coordinate is converted to string\n(separated by *separator*), then each part of its value.\n\nTo convert :class:`Graph` to CSV inside a Lena sequence,\nuse :class:`lena.output.ToCSV`.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def to_csv(self, separator=\",\", header=None):\n        \"\"\".. deprecated:: 0.5 in Lena 0.5 to_csv is not used.\n              Iterables are converted to tables.\n\n        Convert graph's points to CSV.\n\n        *separator* delimits values, the default is comma.\n\n        *header*, if not ``None``, is the first string of the output\n        (new line is added automatically).\n\n        Since a graph can be multidimensional,\n        for each point first its coordinate is converted to string\n        (separated by *separator*), then each part of its value.\n\n        To convert :class:`Graph` to CSV inside a Lena sequence,\n        use :class:`lena.output.ToCSV`.\n        \"\"\"\n        if self._sort:\n            self._update()\n\n        def unpack_pt(pt):\n            coord = pt[0]\n            value = pt[1]\n            if isinstance(coord, tuple):\n                unpacked = list(coord)\n            else:\n                unpacked = [coord]\n            if isinstance(value, tuple):\n                unpacked += list(value)\n            else:\n                unpacked.append(value)\n            return unpacked\n\n        def pt_to_str(pt, separ):\n            return separ.join([str(val) for val in unpack_pt(pt)])\n\n        if header is not None:\n            # if one needs an empty header line, they may provide \"\"\n            lines = header + \"\\n\"\n        else:\n            lines = \"\"\n        lines += \"\\n\".join([pt_to_str(pt, separator) for pt in self.points])\n\n        return lines", "signature": "def to_csv(self, separator=',', header=None):", "completion_path": "lena/structures/graph.py"}
{"ce_id": "62b87b839a0c4fa8b80b35cb", "namespace": "62b87b839a0c4fa8b80b35cb", "namespace_real": "lena.structures.graph._get_err_indices", "real_proj_path": "ynikitenko---lena/", "type": "class", "class_name": "graph", "function_name": "_get_err_indices", "contexts_above": "\"\"\"A graph is a function at given coordinates.\"\"\"\nimport copy\nimport functools\nimport operator\nimport re\nimport warnings\n\nimport lena.core\nimport lena.context\nimport lena.flow\n\n\nclass graph():\n    \"\"\"Numeric arrays of equal size.\"\"\"\n\n    def __init__(self, coords, field_names=(\"x\", \"y\"), scale=None):\n        \"\"\"This structure generally corresponds\n        to the graph of a function\n        and represents arrays of coordinates and the function values\n        of arbitrary dimensions.\n\n        *coords* is a list of one-dimensional\n        coordinate and value sequences (usually lists).\n        There is little to no distinction between them,\n        and \"values\" can also be called \"coordinates\".\n\n        *field_names* provide the meaning of these arrays.\n        For example, a 3-dimensional graph could be distinguished\n        from a 2-dimensional graph with errors by its fields\n        (\"x\", \"y\", \"z\") versus (\"x\", \"y\", \"error_y\").\n        Field names don't affect drawing graphs:\n        for that :class:`~Variable`-s should be used.\n        Default field names,\n        provided for the most used 2-dimensional graphs,\n        are \"x\" and \"y\".\n\n        *field_names* can be a string separated by whitespace\n        and/or commas or a tuple of strings, such as (\"x\", \"y\").\n        *field_names* must have as many elements\n        as *coords* and each field name must be unique.\n        Otherwise field names are arbitrary.\n        Error fields must go after all other coordinates.\n        Name of a coordinate error is \"error\\\\_\"\n        appended by coordinate name. Further error details\n        are appended after '_'. They could be arbitrary depending\n        on the problem: \"low\", \"high\", \"low_90%_cl\", etc. Example:\n        (\"E\", \"time\", \"error_E_low\", \"error_time\").\n\n        *scale* of the graph is a kind of its norm. It could be\n        the integral of the function or its other property.\n        A scale of a normalised probability density\n        function would be one.\n        An initialized *scale* is required if one needs\n        to renormalise the graph in :meth:`scale`\n        (for example, to plot it with other graphs).\n\n        Coordinates of a function graph would usually be arrays\n        of increasing values, which is not required here.\n        Neither is it checked that coordinates indeed\n        contain one-dimensional numeric values.\n        However, non-standard graphs\n        will likely lead to errors during plotting\n        and will require more programmer's work and caution,\n        so use them only if you understand what you are doing.\n\n        A graph can be iterated yielding tuples of numbers\n        for each point.\n\n        **Attributes**\n\n        :attr:`coords` is a list \\\n            of one-dimensional lists of coordinates.\n\n        :attr:`field_names`\n\n        :attr:`dim` is the dimension of the graph,\n        that is of all its coordinates without errors.\n\n        In case of incorrect initialization arguments,\n        :exc:`~.LenaTypeError` or :exc:`~.LenaValueError` is raised.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if not coords:\n            raise lena.core.LenaValueError(\n                \"coords must be a non-empty sequence \"\n                \"of coordinate sequences\"\n            )\n\n        # require coords to be of the same size\n        pt_len = len(coords[0])\n        for arr in coords[1:]:\n            if len(arr) != pt_len:\n                raise lena.core.LenaValueError(\n                    \"coords must have subsequences of equal lengths\"\n                )\n\n        # Unicode (Python 2) field names would be just bad,\n        # so we don't check for it here.\n        if isinstance(field_names, str):\n            # split(', ') won't work.\n            # From https://stackoverflow.com/a/44785447/952234:\n            # \\s stands for whitespace.\n            field_names = tuple(re.findall(r'[^,\\s]+', field_names))\n        elif not isinstance(field_names, tuple):\n            # todo: why field_names are a tuple,\n            # while coords are a list?\n            # It might be non-Pythonic to require a tuple\n            # (to prohibit a list), but it's important\n            # for comparisons and uniformity\n            raise lena.core.LenaTypeError(\n                \"field_names must be a string or a tuple\"\n            )\n\n        if len(field_names) != len(coords):\n            raise lena.core.LenaValueError(\n                \"field_names must have must have the same size as coords\"\n            )\n\n        if len(set(field_names)) != len(field_names):\n            raise lena.core.LenaValueError(\n                \"field_names contains duplicates\"\n            )\n\n        self.coords = coords\n        self._scale = scale\n\n        # field_names are better than fields,\n        # because they are unambigous (as in namedtuple).\n        self.field_names = field_names\n\n        # decided to use \"error_x_low\" (like in ROOT).\n        # Other versions were x_error (looked better than x_err),\n        # but x_err_low looked much better than x_error_low).\n        try:\n            parsed_error_names = self._parse_error_names(field_names)\n        except lena.core.LenaValueError as err:\n            raise err\n            # in Python 3\n            # raise err from None\n        self._parsed_error_names = parsed_error_names\n\n        dim = len(field_names) - len(parsed_error_names)\n        self._coord_names = field_names[:dim]\n        self.dim = dim\n\n        # todo: add subsequences of coords as attributes\n        # with field names.\n        # In case if someone wants to create a graph of another function\n        # at the same coordinates.\n        # Should a) work when we rescale the graph\n        #        b) not interfere with other fields and methods\n\n        # Probably we won't add methods __del__(n), __add__(*coords),\n        # since it might change the scale.\n\n    def __eq__(self, other):\n        \"\"\"Two graphs are equal, if and only if they have\n        equal coordinates, field names and scales.\n\n        If *other* is not a :class:`.graph`, return ``False``.\n\n        Note that floating numbers should be compared\n        approximately (using :func:`math.isclose`).\n        Therefore this comparison may give false negatives.\n        \"\"\"\n        if not isinstance(other, graph):\n            # in Python comparison between different types is allowed\n            return False\n        return (self.coords == other.coords and self._scale == other._scale\n                and self.field_names == other.field_names)\n", "contexts_below": "    def __iter__(self):\n         \"\"\"Iterate graph coords one by one.\"\"\"\n         for val in zip(*self.coords):\n             yield val\n \n     def __repr__(self):\n         return \"\"\"graph({}, field_names={}, scale={})\"\"\".format(\n             self.coords, self.field_names, self._scale\n         )\n \n     def scale(self, other=None):\n         \"\"\"Get or set the scale of the graph.\n \n         If *other* is ``None``, return the scale of this graph.\n \n         If a numeric *other* is provided, rescale to that value.\n         If the graph has unknown or zero scale,\n         rescaling that will raise :exc:`~.LenaValueError`.\n \n         To get meaningful results, graph's fields are used.\n         Only the last coordinate is rescaled.\n         For example, if the graph has *x* and *y* coordinates,\n         then *y* will be rescaled, and for a 3-dimensional graph\n         *z* will be rescaled.\n         All errors are rescaled together with their coordinate.\n         \"\"\"\n         # this method is called scale() for uniformity with histograms\n         # And this looks really good: explicit for computations\n         # (not a subtle graph.scale, like a constant field (which is,\n         #  however, the case in graph - but not in other structures))\n         # and easy to remember (set_scale? rescale? change_scale_to?..)\n \n         # We modify the graph in place,\n         # because that would be redundant (not optimal)\n         # to create a new graph\n         # if we only want to change the scale of the existing one.\n \n         if other is None:\n             return self._scale\n \n         if not self._scale:\n             raise lena.core.LenaValueError(\n                 \"can't rescale a graph with zero or unknown scale\"\n             )\n \n         last_coord_ind = self.dim - 1\n         last_coord_name = self.field_names[last_coord_ind]\n \n         last_coord_indices = ([last_coord_ind] +\n                 self._get_err_indices(last_coord_name)\n         )\n \n         # In Python 2 3/2 is 1, so we want to be safe;\n         # the downside is that integer-valued graphs\n         # will become floating, but that is doubtfully an issue.\n         # Remove when/if dropping support for Python 2.\n         rescale = float(other) / self._scale\n \n         mul = operator.mul\n         partial = functools.partial\n \n         # a version with lambda is about 50% slower:\n         # timeit.timeit('[*map(lambda val: val*2, vals)]', \\\n         #     setup='vals = list(range(45)); from operator import mul; \\\n         #     from functools import partial')\n         # 3.159\n         # same setup for\n         # timeit.timeit('[*map(partial(mul, 2), vals)]',...):\n         # 2.075\n         # \n         # [*map(...)] is very slightly faster than list(map(...)),\n         # but it's unavailable in Python 2 (and anyway less readable).\n \n         # rescale arrays of values and errors\n         for ind, arr in enumerate(self.coords):\n             if ind in last_coord_indices:\n                 # Python lists are faster than arrays,\n                 # https://stackoverflow.com/a/62399645/952234\n                 # (because each time taking a value from an array\n                 #  creates a Python object)\n                 self.coords[ind] = list(map(partial(mul, rescale),\n                                             arr))\n \n         self._scale = other\n \n         # as suggested in PEP 8\n         return None\n \n     def _parse_error_names(self, field_names):\n         # field_names is a parameter for easier testing,\n         # usually object's field_names are used.\n         errors = []\n \n         # collect all error fields and check that they are\n         # strictly after other fields\n         in_error_fields = False\n         # there is at least one field\n         last_coord_ind = 0\n         for ind, field in enumerate(field_names):\n             if field.startswith(\"error_\"):\n                 in_error_fields = True\n                 errors.append((field, ind))\n             else:\n                 last_coord_ind = ind\n                 if in_error_fields:\n                     raise lena.core.LenaValueError(\n                         \"errors must go after coordinate fields\"\n                     )\n \n         coords = set(field_names[:last_coord_ind+1])\n         parsed_errors = []\n \n         for err, ind in errors:\n             err_coords = []\n             for coord in coords:\n                 err_main = err[6:]  # all after \"error_\"\n                 if err_main == coord or err_main.startswith(coord + \"_\"):\n                     err_coords.append(coord)\n                     err_tail = err_main[len(coord)+1:]\n             if not err_coords:\n                 raise lena.core.LenaValueError(\n                     \"no coordinate corresponding to {} given\".format(err)\n                 )\n             elif len(err_coords) > 1:\n                 raise lena.core.LenaValueError(\n                     \"ambiguous error \" + err +\\\n                     \" corresponding to several coordinates given\"\n                 )\n             # \"error\" may be redundant, but it is explicit.\n             parsed_errors.append((\"error\", err_coords[0], err_tail, ind))\n \n         return parsed_errors\n \n     def _update_context(self, context):\n         \"\"\"Update *context* with the properties of this graph.\n \n         *context.error* is appended with indices of errors.\n         Example subcontext for a graph with fields \"E,t,error_E_low\":\n         {\"error\": {\"x_low\": {\"index\": 2}}}.\n         Note that error names are called \"x\", \"y\" and \"z\"\n         (this corresponds to first three coordinates,\n         if they are present), which allows to simplify plotting.\n         Existing values are not removed\n         from *context.value* and its subcontexts.\n \n         Called on \"destruction\" of the graph (for example,\n         in :class:`.ToCSV`). By destruction we mean conversion\n         to another structure (like text) in the flow.\n         The graph object is not really destroyed in this process.\n         \"\"\"\n         # this method is private, because we encourage users to yield\n         # graphs into the flow and process them with ToCSV element\n         # (not manually).\n \n         if not self._parsed_error_names:\n             # no error fields present\n             return\n \n         dim = self.dim\n \n         xyz_coord_names = self._coord_names[:3]\n         for name, coord_name in zip([\"x\", \"y\", \"z\"], xyz_coord_names):\n             for err in self._parsed_error_names:\n                 if err[1] == coord_name:\n                     error_ind = err[3]\n                     if err[2]:\n                         # add error suffix\n                         error_name = name + \"_\" + err[2]\n                     else:\n                         error_name = name\n                     lena.context.update_recursively(\n                         context,\n                         \"error.{}.index\".format(error_name),\n                         # error can correspond both to variable and\n                         # value, so we put it outside value.\n                         # \"value.error.{}.index\".format(error_name),\n                         error_ind\n                     )\n \n \n # used in deprecated Graph\n def _rescale_value(rescale, value):\n     return rescale * lena.flow.get_data(value)\n \n \n class Graph(object):\n     \"\"\"\n     .. deprecated:: 0.5\n        use :class:`graph`.\n        This class may be used in the future,\n        but with a changed interface.\n \n     Function at given coordinates (arbitraty dimensions).\n \n     Graph points can be set during the initialization and\n     during :meth:`fill`. It can be rescaled (producing a new :class:`Graph`).\n     A point is a tuple of *(coordinate, value)*, where both *coordinate*\n     and *value* can be tuples of numbers.\n     *Coordinate* corresponds to a point in N-dimensional space,\n     while *value* is some function's value at this point\n     (the function can take a value in M-dimensional space).\n     Coordinate and value dimensions must be the same for all points.\n \n     One can get graph points as :attr:`Graph.points` attribute.\n     They will be sorted each time before return\n     if *sort* was set to ``True``.\n     An attempt to change points\n     (use :attr:`Graph.points` on the left of '=')\n     will raise Python's :exc:`AttributeError`.\n     \"\"\"\n \n     def __init__(self, points=None, context=None, scale=None, sort=True):\n         \"\"\"*points* is an array of *(coordinate, value)* tuples.\n \n         *context* is the same as the most recent context\n         during *fill*. Use it to provide a context\n         when initializing a :class:`Graph` from existing points.\n \n         *scale* sets the scale of the graph.\n         It is used during plotting if rescaling is needed.\n \n         Graph coordinates are sorted by default.\n         This is usually needed to plot graphs of functions.\n         If you need to keep the order of insertion, set *sort* to ``False``.\n \n         By default, sorting is done using standard Python\n         lists and functions. You can disable *sort* and provide your own\n         sorting container for *points*.\n         Some implementations are compared\n         `here <http://www.grantjenks.com/docs/sortedcontainers/performance.html>`_.\n         Note that a rescaled graph uses a default list.\n \n         Note that :class:`Graph` does not reduce data.\n         All filled values will be stored in it.\n         To reduce data, use histograms.\n         \"\"\"\n         warnings.warn(\"Graph is deprecated since Lena 0.5. Use graph.\",\n                       DeprecationWarning, stacklevel=2)\n \n         self._points = points if points is not None else []\n         # todo: add some sanity checks for points\n         self._scale = scale\n         self._init_context = {\"scale\": scale}\n         if context is None:\n             self._cur_context = {}\n         elif not isinstance(context, dict):\n             raise lena.core.LenaTypeError(\n                 \"context must be a dict, {} provided\".format(context)\n             )\n         else:\n             self._cur_context = context\n         self._sort = sort\n \n         # todo: probably, scale from context is not needed.\n \n         ## probably this function is not needed.\n         ## it can't be copied, graphs won't be possible to compare.\n         # *rescale_value* is a function, which can be used to scale\n         # complex graph values.\n         # It must accept a rescale parameter and the value at a data point.\n         # By default, it is multiplication of rescale and the value\n         # (which must be a number).\n         # if rescale_value is None:\n         #     self._rescale_value = _rescale_value\n         self._rescale_value = _rescale_value\n         self._update()\n \n     def fill(self, value):\n         \"\"\"Fill the graph with *value*.\n \n         *Value* can be a *(data, context)* tuple.\n         *Data* part must be a *(coordinates, value)* pair,\n         where both coordinates and value are also tuples.\n         For example, *value* can contain the principal number\n         and its precision.\n         \"\"\"\n         point, self._cur_context = lena.flow.get_data_context(value)\n         # coords, val = point\n         self._points.append(point)\n \n     def request(self):\n         \"\"\"Yield graph with context.\n \n         If *sort* was initialized ``True``, graph points will be sorted.\n         \"\"\"\n         # If flow contained *scale* it the context, it is set now.\n         self._update()\n         yield (self, self._context)\n \n     # compute method shouldn't be in this class,\n     # because it is a pure FillRequest.\n     # def compute(self):\n     #     \"\"\"Yield graph with context (as in :meth:`request`),\n     #     and :meth:`reset`.\"\"\"\n     #     self._update()\n     #     yield (self, self._context)\n     #     self.reset()\n \n     @property\n     def points(self):\n         \"\"\"Get graph points (read only).\"\"\"\n         # sort points before giving them\n         self._update()\n         return self._points\n \n     def reset(self):\n         \"\"\"Reset points to an empty list\n         and current context to an empty dict.\n         \"\"\"\n         self._points = []\n         self._cur_context = {}\n \n     def __repr__(self):\n         self._update()\n         return (\"Graph(points={}, scale={}, sort={})\"\n                 .format(self._points, self._scale, self._sort))\n \n     def scale(self, other=None):\n         \"\"\"Get or set the scale.\n \n         Graph's scale comes from an external source.\n         For example, if the graph was computed from a function,\n         this may be its integral passed via context during :meth:`fill`.\n         Once the scale is set, it is stored in the graph.\n         If one attempts to use scale which was not set,\n         :exc:`.LenaAttributeError` is raised.\n \n         If *other* is None, return the scale.\n \n         If a ``float`` *other* is provided, rescale to *other*.\n         A new graph with the scale equal to *other*\n         is returned, the original one remains unchanged.\n         Note that in this case its *points* will be a simple list\n         and new graph *sort* parameter will be ``True``.\n \n         Graphs with scale equal to zero can't be rescaled. \n         Attempts to do that raise :exc:`.LenaValueError`.\n         \"\"\"\n         if other is None:\n             # return scale\n             self._update()\n             if self._scale is None:\n                 raise lena.core.LenaAttributeError(\n                     \"scale must be explicitly set before using that\"\n                 )\n             return self._scale\n         else:\n             # rescale from other\n             scale = self.scale()\n             if scale == 0:\n                 raise lena.core.LenaValueError(\n                     \"can't rescale graph with 0 scale\"\n                 )\n \n             # new_init_context = copy.deepcopy(self._init_context)\n             # new_init_context.update({\"scale\": other})\n \n             rescale = float(other) / scale\n             new_points = []\n             for coord, val in self._points:\n                 # probably not needed, because tuples are immutable:\n                 # make a deep copy so that new values\n                 # are completely independent from old ones.\n                 new_points.append((coord, self._rescale_value(rescale, val)))\n             # todo: should it inherit context?\n             # Probably yes, but watch out scale.\n             new_graph = Graph(points=new_points, scale=other,\n                               sort=self._sort)\n             return new_graph\n \n     def to_csv(self, separator=\",\", header=None):\n         \"\"\".. deprecated:: 0.5 in Lena 0.5 to_csv is not used.\n               Iterables are converted to tables.\n \n         Convert graph's points to CSV.\n \n         *separator* delimits values, the default is comma.\n \n         *header*, if not ``None``, is the first string of the output\n         (new line is added automatically).\n \n         Since a graph can be multidimensional,\n         for each point first its coordinate is converted to string\n         (separated by *separator*), then each part of its value.\n \n         To convert :class:`Graph` to CSV inside a Lena sequence,\n         use :class:`lena.output.ToCSV`.\n         \"\"\"\n         if self._sort:\n             self._update()\n \n         def unpack_pt(pt):\n             coord = pt[0]\n             value = pt[1]\n             if isinstance(coord, tuple):\n                 unpacked = list(coord)\n             else:\n                 unpacked = [coord]\n             if isinstance(value, tuple):\n                 unpacked += list(value)\n             else:\n                 unpacked.append(value)\n             return unpacked\n \n         def pt_to_str(pt, separ):\n             return separ.join([str(val) for val in unpack_pt(pt)])\n \n         if header is not None:\n             # if one needs an empty header line, they may provide \"\"\n             lines = header + \"\\n\"\n         else:\n             lines = \"\"\n         lines += \"\\n\".join([pt_to_str(pt, separator) for pt in self.points])\n \n         return lines\n \n     #     *context* will be added to graph context.\n     #     If it contains \"scale\", :meth:`scale` method will be available.\n     #     Otherwise, if \"scale\" is contained in the context\n     #     during :meth:`fill`, it will be used.\n     #     In this case it is assumed that this scale\n     #     is same for all values (only the last filled context is checked).\n     #     Context from flow takes precedence over the initialized one.\n \n     def _update(self):\n         \"\"\"Sort points if needed, update context.\"\"\"\n         # todo: probably remove this context_scale?\n         context_scale = self._cur_context.get(\"scale\")\n         if context_scale is not None:\n             # this complex check is fine with rescale,\n             # because that returns a new graph (this scale unchanged).\n             if self._scale is not None and self._scale != context_scale:\n                 raise lena.core.LenaRuntimeError(\n                     \"Initialization and context scale differ, \"\n                     \"{} and {} from context {}\"\n                     .format(self._scale, context_scale, self._cur_context)\n                 )\n             self._scale = context_scale\n         if self._sort:\n             self._points = sorted(self._points)\n \n         self._context = copy.deepcopy(self._cur_context)\n         self._context.update(self._init_context)\n         # why this? Not *graph.scale*?\n         self._context.update({\"scale\": self._scale})\n         # self._context.update(lena.context.make_context(self, \"_scale\"))\n \n         # todo: make this check during fill. Probably initialize self._dim\n         # with kwarg dim. (dim of coordinates or values?)\n         if self._points:\n             # check points correctness\n             points = self._points\n             def coord_dim(coord):\n                 if not hasattr(coord, \"__len__\"):\n                     return 1\n                 return len(coord)\n             first_coord = points[0][0]\n             dim = coord_dim(first_coord)\n             same_dim = all(coord_dim(point[0]) == dim for point in points)\n             if not same_dim:\n                 raise lena.core.LenaValueError(\n                     \"coordinates tuples must have same dimension, \"\n                     \"{} given\".format(points)\n                 )\n             self.dim = dim\n             self._context[\"dim\"] = self.dim\n \n     def __eq__(self, other):\n         if not isinstance(other, Graph):\n             return False\n         if self.points != other.points:\n             return False\n         if self._scale is None and other._scale is None:\n             return True\n         try:\n             result = self.scale() == other.scale()\n         except lena.core.LenaAttributeError:\n             # one scale couldn't be computed\n             return False\n         else:\n             return result\n ", "input_code": "def _get_err_indices(self, coord_name):\n\"\"\"\nGet error indices corresponding to a coordinate.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def _get_err_indices(self, coord_name):\n        \"\"\"Get error indices corresponding to a coordinate.\"\"\"\n        err_indices = []\n        dim = self.dim\n        for ind, err in enumerate(self._parsed_error_names):\n            if err[1] == coord_name:\n                err_indices.append(ind+dim)\n        return err_indices", "signature": "def _get_err_indices(self, coord_name):", "completion_path": "lena/structures/graph.py"}
{"ce_id": "62b87b7e9a0c4fa8b80b35bc", "namespace": "62b87b7e9a0c4fa8b80b35bc", "namespace_real": "lena.structures.graph._update_context", "real_proj_path": "ynikitenko---lena/", "type": "class", "class_name": "graph", "function_name": "_update_context", "contexts_above": "\"\"\"A graph is a function at given coordinates.\"\"\"\nimport copy\nimport functools\nimport operator\nimport re\nimport warnings\n\nimport lena.core\nimport lena.context\nimport lena.flow\n\n\nclass graph():\n    \"\"\"Numeric arrays of equal size.\"\"\"\n\n    def __init__(self, coords, field_names=(\"x\", \"y\"), scale=None):\n        \"\"\"This structure generally corresponds\n        to the graph of a function\n        and represents arrays of coordinates and the function values\n        of arbitrary dimensions.\n\n        *coords* is a list of one-dimensional\n        coordinate and value sequences (usually lists).\n        There is little to no distinction between them,\n        and \"values\" can also be called \"coordinates\".\n\n        *field_names* provide the meaning of these arrays.\n        For example, a 3-dimensional graph could be distinguished\n        from a 2-dimensional graph with errors by its fields\n        (\"x\", \"y\", \"z\") versus (\"x\", \"y\", \"error_y\").\n        Field names don't affect drawing graphs:\n        for that :class:`~Variable`-s should be used.\n        Default field names,\n        provided for the most used 2-dimensional graphs,\n        are \"x\" and \"y\".\n\n        *field_names* can be a string separated by whitespace\n        and/or commas or a tuple of strings, such as (\"x\", \"y\").\n        *field_names* must have as many elements\n        as *coords* and each field name must be unique.\n        Otherwise field names are arbitrary.\n        Error fields must go after all other coordinates.\n        Name of a coordinate error is \"error\\\\_\"\n        appended by coordinate name. Further error details\n        are appended after '_'. They could be arbitrary depending\n        on the problem: \"low\", \"high\", \"low_90%_cl\", etc. Example:\n        (\"E\", \"time\", \"error_E_low\", \"error_time\").\n\n        *scale* of the graph is a kind of its norm. It could be\n        the integral of the function or its other property.\n        A scale of a normalised probability density\n        function would be one.\n        An initialized *scale* is required if one needs\n        to renormalise the graph in :meth:`scale`\n        (for example, to plot it with other graphs).\n\n        Coordinates of a function graph would usually be arrays\n        of increasing values, which is not required here.\n        Neither is it checked that coordinates indeed\n        contain one-dimensional numeric values.\n        However, non-standard graphs\n        will likely lead to errors during plotting\n        and will require more programmer's work and caution,\n        so use them only if you understand what you are doing.\n\n        A graph can be iterated yielding tuples of numbers\n        for each point.\n\n        **Attributes**\n\n        :attr:`coords` is a list \\\n            of one-dimensional lists of coordinates.\n\n        :attr:`field_names`\n\n        :attr:`dim` is the dimension of the graph,\n        that is of all its coordinates without errors.\n\n        In case of incorrect initialization arguments,\n        :exc:`~.LenaTypeError` or :exc:`~.LenaValueError` is raised.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if not coords:\n            raise lena.core.LenaValueError(\n                \"coords must be a non-empty sequence \"\n                \"of coordinate sequences\"\n            )\n\n        # require coords to be of the same size\n        pt_len = len(coords[0])\n        for arr in coords[1:]:\n            if len(arr) != pt_len:\n                raise lena.core.LenaValueError(\n                    \"coords must have subsequences of equal lengths\"\n                )\n\n        # Unicode (Python 2) field names would be just bad,\n        # so we don't check for it here.\n        if isinstance(field_names, str):\n            # split(', ') won't work.\n            # From https://stackoverflow.com/a/44785447/952234:\n            # \\s stands for whitespace.\n            field_names = tuple(re.findall(r'[^,\\s]+', field_names))\n        elif not isinstance(field_names, tuple):\n            # todo: why field_names are a tuple,\n            # while coords are a list?\n            # It might be non-Pythonic to require a tuple\n            # (to prohibit a list), but it's important\n            # for comparisons and uniformity\n            raise lena.core.LenaTypeError(\n                \"field_names must be a string or a tuple\"\n            )\n\n        if len(field_names) != len(coords):\n            raise lena.core.LenaValueError(\n                \"field_names must have must have the same size as coords\"\n            )\n\n        if len(set(field_names)) != len(field_names):\n            raise lena.core.LenaValueError(\n                \"field_names contains duplicates\"\n            )\n\n        self.coords = coords\n        self._scale = scale\n\n        # field_names are better than fields,\n        # because they are unambigous (as in namedtuple).\n        self.field_names = field_names\n\n        # decided to use \"error_x_low\" (like in ROOT).\n        # Other versions were x_error (looked better than x_err),\n        # but x_err_low looked much better than x_error_low).\n        try:\n            parsed_error_names = self._parse_error_names(field_names)\n        except lena.core.LenaValueError as err:\n            raise err\n            # in Python 3\n            # raise err from None\n        self._parsed_error_names = parsed_error_names\n\n        dim = len(field_names) - len(parsed_error_names)\n        self._coord_names = field_names[:dim]\n        self.dim = dim\n\n        # todo: add subsequences of coords as attributes\n        # with field names.\n        # In case if someone wants to create a graph of another function\n        # at the same coordinates.\n        # Should a) work when we rescale the graph\n        #        b) not interfere with other fields and methods\n\n        # Probably we won't add methods __del__(n), __add__(*coords),\n        # since it might change the scale.\n\n    def __eq__(self, other):\n        \"\"\"Two graphs are equal, if and only if they have\n        equal coordinates, field names and scales.\n\n        If *other* is not a :class:`.graph`, return ``False``.\n\n        Note that floating numbers should be compared\n        approximately (using :func:`math.isclose`).\n        Therefore this comparison may give false negatives.\n        \"\"\"\n        if not isinstance(other, graph):\n            # in Python comparison between different types is allowed\n            return False\n        return (self.coords == other.coords and self._scale == other._scale\n                and self.field_names == other.field_names)\n\n    def _get_err_indices(self, coord_name):\n        \"\"\"Get error indices corresponding to a coordinate.\"\"\"\n        err_indices = []\n        dim = self.dim\n        for ind, err in enumerate(self._parsed_error_names):\n            if err[1] == coord_name:\n                err_indices.append(ind+dim)\n        return err_indices\n\n    def __iter__(self):\n        \"\"\"Iterate graph coords one by one.\"\"\"\n        for val in zip(*self.coords):\n            yield val\n\n    def __repr__(self):\n        return \"\"\"graph({}, field_names={}, scale={})\"\"\".format(\n            self.coords, self.field_names, self._scale\n        )\n\n    def scale(self, other=None):\n        \"\"\"Get or set the scale of the graph.\n\n        If *other* is ``None``, return the scale of this graph.\n\n        If a numeric *other* is provided, rescale to that value.\n        If the graph has unknown or zero scale,\n        rescaling that will raise :exc:`~.LenaValueError`.\n\n        To get meaningful results, graph's fields are used.\n        Only the last coordinate is rescaled.\n        For example, if the graph has *x* and *y* coordinates,\n        then *y* will be rescaled, and for a 3-dimensional graph\n        *z* will be rescaled.\n        All errors are rescaled together with their coordinate.\n        \"\"\"\n        # this method is called scale() for uniformity with histograms\n        # And this looks really good: explicit for computations\n        # (not a subtle graph.scale, like a constant field (which is,\n        #  however, the case in graph - but not in other structures))\n        # and easy to remember (set_scale? rescale? change_scale_to?..)\n\n        # We modify the graph in place,\n        # because that would be redundant (not optimal)\n        # to create a new graph\n        # if we only want to change the scale of the existing one.\n\n        if other is None:\n            return self._scale\n\n        if not self._scale:\n            raise lena.core.LenaValueError(\n                \"can't rescale a graph with zero or unknown scale\"\n            )\n\n        last_coord_ind = self.dim - 1\n        last_coord_name = self.field_names[last_coord_ind]\n\n        last_coord_indices = ([last_coord_ind] +\n                self._get_err_indices(last_coord_name)\n        )\n\n        # In Python 2 3/2 is 1, so we want to be safe;\n        # the downside is that integer-valued graphs\n        # will become floating, but that is doubtfully an issue.\n        # Remove when/if dropping support for Python 2.\n        rescale = float(other) / self._scale\n\n        mul = operator.mul\n        partial = functools.partial\n\n        # a version with lambda is about 50% slower:\n        # timeit.timeit('[*map(lambda val: val*2, vals)]', \\\n        #     setup='vals = list(range(45)); from operator import mul; \\\n        #     from functools import partial')\n        # 3.159\n        # same setup for\n        # timeit.timeit('[*map(partial(mul, 2), vals)]',...):\n        # 2.075\n        # \n        # [*map(...)] is very slightly faster than list(map(...)),\n        # but it's unavailable in Python 2 (and anyway less readable).\n\n        # rescale arrays of values and errors\n        for ind, arr in enumerate(self.coords):\n            if ind in last_coord_indices:\n                # Python lists are faster than arrays,\n                # https://stackoverflow.com/a/62399645/952234\n                # (because each time taking a value from an array\n                #  creates a Python object)\n                self.coords[ind] = list(map(partial(mul, rescale),\n                                            arr))\n\n        self._scale = other\n\n        # as suggested in PEP 8\n        return None\n\n    def _parse_error_names(self, field_names):\n        # field_names is a parameter for easier testing,\n        # usually object's field_names are used.\n        errors = []\n\n        # collect all error fields and check that they are\n        # strictly after other fields\n        in_error_fields = False\n        # there is at least one field\n        last_coord_ind = 0\n        for ind, field in enumerate(field_names):\n            if field.startswith(\"error_\"):\n                in_error_fields = True\n                errors.append((field, ind))\n            else:\n                last_coord_ind = ind\n                if in_error_fields:\n                    raise lena.core.LenaValueError(\n                        \"errors must go after coordinate fields\"\n                    )\n\n        coords = set(field_names[:last_coord_ind+1])\n        parsed_errors = []\n\n        for err, ind in errors:\n            err_coords = []\n            for coord in coords:\n                err_main = err[6:]  # all after \"error_\"\n                if err_main == coord or err_main.startswith(coord + \"_\"):\n                    err_coords.append(coord)\n                    err_tail = err_main[len(coord)+1:]\n            if not err_coords:\n                raise lena.core.LenaValueError(\n                    \"no coordinate corresponding to {} given\".format(err)\n                )\n            elif len(err_coords) > 1:\n                raise lena.core.LenaValueError(\n                    \"ambiguous error \" + err +\\\n                    \" corresponding to several coordinates given\"\n                )\n            # \"error\" may be redundant, but it is explicit.\n            parsed_errors.append((\"error\", err_coords[0], err_tail, ind))\n\n        return parsed_errors\n", "contexts_below": "\n # used in deprecated Graph\n def _rescale_value(rescale, value):\n     return rescale * lena.flow.get_data(value)\n \n \n class Graph(object):\n     \"\"\"\n     .. deprecated:: 0.5\n        use :class:`graph`.\n        This class may be used in the future,\n        but with a changed interface.\n \n     Function at given coordinates (arbitraty dimensions).\n \n     Graph points can be set during the initialization and\n     during :meth:`fill`. It can be rescaled (producing a new :class:`Graph`).\n     A point is a tuple of *(coordinate, value)*, where both *coordinate*\n     and *value* can be tuples of numbers.\n     *Coordinate* corresponds to a point in N-dimensional space,\n     while *value* is some function's value at this point\n     (the function can take a value in M-dimensional space).\n     Coordinate and value dimensions must be the same for all points.\n \n     One can get graph points as :attr:`Graph.points` attribute.\n     They will be sorted each time before return\n     if *sort* was set to ``True``.\n     An attempt to change points\n     (use :attr:`Graph.points` on the left of '=')\n     will raise Python's :exc:`AttributeError`.\n     \"\"\"\n \n     def __init__(self, points=None, context=None, scale=None, sort=True):\n         \"\"\"*points* is an array of *(coordinate, value)* tuples.\n \n         *context* is the same as the most recent context\n         during *fill*. Use it to provide a context\n         when initializing a :class:`Graph` from existing points.\n \n         *scale* sets the scale of the graph.\n         It is used during plotting if rescaling is needed.\n \n         Graph coordinates are sorted by default.\n         This is usually needed to plot graphs of functions.\n         If you need to keep the order of insertion, set *sort* to ``False``.\n \n         By default, sorting is done using standard Python\n         lists and functions. You can disable *sort* and provide your own\n         sorting container for *points*.\n         Some implementations are compared\n         `here <http://www.grantjenks.com/docs/sortedcontainers/performance.html>`_.\n         Note that a rescaled graph uses a default list.\n \n         Note that :class:`Graph` does not reduce data.\n         All filled values will be stored in it.\n         To reduce data, use histograms.\n         \"\"\"\n         warnings.warn(\"Graph is deprecated since Lena 0.5. Use graph.\",\n                       DeprecationWarning, stacklevel=2)\n \n         self._points = points if points is not None else []\n         # todo: add some sanity checks for points\n         self._scale = scale\n         self._init_context = {\"scale\": scale}\n         if context is None:\n             self._cur_context = {}\n         elif not isinstance(context, dict):\n             raise lena.core.LenaTypeError(\n                 \"context must be a dict, {} provided\".format(context)\n             )\n         else:\n             self._cur_context = context\n         self._sort = sort\n \n         # todo: probably, scale from context is not needed.\n \n         ## probably this function is not needed.\n         ## it can't be copied, graphs won't be possible to compare.\n         # *rescale_value* is a function, which can be used to scale\n         # complex graph values.\n         # It must accept a rescale parameter and the value at a data point.\n         # By default, it is multiplication of rescale and the value\n         # (which must be a number).\n         # if rescale_value is None:\n         #     self._rescale_value = _rescale_value\n         self._rescale_value = _rescale_value\n         self._update()\n \n     def fill(self, value):\n         \"\"\"Fill the graph with *value*.\n \n         *Value* can be a *(data, context)* tuple.\n         *Data* part must be a *(coordinates, value)* pair,\n         where both coordinates and value are also tuples.\n         For example, *value* can contain the principal number\n         and its precision.\n         \"\"\"\n         point, self._cur_context = lena.flow.get_data_context(value)\n         # coords, val = point\n         self._points.append(point)\n \n     def request(self):\n         \"\"\"Yield graph with context.\n \n         If *sort* was initialized ``True``, graph points will be sorted.\n         \"\"\"\n         # If flow contained *scale* it the context, it is set now.\n         self._update()\n         yield (self, self._context)\n \n     # compute method shouldn't be in this class,\n     # because it is a pure FillRequest.\n     # def compute(self):\n     #     \"\"\"Yield graph with context (as in :meth:`request`),\n     #     and :meth:`reset`.\"\"\"\n     #     self._update()\n     #     yield (self, self._context)\n     #     self.reset()\n \n     @property\n     def points(self):\n         \"\"\"Get graph points (read only).\"\"\"\n         # sort points before giving them\n         self._update()\n         return self._points\n \n     def reset(self):\n         \"\"\"Reset points to an empty list\n         and current context to an empty dict.\n         \"\"\"\n         self._points = []\n         self._cur_context = {}\n \n     def __repr__(self):\n         self._update()\n         return (\"Graph(points={}, scale={}, sort={})\"\n                 .format(self._points, self._scale, self._sort))\n \n     def scale(self, other=None):\n         \"\"\"Get or set the scale.\n \n         Graph's scale comes from an external source.\n         For example, if the graph was computed from a function,\n         this may be its integral passed via context during :meth:`fill`.\n         Once the scale is set, it is stored in the graph.\n         If one attempts to use scale which was not set,\n         :exc:`.LenaAttributeError` is raised.\n \n         If *other* is None, return the scale.\n \n         If a ``float`` *other* is provided, rescale to *other*.\n         A new graph with the scale equal to *other*\n         is returned, the original one remains unchanged.\n         Note that in this case its *points* will be a simple list\n         and new graph *sort* parameter will be ``True``.\n \n         Graphs with scale equal to zero can't be rescaled. \n         Attempts to do that raise :exc:`.LenaValueError`.\n         \"\"\"\n         if other is None:\n             # return scale\n             self._update()\n             if self._scale is None:\n                 raise lena.core.LenaAttributeError(\n                     \"scale must be explicitly set before using that\"\n                 )\n             return self._scale\n         else:\n             # rescale from other\n             scale = self.scale()\n             if scale == 0:\n                 raise lena.core.LenaValueError(\n                     \"can't rescale graph with 0 scale\"\n                 )\n \n             # new_init_context = copy.deepcopy(self._init_context)\n             # new_init_context.update({\"scale\": other})\n \n             rescale = float(other) / scale\n             new_points = []\n             for coord, val in self._points:\n                 # probably not needed, because tuples are immutable:\n                 # make a deep copy so that new values\n                 # are completely independent from old ones.\n                 new_points.append((coord, self._rescale_value(rescale, val)))\n             # todo: should it inherit context?\n             # Probably yes, but watch out scale.\n             new_graph = Graph(points=new_points, scale=other,\n                               sort=self._sort)\n             return new_graph\n \n     def to_csv(self, separator=\",\", header=None):\n         \"\"\".. deprecated:: 0.5 in Lena 0.5 to_csv is not used.\n               Iterables are converted to tables.\n \n         Convert graph's points to CSV.\n \n         *separator* delimits values, the default is comma.\n \n         *header*, if not ``None``, is the first string of the output\n         (new line is added automatically).\n \n         Since a graph can be multidimensional,\n         for each point first its coordinate is converted to string\n         (separated by *separator*), then each part of its value.\n \n         To convert :class:`Graph` to CSV inside a Lena sequence,\n         use :class:`lena.output.ToCSV`.\n         \"\"\"\n         if self._sort:\n             self._update()\n \n         def unpack_pt(pt):\n             coord = pt[0]\n             value = pt[1]\n             if isinstance(coord, tuple):\n                 unpacked = list(coord)\n             else:\n                 unpacked = [coord]\n             if isinstance(value, tuple):\n                 unpacked += list(value)\n             else:\n                 unpacked.append(value)\n             return unpacked\n \n         def pt_to_str(pt, separ):\n             return separ.join([str(val) for val in unpack_pt(pt)])\n \n         if header is not None:\n             # if one needs an empty header line, they may provide \"\"\n             lines = header + \"\\n\"\n         else:\n             lines = \"\"\n         lines += \"\\n\".join([pt_to_str(pt, separator) for pt in self.points])\n \n         return lines\n \n     #     *context* will be added to graph context.\n     #     If it contains \"scale\", :meth:`scale` method will be available.\n     #     Otherwise, if \"scale\" is contained in the context\n     #     during :meth:`fill`, it will be used.\n     #     In this case it is assumed that this scale\n     #     is same for all values (only the last filled context is checked).\n     #     Context from flow takes precedence over the initialized one.\n \n     def _update(self):\n         \"\"\"Sort points if needed, update context.\"\"\"\n         # todo: probably remove this context_scale?\n         context_scale = self._cur_context.get(\"scale\")\n         if context_scale is not None:\n             # this complex check is fine with rescale,\n             # because that returns a new graph (this scale unchanged).\n             if self._scale is not None and self._scale != context_scale:\n                 raise lena.core.LenaRuntimeError(\n                     \"Initialization and context scale differ, \"\n                     \"{} and {} from context {}\"\n                     .format(self._scale, context_scale, self._cur_context)\n                 )\n             self._scale = context_scale\n         if self._sort:\n             self._points = sorted(self._points)\n \n         self._context = copy.deepcopy(self._cur_context)\n         self._context.update(self._init_context)\n         # why this? Not *graph.scale*?\n         self._context.update({\"scale\": self._scale})\n         # self._context.update(lena.context.make_context(self, \"_scale\"))\n \n         # todo: make this check during fill. Probably initialize self._dim\n         # with kwarg dim. (dim of coordinates or values?)\n         if self._points:\n             # check points correctness\n             points = self._points\n             def coord_dim(coord):\n                 if not hasattr(coord, \"__len__\"):\n                     return 1\n                 return len(coord)\n             first_coord = points[0][0]\n             dim = coord_dim(first_coord)\n             same_dim = all(coord_dim(point[0]) == dim for point in points)\n             if not same_dim:\n                 raise lena.core.LenaValueError(\n                     \"coordinates tuples must have same dimension, \"\n                     \"{} given\".format(points)\n                 )\n             self.dim = dim\n             self._context[\"dim\"] = self.dim\n \n     def __eq__(self, other):\n         if not isinstance(other, Graph):\n             return False\n         if self.points != other.points:\n             return False\n         if self._scale is None and other._scale is None:\n             return True\n         try:\n             result = self.scale() == other.scale()\n         except lena.core.LenaAttributeError:\n             # one scale couldn't be computed\n             return False\n         else:\n             return result\n ", "input_code": "def _update_context(self, context):\n\"\"\"\nUpdate *context* with the properties of this graph.\n\n*context.error* is appended with indices of errors.\nExample subcontext for a graph with fields \"E,t,error_E_low\":\n{\"error\": {\"x_low\": {\"index\": 2}}}.\nNote that error names are called \"x\", \"y\" and \"z\"\n(this corresponds to first three coordinates,\nif they are present), which allows to simplify plotting.\nExisting values are not removed\nfrom *context.value* and its subcontexts.\n\nCalled on \"destruction\" of the graph (for example,\nin :class:`.ToCSV`). By destruction we mean conversion\nto another structure (like text) in the flow.\nThe graph object is not really destroyed in this process.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def _update_context(self, context):\n        \"\"\"Update *context* with the properties of this graph.\n\n        *context.error* is appended with indices of errors.\n        Example subcontext for a graph with fields \"E,t,error_E_low\":\n        {\"error\": {\"x_low\": {\"index\": 2}}}.\n        Note that error names are called \"x\", \"y\" and \"z\"\n        (this corresponds to first three coordinates,\n        if they are present), which allows to simplify plotting.\n        Existing values are not removed\n        from *context.value* and its subcontexts.\n\n        Called on \"destruction\" of the graph (for example,\n        in :class:`.ToCSV`). By destruction we mean conversion\n        to another structure (like text) in the flow.\n        The graph object is not really destroyed in this process.\n        \"\"\"\n        # this method is private, because we encourage users to yield\n        # graphs into the flow and process them with ToCSV element\n        # (not manually).\n\n        if not self._parsed_error_names:\n            # no error fields present\n            return\n\n        dim = self.dim\n\n        xyz_coord_names = self._coord_names[:3]\n        for name, coord_name in zip([\"x\", \"y\", \"z\"], xyz_coord_names):\n            for err in self._parsed_error_names:\n                if err[1] == coord_name:\n                    error_ind = err[3]\n                    if err[2]:\n                        # add error suffix\n                        error_name = name + \"_\" + err[2]\n                    else:\n                        error_name = name\n                    lena.context.update_recursively(\n                        context,\n                        \"error.{}.index\".format(error_name),\n                        # error can correspond both to variable and\n                        # value, so we put it outside value.\n                        # \"value.error.{}.index\".format(error_name),\n                        error_ind\n                    )", "signature": "def _update_context(self, context):", "completion_path": "lena/structures/graph.py"}
{"ce_id": "62b87b4f9a0c4fa8b80b3580", "namespace": "62b87b4f9a0c4fa8b80b3580", "namespace_real": "lena.structures.hist_functions.integral", "real_proj_path": "ynikitenko---lena/", "type": "function", "class_name": null, "function_name": "integral", "contexts_above": "\"\"\"Functions for histograms.\n\nThese functions are used for low-level work\nwith histograms and their contents.\nThey are not needed for normal usage.\n\"\"\"\nimport collections\nimport copy\nimport itertools\nimport operator\nimport re\nimport sys\nif sys.version_info.major == 3:\n    from functools import reduce as _reduce\nelse:\n    _reduce = reduce\n\nimport lena.core\nfrom .graph import graph as _graph\n\n\nclass HistCell(collections.namedtuple(\"HistCell\", (\"edges, bin, index\"))):\n    \"\"\"A namedtuple with fields *edges, bin, index*.\"\"\"\n    # from Aaron Hall's answer https://stackoverflow.com/a/28568351/952234\n    __slots__ = ()\n\n\ndef cell_to_string(\n        cell_edges, var_context=None, coord_names=None,\n        coord_fmt=\"{}_lte_{}_lt_{}\", coord_join=\"_\", reverse=False):\n    \"\"\"Transform cell edges into a string.\n\n    *cell_edges* is a tuple of pairs *(lower bound, upper bound)*\n    for each coordinate.\n\n    *coord_names* is a list of coordinates names.\n\n    *coord_fmt* is a string,\n    which defines how to format individual coordinates.\n\n    *coord_join* is a string, which joins coordinate pairs.\n\n    If *reverse* is True, coordinates are joined in reverse order.\n    \"\"\"\n    # todo: do we really need var_context?\n    # todo: even if so, why isn't that a {}? Is that dangerous?\n    if coord_names is None:\n        if var_context is None:\n            coord_names = [\n                \"coord{}\".format(ind) for ind in range(len(cell_edges))\n            ]\n        else:\n            if \"combine\" in var_context:\n                coord_names = [var[\"name\"]\n                               for var in var_context[\"combine\"]]\n            else:\n                coord_names = [var_context[\"name\"]]\n    if len(cell_edges) != len(coord_names):\n        raise lena.core.LenaValueError(\n            \"coord_names must have same length as cell_edges, \"\n            \"{} and {} given\".format(coord_names, cell_edges)\n        )\n    coord_strings = [coord_fmt.format(edge[0], coord_names[ind], edge[1])\n                     for (ind, edge) in enumerate(cell_edges)]\n    if reverse:\n        coord_strings = reversed(coord_strings)\n    coord_str = coord_join.join(coord_strings)\n    return coord_str\n\n\ndef _check_edges_increasing_1d(arr):\n    if len(arr) <= 1:\n        raise lena.core.LenaValueError(\"size of edges should be more than one,\"\n                                       \" {} provided\".format(arr))\n    increasing = (tup[0] < tup[1] for tup in zip(arr, arr[1:]))\n    if not all(increasing):\n        raise lena.core.LenaValueError(\n            \"expected strictly increasing values, \"\n            \"{} provided\".format(arr)\n        )\n\n\ndef check_edges_increasing(edges):\n    \"\"\"Assure that multidimensional *edges* are increasing.\n\n    If length of *edges* or its subarray is less than 2\n    or if some subarray of *edges*\n    contains not strictly increasing values,\n    :exc:`.LenaValueError` is raised.\n    \"\"\"\n    if not len(edges):\n        raise lena.core.LenaValueError(\"edges must be non-empty\")\n    elif not hasattr(edges[0], '__iter__'):\n        _check_edges_increasing_1d(edges)\n        return\n    for arr in edges:\n        if len(arr) <= 1:\n            raise lena.core.LenaValueError(\n                \"size of edges should be more than one. \"\n                \"{} provided\".format(arr)\n            )\n        _check_edges_increasing_1d(arr)\n\n\ndef get_bin_edges(index, edges):\n    \"\"\"Return edges of the bin for the given *edges* of a histogram.\n\n    In one-dimensional case *index* must be an integer and a tuple\n    of *(x_low_edge, x_high_edge)* for that bin is returned.\n\n    In a multidimensional case *index* is a container of numeric indices\n    in each dimension.\n    A list of bin edges in each dimension is returned.\"\"\"\n    # todo: maybe give up this 1- and multidimensional unification\n    # and write separate functions for each case.\n    if not hasattr(edges[0], '__iter__'):\n        # 1-dimensional edges\n        if hasattr(index, '__iter__'):\n            index = index[0]\n        return (edges[index], edges[index+1])\n    # multidimensional edges\n    return [(edges[coord][i], edges[coord][i+1])\n            for coord, i in enumerate(index)]\n\n\ndef get_bin_on_index(index, bins):\n    \"\"\"Return bin corresponding to multidimensional *index*.\n\n    *index* can be a number or a list/tuple.\n    If *index* length is less than dimension of *bins*,\n    a subarray of *bins* is returned.\n\n    In case of an index error, :exc:`.LenaIndexError` is raised.\n\n    Example:\n\n    >>> from lena.structures import histogram, get_bin_on_index\n    >>> hist = histogram([0, 1], [0])\n    >>> get_bin_on_index(0, hist.bins)\n    0\n    >>> get_bin_on_index((0, 1), [[0, 1], [0, 0]])\n    1\n    >>> get_bin_on_index(0, [[0, 1], [0, 0]])\n    [0, 1]\n    \"\"\"\n    if not isinstance(index, (list, tuple)):\n        index = [index]\n    subarr = bins\n    for ind in index:\n        try:\n            subarr = subarr[ind]\n        except IndexError:\n            raise lena.core.LenaIndexError(\n                \"bad index: {}, bins = {}\".format(index, bins)\n            )\n    return subarr\n\n\ndef get_bin_on_value_1d(val, arr):\n    \"\"\"Return index for value in one-dimensional array.\n\n    *arr* must contain strictly increasing values\n    (not necessarily equidistant),\n    it is not checked.\n\n    \"Linear binary search\" is used,\n    that is our array search by default assumes\n    the array to be split on equidistant steps.\n\n    Example:\n\n    >>> from lena.structures import get_bin_on_value_1d\n    >>> arr = [0, 1, 4, 5, 7, 10]\n    >>> get_bin_on_value_1d(0, arr)\n    0\n    >>> get_bin_on_value_1d(4.5, arr)\n    2\n    >>> # upper range is excluded\n    >>> get_bin_on_value_1d(10, arr)\n    5\n    >>> # underflow\n    >>> get_bin_on_value_1d(-10, arr)\n    -1\n    \"\"\"\n    # may also use numpy.searchsorted\n    # https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.searchsorted.html\n    ind_min = 0\n    ind_max = len(arr) - 1\n    while True:\n        if ind_max - ind_min <= 1:\n            # lower bound is close\n            if val < arr[ind_min]:\n                return ind_min - 1\n            # upper bound is open\n            elif val >= arr[ind_max]:\n                return ind_max\n            else:\n                return ind_min\n        if val == arr[ind_min]:\n            return ind_min\n        if val < arr[ind_min]:\n            return ind_min - 1\n        elif val >= arr[ind_max]:\n            return ind_max\n        else:\n            shift = int(\n                (ind_max - ind_min) * (\n                    float(val - arr[ind_min]) / (arr[ind_max] - arr[ind_min])\n                ))\n            ind_guess = ind_min + shift\n\n            if ind_min == ind_guess:\n                ind_min += 1\n                continue\n            # ind_max is always more that ind_guess,\n            # because val < arr[ind_max] (see the formula for shift).\n            # This branch is not needed and can't be tested.\n            # But for the sake of numerical inaccuracies, let us keep this\n            # so that we never get into an infinite loop.\n            elif ind_max == ind_guess:\n                ind_max -= 1\n                continue\n\n            if val < arr[ind_guess]:\n                ind_max = ind_guess\n            else:\n                ind_min = ind_guess\n\n\ndef get_bin_on_value(arg, edges):\n    \"\"\"Get the bin index for *arg* in a multidimensional array *edges*.\n\n    *arg* is a 1-dimensional array of numbers\n    (or a number for 1-dimensional *edges*),\n    and corresponds to a point in N-dimensional space.\n\n    *edges* is an array of N-1 dimensional arrays (lists or tuples) of numbers.\n    Each 1-dimensional subarray consists of increasing numbers.\n\n    *arg* and *edges* must have the same length\n    (otherwise :exc:`.LenaValueError` is raised).\n    *arg* and *edges* must be iterable and support *len()*.\n\n    Return list of indices in *edges* corresponding to *arg*.\n\n    If any coordinate is out of its corresponding edge range,\n    its index will be ``-1`` for underflow\n    or ``len(edge)-1`` for overflow.\n\n    Examples:\n\n    >>> from lena.structures import get_bin_on_value\n    >>> edges = [[1, 2, 3], [1, 3.5]]\n    >>> get_bin_on_value((1.5, 2), edges)\n    [0, 0]\n    >>> get_bin_on_value((1.5, 0), edges)\n    [0, -1]\n    >>> # the upper edge is excluded\n    >>> get_bin_on_value((3, 2), edges)\n    [2, 0]\n    >>> # one-dimensional edges\n    >>> edges = [1, 2, 3]\n    >>> get_bin_on_value(2, edges)\n    [1]\n    \"\"\"\n    # arg is a one-dimensional index\n    if not isinstance(arg, (tuple, list)):\n        return [get_bin_on_value_1d(arg, edges)]\n    # arg is a multidimensional index\n    if len(arg) != len(edges):\n        raise lena.core.LenaValueError(\n            \"argument should have same dimension as edges. \"\n            \"arg = {}, edges = {}\".format(arg, edges)\n        )\n    indices = []\n    for ind, array in enumerate(edges):\n        cur_bin = get_bin_on_value_1d(arg[ind], array)\n        indices.append(cur_bin)\n    return indices\n\n\ndef get_example_bin(struct):\n    \"\"\"Return bin with zero index on each axis of the histogram bins.\n\n    For example, if the histogram is two-dimensional, return hist[0][0].\n\n    *struct* can be a :class:`.histogram`\n    or an array of bins.\n    \"\"\"\n    if isinstance(struct, lena.structures.histogram):\n        return lena.structures.get_bin_on_index([0] * struct.dim, struct.bins)\n    else:\n        bins = struct\n        while isinstance(bins, list):\n            bins = bins[0]\n        return bins\n\n\ndef hist_to_graph(hist, make_value=None, get_coordinate=\"left\",\n                  field_names=(\"x\", \"y\"), scale=None):\n    \"\"\"Convert a :class:`.histogram` to a :class:`.graph`.\n\n    *make_value* is a function to set the value of a graph's point.\n    By default it is bin content.\n    *make_value* accepts a single value (bin content) without context.\n\n    This option could be used to create graph's error bars.\n    For example, to create a graph with errors\n    from a histogram where bins contain\n    a named tuple with fields *mean*, *mean_error* and a context\n    one could use\n\n    >>> make_value = lambda bin_: (bin_.mean, bin_.mean_error)\n\n    *get_coordinate* defines what the coordinate\n    of a graph point created from a histogram bin will be.\n    It can be \"left\" (default), \"right\" and \"middle\".\n\n    *field_names* set field names of the graph. Their number\n    must be the same as the dimension of the result.\n    For a *make_value* above they would be\n    *(\"x\", \"y_mean\", \"y_mean_error\")*.\n\n    *scale* becomes the graph's scale (unknown by default).\n    If it is ``True``, it uses the histogram scale.\n\n    *hist* must contain only numeric bins (without context)\n    or *make_value* must remove context when creating a numeric graph.\n\n    Return the resulting graph.\n    \"\"\"\n    ## Could have allowed get_coordinate to be callable\n    # (for generality), but 1) first find a use case,\n    # 2) histogram bins could be adjusted in the first place.\n    # -- don't understand 2.\n    if get_coordinate == \"left\":\n        get_coord = lambda edges: tuple(coord[0] for coord in edges)\n    elif get_coordinate == \"right\":\n        get_coord = lambda edges: tuple(coord[1] for coord in edges)\n    # *middle* between the two edges, not the *center* of the bin\n    # as a whole (because the graph corresponds to a point)\n    elif get_coordinate == \"middle\":\n        get_coord = lambda edges: tuple(0.5*(coord[0] + coord[1])\n                                        for coord in edges)\n    else:\n        raise lena.core.LenaValueError(\n            'get_coordinate must be one of \"left\", \"right\" or \"middle\"; '\n            '\"{}\" provided'.format(get_coordinate)\n        )\n\n    # todo: make_value may be bad design.\n    # Maybe allow to change the graph in the sequence.\n    # However, make_value allows not to recreate a graph\n    # or its coordinates (if that is not needed).\n\n    if isinstance(field_names, str):\n        # copied from graph.__init__\n        field_names = tuple(re.findall(r'[^,\\s]+', field_names))\n    elif not isinstance(field_names, tuple):\n        raise lena.core.LenaTypeError(\n            \"field_names must be a string or a tuple\"\n        )\n    coords = [[] for _ in field_names]\n\n    chain = itertools.chain\n\n    if scale is True:\n        scale = hist.scale()\n\n    for value, edges in iter_bins_with_edges(hist.bins, hist.edges):\n        coord = get_coord(edges)\n\n        # Since we never use contexts here, it will be optimal\n        # to ignore them completely (remove them elsewhere).\n        # bin_value = lena.flow.get_data(value)\n        bin_value = value\n\n        if make_value is None:\n            graph_value = bin_value\n        else:\n            graph_value = make_value(bin_value)\n\n        # for iteration below\n        if not hasattr(graph_value, \"__iter__\"):\n            graph_value = (graph_value,)\n\n        # add each coordinate to respective array\n        for arr, coord_ in zip(coords, chain(coord, graph_value)):\n            arr.append(coord_)\n\n    return _graph(coords, field_names=field_names, scale=scale)\n\n\ndef init_bins(edges, value=0, deepcopy=False):\n    \"\"\"Initialize cells of the form *edges* with the given *value*.\n\n    Return bins filled with copies of *value*.\n\n    *Value* must be copyable, usual numbers will suit.\n    If the value is mutable, use *deepcopy =* ``True``\n    (or the content of cells will be identical).\n\n    Examples:\n\n    >>> edges = [[0, 1], [0, 1]]\n    >>> # one cell\n    >>> init_bins(edges)\n    [[0]]\n    >>> # no need to use floats,\n    >>> # because integers will automatically be cast to floats\n    >>> # when used together\n    >>> init_bins(edges, 0.0)\n    [[0.0]]\n    >>> init_bins([[0, 1, 2], [0, 1, 2]])\n    [[0, 0], [0, 0]]\n    >>> init_bins([0, 1, 2])\n    [0, 0]\n    \"\"\"\n    nbins = len(edges) - 1\n    if not isinstance(edges[0], (list, tuple)):\n        # edges is one-dimensional\n        if deepcopy:\n            return [copy.deepcopy(value) for _ in range(nbins)]\n        else:\n            return [value] * nbins\n    for ind, arr in enumerate(edges):\n        if ind == nbins:\n            if deepcopy:\n                return [copy.deepcopy(value) for _ in range(len(arr)-1)]\n            else:\n                return list([value] * (len(arr)-1))\n        bins = []\n        for _ in range(len(arr)-1):\n            bins.append(init_bins(edges[ind+1:], value, deepcopy))\n        return bins\n\n", "contexts_below": "\n def iter_bins(bins):\n     \"\"\"Iterate on *bins*. Yield *(index, bin content)*.\n \n     Edges with higher index are iterated first\n     (that is z, then y, then x for a 3-dimensional histogram).\n     \"\"\"\n     # if not isinstance(bins, (list, tuple)):\n     if not hasattr(bins, '__iter__'):\n         # cell\n         yield ((), bins)\n     else:\n         for ind, _ in enumerate(bins):\n             for sub_ind, val in iter_bins(bins[ind]):\n                 yield (((ind,) + sub_ind), val)\n \n \n def iter_bins_with_edges(bins, edges):\n     \"\"\"Generate *(bin content, bin edges)* pairs.\n \n     Bin edges is a tuple, such that\n     its item at index i is *(lower bound, upper bound)*\n     of the bin at i-th coordinate.\n \n     Examples:\n \n     >>> from lena.math import mesh\n     >>> list(iter_bins_with_edges([0, 1, 2], edges=mesh((0, 3), 3)))\n     [(0, ((0, 1.0),)), (1, ((1.0, 2.0),)), (2, ((2.0, 3),))]\n     >>>\n     >>> # 2-dimensional histogram\n     >>> list(iter_bins_with_edges(\n     ...     bins=[[2]], edges=mesh(((0, 1), (0, 1)), (1, 1))\n     ... ))\n     [(2, ((0, 1), (0, 1)))]\n \n     .. versionadded:: 0.5\n        made public.\n     \"\"\"\n     # todo: only a list or also a tuple, an array?\n     if not isinstance(edges[0], list):\n         edges = [edges]\n     bins_sizes = [len(edge)-1 for edge in edges]\n     indices = [list(range(nbins)) for nbins in bins_sizes]\n     for index in itertools.product(*indices):\n         bin_ = lena.structures.get_bin_on_index(index, bins)\n         edges_low = []\n         edges_high = []\n         for var, var_ind in enumerate(index):\n             edges_low.append(edges[var][var_ind])\n             edges_high.append(edges[var][var_ind+1])\n         yield (bin_, tuple(zip(edges_low, edges_high)))\n \n \n def iter_cells(hist, ranges=None, coord_ranges=None):\n     \"\"\"Iterate cells of a histogram *hist*, possibly in a subrange.\n \n     For each bin, yield a :class:`HistCell`\n     containing *bin edges, bin content* and *bin index*.\n     The order of iteration is the same as for :func:`iter_bins`.\n \n     *ranges* are the ranges of bin indices to be used\n     for each coordinate\n     (the lower value is included, the upper value is excluded).\n \n     *coord_ranges* set real coordinate ranges based on histogram edges.\n     Obviously, they can be not exactly bin edges.\n     If one of the ranges for the given coordinate\n     is outside the histogram edges,\n     then only existing histogram edges within the range are selected.\n     If the coordinate range is completely outside histogram edges,\n     nothing is yielded.\n     If a lower or upper *coord_range*\n     falls within a bin, this bin is yielded.\n     Note that if a coordinate range falls on a bin edge,\n     the number of generated bins can be unstable\n     because of limited float precision.\n \n     *ranges* and *coord_ranges* are tuples of tuples of limits\n     in corresponding dimensions. \n     For one-dimensional histogram it must be a tuple \n     containing a tuple, for example\n     *((None, None),)*.\n \n     ``None`` as an upper or lower *range* means no limit\n     (*((None, None),)* is equivalent to *((0, len(bins)),)*\n     for a 1-dimensional histogram).\n \n     If a *range* index is lower than 0 or higher than possible index,\n     :exc:`.LenaValueError` is raised.\n     If both *coord_ranges* and *ranges* are provided,\n     :exc:`.LenaTypeError` is raised.\n     \"\"\"\n     # for bin_ind, bin_ in iter_bins(hist.bins):\n     #     yield HistCell(get_bin_edges(bin_ind, hist.edges), bin_, bin_ind)\n     # if bins and edges are calculated each time, save the result now\n     bins, edges = hist.bins, hist.edges\n     # todo: hist.edges must be same\n     # for 1- and multidimensional histograms.\n     if hist.dim == 1:\n         edges = (edges,)\n \n     if coord_ranges is not None:\n         if ranges is not None:\n             raise lena.core.LenaTypeError(\n                 \"only ranges or coord_ranges can be provided, not both\"\n             )\n         ranges = []\n         if not isinstance(coord_ranges[0], (tuple, list)):\n             coord_ranges = (coord_ranges, )\n         for coord, coord_range in enumerate(coord_ranges):\n             # todo: (dis?)allow None as an infinite range.\n             # todo: raise or transpose unordered coordinates?\n             # todo: change the order of function arguments.\n             lower_bin_ind = get_bin_on_value_1d(coord_range[0], edges[coord])\n             if lower_bin_ind == -1:\n                  lower_bin_ind = 0\n             upper_bin_ind = get_bin_on_value_1d(coord_range[1], edges[coord])\n             max_ind = len(edges[coord])\n             if upper_bin_ind == max_ind:\n                  upper_bin_ind -= 1\n             if lower_bin_ind >= max_ind or upper_bin_ind <= 0:\n                  # histogram edges are outside the range.\n                  return\n             ranges.append((lower_bin_ind, upper_bin_ind))\n \n     if not ranges:\n         ranges = ((None, None),) * hist.dim\n \n     real_ind_ranges = []\n     for coord, coord_range in enumerate(ranges):\n         low, up = coord_range\n         if low is None:\n             low = 0\n         else:\n             # negative indices should not be supported\n             if low < 0:\n                 raise lena.core.LenaValueError(\n                     \"low must be not less than 0 if provided\"\n                 )\n         max_ind = len(edges[coord]) - 1\n         if up is None:\n             up = max_ind\n         else:\n             # huge indices should not be supported as well.\n             if up > max_ind:\n                 raise lena.core.LenaValueError(\n                     \"up must not be greater than len(edges)-1, if provided\"\n                 )\n         real_ind_ranges.append(list(range(low, up)))\n \n     indices = list(itertools.product(*real_ind_ranges))\n     for ind in indices:\n         yield HistCell(get_bin_edges(ind, edges),\n                        get_bin_on_index(ind, bins),\n                        ind)\n \n \n def make_hist_context(hist, context):\n     \"\"\"Update a deep copy of *context* with the context\n     of a :class:`.histogram` *hist*.\n \n     .. deprecated:: 0.5\n        histogram context is updated automatically\n        during conversion in :class:`~.output.ToCSV`.\n        Use histogram._update_context explicitly if needed.\n     \"\"\"\n     # absolutely unnecessary.\n     context = copy.deepcopy(context)\n \n     hist_context = {\n         \"histogram\": {\n             \"dim\": hist.dim,\n             \"nbins\": hist.nbins,\n             \"ranges\": hist.ranges\n         }\n     }\n     context.update(hist_context)\n     # just bad.\n     return context\n \n \n def unify_1_md(bins, edges):\n     \"\"\"Unify 1- and multidimensional bins and edges.\n \n     Return a tuple of *(bins, edges)*.  \n     Bins and multidimensional *edges* return unchanged,\n     while one-dimensional *edges* are inserted into a list.\n     \"\"\"\n     if hasattr(edges[0], '__iter__'):\n     # if isinstance(edges[0], (list, tuple)):\n         return (bins, edges)\n     else:\n         return (bins, [edges])\n ", "input_code": "def integral(bins, edges):\n\"\"\"\nCompute integral (scale for a histogram).\n\n*bins* contain values, and *edges* form the mesh\nfor the integration.\nTheir format is defined in :class:`.histogram` description.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def integral(bins, edges):\n    \"\"\"Compute integral (scale for a histogram).\n\n    *bins* contain values, and *edges* form the mesh\n    for the integration.\n    Their format is defined in :class:`.histogram` description.\n    \"\"\"\n    total = 0\n    for ind, bin_content in iter_bins(bins):\n        bin_lengths = [\n            edges[coord][i+1] - edges[coord][i]\n            for coord, i in enumerate(ind)\n        ]\n        # product\n        vol = _reduce(operator.mul, bin_lengths, 1)\n        cell_integral = vol * bin_content\n        total += cell_integral\n    return total", "signature": "def integral(bins, edges):", "completion_path": "lena/structures/hist_functions.py"}
{"ce_id": "62b87b199a0c4fa8b80b354e", "namespace": "62b87b199a0c4fa8b80b354e", "namespace_real": "lena.core.check_sequence_type.is_fill_request_seq", "real_proj_path": "ynikitenko---lena/", "type": "function", "class_name": null, "function_name": "is_fill_request_seq", "contexts_above": "\"\"\"Check whether a sequence can be converted to a Lena Sequence.\"\"\"\n# otherwise import errors arise\n# from . import source\n\n\ndef is_fill_compute_el(obj):\n    \"\"\"Object contains executable methods 'fill' and 'compute'.\"\"\"\n    return (hasattr(obj, \"fill\")\n            and hasattr(obj, \"compute\")\n            and callable(obj.fill)\n            and callable(obj.compute))\n\n\ndef is_fill_compute_seq(seq):\n    \"\"\"Test whether *seq* can be converted to a FillComputeSeq.\n\n    True only if it is a FillCompute element\n    or contains at least one such,\n    and it is not a Source sequence.\n    \"\"\"\n    if is_source(seq):\n        return False\n    is_fcseq = False\n    try:\n        is_fcseq = any(map(is_fill_compute_el, seq))\n    except TypeError:\n        # seq is non-iterable\n        pass\n    if is_fill_compute_el(seq):\n        is_fcseq = True\n    return is_fcseq\n\n\ndef is_fill_request_el(obj):\n    \"\"\"Object contains executable methods 'fill' and 'request'.\"\"\"\n    return hasattr(obj, \"fill\") and hasattr(obj, \"request\") \\\n            and callable(obj.fill) and callable(obj.request)\n\n", "contexts_below": "\n def is_run_el(obj):\n     \"\"\"Object contains executable method 'run'.\"\"\"\n     return hasattr(obj, \"run\") and callable(obj.run)\n \n \n def is_source(seq):\n     \"\"\"Sequence is a Source, if and only if its type is Source.\"\"\"\n     # Otherwise lambdas would be counted as Source,\n     # but they must be converted to Sequences.\n     # Moreover: this makes Source elements explicit and visible in code.\n     from . import source\n     return isinstance(seq, source.Source)\n ", "input_code": "def is_fill_request_seq(seq):\n\"\"\"\nTest whether *seq* can be converted to a FillRequestSeq.\n\nTrue only if it is a FillRequest element\nor contains at least one such,\nand it is not a Source sequence.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def is_fill_request_seq(seq):\n    \"\"\"Test whether *seq* can be converted to a FillRequestSeq.\n\n    True only if it is a FillRequest element\n    or contains at least one such,\n    and it is not a Source sequence.\n    \"\"\"\n    if is_source(seq):\n        return False\n    is_fcseq = False\n    if hasattr(seq, \"__iter__\"):\n        is_fcseq = any(map(is_fill_request_el, seq))\n    if is_fill_request_el(seq):\n        is_fcseq = True\n    return is_fcseq", "signature": "def is_fill_request_seq(seq):", "completion_path": "lena/core/check_sequence_type.py"}
{"ce_id": "62b87b099a0c4fa8b80b3538", "namespace": "62b87b099a0c4fa8b80b3538", "namespace_real": "lena.core.check_sequence_type.is_fill_request_el", "real_proj_path": "ynikitenko---lena/", "type": "function", "class_name": null, "function_name": "is_fill_request_el", "contexts_above": "\"\"\"Check whether a sequence can be converted to a Lena Sequence.\"\"\"\n# otherwise import errors arise\n# from . import source\n\n\ndef is_fill_compute_el(obj):\n    \"\"\"Object contains executable methods 'fill' and 'compute'.\"\"\"\n    return (hasattr(obj, \"fill\")\n            and hasattr(obj, \"compute\")\n            and callable(obj.fill)\n            and callable(obj.compute))\n\n\ndef is_fill_compute_seq(seq):\n    \"\"\"Test whether *seq* can be converted to a FillComputeSeq.\n\n    True only if it is a FillCompute element\n    or contains at least one such,\n    and it is not a Source sequence.\n    \"\"\"\n    if is_source(seq):\n        return False\n    is_fcseq = False\n    try:\n        is_fcseq = any(map(is_fill_compute_el, seq))\n    except TypeError:\n        # seq is non-iterable\n        pass\n    if is_fill_compute_el(seq):\n        is_fcseq = True\n    return is_fcseq\n\n", "contexts_below": "\n def is_fill_request_seq(seq):\n     \"\"\"Test whether *seq* can be converted to a FillRequestSeq.\n \n     True only if it is a FillRequest element\n     or contains at least one such,\n     and it is not a Source sequence.\n     \"\"\"\n     if is_source(seq):\n         return False\n     is_fcseq = False\n     if hasattr(seq, \"__iter__\"):\n         is_fcseq = any(map(is_fill_request_el, seq))\n     if is_fill_request_el(seq):\n         is_fcseq = True\n     return is_fcseq\n \n \n def is_run_el(obj):\n     \"\"\"Object contains executable method 'run'.\"\"\"\n     return hasattr(obj, \"run\") and callable(obj.run)\n \n \n def is_source(seq):\n     \"\"\"Sequence is a Source, if and only if its type is Source.\"\"\"\n     # Otherwise lambdas would be counted as Source,\n     # but they must be converted to Sequences.\n     # Moreover: this makes Source elements explicit and visible in code.\n     from . import source\n     return isinstance(seq, source.Source)\n ", "input_code": "def is_fill_request_el(obj):\n\"\"\"\nObject contains executable methods 'fill' and 'request'.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def is_fill_request_el(obj):\n    \"\"\"Object contains executable methods 'fill' and 'request'.\"\"\"\n    return hasattr(obj, \"fill\") and hasattr(obj, \"request\") \\\n            and callable(obj.fill) and callable(obj.request)", "signature": "def is_fill_request_el(obj):", "completion_path": "lena/core/check_sequence_type.py"}
{"ce_id": "62b87af99a0c4fa8b80b3524", "namespace": "62b87af99a0c4fa8b80b3524", "namespace_real": "lena.core.check_sequence_type.is_run_el", "real_proj_path": "ynikitenko---lena/", "type": "function", "class_name": null, "function_name": "is_run_el", "contexts_above": "\"\"\"Check whether a sequence can be converted to a Lena Sequence.\"\"\"\n# otherwise import errors arise\n# from . import source\n\n\ndef is_fill_compute_el(obj):\n    \"\"\"Object contains executable methods 'fill' and 'compute'.\"\"\"\n    return (hasattr(obj, \"fill\")\n            and hasattr(obj, \"compute\")\n            and callable(obj.fill)\n            and callable(obj.compute))\n\n\ndef is_fill_compute_seq(seq):\n    \"\"\"Test whether *seq* can be converted to a FillComputeSeq.\n\n    True only if it is a FillCompute element\n    or contains at least one such,\n    and it is not a Source sequence.\n    \"\"\"\n    if is_source(seq):\n        return False\n    is_fcseq = False\n    try:\n        is_fcseq = any(map(is_fill_compute_el, seq))\n    except TypeError:\n        # seq is non-iterable\n        pass\n    if is_fill_compute_el(seq):\n        is_fcseq = True\n    return is_fcseq\n\n\ndef is_fill_request_el(obj):\n    \"\"\"Object contains executable methods 'fill' and 'request'.\"\"\"\n    return hasattr(obj, \"fill\") and hasattr(obj, \"request\") \\\n            and callable(obj.fill) and callable(obj.request)\n\n\ndef is_fill_request_seq(seq):\n    \"\"\"Test whether *seq* can be converted to a FillRequestSeq.\n\n    True only if it is a FillRequest element\n    or contains at least one such,\n    and it is not a Source sequence.\n    \"\"\"\n    if is_source(seq):\n        return False\n    is_fcseq = False\n    if hasattr(seq, \"__iter__\"):\n        is_fcseq = any(map(is_fill_request_el, seq))\n    if is_fill_request_el(seq):\n        is_fcseq = True\n    return is_fcseq\n\n", "contexts_below": "\n def is_source(seq):\n     \"\"\"Sequence is a Source, if and only if its type is Source.\"\"\"\n     # Otherwise lambdas would be counted as Source,\n     # but they must be converted to Sequences.\n     # Moreover: this makes Source elements explicit and visible in code.\n     from . import source\n     return isinstance(seq, source.Source)\n ", "input_code": "def is_run_el(obj):\n\"\"\"\nObject contains executable method 'run'.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def is_run_el(obj):\n    \"\"\"Object contains executable method 'run'.\"\"\"\n    return hasattr(obj, \"run\") and callable(obj.run)", "signature": "def is_run_el(obj):", "completion_path": "lena/core/check_sequence_type.py"}
{"ce_id": "62b87af69a0c4fa8b80b351a", "namespace": "62b87af69a0c4fa8b80b351a", "namespace_real": "lena.core.check_sequence_type.is_fill_compute_el", "real_proj_path": "ynikitenko---lena/", "type": "function", "class_name": null, "function_name": "is_fill_compute_el", "contexts_above": "\"\"\"Check whether a sequence can be converted to a Lena Sequence.\"\"\"\n# otherwise import errors arise\n# from . import source\n\n", "contexts_below": "\n def is_fill_compute_seq(seq):\n     \"\"\"Test whether *seq* can be converted to a FillComputeSeq.\n \n     True only if it is a FillCompute element\n     or contains at least one such,\n     and it is not a Source sequence.\n     \"\"\"\n     if is_source(seq):\n         return False\n     is_fcseq = False\n     try:\n         is_fcseq = any(map(is_fill_compute_el, seq))\n     except TypeError:\n         # seq is non-iterable\n         pass\n     if is_fill_compute_el(seq):\n         is_fcseq = True\n     return is_fcseq\n \n \n def is_fill_request_el(obj):\n     \"\"\"Object contains executable methods 'fill' and 'request'.\"\"\"\n     return hasattr(obj, \"fill\") and hasattr(obj, \"request\") \\\n             and callable(obj.fill) and callable(obj.request)\n \n \n def is_fill_request_seq(seq):\n     \"\"\"Test whether *seq* can be converted to a FillRequestSeq.\n \n     True only if it is a FillRequest element\n     or contains at least one such,\n     and it is not a Source sequence.\n     \"\"\"\n     if is_source(seq):\n         return False\n     is_fcseq = False\n     if hasattr(seq, \"__iter__\"):\n         is_fcseq = any(map(is_fill_request_el, seq))\n     if is_fill_request_el(seq):\n         is_fcseq = True\n     return is_fcseq\n \n \n def is_run_el(obj):\n     \"\"\"Object contains executable method 'run'.\"\"\"\n     return hasattr(obj, \"run\") and callable(obj.run)\n \n \n def is_source(seq):\n     \"\"\"Sequence is a Source, if and only if its type is Source.\"\"\"\n     # Otherwise lambdas would be counted as Source,\n     # but they must be converted to Sequences.\n     # Moreover: this makes Source elements explicit and visible in code.\n     from . import source\n     return isinstance(seq, source.Source)\n ", "input_code": "def is_fill_compute_el(obj):\n\"\"\"\nObject contains executable methods 'fill' and 'compute'.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def is_fill_compute_el(obj):\n    \"\"\"Object contains executable methods 'fill' and 'compute'.\"\"\"\n    return (hasattr(obj, \"fill\")\n            and hasattr(obj, \"compute\")\n            and callable(obj.fill)\n            and callable(obj.compute))", "signature": "def is_fill_compute_el(obj):", "completion_path": "lena/core/check_sequence_type.py"}
{"ce_id": "62b87af19a0c4fa8b80b34f7", "namespace": "62b87af19a0c4fa8b80b34f7", "namespace_real": "lena.context.functions.difference", "real_proj_path": "ynikitenko---lena/", "type": "function", "class_name": null, "function_name": "difference", "contexts_above": "\"\"\"Functions to work with context (dictionary).\"\"\"\n\nimport copy\n\nimport lena.core\n\n# pylint: disable=invalid-name\n# d is a good name for dictionary,\n# used in Python documentation for dict.\n\n\ndef contains(d, s):\n    \"\"\"Check that a dictionary *d* contains a subdictionary\n    defined by a string *s*.\n\n    True if *d* contains a subdictionary that is represented by *s*.\n    Dots in *s* mean nested subdictionaries.\n    A string without dots means a key in *d*.\n\n    Example:\n\n    >>> d = {'fit': {'coordinate': 'x'}}\n    >>> contains(d, \"fit\")\n    True\n    >>> contains(d, \"fit.coordinate.x\")\n    True\n    >>> contains(d, \"fit.coordinate.y\")\n    False\n\n    If the most nested element of *d* to be compared with *s*\n    is not a string, its string representation is used for comparison.\n    See also :func:`str_to_dict`.\n    \"\"\"\n    # todo: s can be a list, or a dict?\n    levels = s.split(\".\")\n    if len(levels) < 2:\n        return s in d\n    subdict = d\n    for key in levels[:-1]:\n        if key not in subdict:\n            return False\n        subdict = subdict[key]\n    last_val = levels[-1]\n    if isinstance(subdict, dict):\n        return last_val in subdict\n    else:\n        # just a value\n        try:\n            # it's better to test for an object to be cast to str\n            # than to disallow \"dim.1\"\n            subd = str(subdict)\n        except Exception:\n            return False\n        else:\n            return subd == last_val\n\n", "contexts_below": "\n def format_context(format_str):\n     \"\"\"Create a function that formats a given string using a context.\n \n     It is recommended to use jinja2.Template.\n     Use this function only if you don't have jinja2.\n \n     *format_str* is a Python format string with double braces\n     instead of single ones.\n     It must contain all non-empty replacement fields,\n     and only simplest formatting without attribute lookup.\n     Example:\n \n     >>> f = format_context(\"{{x}}\")\n     >>> f({\"x\": 10})\n     '10'\n \n     When calling *format_context*, arguments are bound and\n     a new function is returned. When called with a context,\n     its keys are extracted and formatted in *format_str*.\n \n     Keys can be nested using a dot, for example:\n \n     >>> f = format_context(\"{{x.y}}_{{z}}\")\n     >>> f({\"x\": {\"y\": 10}, \"z\": 1})\n     '10_1'\n \n     This function does not work with unbalanced braces.\n     If a simple check fails, :exc:`.LenaValueError` is raised.\n     If *format_str* is not a string, :exc:`.LenaTypeError` is raised.\n     All other errors are raised only during formatting.\n     If context doesn't contain the needed key,\n     :exc:`.LenaKeyError` is raised.\n     Note that string formatting can also raise a :exc:`ValueError`,\n     so it is recommended to test your formatters before using them.\n     \"\"\"\n     if not isinstance(format_str, str):\n         raise lena.core.LenaTypeError(\n             \"format_str must be a string, {} given\".format(format_str)\n         )\n \n     # prohibit single or unbalanced braces\n     if format_str.count('{') != format_str.count('}'):\n         raise lena.core.LenaValueError(\"unbalanced braces in '{}'\".format(format_str))\n     if '{' in format_str and not '{{' in format_str:\n         raise lena.core.LenaValueError(\n             \"double braces must be used for formatting instead of '{}'\"\n             .format(format_str)\n         )\n \n     # new format: now double braces instead of single ones.\n     # but the algorithm may be left unchanged.\n     format_str = format_str.replace(\"{{\", \"{\").replace(\"}}\", \"}\")\n     new_str = []\n     new_args = []\n     prev_char = ''\n     ind = 0\n     within_field = False\n     while ind < len(format_str):\n         c = format_str[ind]\n         if c != '{' and not within_field:\n             prev_char = c\n             new_str.append(c)\n             ind += 1\n             continue\n         while c == '{' and ind < len(format_str):\n             new_str.append(c)\n             # literal formatting { are not allowed\n             # if prev_char == '{':\n             #     prev_char = ''\n             #     within_field = False\n             # else:\n             prev_char = c\n             within_field = True\n \n             ind += 1\n             c = format_str[ind]\n         if within_field:\n             new_arg = []\n             while ind < len(format_str):\n                 if c in '}!:':\n                     prev_char = c\n                     within_field = False\n                     new_args.append(''.join(new_arg))\n                     break\n                 new_arg.append(c)\n                 ind += 1\n                 c = format_str[ind]\n     format_str = ''.join(new_str)\n     args = new_args\n     def _format_context(context):\n         new_args = []\n         for arg in args:\n             # LenaKeyError may be raised\n             new_args.append(lena.context.get_recursively(context, arg))\n         # other exceptions, like ValueError\n         # (for bad string formatting) may be raised.\n         s = format_str.format(*new_args)\n         return s\n     return _format_context\n \n \n _sentinel = object()\n \n \n def get_recursively(d, keys, default=_sentinel):\n     \"\"\"Get value from a dictionary *d* recursively.\n \n     *keys* can be a list of simple keys (strings),\n     a dot-separated string\n     or a dictionary with at most one key at each level.\n     A string is split by dots and used as a list.\n     A list of keys is searched in the dictionary recursively\n     (it represents nested dictionaries).\n     If any of them is not found, *default* is returned\n     if \"default\" is given,\n     otherwise :exc:`.LenaKeyError` is raised.\n \n     If *keys* is empty, *d* is returned.\n \n     Examples:\n \n     >>> context = {\"output\": {\"latex\": {\"name\": \"x\"}}}\n     >>> get_recursively(context, [\"output\", \"latex\", \"name\"], default=\"y\")\n     'x'\n     >>> get_recursively(context, \"output.latex.name\")\n     'x'\n \n     .. note::\n         Python's dict.get in case of a missing value\n         returns ``None`` and never raises an error.\n         We implement it differently,\n         because it allows more flexibility.\n \n     If *d* is not a dictionary or if *keys* is not a string, a dict\n     or a list, :exc:`.LenaTypeError` is raised.\n     If *keys* is a dictionary with more than one key at some level,\n     :exc:`.LenaValueError` is raised.\n     \"\"\"\n     has_default = default is not _sentinel\n     if not isinstance(d, dict):\n         raise lena.core.LenaTypeError(\n             \"need a dictionary, {} provided\".format(d)\n         )\n     if isinstance(keys, str):\n         # here empty substrings are skipped, but this is undefined.\n         keys = [key for key in keys.split('.') if key]\n     # todo: create dict_to_list and disable dict keys here?\n     elif isinstance(keys, dict):\n         new_keys = []\n         while keys:\n             if isinstance(keys, dict) and len(keys) != 1:\n                 raise lena.core.LenaValueError(\n                     \"keys must have exactly one key at each level, \"\n                     \"{} given\".format(keys)\n                 )\n             else:\n                 if not isinstance(keys, dict):\n                     new_keys.append(keys)\n                     break\n                 for key in keys:\n                     new_keys.append(key)\n                     keys = keys[key]\n                     break\n         keys = new_keys\n     elif isinstance(keys, list):\n         if not all(isinstance(k, str) for k in keys):\n             raise lena.core.LenaTypeError(\n                 \"all simple keys must be strings, \"\n                 \"{} given\".format(keys)\n             )\n     else:\n         raise lena.core.LenaTypeError(\n             \"keys must be a dict, a string or a list of keys, \"\n             \"{} given\".format(keys)\n         )\n \n     for key in keys[:-1]:\n         if key in d and isinstance(d.get(key), dict):\n             d = d[key]\n         elif has_default:\n             return default\n         else:\n             raise lena.core.LenaKeyError(\n                 \"nested dict {} not found in {}\".format(key, d)\n             )\n \n     if not keys:\n         return d\n     if keys[-1] in d:\n         return d[keys[-1]]\n     elif has_default:\n         return default\n     else:\n         raise lena.core.LenaKeyError(\n             \"nested key {} not found in {}\".format(keys[-1], d)\n         )\n \n \n def intersection(*dicts, **kwargs):\n     \"\"\"Return a dictionary, such that each of its items\n     are contained in all *dicts* (recursively).\n \n     *dicts* are several dictionaries.\n     If *dicts* is empty, an empty dictionary is returned.\n \n     A keyword argument *level* sets maximum number of recursions.\n     For example, if *level* is 0, all *dicts* must be equal\n     (otherwise an empty dict is returned).\n     If *level* is 1, the result contains those subdictionaries\n     which are equal.\n     For arbitrarily nested subdictionaries set *level* to -1 (default).\n \n     Example:\n \n     >>> from lena.context import intersection\n     >>> d1 = {1: \"1\", 2: {3: \"3\", 4: \"4\"}}\n     >>> d2 = {2: {4: \"4\"}}\n     >>> # by default level is -1, which means infinite recursion\n     >>> intersection(d1, d2) == d2\n     True\n     >>> intersection(d1, d2, level=0)\n     {}\n     >>> intersection(d1, d2, level=1)\n     {}\n     >>> intersection(d1, d2, level=2)\n     {2: {4: '4'}}\n \n     This function always returns a dictionary\n     or its subtype (copied from dicts[0]).\n     All values are deeply copied.\n     No dictionary or subdictionary is changed.\n \n     If any of *dicts* is not a dictionary\n     or if some *kwargs* are unknown,\n     :exc:`.LenaTypeError` is raised.\n     \"\"\"\n     if not all([isinstance(d, dict) for d in dicts]):\n         raise lena.core.LenaTypeError(\n             \"all dicts must be dictionaries, \"\n             \"{} given\".format(dicts)\n         )\n \n     level = kwargs.pop(\"level\", -1)\n     if kwargs:\n         raise lena.core.LenaTypeError(\n             \"unknown kwargs {}\".format(kwargs)\n         )\n \n     if not dicts:\n         return {}\n     res = copy.deepcopy(dicts[0])\n     for d in dicts[1:]:\n         if level == 0:\n             if d == res and d:\n                 continue\n             else:\n                 return {}\n         to_delete = []\n         for key in res:\n             if key in d:\n                 if d[key] != res[key]:\n                     if level == 1:\n                         to_delete.append(key)\n                     elif isinstance(res[key], dict) and isinstance(d[key], dict):\n                         res[key] = intersection(res[key], d[key], level=level-1)\n                     else:\n                         to_delete.append(key)\n             else:\n                 # keys can't be deleted during iteration\n                 to_delete.append(key)\n         for key in to_delete:\n             del res[key]\n         if not res:\n             # res was calculated empty\n             return res\n     return res\n \n \n def iterate_update(d, updates):\n     \"\"\"Iterate on updates of *d* with *updates*.\n \n     *d* is a dictionary. It remains unchanged.\n \n     *updates* is a list of dictionaries.\n     For each element *update*\n     a copy of *d* updated with *update* is yielded.\n \n     If *updates* is empty, nothing is yielded.\n     \"\"\"\n     # todo: do I need this function?\n     for update in updates:\n         d_copy = copy.deepcopy(d)\n         update_recursively(d_copy, update)\n         yield d_copy\n \n \n def make_context(obj, *attrs):\n     \"\"\"Return context for object *obj*.\n \n     *attrs* is a list of attributes of *obj* to be inserted\n     into the context.\n     If an attribute starts with an underscore '_',\n     it is inserted without the underscore.\n     If an attribute is absent or None, it is skipped.\n     \"\"\"\n     # todo: rename to to_dict\n     # not used anywhere, change it freely.\n     # add examples.\n     context = {}\n     for attr in attrs:\n         val = getattr(obj, attr, None)\n         if val is not None:\n             if attr.startswith(\"_\"):\n                 attr = attr[1:]\n             context.update({attr: val})\n     return context\n \n \n def str_to_dict(s, value=_sentinel):\n     \"\"\"Create a dictionary from a dot-separated string *s*.\n \n     If the *value* is provided, it becomes the value of \n     the deepest key represented by *s*.\n \n     Dots represent nested dictionaries.\n     If *s* is non-empty and *value* is not provided,\n     then *s* must have at least two dot-separated parts\n     (*\"a.b\"*), otherwise :exc:`.LenaValueError` is raised.\n     If a *value* is provided, *s* must be non-empty.\n \n     If *s* is empty, an empty dictionary is returned.\n \n     Examples:\n \n     >>> str_to_dict(\"a.b.c d\")\n     {'a': {'b': 'c d'}}\n     >>> str_to_dict(\"output.changed\", True)\n     {'output': {'changed': True}}\n     \"\"\"\n     if s == \"\":\n         if value is _sentinel:\n             return {}\n         else:\n             raise lena.core.LenaValueError(\n                 \"to make a dict with a value, \"\n                 \"provide at least one dot-separated key\"\n             )\n     # \"\"\"*s* can be a dictionary. In this case it is returned as it is.\n     # If s were a dictionary, value mustn't had been allowed.\n     # probably this is a bad design,\n     # elif isinstance(s, dict):\n     #     return s\n     parts = s.split(\".\")\n     if value is not _sentinel:\n         parts.append(value)\n     def nest_list(d, l):\n         \"\"\"Convert list *l* to nested dictionaries in *d*.\"\"\"\n         len_l = len(l)\n         if len_l == 2:\n             d.update([(l[0], l[1])])\n         elif len_l < 2:\n             raise lena.core.LenaValueError(\n                 \"to make a dict, provide at least two dot-separated values\"\n             )\n         else:\n             d.update([(l[0], nest_list({}, l[1:]))])\n         return d\n     d = nest_list({}, parts)\n     return d\n \n \n def str_to_list(s):\n     \"\"\"Like :func:`str_to_dict`, but return a flat list.\n \n     If the string *s* is empty, an empty list is returned.\n     This is different from *str.split*: the latter would\n     return a list with one empty string.\n     Contrarily to :func:`str_to_dict`, this function allows\n     an arbitrary number of dots in *s* (or none).\n     \"\"\"\n     if s == \"\":\n         return []\n     # s can't be a list. This function is not used as a general\n     # interface (as str_to_dict could be).\n \n     # s may contain empty substrings, like in \"a..b\"\n     # this is not encouraged, of course, but may suit:\n     # if there are two errors in some user's context logic,\n     # they may compensate and not destroy all.\n     # Another variant would be to treat empty strings\n     # as whole context. The variant with '' seems more understandable\n     # to the user.\n     return s.split(\".\")\n \n \n def update_nested(key, d, other):\n     \"\"\"Update *d[key]* with the *other* dictionary preserving data.\n \n     If *d* doesn't contain the *key*, it is updated with *{key: other}*.\n     If *d* contains the *key*, *d[key]* is inserted into *other[key]*\n     (so that it is not overriden).\n     If *other* contains *key* (and possibly more nested *key*-s),\n     then *d[key]* is inserted into the deepest level\n     of *other.key.key...* Finally, *d[key]* becomes *other*.\n \n     Example:\n \n     >>> context = {\"variable\": {\"name\": \"x\"}}\n     >>> new_var_context = {\"name\": \"n\"}\n     >>> update_nested(\"variable\", context, copy.deepcopy(new_var_context))\n     >>> context == {'variable': {'name': 'n', 'variable': {'name': 'x'}}}\n     True\n     >>>\n     >>> update_nested(\"variable\", context, {\"name\": \"top\"})\n     >>> context == {\n     ...    'variable': {'name': 'top',\n     ...                 'variable': {'name': 'n', 'variable': {'name': 'x'}}}\n     ... }\n     True\n \n     *other* is modified in general. Create that on the fly\n     or use *copy.deepcopy* when appropriate.\n \n     Recursive dictionaries (containing references to themselves)\n     are strongly discouraged and meaningless when nesting.\n     If *other[key]* is recursive, :exc:`.LenaValueError` may be raised.\n     \"\"\"\n     # there was an idea to add a keyword argument copy_other\n     # (by default True), but the user can do that him/herself\n     # with copy.deepcopy when needed. Otherwise it would be \n     # unnecessary complication of this interface.\n \n     # Only one key is nested. This encourages design when\n     # 1) elements combine their contexts into one key\n     # (like {\"split_into_bins\": {\"variable\": {}, \"histogram\": {}}})\n     # 2) elements change only one key (\"variable\", \"histogram\",...).\n \n     def get_most_nested_subdict_with(key, d):\n         nested_dicts = []\n         while True:\n             if key in d:\n                 if d in nested_dicts:\n                     raise lena.core.LenaValueError(\n                         \"recursive *other* is forbidden\"\n                     )\n                 nested_dicts.append(d)\n                 d = d[key]\n             else:\n                 return d\n \n     if key in d:\n         other_most_nested = get_most_nested_subdict_with(key, other)\n         # insert d[key] at the lowest other.key.key....\n         other_most_nested[key] = d[key]\n \n     d[key] = other\n \n \n def update_recursively(d, other, value=_sentinel):\n     \"\"\"Update dictionary *d* with items from *other* dictionary.\n \n     *other* can be a dot-separated string. In this case\n     :func:`str_to_dict` is used to convert it and the *value*\n     to a dictionary.\n     A *value* argument is allowed only when *other* is a string,\n     otherwise :exc:`.LenaValueError` is raised.\n \n     Existing values are updated recursively,\n     that is including nested subdictionaries.\n     Example:\n \n     >>> d1 = {\"a\": 1, \"b\": {\"c\": 3}}\n     >>> d2 = {\"b\": {\"d\": 4}}\n     >>> update_recursively(d1, d2)\n     >>> d1 == {'a': 1, 'b': {'c': 3, 'd': 4}}\n     True\n     >>> # Usual update would have made d1[\"b\"] = {\"d\": 4}, erasing \"c\".\n \n     Non-dictionary items from *other* overwrite those in *d*:\n \n     >>> update_recursively(d1, {\"b\": 2})\n     >>> d1 == {'a': 1, 'b': 2}\n     True\n     \"\"\"\n     # skip this docstring, because it's trivial.\n     # Both *d* and *other* must be dictionaries,\n     # otherwise :exc:`.LenaTypeError` is raised.\n     # it would be cleaner to allow only dict as other,\n     # but it's very clear and useful to allow\n     # lena.context.update_recursively(context, \"output.changed\", True)\n     if isinstance(other, str):\n         other = str_to_dict(other, value)\n     else:\n         if value is not _sentinel:\n             raise lena.core.LenaValueError(\n                 \"explicit value is allowed only when other is a string\"\n             )\n     if not isinstance(d, dict) or not isinstance(other, dict):\n         raise lena.core.LenaTypeError(\n             \"d and other must be dicts, {} and {} provided\".format(d, other)\n         )\n     for key, val in other.items():\n         if not isinstance(val, dict):\n             d[key] = val\n         else:\n             if key in d:\n                 if not isinstance(d[key], dict):\n                     d[key] = {}\n                 update_recursively(d[key], other[key])\n             else:\n                 d[key] = val\n ", "input_code": "def difference(d1, d2, level=-1):\n\"\"\"\nReturn a dictionary with items from *d1* not contained in *d2*.\n\n*level* sets the maximum depth of recursion. For infinite recursion,\nset that to -1. For level 1,\nif a key is present both in *d1* and *d2* but has different values,\nit is included into the difference.\nSee :func:`intersection` for more details.\n\n*d1* and *d2* remain unchanged. However, *d1* or some of its\nsubdictionaries may be returned directly.\nMake a deep copy of the result when appropriate.\n\n.. versionadded:: 0.5\n   add keyword argument *level*.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def difference(d1, d2, level=-1):\n    \"\"\"Return a dictionary with items from *d1* not contained in *d2*.\n\n    *level* sets the maximum depth of recursion. For infinite recursion,\n    set that to -1. For level 1,\n    if a key is present both in *d1* and *d2* but has different values,\n    it is included into the difference.\n    See :func:`intersection` for more details.\n\n    *d1* and *d2* remain unchanged. However, *d1* or some of its\n    subdictionaries may be returned directly.\n    Make a deep copy of the result when appropriate.\n\n    .. versionadded:: 0.5\n       add keyword argument *level*.\n    \"\"\"\n    # can become not dicts during the recursion\n    if not isinstance(d1, dict) or not isinstance(d2, dict):\n        return d1\n\n    if d1 == d2:\n        return {}\n    elif level == 0:\n        return d1\n\n    # some keys differ\n    result = {}\n    for key in d1:\n        if key not in d2:\n            result[key] = d1[key]\n        elif d1[key] != d2[key]:\n            res = difference(d1[key], d2[key], level-1)\n            # if d2[key] contains all d1[key] elements,\n            # the difference will be empty\n            if res:\n                result[key] = res\n    return result", "signature": "def difference(d1, d2, level=-1):", "completion_path": "lena/context/functions.py"}
{"ce_id": "62b87af09a0c4fa8b80b34f1", "namespace": "62b87af09a0c4fa8b80b34f1", "namespace_real": "lena.structures.histogram.fill", "real_proj_path": "ynikitenko---lena/", "type": "class", "class_name": "histogram", "function_name": "fill", "contexts_above": "\"\"\"Histogram structure *histogram* and element *Histogram*.\"\"\"\nimport copy\n\nimport lena.context\nimport lena.core\nimport lena.flow\nimport lena.math\nfrom . import hist_functions as hf\n\n\nclass histogram():\n    \"\"\"A multidimensional histogram.\n\n    Arbitrary dimension, variable bin size and weights are supported.\n    Lower bin edge is included, upper edge is excluded.\n    Underflow and overflow values are skipped.\n    Bin content can be of arbitrary type,\n    which is defined during initialization.\n\n    Examples:\n\n    >>> # a two-dimensional histogram\n    >>> hist = histogram([[0, 1, 2], [0, 1, 2]])\n    >>> hist.fill([0, 1])\n    >>> hist.bins\n    [[0, 1], [0, 0]]\n    >>> values = [[0, 0], [1, 0], [1, 1]]\n    >>> # fill the histogram with values\n    >>> for v in values:\n    ...     hist.fill(v)\n    >>> hist.bins\n    [[1, 1], [1, 1]]\n    \"\"\"\n    # Note the differences from existing packages.\n    # Numpy 1.16 (numpy.histogram): all but the last\n    # (righthand-most) bin is half-open.\n    # This histogram class has bin limits as in ROOT\n    # (but without overflow and underflow).\n\n    # Numpy: the first element of the range must be less than or equal to the second.\n    # This histogram requires strictly increasing edges.\n    # https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html\n    # https://root.cern.ch/root/htmldoc/guides/users-guide/Histograms.html#bin-numbering\n\n    def __init__(self, edges, bins=None, initial_value=0):\n        \"\"\"*edges* is a sequence of one-dimensional arrays,\n        each containing strictly increasing bin edges.\n\n        Histogram's bins by default\n        are initialized with *initial_value*.\n        It can be any object that supports addition with *weight*\n        during *fill* (but that is not necessary\n        if you don't plan to fill the histogram).\n        If the *initial_value* is compound and requires special copying,\n        create initial bins yourself (see :func:`.init_bins`).\n\n        A histogram can be created from existing *bins* and *edges*.\n        In this case a simple check of the shape of *bins* is done\n        (raising :exc:`.LenaValueError` if failed).\n\n        **Attributes**\n\n        :attr:`edges` is a list of edges on each dimension.\n        Edges mark the borders of the bin.\n        Edges along each dimension are one-dimensional lists,\n        and the multidimensional bin is the result of all intersections\n        of one-dimensional edges.\n        For example, a 3-dimensional histogram has edges of the form\n        *[x_edges, y_edges, z_edges]*,\n        and the 0th bin has borders\n        *((x[0], x[1]), (y[0], y[1]), (z[0], z[1]))*.\n\n        Index in the edges is a tuple, where a given position corresponds\n        to a dimension, and the content at that position\n        to the bin along that dimension.\n        For example, index *(0, 1, 3)* corresponds to the bin\n        with lower edges *(x[0], y[1], z[3])*.\n\n        :attr:`bins` is a list of nested lists.\n        Same index as for edges can be used to get bin content:\n        bin at *(0, 1, 3)* can be obtained as *bins[0][1][3]*.\n        Most nested arrays correspond to highest\n        (further from x) coordinates.\n        For example, for a 3-dimensional histogram bins equal to\n        *[[[1, 1], [0, 0]], [[0, 0], [0, 0]]]*\n        mean that the only filled bins are those\n        where x and y indices are 0, and z index is 0 and 1.\n\n        :attr:`dim` is the dimension of a histogram\n        (length of its *edges* for a multidimensional histogram).\n\n        If subarrays of *edges* are not increasing\n        or if any of them has length less than 2,\n        :exc:`.LenaValueError` is raised.\n\n        .. admonition:: Programmer's note\n\n            one- and multidimensional histograms\n            have different *bins* and *edges* format.\n            To be unified, 1-dimensional edges should be\n            nested in a list (like *[[1, 2, 3]]*).\n            Instead, they are simply the x-edges list,\n            because it is more intuitive and one-dimensional histograms\n            are used more often.\n            To unify the interface for bins and edges in your code,\n            use :func:`.unify_1_md` function.\n        \"\"\"\n        # todo: allow creation of *edges* from tuples\n        # (without lena.math.mesh). Allow bin_size in this case.\n        hf.check_edges_increasing(edges)\n        self.edges = edges\n        self._scale = None\n\n        if hasattr(edges[0], \"__iter__\"):\n            self.dim = len(edges)\n        else:\n            self.dim = 1\n\n        # todo: add a kwarg no_check=False to disable bins testing\n        if bins is None:\n            self.bins = hf.init_bins(self.edges, initial_value)\n        else:\n            self.bins = bins\n            # We can't make scale for an arbitrary histogram,\n            # because it may contain compound values.\n            # self._scale = self.make_scale()\n            wrong_bins_error = lena.core.LenaValueError(\n                \"bins of incorrect shape given, {}\".format(bins)\n            )\n            if self.dim == 1:\n                if len(bins) != len(edges) - 1:\n                    raise wrong_bins_error\n            else:\n                if len(bins) != len(edges[0]) - 1:\n                    raise wrong_bins_error\n        if self.dim > 1:\n            self.ranges = [(axis[0], axis[-1]) for axis in edges]\n            self.nbins =  [len(axis) - 1 for axis in edges]\n        else:\n            self.ranges = [(edges[0], edges[-1])]\n            self.nbins = [len(edges)-1]\n\n    def __eq__(self, other):\n        \"\"\"Two histograms are equal, if and only if they have\n        equal bins and equal edges.\n\n        If *other* is not a :class:`.histogram`, return ``False``.\n\n        Note that floating numbers should be compared\n        approximately (using :func:`math.isclose`).\n        \"\"\"\n        if not isinstance(other, histogram):\n            # in Python comparison between different types is allowed\n            return False\n        return self.bins == other.bins and self.edges == other.edges\n", "contexts_below": "    def __repr__(self):\n         return \"histogram({}, bins={})\".format(self.edges, self.bins)\n \n     def scale(self, other=None, recompute=False):\n         \"\"\"Compute or set scale (integral of the histogram).\n \n         If *other* is ``None``, return scale of this histogram.\n         If its scale was not computed before,\n         it is computed and stored for subsequent use\n         (unless explicitly asked to *recompute*).\n         Note that after changing (filling) the histogram\n         one must explicitly recompute the scale\n         if it was computed before.\n \n         If a float *other* is provided, rescale self to *other*.\n \n         Histograms with scale equal to zero can't be rescaled.\n         :exc:`.LenaValueError` is raised if one tries to do that.\n         \"\"\"\n         # see graph.scale comments why this is called simply \"scale\"\n         # (not set_scale, get_scale, etc.)\n         if other is None:\n             # return scale\n             if self._scale is None or recompute:\n                 self._scale = hf.integral(\n                     *hf.unify_1_md(self.bins, self.edges)\n                 )\n             return self._scale\n         else:\n             # rescale from other\n             scale = self.scale()\n             if scale == 0:\n                 raise lena.core.LenaValueError(\n                     \"can not rescale histogram with zero scale\"\n                 )\n             self.bins = lena.math.md_map(lambda binc: binc*float(other) / scale,\n                                          self.bins)\n             self._scale = other\n             return None\n \n     def _update_context(self, context):\n         \"\"\"Update *context* with the properties of this histogram.\n \n         *context.histogram* is updated with \"dim\", \"nbins\"\n         and \"ranges\" with values for this histogram.\n         If this histogram has a computed scale, it is also added\n         to the context.\n \n         Called on \"destruction\" of the histogram structure (for example,\n         in :class:`.ToCSV`). See graph._update_context for more details.\n         \"\"\"\n \n         hist_context = {\n             \"dim\": self.dim,\n             \"nbins\": self.nbins,\n             \"ranges\": self.ranges\n         }\n \n         if self._scale is not None:\n             hist_context[\"scale\"] = self._scale\n \n         lena.context.update_recursively(context, {\"histogram\": hist_context})\n \n \n class Histogram():\n     \"\"\"An element to produce histograms.\"\"\"\n \n     def __init__(self, edges, bins=None, make_bins=None, initial_value=0):\n         \"\"\"*edges*, *bins* and *initial_value* have the same meaning\n         as during creation of a :class:`histogram`.\n \n         *make_bins* is a function without arguments\n         that creates new bins\n         (it will be called during :meth:`__init__` and :meth:`reset`).\n         *initial_value* in this case is ignored, but bin check is made.\n         If both *bins* and *make_bins* are provided,\n         :exc:`.LenaTypeError` is raised.\n         \"\"\"\n         self._hist = histogram(edges, bins)\n \n         if make_bins is not None and bins is not None:\n             raise lena.core.LenaTypeError(\n                 \"either initial bins or make_bins must be provided, \"\n                 \"not both: {} and {}\".format(bins, make_bins)\n             )\n \n         # may be None\n         self._initial_bins = copy.deepcopy(bins)\n \n         # todo: bins, make_bins, initial_value look redundant\n         # and may be reconsidered when really using reset().\n         if make_bins:\n             bins = make_bins()\n         self._make_bins = make_bins\n \n         self._cur_context = {}\n \n     def fill(self, value):\n         \"\"\"Fill the histogram with *value*.\n \n         *value* can be a *(data, context)* pair. \n         Values outside the histogram edges are ignored.\n         \"\"\"\n         data, self._cur_context = lena.flow.get_data_context(value)\n         self._hist.fill(data)\n         # filling with weight is only allowed in histogram structure\n         # self._hist.fill(data, weight)\n \n     def compute(self):\n         \"\"\"Yield histogram with context.\"\"\"\n         yield (self._hist, self._cur_context)\n \n     def reset(self):\n         \"\"\"Reset the histogram.\n \n         Current context is reset to an empty dict.\n         Bins are reinitialized with the *initial_value*\n         or with *make_bins()* (depending on the initialization).\n         \"\"\"\n         if self._make_bins is not None:\n             self.bins = self._make_bins()\n         elif self._initial_bins is not None:\n             self.bins = copy.deepcopy(self._initial_bins)\n         else:\n             self.bins = hf.init_bins(self.edges, self._initial_value)\n \n         self._cur_context = {}\n ", "input_code": "def fill(self, coord, weight=1):\n\"\"\"\nFill histogram at *coord* with the given *weight*.\n\nCoordinates outside the histogram edges are ignored.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def fill(self, coord, weight=1):\n        \"\"\"Fill histogram at *coord* with the given *weight*.\n\n        Coordinates outside the histogram edges are ignored.\n        \"\"\"\n        indices = hf.get_bin_on_value(coord, self.edges)\n        subarr = self.bins\n        for ind in indices[:-1]:\n            # underflow\n            if ind < 0:\n                return\n            try:\n                subarr = subarr[ind]\n            # overflow\n            except IndexError:\n                return\n        ind = indices[-1]\n        # underflow\n        if ind < 0:\n            return\n\n        # fill\n        try:\n            subarr[ind] += weight\n        except IndexError:\n            return", "signature": "def fill(self, coord, weight=1):", "completion_path": "lena/structures/histogram.py"}
{"ce_id": "62b86aa3b4d922cb0e688d36", "namespace": "62b86aa3b4d922cb0e688d36", "namespace_real": "krake.krake.data.core._validate_labels", "real_proj_path": "rak-n-rok---Krake/", "type": "function", "class_name": null, "function_name": "_validate_labels", "contexts_above": "import re\nfrom enum import Enum, IntEnum, auto\nfrom datetime import datetime\nfrom dataclasses import field\nfrom typing import List, Dict\n\nfrom marshmallow import ValidationError\n\nfrom . import persistent\nfrom .serializable import Serializable, ApiObject, PolymorphicContainer\n\n\nclass ResourceRef(Serializable):\n    api: str\n    namespace: str = field(default=None)\n    kind: str\n    name: str\n\n    def __hash__(self):\n        return hash((self.api, self.namespace, self.kind, self.name))\n\n    def __repr__(self):\n        message = f\"{self.kind}(api='{self.api}', \"\n        return message + f\"namespace='{self.namespace}', name='{self.name}')\"\n\n\n_label_key_pattern = None\n_label_value_pattern = None\n\n_label_key_regex = None\n_label_value_regex = None\n\n\ndef _get_labels_regex():\n    \"\"\"Build or return the regular expressions that are used to validate the key and\n    value of the labels of the Krake resources.\n\n    The first call builds the expressions, while a second returns the already built\n    ones.\n\n    Returns:\n        (re.Pattern, re.Pattern): a tuple that contains the compiled regular,\n            expressions, the first element to validate the key and the second to\n            validate the value.\n\n    \"\"\"\n    global _label_key_pattern, _label_value_pattern\n    global _label_key_regex, _label_value_regex\n\n    if _label_key_regex and _label_value_regex:\n        return _label_key_regex, _label_value_regex\n\n    # Build the patterns only if not already built\n    max_prefix_size = 253\n    max_key_size = 63\n    max_value_size = max_key_size\n\n    # First and last characters must be alphanumeric. The rest of the string must be\n    # alphanumeric, \"-\", \"_\" or \".\"\n    base_alphanumeric_pattern = \"\\\\w|(\\\\w[\\\\w\\\\-_.]{{0,{length}}}\\\\w)\"\n\n    key_pattern = base_alphanumeric_pattern.format(length=max_key_size - 2)\n    value_pattern = base_alphanumeric_pattern.format(length=max_value_size - 2)\n    prefix_pattern = base_alphanumeric_pattern.format(length=max_prefix_size - 2)\n\n    # The key can be a string of length 63 with the specifications described above,\n    # or have a prefix, then one \"/\" character, then the string of length 63 (called\n    # name).\n    # The prefix itself should have a max length of 253, but otherwise follows the\n    # specifications described above.\n    _label_key_pattern = f\"^(({prefix_pattern})\\\\/)?({key_pattern})$\"\n\n    # The value can be a string of length 63 with the specifications described\n    # above.\n    _label_value_pattern = value_pattern\n\n    _label_key_regex = re.compile(_label_key_pattern, re.ASCII)\n    _label_value_regex = re.compile(_label_value_pattern, re.ASCII)\n\n    return _label_key_regex, _label_value_regex\n\n\ndef validate_key(key):\n    \"\"\"Validate the given key against the corresponding regular expression.\n\n    Args:\n        key: the string to validate\n\n    Raises:\n        ValidationError: if the given key is not conform to the regular expression.\n    \"\"\"\n    key_regex, _ = _get_labels_regex()\n    if not key_regex.fullmatch(key):\n        raise ValidationError(\n            f\"Label key {key!r} does not match the regex {_label_key_pattern!r}.\"\n        )\n\n\ndef validate_value(value):\n    \"\"\"Validate the given value against the corresponding regular expression.\n\n    Args:\n        value: the string to validate\n\n    Raises:\n        ValidationError: if the given value is not conform to the regular expression.\n    \"\"\"\n    _, value_regex = _get_labels_regex()\n    if not value_regex.fullmatch(value):\n        raise ValidationError(\n            f\"Label value {value!r} does not match\"\n            f\" the regex {_label_value_pattern!r}.\"\n        )\n\n", "contexts_below": "\n _resource_name_pattern = None\n _resource_name_regex = None\n \n \n def _get_resource_name_regex():\n     \"\"\"Build or return the regular expressions that are used to validate\n     the name of the Krake resources.\n \n     Returns:\n         (re.Pattern): the compiled regular expressions, to validate\n         the resource name.\n     \"\"\"\n     global _resource_name_regex, _resource_name_pattern\n \n     # Build the patterns only if not already built\n     if _resource_name_regex:\n         return _resource_name_regex\n \n     # First and last characters must be alphanumeric. The rest of the string must be\n     # alphanumeric, \"-\", \"_\" or \".\" and without whitespace as well as have a\n     # max length of 255 and a min length of 1\n     max_name_size = 253  # reduced by 2 for the regex\n     min_name_size = 0  # reduced by 1 for the regex\n     base_alphanumeric_pattern = \"\\\\w|(\\\\w[\\\\w\\\\-_.:]{{{min_length},{length}}}\\\\w)\"\n \n     resource_name_pattern = base_alphanumeric_pattern.format(\n         min_length=min_name_size, length=max_name_size\n     )\n \n     _resource_name_pattern = resource_name_pattern\n     _resource_name_regex = re.compile(_resource_name_pattern, re.ASCII)\n     return _resource_name_regex\n \n \n def _validate_resource_name(name):\n     \"\"\"Each Krake resource name is checked against a specific pattern.\n     Which characters are not allowed is defined in _get_resource_name_regex\n \n     Args:\n         name(str): the different resource names to validate.\n \n     Raises:\n         ValidationError: if any resource name does not match their respective\n             regular expression.\n     \"\"\"\n     resource_name_regex = _get_resource_name_regex()\n     if not resource_name_regex.fullmatch(name):\n         raise ValidationError(\"Invalid character in resource name.\")\n \n \n def _validate_resource_namespace(namespace):\n     \"\"\"Each Krake resource namespace is checked against a specific pattern.\n     Which characters are not allowed is defined in _get_resource_name_regex\n \n     Args:\n         namespace(str): the different resource namespaces to validate.\n \n     Raises:\n         ValidationError: if any resource namespace does not match their respective\n             regular expression.\n     \"\"\"\n     resource_namespace_regex = _get_resource_name_regex()\n     if not resource_namespace_regex.fullmatch(namespace):\n         raise ValidationError(\"Invalid character in resource namespace.\")\n \n \n class Metadata(Serializable):\n     name: str = field(metadata={\"immutable\": True, \"validate\": _validate_resource_name})\n     namespace: str = field(\n         default=None,\n         metadata={\"immutable\": True, \"validate\": _validate_resource_namespace},\n     )\n     labels: dict = field(default_factory=dict, metadata={\"validate\": _validate_labels})\n     finalizers: List[str] = field(default_factory=list)\n \n     uid: str = field(metadata={\"readonly\": True})\n     created: datetime = field(metadata={\"readonly\": True})\n     modified: datetime = field(metadata={\"readonly\": True})\n     deleted: datetime = field(default=None, metadata={\"readonly\": True})\n \n     owners: List[ResourceRef] = field(default_factory=list)\n \n \n class CoreMetadata(Serializable):\n     name: str\n     uid: str\n \n \n class ListMetadata(Serializable):\n     pass  # TODO\n \n \n class ReasonCode(IntEnum):\n     INTERNAL_ERROR = 1  # Default error\n \n     INVALID_RESOURCE = 10  # Invalid values in the Manifest\n     # Kubernetes' resource is not supported by the Kubernetes controller\n     UNSUPPORTED_RESOURCE = 11\n     # The custom resource provided does not exist or is invalid\n     INVALID_CUSTOM_RESOURCE = 12\n \n     CLUSTER_NOT_REACHABLE = 20  # Connectivity issue with the Kubernetes deployment\n     NO_SUITABLE_RESOURCE = 50  # Scheduler issue\n \n     KUBERNETES_ERROR = 60\n \n     CREATE_FAILED = 70\n     RECONCILE_FAILED = 71\n     DELETE_FAILED = 72\n \n     OPENSTACK_ERROR = 80\n     INVALID_CLUSTER_TEMPLATE = 81\n \n     # Related to Metrics and Metric Provider\n     INVALID_METRIC = 91\n     UNREACHABLE_METRICS_PROVIDER = 92\n     UNKNOWN_METRIC = 93\n     UNKNOWN_METRICS_PROVIDER = 94\n \n \n class Reason(Serializable):\n     code: ReasonCode\n     message: str\n \n \n class WatchEventType(Enum):\n     ADDED = auto()\n     MODIFIED = auto()\n     DELETED = auto()\n \n \n class Status(Serializable):\n     reason: Reason = None\n \n \n class WatchEvent(Serializable):\n     type: WatchEventType\n     object: dict\n \n \n class Verb(Enum):\n     create = auto()\n     list = auto()\n     list_all = auto()\n     get = auto()\n     update = auto()\n     delete = auto()\n \n \n class RoleRule(Serializable):\n     api: str\n     resources: List[str]\n     namespaces: List[str]\n     verbs: List[Verb]\n \n \n @persistent(\"/core/roles/{name}\")\n class Role(ApiObject):\n     api: str = \"core\"\n     kind: str = \"Role\"\n     metadata: Metadata\n     rules: List[RoleRule]\n \n \n class RoleList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"RoleList\"\n     metadata: ListMetadata\n     items: List[Role]\n \n \n @persistent(\"/core/rolebindings/{name}\")\n class RoleBinding(ApiObject):\n     api: str = \"core\"\n     kind: str = \"RoleBinding\"\n     metadata: Metadata\n     users: List[str]\n     roles: List[str]\n \n \n class RoleBindingList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"RoleBindingList\"\n     metadata: ListMetadata\n     items: List[RoleBinding]\n \n \n class Conflict(Serializable):\n     source: ResourceRef\n     conflicting: List[ResourceRef]\n \n \n def resource_ref(resource):\n     \"\"\"Create a :class:`ResourceRef` from a :class:`ApiObject`\n \n     Args:\n         resource (.serializable.ApiObject): API object that should be\n             referenced\n \n     Returns:\n         ResourceRef: Corresponding reference to the API object\n     \"\"\"\n     return ResourceRef(\n         api=resource.api,\n         kind=resource.kind,\n         namespace=resource.metadata.namespace,\n         name=resource.metadata.name,\n     )\n \n \n class MetricSpecProvider(Serializable):\n     name: str\n     metric: str\n \n \n class MetricSpec(Serializable):\n     min: float\n     max: float\n     provider: MetricSpecProvider\n \n \n class BaseMetric(ApiObject):\n     api: str = \"core\"\n     kind: str = None\n     metadata: Metadata\n     spec: MetricSpec\n \n \n @persistent(\"/core/globalmetrics/{name}\")\n class GlobalMetric(BaseMetric):\n     api: str = \"core\"\n     kind: str = \"GlobalMetric\"\n     metadata: Metadata\n     spec: MetricSpec\n \n \n @persistent(\"/core/metrics/{namespace}/{name}\")\n class Metric(BaseMetric):\n     api: str = \"core\"\n     kind: str = \"Metric\"\n     metadata: Metadata\n     spec: MetricSpec\n \n \n class MetricList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"MetricList\"\n     metadata: ListMetadata\n     items: List[Metric]\n \n \n class GlobalMetricList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"GlobalMetricList\"\n     metadata: ListMetadata\n     items: List[GlobalMetric]\n \n \n class MetricsProviderSpec(PolymorphicContainer):\n     type: str\n \n \n @MetricsProviderSpec.register(\"prometheus\")\n class PrometheusSpec(Serializable):\n     url: str\n \n \n @MetricsProviderSpec.register(\"kafka\")\n class KafkaSpec(Serializable):\n     \"\"\"Specifications to connect to a KSQL database, and retrieve a specific row from a\n     specific table.\n \n     Attributes:\n         comparison_column (str): name of the column where the value will be compared to\n             the metric name, to select the right metric.\n         value_column (str): name of the column where the value of a metric is stored.\n         table (str): the name of the KSQL table where the metric is defined.\n         url (str): endpoint of the KSQL database.\n \n     \"\"\"\n \n     comparison_column: str\n     value_column: str\n     table: str\n     url: str\n \n \n @MetricsProviderSpec.register(\"static\")\n class StaticSpec(Serializable):\n     metrics: Dict[str, float]\n \n \n class BaseMetricsProvider(ApiObject):\n     api: str = \"core\"\n     kind: str = None\n     metadata: Metadata\n     spec: MetricsProviderSpec\n \n \n @persistent(\"/core/globalmetricsproviders/{name}\")\n class GlobalMetricsProvider(BaseMetricsProvider):\n     api: str = \"core\"\n     kind: str = \"GlobalMetricsProvider\"\n     metadata: Metadata\n     spec: MetricsProviderSpec\n \n \n @persistent(\"/core/metricsproviders/{namespace}/{name}\")\n class MetricsProvider(BaseMetricsProvider):\n     api: str = \"core\"\n     kind: str = \"MetricsProvider\"\n     metadata: Metadata\n     spec: MetricsProviderSpec\n \n \n class MetricsProviderList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"MetricsProviderList\"\n     metadata: ListMetadata\n     items: List[MetricsProvider]\n \n \n class GlobalMetricsProviderList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"GlobalMetricsProviderList\"\n     metadata: ListMetadata\n     items: List[GlobalMetricsProvider]\n \n \n class MetricRef(Serializable):\n     name: str\n     weight: float\n     namespaced: bool = False\n ", "input_code": "def _validate_labels(labels):\n\"\"\"\nCheck that keys and values in the given labels match against their corresponding\nregular expressions.\n\nArgs:\n    labels (dict): the different labels to validate.\n\nRaises:\n    ValidationError: if any of the keys and labels does not match their respective\n        regular expression. The error contains as message the list of all errors\n        which occurred in the labels. Each element of the list is a dictionary with\n        one key-value pair:\n        - key: the label key or label value for which an error occurred as string.\n        - value: the error message.\n\n        .. code:: python\n\n            # Example:\n            labels = {\n                \"key1\": \"valid\",\n                \"key2\": [\"invalid\"],\n                \"$$\": \"invalid\",\n                True: True,\n            }\n            try:\n                _validate_labels(labels)\n            except ValidationError as err:\n                assert err.messages == [\n                    {\"['invalid']\": 'expected string or bytes-like object'},\n                    {'$$': \"Label key '$$' does not match the regex [...]\"},\n                    {'True': 'expected string or bytes-like object'},\n                    {'True': 'expected string or bytes-like object'},\n                ]\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _validate_labels(labels):\n    \"\"\"Check that keys and values in the given labels match against their corresponding\n    regular expressions.\n\n    Args:\n        labels (dict): the different labels to validate.\n\n    Raises:\n        ValidationError: if any of the keys and labels does not match their respective\n            regular expression. The error contains as message the list of all errors\n            which occurred in the labels. Each element of the list is a dictionary with\n            one key-value pair:\n            - key: the label key or label value for which an error occurred as string.\n            - value: the error message.\n\n            .. code:: python\n\n                # Example:\n                labels = {\n                    \"key1\": \"valid\",\n                    \"key2\": [\"invalid\"],\n                    \"$$\": \"invalid\",\n                    True: True,\n                }\n                try:\n                    _validate_labels(labels)\n                except ValidationError as err:\n                    assert err.messages == [\n                        {\"['invalid']\": 'expected string or bytes-like object'},\n                        {'$$': \"Label key '$$' does not match the regex [...]\"},\n                        {'True': 'expected string or bytes-like object'},\n                        {'True': 'expected string or bytes-like object'},\n                    ]\n    \"\"\"\n    errors = []\n    for key, value in labels.items():\n        try:\n            validate_key(key)\n        except (ValidationError, TypeError) as err:\n            errors.append({str(key): str(err)})\n\n        try:\n            validate_value(value)\n        except (ValidationError, TypeError) as err:\n            errors.append({str(value): str(err)})\n\n    if errors:\n        raise ValidationError(list(errors))", "signature": "def _validate_labels(labels):", "completion_path": "krake/krake/data/core.py"}
{"ce_id": "62b86a9eb4d922cb0e688d25", "namespace": "62b86a9eb4d922cb0e688d25", "namespace_real": "krake.krake.data.core._get_resource_name_regex", "real_proj_path": "rak-n-rok---Krake/", "type": "function", "class_name": null, "function_name": "_get_resource_name_regex", "contexts_above": "import re\nfrom enum import Enum, IntEnum, auto\nfrom datetime import datetime\nfrom dataclasses import field\nfrom typing import List, Dict\n\nfrom marshmallow import ValidationError\n\nfrom . import persistent\nfrom .serializable import Serializable, ApiObject, PolymorphicContainer\n\n\nclass ResourceRef(Serializable):\n    api: str\n    namespace: str = field(default=None)\n    kind: str\n    name: str\n\n    def __hash__(self):\n        return hash((self.api, self.namespace, self.kind, self.name))\n\n    def __repr__(self):\n        message = f\"{self.kind}(api='{self.api}', \"\n        return message + f\"namespace='{self.namespace}', name='{self.name}')\"\n\n\n_label_key_pattern = None\n_label_value_pattern = None\n\n_label_key_regex = None\n_label_value_regex = None\n\n\ndef _get_labels_regex():\n    \"\"\"Build or return the regular expressions that are used to validate the key and\n    value of the labels of the Krake resources.\n\n    The first call builds the expressions, while a second returns the already built\n    ones.\n\n    Returns:\n        (re.Pattern, re.Pattern): a tuple that contains the compiled regular,\n            expressions, the first element to validate the key and the second to\n            validate the value.\n\n    \"\"\"\n    global _label_key_pattern, _label_value_pattern\n    global _label_key_regex, _label_value_regex\n\n    if _label_key_regex and _label_value_regex:\n        return _label_key_regex, _label_value_regex\n\n    # Build the patterns only if not already built\n    max_prefix_size = 253\n    max_key_size = 63\n    max_value_size = max_key_size\n\n    # First and last characters must be alphanumeric. The rest of the string must be\n    # alphanumeric, \"-\", \"_\" or \".\"\n    base_alphanumeric_pattern = \"\\\\w|(\\\\w[\\\\w\\\\-_.]{{0,{length}}}\\\\w)\"\n\n    key_pattern = base_alphanumeric_pattern.format(length=max_key_size - 2)\n    value_pattern = base_alphanumeric_pattern.format(length=max_value_size - 2)\n    prefix_pattern = base_alphanumeric_pattern.format(length=max_prefix_size - 2)\n\n    # The key can be a string of length 63 with the specifications described above,\n    # or have a prefix, then one \"/\" character, then the string of length 63 (called\n    # name).\n    # The prefix itself should have a max length of 253, but otherwise follows the\n    # specifications described above.\n    _label_key_pattern = f\"^(({prefix_pattern})\\\\/)?({key_pattern})$\"\n\n    # The value can be a string of length 63 with the specifications described\n    # above.\n    _label_value_pattern = value_pattern\n\n    _label_key_regex = re.compile(_label_key_pattern, re.ASCII)\n    _label_value_regex = re.compile(_label_value_pattern, re.ASCII)\n\n    return _label_key_regex, _label_value_regex\n\n\ndef validate_key(key):\n    \"\"\"Validate the given key against the corresponding regular expression.\n\n    Args:\n        key: the string to validate\n\n    Raises:\n        ValidationError: if the given key is not conform to the regular expression.\n    \"\"\"\n    key_regex, _ = _get_labels_regex()\n    if not key_regex.fullmatch(key):\n        raise ValidationError(\n            f\"Label key {key!r} does not match the regex {_label_key_pattern!r}.\"\n        )\n\n\ndef validate_value(value):\n    \"\"\"Validate the given value against the corresponding regular expression.\n\n    Args:\n        value: the string to validate\n\n    Raises:\n        ValidationError: if the given value is not conform to the regular expression.\n    \"\"\"\n    _, value_regex = _get_labels_regex()\n    if not value_regex.fullmatch(value):\n        raise ValidationError(\n            f\"Label value {value!r} does not match\"\n            f\" the regex {_label_value_pattern!r}.\"\n        )\n\n\ndef _validate_labels(labels):\n    \"\"\"Check that keys and values in the given labels match against their corresponding\n    regular expressions.\n\n    Args:\n        labels (dict): the different labels to validate.\n\n    Raises:\n        ValidationError: if any of the keys and labels does not match their respective\n            regular expression. The error contains as message the list of all errors\n            which occurred in the labels. Each element of the list is a dictionary with\n            one key-value pair:\n            - key: the label key or label value for which an error occurred as string.\n            - value: the error message.\n\n            .. code:: python\n\n                # Example:\n                labels = {\n                    \"key1\": \"valid\",\n                    \"key2\": [\"invalid\"],\n                    \"$$\": \"invalid\",\n                    True: True,\n                }\n                try:\n                    _validate_labels(labels)\n                except ValidationError as err:\n                    assert err.messages == [\n                        {\"['invalid']\": 'expected string or bytes-like object'},\n                        {'$$': \"Label key '$$' does not match the regex [...]\"},\n                        {'True': 'expected string or bytes-like object'},\n                        {'True': 'expected string or bytes-like object'},\n                    ]\n    \"\"\"\n    errors = []\n    for key, value in labels.items():\n        try:\n            validate_key(key)\n        except (ValidationError, TypeError) as err:\n            errors.append({str(key): str(err)})\n\n        try:\n            validate_value(value)\n        except (ValidationError, TypeError) as err:\n            errors.append({str(value): str(err)})\n\n    if errors:\n        raise ValidationError(list(errors))\n\n\n_resource_name_pattern = None\n_resource_name_regex = None\n\n", "contexts_below": "\n def _validate_resource_name(name):\n     \"\"\"Each Krake resource name is checked against a specific pattern.\n     Which characters are not allowed is defined in _get_resource_name_regex\n \n     Args:\n         name(str): the different resource names to validate.\n \n     Raises:\n         ValidationError: if any resource name does not match their respective\n             regular expression.\n     \"\"\"\n     resource_name_regex = _get_resource_name_regex()\n     if not resource_name_regex.fullmatch(name):\n         raise ValidationError(\"Invalid character in resource name.\")\n \n \n def _validate_resource_namespace(namespace):\n     \"\"\"Each Krake resource namespace is checked against a specific pattern.\n     Which characters are not allowed is defined in _get_resource_name_regex\n \n     Args:\n         namespace(str): the different resource namespaces to validate.\n \n     Raises:\n         ValidationError: if any resource namespace does not match their respective\n             regular expression.\n     \"\"\"\n     resource_namespace_regex = _get_resource_name_regex()\n     if not resource_namespace_regex.fullmatch(namespace):\n         raise ValidationError(\"Invalid character in resource namespace.\")\n \n \n class Metadata(Serializable):\n     name: str = field(metadata={\"immutable\": True, \"validate\": _validate_resource_name})\n     namespace: str = field(\n         default=None,\n         metadata={\"immutable\": True, \"validate\": _validate_resource_namespace},\n     )\n     labels: dict = field(default_factory=dict, metadata={\"validate\": _validate_labels})\n     finalizers: List[str] = field(default_factory=list)\n \n     uid: str = field(metadata={\"readonly\": True})\n     created: datetime = field(metadata={\"readonly\": True})\n     modified: datetime = field(metadata={\"readonly\": True})\n     deleted: datetime = field(default=None, metadata={\"readonly\": True})\n \n     owners: List[ResourceRef] = field(default_factory=list)\n \n \n class CoreMetadata(Serializable):\n     name: str\n     uid: str\n \n \n class ListMetadata(Serializable):\n     pass  # TODO\n \n \n class ReasonCode(IntEnum):\n     INTERNAL_ERROR = 1  # Default error\n \n     INVALID_RESOURCE = 10  # Invalid values in the Manifest\n     # Kubernetes' resource is not supported by the Kubernetes controller\n     UNSUPPORTED_RESOURCE = 11\n     # The custom resource provided does not exist or is invalid\n     INVALID_CUSTOM_RESOURCE = 12\n \n     CLUSTER_NOT_REACHABLE = 20  # Connectivity issue with the Kubernetes deployment\n     NO_SUITABLE_RESOURCE = 50  # Scheduler issue\n \n     KUBERNETES_ERROR = 60\n \n     CREATE_FAILED = 70\n     RECONCILE_FAILED = 71\n     DELETE_FAILED = 72\n \n     OPENSTACK_ERROR = 80\n     INVALID_CLUSTER_TEMPLATE = 81\n \n     # Related to Metrics and Metric Provider\n     INVALID_METRIC = 91\n     UNREACHABLE_METRICS_PROVIDER = 92\n     UNKNOWN_METRIC = 93\n     UNKNOWN_METRICS_PROVIDER = 94\n \n \n class Reason(Serializable):\n     code: ReasonCode\n     message: str\n \n \n class WatchEventType(Enum):\n     ADDED = auto()\n     MODIFIED = auto()\n     DELETED = auto()\n \n \n class Status(Serializable):\n     reason: Reason = None\n \n \n class WatchEvent(Serializable):\n     type: WatchEventType\n     object: dict\n \n \n class Verb(Enum):\n     create = auto()\n     list = auto()\n     list_all = auto()\n     get = auto()\n     update = auto()\n     delete = auto()\n \n \n class RoleRule(Serializable):\n     api: str\n     resources: List[str]\n     namespaces: List[str]\n     verbs: List[Verb]\n \n \n @persistent(\"/core/roles/{name}\")\n class Role(ApiObject):\n     api: str = \"core\"\n     kind: str = \"Role\"\n     metadata: Metadata\n     rules: List[RoleRule]\n \n \n class RoleList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"RoleList\"\n     metadata: ListMetadata\n     items: List[Role]\n \n \n @persistent(\"/core/rolebindings/{name}\")\n class RoleBinding(ApiObject):\n     api: str = \"core\"\n     kind: str = \"RoleBinding\"\n     metadata: Metadata\n     users: List[str]\n     roles: List[str]\n \n \n class RoleBindingList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"RoleBindingList\"\n     metadata: ListMetadata\n     items: List[RoleBinding]\n \n \n class Conflict(Serializable):\n     source: ResourceRef\n     conflicting: List[ResourceRef]\n \n \n def resource_ref(resource):\n     \"\"\"Create a :class:`ResourceRef` from a :class:`ApiObject`\n \n     Args:\n         resource (.serializable.ApiObject): API object that should be\n             referenced\n \n     Returns:\n         ResourceRef: Corresponding reference to the API object\n     \"\"\"\n     return ResourceRef(\n         api=resource.api,\n         kind=resource.kind,\n         namespace=resource.metadata.namespace,\n         name=resource.metadata.name,\n     )\n \n \n class MetricSpecProvider(Serializable):\n     name: str\n     metric: str\n \n \n class MetricSpec(Serializable):\n     min: float\n     max: float\n     provider: MetricSpecProvider\n \n \n class BaseMetric(ApiObject):\n     api: str = \"core\"\n     kind: str = None\n     metadata: Metadata\n     spec: MetricSpec\n \n \n @persistent(\"/core/globalmetrics/{name}\")\n class GlobalMetric(BaseMetric):\n     api: str = \"core\"\n     kind: str = \"GlobalMetric\"\n     metadata: Metadata\n     spec: MetricSpec\n \n \n @persistent(\"/core/metrics/{namespace}/{name}\")\n class Metric(BaseMetric):\n     api: str = \"core\"\n     kind: str = \"Metric\"\n     metadata: Metadata\n     spec: MetricSpec\n \n \n class MetricList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"MetricList\"\n     metadata: ListMetadata\n     items: List[Metric]\n \n \n class GlobalMetricList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"GlobalMetricList\"\n     metadata: ListMetadata\n     items: List[GlobalMetric]\n \n \n class MetricsProviderSpec(PolymorphicContainer):\n     type: str\n \n \n @MetricsProviderSpec.register(\"prometheus\")\n class PrometheusSpec(Serializable):\n     url: str\n \n \n @MetricsProviderSpec.register(\"kafka\")\n class KafkaSpec(Serializable):\n     \"\"\"Specifications to connect to a KSQL database, and retrieve a specific row from a\n     specific table.\n \n     Attributes:\n         comparison_column (str): name of the column where the value will be compared to\n             the metric name, to select the right metric.\n         value_column (str): name of the column where the value of a metric is stored.\n         table (str): the name of the KSQL table where the metric is defined.\n         url (str): endpoint of the KSQL database.\n \n     \"\"\"\n \n     comparison_column: str\n     value_column: str\n     table: str\n     url: str\n \n \n @MetricsProviderSpec.register(\"static\")\n class StaticSpec(Serializable):\n     metrics: Dict[str, float]\n \n \n class BaseMetricsProvider(ApiObject):\n     api: str = \"core\"\n     kind: str = None\n     metadata: Metadata\n     spec: MetricsProviderSpec\n \n \n @persistent(\"/core/globalmetricsproviders/{name}\")\n class GlobalMetricsProvider(BaseMetricsProvider):\n     api: str = \"core\"\n     kind: str = \"GlobalMetricsProvider\"\n     metadata: Metadata\n     spec: MetricsProviderSpec\n \n \n @persistent(\"/core/metricsproviders/{namespace}/{name}\")\n class MetricsProvider(BaseMetricsProvider):\n     api: str = \"core\"\n     kind: str = \"MetricsProvider\"\n     metadata: Metadata\n     spec: MetricsProviderSpec\n \n \n class MetricsProviderList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"MetricsProviderList\"\n     metadata: ListMetadata\n     items: List[MetricsProvider]\n \n \n class GlobalMetricsProviderList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"GlobalMetricsProviderList\"\n     metadata: ListMetadata\n     items: List[GlobalMetricsProvider]\n \n \n class MetricRef(Serializable):\n     name: str\n     weight: float\n     namespaced: bool = False\n ", "input_code": "def _get_resource_name_regex():\n\"\"\"\nBuild or return the regular expressions that are used to validate\nthe name of the Krake resources.\n\nReturns:\n    (re.Pattern): the compiled regular expressions, to validate\n    the resource name.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _get_resource_name_regex():\n    \"\"\"Build or return the regular expressions that are used to validate\n    the name of the Krake resources.\n\n    Returns:\n        (re.Pattern): the compiled regular expressions, to validate\n        the resource name.\n    \"\"\"\n    global _resource_name_regex, _resource_name_pattern\n\n    # Build the patterns only if not already built\n    if _resource_name_regex:\n        return _resource_name_regex\n\n    # First and last characters must be alphanumeric. The rest of the string must be\n    # alphanumeric, \"-\", \"_\" or \".\" and without whitespace as well as have a\n    # max length of 255 and a min length of 1\n    max_name_size = 253  # reduced by 2 for the regex\n    min_name_size = 0  # reduced by 1 for the regex\n    base_alphanumeric_pattern = \"\\\\w|(\\\\w[\\\\w\\\\-_.:]{{{min_length},{length}}}\\\\w)\"\n\n    resource_name_pattern = base_alphanumeric_pattern.format(\n        min_length=min_name_size, length=max_name_size\n    )\n\n    _resource_name_pattern = resource_name_pattern\n    _resource_name_regex = re.compile(_resource_name_pattern, re.ASCII)\n    return _resource_name_regex", "signature": "def _get_resource_name_regex():", "completion_path": "krake/krake/data/core.py"}
{"ce_id": "62b86a4fb4d922cb0e688cf8", "namespace": "62b86a4fb4d922cb0e688cf8", "namespace_real": "krake.krake.data.core.validate_value", "real_proj_path": "rak-n-rok---Krake/", "type": "function", "class_name": null, "function_name": "validate_value", "contexts_above": "import re\nfrom enum import Enum, IntEnum, auto\nfrom datetime import datetime\nfrom dataclasses import field\nfrom typing import List, Dict\n\nfrom marshmallow import ValidationError\n\nfrom . import persistent\nfrom .serializable import Serializable, ApiObject, PolymorphicContainer\n\n\nclass ResourceRef(Serializable):\n    api: str\n    namespace: str = field(default=None)\n    kind: str\n    name: str\n\n    def __hash__(self):\n        return hash((self.api, self.namespace, self.kind, self.name))\n\n    def __repr__(self):\n        message = f\"{self.kind}(api='{self.api}', \"\n        return message + f\"namespace='{self.namespace}', name='{self.name}')\"\n\n\n_label_key_pattern = None\n_label_value_pattern = None\n\n_label_key_regex = None\n_label_value_regex = None\n\n\ndef _get_labels_regex():\n    \"\"\"Build or return the regular expressions that are used to validate the key and\n    value of the labels of the Krake resources.\n\n    The first call builds the expressions, while a second returns the already built\n    ones.\n\n    Returns:\n        (re.Pattern, re.Pattern): a tuple that contains the compiled regular,\n            expressions, the first element to validate the key and the second to\n            validate the value.\n\n    \"\"\"\n    global _label_key_pattern, _label_value_pattern\n    global _label_key_regex, _label_value_regex\n\n    if _label_key_regex and _label_value_regex:\n        return _label_key_regex, _label_value_regex\n\n    # Build the patterns only if not already built\n    max_prefix_size = 253\n    max_key_size = 63\n    max_value_size = max_key_size\n\n    # First and last characters must be alphanumeric. The rest of the string must be\n    # alphanumeric, \"-\", \"_\" or \".\"\n    base_alphanumeric_pattern = \"\\\\w|(\\\\w[\\\\w\\\\-_.]{{0,{length}}}\\\\w)\"\n\n    key_pattern = base_alphanumeric_pattern.format(length=max_key_size - 2)\n    value_pattern = base_alphanumeric_pattern.format(length=max_value_size - 2)\n    prefix_pattern = base_alphanumeric_pattern.format(length=max_prefix_size - 2)\n\n    # The key can be a string of length 63 with the specifications described above,\n    # or have a prefix, then one \"/\" character, then the string of length 63 (called\n    # name).\n    # The prefix itself should have a max length of 253, but otherwise follows the\n    # specifications described above.\n    _label_key_pattern = f\"^(({prefix_pattern})\\\\/)?({key_pattern})$\"\n\n    # The value can be a string of length 63 with the specifications described\n    # above.\n    _label_value_pattern = value_pattern\n\n    _label_key_regex = re.compile(_label_key_pattern, re.ASCII)\n    _label_value_regex = re.compile(_label_value_pattern, re.ASCII)\n\n    return _label_key_regex, _label_value_regex\n\n\ndef validate_key(key):\n    \"\"\"Validate the given key against the corresponding regular expression.\n\n    Args:\n        key: the string to validate\n\n    Raises:\n        ValidationError: if the given key is not conform to the regular expression.\n    \"\"\"\n    key_regex, _ = _get_labels_regex()\n    if not key_regex.fullmatch(key):\n        raise ValidationError(\n            f\"Label key {key!r} does not match the regex {_label_key_pattern!r}.\"\n        )\n\n", "contexts_below": "\n def _validate_labels(labels):\n     \"\"\"Check that keys and values in the given labels match against their corresponding\n     regular expressions.\n \n     Args:\n         labels (dict): the different labels to validate.\n \n     Raises:\n         ValidationError: if any of the keys and labels does not match their respective\n             regular expression. The error contains as message the list of all errors\n             which occurred in the labels. Each element of the list is a dictionary with\n             one key-value pair:\n             - key: the label key or label value for which an error occurred as string.\n             - value: the error message.\n \n             .. code:: python\n \n                 # Example:\n                 labels = {\n                     \"key1\": \"valid\",\n                     \"key2\": [\"invalid\"],\n                     \"$$\": \"invalid\",\n                     True: True,\n                 }\n                 try:\n                     _validate_labels(labels)\n                 except ValidationError as err:\n                     assert err.messages == [\n                         {\"['invalid']\": 'expected string or bytes-like object'},\n                         {'$$': \"Label key '$$' does not match the regex [...]\"},\n                         {'True': 'expected string or bytes-like object'},\n                         {'True': 'expected string or bytes-like object'},\n                     ]\n     \"\"\"\n     errors = []\n     for key, value in labels.items():\n         try:\n             validate_key(key)\n         except (ValidationError, TypeError) as err:\n             errors.append({str(key): str(err)})\n \n         try:\n             validate_value(value)\n         except (ValidationError, TypeError) as err:\n             errors.append({str(value): str(err)})\n \n     if errors:\n         raise ValidationError(list(errors))\n \n \n _resource_name_pattern = None\n _resource_name_regex = None\n \n \n def _get_resource_name_regex():\n     \"\"\"Build or return the regular expressions that are used to validate\n     the name of the Krake resources.\n \n     Returns:\n         (re.Pattern): the compiled regular expressions, to validate\n         the resource name.\n     \"\"\"\n     global _resource_name_regex, _resource_name_pattern\n \n     # Build the patterns only if not already built\n     if _resource_name_regex:\n         return _resource_name_regex\n \n     # First and last characters must be alphanumeric. The rest of the string must be\n     # alphanumeric, \"-\", \"_\" or \".\" and without whitespace as well as have a\n     # max length of 255 and a min length of 1\n     max_name_size = 253  # reduced by 2 for the regex\n     min_name_size = 0  # reduced by 1 for the regex\n     base_alphanumeric_pattern = \"\\\\w|(\\\\w[\\\\w\\\\-_.:]{{{min_length},{length}}}\\\\w)\"\n \n     resource_name_pattern = base_alphanumeric_pattern.format(\n         min_length=min_name_size, length=max_name_size\n     )\n \n     _resource_name_pattern = resource_name_pattern\n     _resource_name_regex = re.compile(_resource_name_pattern, re.ASCII)\n     return _resource_name_regex\n \n \n def _validate_resource_name(name):\n     \"\"\"Each Krake resource name is checked against a specific pattern.\n     Which characters are not allowed is defined in _get_resource_name_regex\n \n     Args:\n         name(str): the different resource names to validate.\n \n     Raises:\n         ValidationError: if any resource name does not match their respective\n             regular expression.\n     \"\"\"\n     resource_name_regex = _get_resource_name_regex()\n     if not resource_name_regex.fullmatch(name):\n         raise ValidationError(\"Invalid character in resource name.\")\n \n \n def _validate_resource_namespace(namespace):\n     \"\"\"Each Krake resource namespace is checked against a specific pattern.\n     Which characters are not allowed is defined in _get_resource_name_regex\n \n     Args:\n         namespace(str): the different resource namespaces to validate.\n \n     Raises:\n         ValidationError: if any resource namespace does not match their respective\n             regular expression.\n     \"\"\"\n     resource_namespace_regex = _get_resource_name_regex()\n     if not resource_namespace_regex.fullmatch(namespace):\n         raise ValidationError(\"Invalid character in resource namespace.\")\n \n \n class Metadata(Serializable):\n     name: str = field(metadata={\"immutable\": True, \"validate\": _validate_resource_name})\n     namespace: str = field(\n         default=None,\n         metadata={\"immutable\": True, \"validate\": _validate_resource_namespace},\n     )\n     labels: dict = field(default_factory=dict, metadata={\"validate\": _validate_labels})\n     finalizers: List[str] = field(default_factory=list)\n \n     uid: str = field(metadata={\"readonly\": True})\n     created: datetime = field(metadata={\"readonly\": True})\n     modified: datetime = field(metadata={\"readonly\": True})\n     deleted: datetime = field(default=None, metadata={\"readonly\": True})\n \n     owners: List[ResourceRef] = field(default_factory=list)\n \n \n class CoreMetadata(Serializable):\n     name: str\n     uid: str\n \n \n class ListMetadata(Serializable):\n     pass  # TODO\n \n \n class ReasonCode(IntEnum):\n     INTERNAL_ERROR = 1  # Default error\n \n     INVALID_RESOURCE = 10  # Invalid values in the Manifest\n     # Kubernetes' resource is not supported by the Kubernetes controller\n     UNSUPPORTED_RESOURCE = 11\n     # The custom resource provided does not exist or is invalid\n     INVALID_CUSTOM_RESOURCE = 12\n \n     CLUSTER_NOT_REACHABLE = 20  # Connectivity issue with the Kubernetes deployment\n     NO_SUITABLE_RESOURCE = 50  # Scheduler issue\n \n     KUBERNETES_ERROR = 60\n \n     CREATE_FAILED = 70\n     RECONCILE_FAILED = 71\n     DELETE_FAILED = 72\n \n     OPENSTACK_ERROR = 80\n     INVALID_CLUSTER_TEMPLATE = 81\n \n     # Related to Metrics and Metric Provider\n     INVALID_METRIC = 91\n     UNREACHABLE_METRICS_PROVIDER = 92\n     UNKNOWN_METRIC = 93\n     UNKNOWN_METRICS_PROVIDER = 94\n \n \n class Reason(Serializable):\n     code: ReasonCode\n     message: str\n \n \n class WatchEventType(Enum):\n     ADDED = auto()\n     MODIFIED = auto()\n     DELETED = auto()\n \n \n class Status(Serializable):\n     reason: Reason = None\n \n \n class WatchEvent(Serializable):\n     type: WatchEventType\n     object: dict\n \n \n class Verb(Enum):\n     create = auto()\n     list = auto()\n     list_all = auto()\n     get = auto()\n     update = auto()\n     delete = auto()\n \n \n class RoleRule(Serializable):\n     api: str\n     resources: List[str]\n     namespaces: List[str]\n     verbs: List[Verb]\n \n \n @persistent(\"/core/roles/{name}\")\n class Role(ApiObject):\n     api: str = \"core\"\n     kind: str = \"Role\"\n     metadata: Metadata\n     rules: List[RoleRule]\n \n \n class RoleList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"RoleList\"\n     metadata: ListMetadata\n     items: List[Role]\n \n \n @persistent(\"/core/rolebindings/{name}\")\n class RoleBinding(ApiObject):\n     api: str = \"core\"\n     kind: str = \"RoleBinding\"\n     metadata: Metadata\n     users: List[str]\n     roles: List[str]\n \n \n class RoleBindingList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"RoleBindingList\"\n     metadata: ListMetadata\n     items: List[RoleBinding]\n \n \n class Conflict(Serializable):\n     source: ResourceRef\n     conflicting: List[ResourceRef]\n \n \n def resource_ref(resource):\n     \"\"\"Create a :class:`ResourceRef` from a :class:`ApiObject`\n \n     Args:\n         resource (.serializable.ApiObject): API object that should be\n             referenced\n \n     Returns:\n         ResourceRef: Corresponding reference to the API object\n     \"\"\"\n     return ResourceRef(\n         api=resource.api,\n         kind=resource.kind,\n         namespace=resource.metadata.namespace,\n         name=resource.metadata.name,\n     )\n \n \n class MetricSpecProvider(Serializable):\n     name: str\n     metric: str\n \n \n class MetricSpec(Serializable):\n     min: float\n     max: float\n     provider: MetricSpecProvider\n \n \n class BaseMetric(ApiObject):\n     api: str = \"core\"\n     kind: str = None\n     metadata: Metadata\n     spec: MetricSpec\n \n \n @persistent(\"/core/globalmetrics/{name}\")\n class GlobalMetric(BaseMetric):\n     api: str = \"core\"\n     kind: str = \"GlobalMetric\"\n     metadata: Metadata\n     spec: MetricSpec\n \n \n @persistent(\"/core/metrics/{namespace}/{name}\")\n class Metric(BaseMetric):\n     api: str = \"core\"\n     kind: str = \"Metric\"\n     metadata: Metadata\n     spec: MetricSpec\n \n \n class MetricList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"MetricList\"\n     metadata: ListMetadata\n     items: List[Metric]\n \n \n class GlobalMetricList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"GlobalMetricList\"\n     metadata: ListMetadata\n     items: List[GlobalMetric]\n \n \n class MetricsProviderSpec(PolymorphicContainer):\n     type: str\n \n \n @MetricsProviderSpec.register(\"prometheus\")\n class PrometheusSpec(Serializable):\n     url: str\n \n \n @MetricsProviderSpec.register(\"kafka\")\n class KafkaSpec(Serializable):\n     \"\"\"Specifications to connect to a KSQL database, and retrieve a specific row from a\n     specific table.\n \n     Attributes:\n         comparison_column (str): name of the column where the value will be compared to\n             the metric name, to select the right metric.\n         value_column (str): name of the column where the value of a metric is stored.\n         table (str): the name of the KSQL table where the metric is defined.\n         url (str): endpoint of the KSQL database.\n \n     \"\"\"\n \n     comparison_column: str\n     value_column: str\n     table: str\n     url: str\n \n \n @MetricsProviderSpec.register(\"static\")\n class StaticSpec(Serializable):\n     metrics: Dict[str, float]\n \n \n class BaseMetricsProvider(ApiObject):\n     api: str = \"core\"\n     kind: str = None\n     metadata: Metadata\n     spec: MetricsProviderSpec\n \n \n @persistent(\"/core/globalmetricsproviders/{name}\")\n class GlobalMetricsProvider(BaseMetricsProvider):\n     api: str = \"core\"\n     kind: str = \"GlobalMetricsProvider\"\n     metadata: Metadata\n     spec: MetricsProviderSpec\n \n \n @persistent(\"/core/metricsproviders/{namespace}/{name}\")\n class MetricsProvider(BaseMetricsProvider):\n     api: str = \"core\"\n     kind: str = \"MetricsProvider\"\n     metadata: Metadata\n     spec: MetricsProviderSpec\n \n \n class MetricsProviderList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"MetricsProviderList\"\n     metadata: ListMetadata\n     items: List[MetricsProvider]\n \n \n class GlobalMetricsProviderList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"GlobalMetricsProviderList\"\n     metadata: ListMetadata\n     items: List[GlobalMetricsProvider]\n \n \n class MetricRef(Serializable):\n     name: str\n     weight: float\n     namespaced: bool = False\n ", "input_code": "def validate_value(value):\n\"\"\"\nValidate the given value against the corresponding regular expression.\n\nArgs:\n    value: the string to validate\n\nRaises:\n    ValidationError: if the given value is not conform to the regular expression.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def validate_value(value):\n    \"\"\"Validate the given value against the corresponding regular expression.\n\n    Args:\n        value: the string to validate\n\n    Raises:\n        ValidationError: if the given value is not conform to the regular expression.\n    \"\"\"\n    _, value_regex = _get_labels_regex()\n    if not value_regex.fullmatch(value):\n        raise ValidationError(\n            f\"Label value {value!r} does not match\"\n            f\" the regex {_label_value_pattern!r}.\"\n        )", "signature": "def validate_value(value):", "completion_path": "krake/krake/data/core.py"}
{"ce_id": "62b86a4fb4d922cb0e688cf7", "namespace": "62b86a4fb4d922cb0e688cf7", "namespace_real": "krake.krake.data.core.validate_key", "real_proj_path": "rak-n-rok---Krake/", "type": "function", "class_name": null, "function_name": "validate_key", "contexts_above": "import re\nfrom enum import Enum, IntEnum, auto\nfrom datetime import datetime\nfrom dataclasses import field\nfrom typing import List, Dict\n\nfrom marshmallow import ValidationError\n\nfrom . import persistent\nfrom .serializable import Serializable, ApiObject, PolymorphicContainer\n\n\nclass ResourceRef(Serializable):\n    api: str\n    namespace: str = field(default=None)\n    kind: str\n    name: str\n\n    def __hash__(self):\n        return hash((self.api, self.namespace, self.kind, self.name))\n\n    def __repr__(self):\n        message = f\"{self.kind}(api='{self.api}', \"\n        return message + f\"namespace='{self.namespace}', name='{self.name}')\"\n\n\n_label_key_pattern = None\n_label_value_pattern = None\n\n_label_key_regex = None\n_label_value_regex = None\n\n\ndef _get_labels_regex():\n    \"\"\"Build or return the regular expressions that are used to validate the key and\n    value of the labels of the Krake resources.\n\n    The first call builds the expressions, while a second returns the already built\n    ones.\n\n    Returns:\n        (re.Pattern, re.Pattern): a tuple that contains the compiled regular,\n            expressions, the first element to validate the key and the second to\n            validate the value.\n\n    \"\"\"\n    global _label_key_pattern, _label_value_pattern\n    global _label_key_regex, _label_value_regex\n\n    if _label_key_regex and _label_value_regex:\n        return _label_key_regex, _label_value_regex\n\n    # Build the patterns only if not already built\n    max_prefix_size = 253\n    max_key_size = 63\n    max_value_size = max_key_size\n\n    # First and last characters must be alphanumeric. The rest of the string must be\n    # alphanumeric, \"-\", \"_\" or \".\"\n    base_alphanumeric_pattern = \"\\\\w|(\\\\w[\\\\w\\\\-_.]{{0,{length}}}\\\\w)\"\n\n    key_pattern = base_alphanumeric_pattern.format(length=max_key_size - 2)\n    value_pattern = base_alphanumeric_pattern.format(length=max_value_size - 2)\n    prefix_pattern = base_alphanumeric_pattern.format(length=max_prefix_size - 2)\n\n    # The key can be a string of length 63 with the specifications described above,\n    # or have a prefix, then one \"/\" character, then the string of length 63 (called\n    # name).\n    # The prefix itself should have a max length of 253, but otherwise follows the\n    # specifications described above.\n    _label_key_pattern = f\"^(({prefix_pattern})\\\\/)?({key_pattern})$\"\n\n    # The value can be a string of length 63 with the specifications described\n    # above.\n    _label_value_pattern = value_pattern\n\n    _label_key_regex = re.compile(_label_key_pattern, re.ASCII)\n    _label_value_regex = re.compile(_label_value_pattern, re.ASCII)\n\n    return _label_key_regex, _label_value_regex\n\n", "contexts_below": "\n def validate_value(value):\n     \"\"\"Validate the given value against the corresponding regular expression.\n \n     Args:\n         value: the string to validate\n \n     Raises:\n         ValidationError: if the given value is not conform to the regular expression.\n     \"\"\"\n     _, value_regex = _get_labels_regex()\n     if not value_regex.fullmatch(value):\n         raise ValidationError(\n             f\"Label value {value!r} does not match\"\n             f\" the regex {_label_value_pattern!r}.\"\n         )\n \n \n def _validate_labels(labels):\n     \"\"\"Check that keys and values in the given labels match against their corresponding\n     regular expressions.\n \n     Args:\n         labels (dict): the different labels to validate.\n \n     Raises:\n         ValidationError: if any of the keys and labels does not match their respective\n             regular expression. The error contains as message the list of all errors\n             which occurred in the labels. Each element of the list is a dictionary with\n             one key-value pair:\n             - key: the label key or label value for which an error occurred as string.\n             - value: the error message.\n \n             .. code:: python\n \n                 # Example:\n                 labels = {\n                     \"key1\": \"valid\",\n                     \"key2\": [\"invalid\"],\n                     \"$$\": \"invalid\",\n                     True: True,\n                 }\n                 try:\n                     _validate_labels(labels)\n                 except ValidationError as err:\n                     assert err.messages == [\n                         {\"['invalid']\": 'expected string or bytes-like object'},\n                         {'$$': \"Label key '$$' does not match the regex [...]\"},\n                         {'True': 'expected string or bytes-like object'},\n                         {'True': 'expected string or bytes-like object'},\n                     ]\n     \"\"\"\n     errors = []\n     for key, value in labels.items():\n         try:\n             validate_key(key)\n         except (ValidationError, TypeError) as err:\n             errors.append({str(key): str(err)})\n \n         try:\n             validate_value(value)\n         except (ValidationError, TypeError) as err:\n             errors.append({str(value): str(err)})\n \n     if errors:\n         raise ValidationError(list(errors))\n \n \n _resource_name_pattern = None\n _resource_name_regex = None\n \n \n def _get_resource_name_regex():\n     \"\"\"Build or return the regular expressions that are used to validate\n     the name of the Krake resources.\n \n     Returns:\n         (re.Pattern): the compiled regular expressions, to validate\n         the resource name.\n     \"\"\"\n     global _resource_name_regex, _resource_name_pattern\n \n     # Build the patterns only if not already built\n     if _resource_name_regex:\n         return _resource_name_regex\n \n     # First and last characters must be alphanumeric. The rest of the string must be\n     # alphanumeric, \"-\", \"_\" or \".\" and without whitespace as well as have a\n     # max length of 255 and a min length of 1\n     max_name_size = 253  # reduced by 2 for the regex\n     min_name_size = 0  # reduced by 1 for the regex\n     base_alphanumeric_pattern = \"\\\\w|(\\\\w[\\\\w\\\\-_.:]{{{min_length},{length}}}\\\\w)\"\n \n     resource_name_pattern = base_alphanumeric_pattern.format(\n         min_length=min_name_size, length=max_name_size\n     )\n \n     _resource_name_pattern = resource_name_pattern\n     _resource_name_regex = re.compile(_resource_name_pattern, re.ASCII)\n     return _resource_name_regex\n \n \n def _validate_resource_name(name):\n     \"\"\"Each Krake resource name is checked against a specific pattern.\n     Which characters are not allowed is defined in _get_resource_name_regex\n \n     Args:\n         name(str): the different resource names to validate.\n \n     Raises:\n         ValidationError: if any resource name does not match their respective\n             regular expression.\n     \"\"\"\n     resource_name_regex = _get_resource_name_regex()\n     if not resource_name_regex.fullmatch(name):\n         raise ValidationError(\"Invalid character in resource name.\")\n \n \n def _validate_resource_namespace(namespace):\n     \"\"\"Each Krake resource namespace is checked against a specific pattern.\n     Which characters are not allowed is defined in _get_resource_name_regex\n \n     Args:\n         namespace(str): the different resource namespaces to validate.\n \n     Raises:\n         ValidationError: if any resource namespace does not match their respective\n             regular expression.\n     \"\"\"\n     resource_namespace_regex = _get_resource_name_regex()\n     if not resource_namespace_regex.fullmatch(namespace):\n         raise ValidationError(\"Invalid character in resource namespace.\")\n \n \n class Metadata(Serializable):\n     name: str = field(metadata={\"immutable\": True, \"validate\": _validate_resource_name})\n     namespace: str = field(\n         default=None,\n         metadata={\"immutable\": True, \"validate\": _validate_resource_namespace},\n     )\n     labels: dict = field(default_factory=dict, metadata={\"validate\": _validate_labels})\n     finalizers: List[str] = field(default_factory=list)\n \n     uid: str = field(metadata={\"readonly\": True})\n     created: datetime = field(metadata={\"readonly\": True})\n     modified: datetime = field(metadata={\"readonly\": True})\n     deleted: datetime = field(default=None, metadata={\"readonly\": True})\n \n     owners: List[ResourceRef] = field(default_factory=list)\n \n \n class CoreMetadata(Serializable):\n     name: str\n     uid: str\n \n \n class ListMetadata(Serializable):\n     pass  # TODO\n \n \n class ReasonCode(IntEnum):\n     INTERNAL_ERROR = 1  # Default error\n \n     INVALID_RESOURCE = 10  # Invalid values in the Manifest\n     # Kubernetes' resource is not supported by the Kubernetes controller\n     UNSUPPORTED_RESOURCE = 11\n     # The custom resource provided does not exist or is invalid\n     INVALID_CUSTOM_RESOURCE = 12\n \n     CLUSTER_NOT_REACHABLE = 20  # Connectivity issue with the Kubernetes deployment\n     NO_SUITABLE_RESOURCE = 50  # Scheduler issue\n \n     KUBERNETES_ERROR = 60\n \n     CREATE_FAILED = 70\n     RECONCILE_FAILED = 71\n     DELETE_FAILED = 72\n \n     OPENSTACK_ERROR = 80\n     INVALID_CLUSTER_TEMPLATE = 81\n \n     # Related to Metrics and Metric Provider\n     INVALID_METRIC = 91\n     UNREACHABLE_METRICS_PROVIDER = 92\n     UNKNOWN_METRIC = 93\n     UNKNOWN_METRICS_PROVIDER = 94\n \n \n class Reason(Serializable):\n     code: ReasonCode\n     message: str\n \n \n class WatchEventType(Enum):\n     ADDED = auto()\n     MODIFIED = auto()\n     DELETED = auto()\n \n \n class Status(Serializable):\n     reason: Reason = None\n \n \n class WatchEvent(Serializable):\n     type: WatchEventType\n     object: dict\n \n \n class Verb(Enum):\n     create = auto()\n     list = auto()\n     list_all = auto()\n     get = auto()\n     update = auto()\n     delete = auto()\n \n \n class RoleRule(Serializable):\n     api: str\n     resources: List[str]\n     namespaces: List[str]\n     verbs: List[Verb]\n \n \n @persistent(\"/core/roles/{name}\")\n class Role(ApiObject):\n     api: str = \"core\"\n     kind: str = \"Role\"\n     metadata: Metadata\n     rules: List[RoleRule]\n \n \n class RoleList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"RoleList\"\n     metadata: ListMetadata\n     items: List[Role]\n \n \n @persistent(\"/core/rolebindings/{name}\")\n class RoleBinding(ApiObject):\n     api: str = \"core\"\n     kind: str = \"RoleBinding\"\n     metadata: Metadata\n     users: List[str]\n     roles: List[str]\n \n \n class RoleBindingList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"RoleBindingList\"\n     metadata: ListMetadata\n     items: List[RoleBinding]\n \n \n class Conflict(Serializable):\n     source: ResourceRef\n     conflicting: List[ResourceRef]\n \n \n def resource_ref(resource):\n     \"\"\"Create a :class:`ResourceRef` from a :class:`ApiObject`\n \n     Args:\n         resource (.serializable.ApiObject): API object that should be\n             referenced\n \n     Returns:\n         ResourceRef: Corresponding reference to the API object\n     \"\"\"\n     return ResourceRef(\n         api=resource.api,\n         kind=resource.kind,\n         namespace=resource.metadata.namespace,\n         name=resource.metadata.name,\n     )\n \n \n class MetricSpecProvider(Serializable):\n     name: str\n     metric: str\n \n \n class MetricSpec(Serializable):\n     min: float\n     max: float\n     provider: MetricSpecProvider\n \n \n class BaseMetric(ApiObject):\n     api: str = \"core\"\n     kind: str = None\n     metadata: Metadata\n     spec: MetricSpec\n \n \n @persistent(\"/core/globalmetrics/{name}\")\n class GlobalMetric(BaseMetric):\n     api: str = \"core\"\n     kind: str = \"GlobalMetric\"\n     metadata: Metadata\n     spec: MetricSpec\n \n \n @persistent(\"/core/metrics/{namespace}/{name}\")\n class Metric(BaseMetric):\n     api: str = \"core\"\n     kind: str = \"Metric\"\n     metadata: Metadata\n     spec: MetricSpec\n \n \n class MetricList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"MetricList\"\n     metadata: ListMetadata\n     items: List[Metric]\n \n \n class GlobalMetricList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"GlobalMetricList\"\n     metadata: ListMetadata\n     items: List[GlobalMetric]\n \n \n class MetricsProviderSpec(PolymorphicContainer):\n     type: str\n \n \n @MetricsProviderSpec.register(\"prometheus\")\n class PrometheusSpec(Serializable):\n     url: str\n \n \n @MetricsProviderSpec.register(\"kafka\")\n class KafkaSpec(Serializable):\n     \"\"\"Specifications to connect to a KSQL database, and retrieve a specific row from a\n     specific table.\n \n     Attributes:\n         comparison_column (str): name of the column where the value will be compared to\n             the metric name, to select the right metric.\n         value_column (str): name of the column where the value of a metric is stored.\n         table (str): the name of the KSQL table where the metric is defined.\n         url (str): endpoint of the KSQL database.\n \n     \"\"\"\n \n     comparison_column: str\n     value_column: str\n     table: str\n     url: str\n \n \n @MetricsProviderSpec.register(\"static\")\n class StaticSpec(Serializable):\n     metrics: Dict[str, float]\n \n \n class BaseMetricsProvider(ApiObject):\n     api: str = \"core\"\n     kind: str = None\n     metadata: Metadata\n     spec: MetricsProviderSpec\n \n \n @persistent(\"/core/globalmetricsproviders/{name}\")\n class GlobalMetricsProvider(BaseMetricsProvider):\n     api: str = \"core\"\n     kind: str = \"GlobalMetricsProvider\"\n     metadata: Metadata\n     spec: MetricsProviderSpec\n \n \n @persistent(\"/core/metricsproviders/{namespace}/{name}\")\n class MetricsProvider(BaseMetricsProvider):\n     api: str = \"core\"\n     kind: str = \"MetricsProvider\"\n     metadata: Metadata\n     spec: MetricsProviderSpec\n \n \n class MetricsProviderList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"MetricsProviderList\"\n     metadata: ListMetadata\n     items: List[MetricsProvider]\n \n \n class GlobalMetricsProviderList(ApiObject):\n     api: str = \"core\"\n     kind: str = \"GlobalMetricsProviderList\"\n     metadata: ListMetadata\n     items: List[GlobalMetricsProvider]\n \n \n class MetricRef(Serializable):\n     name: str\n     weight: float\n     namespaced: bool = False\n ", "input_code": "def validate_key(key):\n\"\"\"\nValidate the given key against the corresponding regular expression.\n\nArgs:\n    key: the string to validate\n\nRaises:\n    ValidationError: if the given key is not conform to the regular expression.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def validate_key(key):\n    \"\"\"Validate the given key against the corresponding regular expression.\n\n    Args:\n        key: the string to validate\n\n    Raises:\n        ValidationError: if the given key is not conform to the regular expression.\n    \"\"\"\n    key_regex, _ = _get_labels_regex()\n    if not key_regex.fullmatch(key):\n        raise ValidationError(\n            f\"Label key {key!r} does not match the regex {_label_key_pattern!r}.\"\n        )", "signature": "def validate_key(key):", "completion_path": "krake/krake/data/core.py"}
{"ce_id": "62b86a01b4d922cb0e688ccc", "namespace": "62b86a01b4d922cb0e688ccc", "namespace_real": "krake.krake.controller.kubernetes.hooks.generate_default_observer_schema_dict", "real_proj_path": "rak-n-rok---Krake/", "type": "function", "class_name": null, "function_name": "generate_default_observer_schema_dict", "contexts_above": "\"\"\"This module defines the Hook Dispatcher and listeners for registering and\nexecuting hooks. Hook Dispatcher emits hooks based on :class:`Hook` attributes which\ndefine when the hook will be executed.\n\n\"\"\"\nimport asyncio\nimport logging\nimport random\nfrom base64 import b64encode\nfrom collections import defaultdict\nfrom contextlib import suppress\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom functools import reduce\nfrom operator import getitem\nfrom enum import Enum, auto\nfrom inspect import iscoroutinefunction\nfrom OpenSSL import crypto\nfrom typing import NamedTuple\n\nimport yarl\nfrom aiohttp import ClientConnectorError\n\nfrom krake.controller import Observer\nfrom krake.controller.kubernetes.client import KubernetesClient, InvalidManifestError\nfrom krake.utils import camel_to_snake_case, get_kubernetes_resource_idx\nfrom kubernetes_asyncio.client.rest import ApiException\nfrom kubernetes_asyncio.client.api_client import ApiClient\nfrom kubernetes_asyncio import client\nfrom krake.data.kubernetes import ClusterState, Application, Cluster\nfrom yarl import URL\nfrom secrets import token_urlsafe\n\nfrom kubernetes_asyncio.client import (\n    Configuration,\n    V1Secret,\n    V1EnvVar,\n    V1VolumeMount,\n    V1Volume,\n    V1SecretKeySelector,\n    V1EnvVarSource,\n)\nfrom kubernetes_asyncio.config.kube_config import KubeConfigLoader\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass HookType(Enum):\n    ResourcePreCreate = auto()\n    ResourcePostCreate = auto()\n    ResourcePreUpdate = auto()\n    ResourcePostUpdate = auto()\n    ResourcePreDelete = auto()\n    ResourcePostDelete = auto()\n    ApplicationMangling = auto()\n    ApplicationPreMigrate = auto()\n    ApplicationPostMigrate = auto()\n    ApplicationPreReconcile = auto()\n    ApplicationPostReconcile = auto()\n    ApplicationPreDelete = auto()\n    ApplicationPostDelete = auto()\n    ClusterCreation = auto()\n    ClusterDeletion = auto()\n\n\nclass HookDispatcher(object):\n    \"\"\"Simple wrapper around a registry of handlers associated to :class:`Hook`\n     attributes. Each :class:`Hook` attribute defines when the handler will be\n     executed.\n\n    Listeners for certain hooks can be registered via :meth:`on`. Registered\n    listeners are executed via :meth:`hook`.\n\n    Example:\n        .. code:: python\n\n        listen = HookDispatcher()\n\n        @listen.on(HookType.PreApply)\n        def to_perform_before_app_creation(app, cluster, resource, controller):\n            # Do Stuff\n\n        @listen.on(HookType.PostApply)\n        def another_to_perform_after_app_creation(app, cluster, resource, resp):\n            # Do Stuff\n\n        @listen.on(HookType.PostDelete)\n        def to_perform_after_app_deletion(app, cluster, resource, resp):\n            # Do Stuff\n\n    \"\"\"\n\n    def __init__(self):\n        self.registry = defaultdict(list)\n\n    def on(self, hook):\n        \"\"\"Decorator function to add a new handler to the registry.\n\n        Args:\n            hook (HookType): Hook attribute for which to register the handler.\n\n        Returns:\n            callable: Decorator for registering listeners for the specified\n            hook.\n\n        \"\"\"\n\n        def decorator(handler):\n            self.registry[hook].append(handler)\n\n            return handler\n\n        return decorator\n\n    async def hook(self, hook, **kwargs):\n        \"\"\"Execute the list of handlers associated to the provided :class:`Hook`\n        attribute.\n\n        Args:\n            hook (HookType): The hook attribute for which to execute handlers.\n\n        \"\"\"\n        try:\n            handlers = self.registry[hook]\n        except KeyError:\n            pass\n        else:\n            for handler in handlers:\n                if iscoroutinefunction(handler):\n                    await handler(**kwargs)\n                else:\n                    handler(**kwargs)\n\n\nlisten = HookDispatcher()\n\n\n@listen.on(HookType.ResourcePostCreate)\n@listen.on(HookType.ResourcePostUpdate)\nasync def register_service(app, cluster, resource, response):\n    \"\"\"Register endpoint of Kubernetes Service object on creation and update.\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        cluster (krake.data.kubernetes.Cluster): The cluster on which the\n            application is running\n        resource (dict): Kubernetes object description as specified in the\n            specification of the application.\n        response (kubernetes_asyncio.client.V1Service): Response of the\n            Kubernetes API\n\n    \"\"\"\n    if resource[\"kind\"] != \"Service\":\n        return\n\n    service_name = resource[\"metadata\"][\"name\"]\n\n    if response.spec and response.spec.type == \"LoadBalancer\":\n        # For a \"LoadBalancer\" type of Service, an external IP is given in the cluster\n        # by a load balancer controller to the service. In this case, the \"port\"\n        # specified in the spec is reachable from the outside.\n        if (\n            not response.status.load_balancer\n            or not response.status.load_balancer.ingress\n        ):\n            # When a \"LoadBalancer\" type of service is created, the IP is given by an\n            # additional controller (e.g. a controller that requests a floating IP to an\n            # OpenStack infrastructure). This process can take some time, but the\n            # Service itself already exist before the IP is assigned. In the case of an\n            # error with the controller, the IP is also not given. This \"<pending>\" IP\n            # just expresses that the Service exists, but the IP is not ready yet.\n            external_ip = \"<pending>\"\n        else:\n            external_ip = response.status.load_balancer.ingress[0].ip\n\n        if not response.spec.ports:\n            external_port = \"<pending>\"\n        else:\n            external_port = response.spec.ports[0].port\n        app.status.services[service_name] = f\"{external_ip}:{external_port}\"\n        return\n\n    node_port = None\n    # Ensure that ports are specified\n    if response.spec and response.spec.ports:\n        node_port = response.spec.ports[0].node_port\n\n    # If the service does not have a node port, remove a potential reference\n    # and return.\n    if node_port is None:\n        try:\n            del app.status.services[service_name]\n        except KeyError:\n            pass\n        return\n\n    # Determine URL of Kubernetes cluster API\n    loader = KubeConfigLoader(cluster.spec.kubeconfig)\n    config = Configuration()\n    await loader.load_and_set(config)\n    cluster_url = yarl.URL(config.host)\n\n    app.status.services[service_name] = f\"{cluster_url.host}:{node_port}\"\n\n\n@listen.on(HookType.ResourcePostDelete)\nasync def unregister_service(app, resource, **kwargs):\n    \"\"\"Unregister endpoint of Kubernetes Service object on deletion.\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        resource (dict): Kubernetes object description as specified in the\n            specification of the application.\n\n    \"\"\"\n    if resource[\"kind\"] != \"Service\":\n        return\n\n    service_name = resource[\"metadata\"][\"name\"]\n    try:\n        del app.status.services[service_name]\n    except KeyError:\n        pass\n\n\n@listen.on(HookType.ResourcePostDelete)\nasync def remove_resource_from_last_observed_manifest(app, resource, **kwargs):\n    \"\"\"Remove a given resource from the last_observed_manifest after its deletion\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        resource (dict): Kubernetes object description as specified in the\n            specification of the application.\n\n    \"\"\"\n    try:\n        idx = get_kubernetes_resource_idx(app.status.last_observed_manifest, resource)\n    except IndexError:\n        return\n\n    app.status.last_observed_manifest.pop(idx)\n\n\ndef update_last_applied_manifest_dict_from_resp(\n    last_applied_manifest, observer_schema, response\n):\n    \"\"\"Together with :func:``update_last_applied_manifest_list_from_resp``, this\n    function is called recursively to update a partial ``last_applied_manifest``\n    from a partial Kubernetes response\n\n    Args:\n        last_applied_manifest (dict): partial ``last_applied_manifest`` being\n            updated\n        observer_schema (dict): partial ``observer_schema``\n        response (dict): partial response from the Kubernetes API.\n\n    Raises:\n        KeyError: If the observed field is not present in the Kubernetes response\n\n    This function go through all observed fields, and initialized their value in\n    last_applied_manifest if they are not yet present\n\n    \"\"\"\n    for key, value in observer_schema.items():\n\n        # Keys in the response are in camelCase\n        camel_key = camel_to_snake_case(key)\n\n        if camel_key not in response:\n            # An observed key should always be present in the k8s response\n            raise KeyError(\n                f\"Observed key {camel_key} is not present in response {response}\"\n            )\n\n        if isinstance(value, dict):\n            if key not in last_applied_manifest:\n                # The dictionary is observed, but not present in\n                # last_applied_manifest\n                last_applied_manifest[key] = {}\n\n            update_last_applied_manifest_dict_from_resp(\n                last_applied_manifest[key], observer_schema[key], response[camel_key]\n            )\n\n        elif isinstance(value, list):\n            if key not in last_applied_manifest:\n                # The list is observed, but not present in last_applied_manifest\n                last_applied_manifest[key] = []\n\n            update_last_applied_manifest_list_from_resp(\n                last_applied_manifest[key], observer_schema[key], response[camel_key]\n            )\n\n        elif key not in last_applied_manifest:\n            # If key not present in last_applied_manifest, and value is neither a\n            # dict nor a list, simply add it.\n            last_applied_manifest[key] = response[camel_key]\n\n\ndef update_last_applied_manifest_list_from_resp(\n    last_applied_manifest, observer_schema, response\n):\n    \"\"\"Together with :func:``update_last_applied_manifest_dict_from_resp``, this\n    function is called recursively to update a partial ``last_applied_manifest``\n    from a partial Kubernetes response\n\n    Args:\n        last_applied_manifest (list): partial ``last_applied_manifest`` being\n            updated\n        observer_schema (list): partial ``observer_schema``\n        response (list): partial response from the Kubernetes API.\n\n    This function go through all observed fields, and initialized their value in\n    last_applied_manifest if they are not yet present\n\n    \"\"\"\n    # Looping over the observed resource, except the last element which is the\n    # special control dictionary\n    for idx, val in enumerate(observer_schema[:-1]):\n\n        if idx >= len(response):\n            # Element is observed but not present in k8s response, so following\n            # elements will also not exist.\n            #\n            # This doesn't raise an Exception as observing the element of a list\n            # doesn't ensure its presence. The list length is controlled by the\n            # special control dictionary\n            return\n\n        if isinstance(val, dict):\n            if idx >= len(last_applied_manifest):\n                # The dict is observed, but not present in last_applied_manifest\n                last_applied_manifest.append({})\n\n            update_last_applied_manifest_dict_from_resp(\n                last_applied_manifest[idx], observer_schema[idx], response[idx]\n            )\n\n        elif isinstance(response[idx], list):\n            if idx >= len(last_applied_manifest):\n                # The list is observed, but not present in last_applied_manifest\n                last_applied_manifest.append([])\n\n            update_last_applied_manifest_list_from_resp(\n                last_applied_manifest[idx], observer_schema[idx], response[idx]\n            )\n\n        elif idx >= len(last_applied_manifest):\n            # Element is not yet present in last_applied_manifest. Adding it.\n            last_applied_manifest.append(response[idx])\n\n\n@listen.on(HookType.ResourcePostCreate)\n@listen.on(HookType.ResourcePostUpdate)\ndef update_last_applied_manifest_from_resp(app, response, **kwargs):\n    \"\"\"Hook run after the creation or update of an application in order to update the\n    `status.last_applied_manifest` using the k8s response.\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        response (kubernetes_asyncio.client.V1Status): Response of the Kubernetes API\n\n    After a Kubernetes resource has been created/updated, the\n    `status.last_applied_manifest` has to be updated. All fields already initialized\n    (either from the mangling of `spec.manifest`, or by a previous call to this\n    function) should be left untouched. Only observed fields which are not present in\n    `status.last_applied_manifest` should be initialized.\n\n    \"\"\"\n\n    if isinstance(response, dict):\n        # The Kubernetes API couldn't deserialize the k8s response into an object\n        resp = response\n    else:\n        # The Kubernetes API deserialized the k8s response into an object\n        resp = response.to_dict()\n\n    idx_applied = get_kubernetes_resource_idx(app.status.last_applied_manifest, resp)\n\n    idx_observed = get_kubernetes_resource_idx(app.status.mangled_observer_schema, resp)\n\n    update_last_applied_manifest_dict_from_resp(\n        app.status.last_applied_manifest[idx_applied],\n        app.status.mangled_observer_schema[idx_observed],\n        resp,\n    )\n\n\n@listen.on(HookType.ResourcePostCreate)\n@listen.on(HookType.ResourcePostUpdate)\ndef update_last_observed_manifest_from_resp(app, response, **kwargs):\n    \"\"\"Handler to run after the creation or update of a Kubernetes resource to update\n    the last_observed_manifest from the response of the Kubernetes API.\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        response (kubernetes_asyncio.client.V1Service): Response of the\n            Kubernetes API\n\n    The target last_observed_manifest holds the value of all observed fields plus the\n    special control dictionaries for the list length\n\n    \"\"\"\n    if isinstance(response, dict):\n        # The Kubernetes API couldn't deserialize the k8s response into an object\n        resp = response\n    else:\n        # The Kubernetes API deserialized the k8s response into an object\n        resp = response.to_dict()\n\n    try:\n        idx_observed = get_kubernetes_resource_idx(\n            app.status.mangled_observer_schema,\n            resp,\n        )\n    except IndexError:\n        # All created resources should be observed\n        raise\n\n    try:\n        idx_last_observed = get_kubernetes_resource_idx(\n            app.status.last_observed_manifest,\n            resp,\n        )\n    except IndexError:\n        # If the resource is not yes present in last_observed_manifest, append it.\n        idx_last_observed = len(app.status.last_observed_manifest)\n        app.status.last_observed_manifest.append({})\n\n    # Overwrite the last_observed_manifest for this resource\n    app.status.last_observed_manifest[\n        idx_last_observed\n    ] = update_last_observed_manifest_dict(\n        app.status.mangled_observer_schema[idx_observed], resp\n    )\n\n\ndef update_last_observed_manifest_dict(observed_resource, response):\n    \"\"\"Together with :func:``update_last_observed_manifest_list``, recursively\n    crafts the ``last_observed_manifest`` from the Kubernetes :attr:``response``.\n\n    Args:\n        observed_resource (dict): The schema to observe for the partial given resource\n        response (dict): The partial Kubernetes response for this resource.\n\n    Raises:\n        KeyError: If an observed key is not present in the Kubernetes response\n\n    Returns:\n        dict: The dictionary of observed keys and their value\n\n    Get the value of all observed fields from the Kubernetes response\n    \"\"\"\n    res = {}\n    for key, value in observed_resource.items():\n\n        camel_key = camel_to_snake_case(key)\n        if camel_key not in response:\n            raise KeyError(\n                f\"Observed key {camel_key} is not present in response {response}\"\n            )\n\n        if isinstance(value, dict):\n            res[key] = update_last_observed_manifest_dict(value, response[camel_key])\n\n        elif isinstance(value, list):\n            res[key] = update_last_observed_manifest_list(value, response[camel_key])\n\n        else:\n            res[key] = response[camel_key]\n\n    return res\n\n\ndef update_last_observed_manifest_list(observed_resource, response):\n    \"\"\"Together with :func:``update_last_observed_manifest_dict``, recursively\n    crafts the ``last_observed_manifest`` from the Kubernetes :attr:``response``.\n\n    Args:\n        observed_resource (list): the schema to observe for the partial given resource\n        response (list): the partial Kubernetes response for this resource.\n\n    Returns:\n        list: The list of observed elements, plus the special list length control\n            dictionary\n\n    Get the value of all observed elements from the Kubernetes response\n    \"\"\"\n\n    if not response:\n        return [{\"observer_schema_list_current_length\": 0}]\n\n    res = []\n    # Looping over the observed resource, except the last element which is the special\n    # control dictionary\n    for idx, val in enumerate(observed_resource[:-1]):\n\n        if idx >= len(response):\n            # Element is not present in the Kubernetes response, nothing more to do\n            break\n\n        if type(response[idx]) == dict:\n            res.append(update_last_observed_manifest_dict(val, response[idx]))\n\n        elif type(response[idx]) == list:\n            res.append(update_last_observed_manifest_list(val, response[idx]))\n\n        else:\n            res.append(response[idx])\n\n    # Append the special control dictionary to the list\n    res.append({\"observer_schema_list_current_length\": len(response)})\n\n    return res\n\n\ndef update_last_applied_manifest_dict_from_spec(\n    resource_status_new, resource_status_old, resource_observed\n):\n    \"\"\"Together with :func:``update_last_applied_manifest_list_from_spec``, this\n    function is called recursively to update a partial ``last_applied_manifest``\n\n    Args:\n        resource_status_new (dict): partial ``last_applied_manifest`` being updated\n        resource_status_old (dict): partial of the current ``last_applied_manifest``\n        resource_observed (dict): partial observer_schema for the manifest file\n            being updated\n\n    \"\"\"\n    for key, value in resource_observed.items():\n\n        if key not in resource_status_old:\n            continue\n\n        if key in resource_status_new:\n\n            if isinstance(value, dict):\n                update_last_applied_manifest_dict_from_spec(\n                    resource_status_new[key],\n                    resource_status_old[key],\n                    resource_observed[key],\n                )\n\n            elif isinstance(value, list):\n                update_last_applied_manifest_list_from_spec(\n                    resource_status_new[key],\n                    resource_status_old[key],\n                    resource_observed[key],\n                )\n\n        else:\n            # If the key is not present the spec.manifest, we first need to\n            # initialize it\n\n            if isinstance(value, dict):\n                resource_status_new[key] = {}\n                update_last_applied_manifest_dict_from_spec(\n                    resource_status_new[key],\n                    resource_status_old[key],\n                    resource_observed[key],\n                )\n\n            elif isinstance(value, list):\n                resource_status_new[key] = []\n                update_last_applied_manifest_list_from_spec(\n                    resource_status_new[key],\n                    resource_status_old[key],\n                    resource_observed[key],\n                )\n\n            else:\n                resource_status_new[key] = resource_status_old[key]\n\n\ndef update_last_applied_manifest_list_from_spec(\n    resource_status_new, resource_status_old, resource_observed\n):\n    \"\"\"Together with :func:``update_last_applied_manifest_dict_from_spec``, this\n    function is called recursively to update a partial ``last_applied_manifest``\n\n    Args:\n        resource_status_new (list): partial ``last_applied_manifest`` being updated\n        resource_status_old (list): partial of the current ``last_applied_manifest``\n        resource_observed (list): partial observer_schema for the manifest file\n            being updated\n\n    \"\"\"\n\n    # Looping over the observed resource, except the last element which is the\n    # special control dictionary\n    for idx, val in enumerate(resource_observed[:-1]):\n\n        if idx >= len(resource_status_old):\n            # The element in not in the current last_applied_manifest, and neither\n            # is the rest of the list\n            break\n\n        if idx < len(resource_status_new):\n            # The element is present in spec.manifest and in the current\n            # last_applied_manifest. Updating observed fields\n\n            if isinstance(val, dict):\n                update_last_applied_manifest_dict_from_spec(\n                    resource_status_new[idx],\n                    resource_status_old[idx],\n                    resource_observed[idx],\n                )\n\n            elif isinstance(val, list):\n                update_last_applied_manifest_list_from_spec(\n                    resource_status_new[idx],\n                    resource_status_old[idx],\n                    resource_observed[idx],\n                )\n\n        else:\n            # If the element is not present in the spec.manifest, we first have to\n            # initialize it.\n\n            if isinstance(val, dict):\n                resource_status_new.append({})\n                update_last_applied_manifest_dict_from_spec(\n                    resource_status_new[idx],\n                    resource_status_old[idx],\n                    resource_observed[idx],\n                )\n\n            elif isinstance(val, list):\n                resource_status_new.append([])\n                update_last_applied_manifest_list_from_spec(\n                    resource_status_new[idx],\n                    resource_status_old[idx],\n                    resource_observed[idx],\n                )\n\n            else:\n                resource_status_new.append(resource_status_old[idx])\n\n\ndef update_last_applied_manifest_from_spec(app):\n    \"\"\"Update the status.last_applied_manifest of an application from spec.manifests\n\n    Args:\n        app (krake.data.kubernetes.Application): Application to update\n\n    This function is called on application creation and updates. The\n    last_applied_manifest of an application is initialized as a copy of spec.manifest,\n    and is augmented by all known observed fields not yet initialized (i.e. all observed\n    fields or resources which are present in the current last_applied_manifest but not\n    in the spec.manifest)\n\n    \"\"\"\n\n    # The new last_applied_manifest is initialized as a copy of the spec.manifest, and\n    # augmented by all observed fields which are present in the current\n    # last_applied_manifest but not in the original spec.manifest\n    new_last_applied_manifest = deepcopy(app.spec.manifest)\n\n    # Loop over observed resources and observed fields, and check if they should be\n    # added to the new last_applied_manifest (i.e. present in the current\n    # last_applied_manifest but not in spec.manifest)\n    for resource_observed in app.status.mangled_observer_schema:\n\n        # If the resource is not present in the current last_applied_manifest, there is\n        # nothing to do. Whether the resource was initialized by spec.manifest doesn't\n        # matter.\n        try:\n            idx_status_old = get_kubernetes_resource_idx(\n                app.status.last_applied_manifest, resource_observed\n            )\n        except IndexError:\n            continue\n\n        # As the resource is present in the current last_applied_manifest, we need to go\n        # through it to check if observed fields should be set to their current value\n        # (i.e. fields are present in the current last_applied_manifest, but not in\n        # spec.manifest)\n        try:\n            # Check if the observed resource is present in spec.manifest\n            idx_status_new = get_kubernetes_resource_idx(\n                new_last_applied_manifest, resource_observed\n            )\n        except IndexError:\n            # The resource is observed but is not present in the spec.manifest.\n            # Create an empty resource, which will be augmented in\n            # update_last_applied_manifest_dict_from_spec with the observed and known\n            # fields.\n            new_last_applied_manifest.append({})\n            idx_status_new = len(new_last_applied_manifest) - 1\n\n        update_last_applied_manifest_dict_from_spec(\n            new_last_applied_manifest[idx_status_new],\n            app.status.last_applied_manifest[idx_status_old],\n            resource_observed,\n        )\n\n    app.status.last_applied_manifest = new_last_applied_manifest\n\n\nclass KubernetesApplicationObserver(Observer):\n    \"\"\"Observer specific for Kubernetes Applications. One observer is created for each\n    Application managed by the Controller, but not one per Kubernetes resource\n    (Deployment, Service...). If several resources are defined by an Application, they\n    are all monitored by the same observer.\n\n    The observer gets the actual status of the resources on the cluster using the\n    Kubernetes API, and compare it to the status stored in the API.\n\n    The observer is:\n     * started at initial Krake resource creation;\n\n     * deleted when a resource needs to be updated, then started again when it is done;\n\n     * simply deleted on resource deletion.\n\n    Args:\n        cluster (krake.data.kubernetes.Cluster): the cluster on which the observed\n            Application is created.\n        resource (krake.data.kubernetes.Application): the application that will be\n            observed.\n        on_res_update (coroutine): a coroutine called when a resource's actual status\n            differs from the status sent by the database. Its signature is:\n            ``(resource) -> updated_resource``. ``updated_resource`` is the instance of\n            the resource that is up-to-date with the API. The Observer internal instance\n            of the resource to observe will be updated. If the API cannot be contacted,\n            ``None`` can be returned. In this case the internal instance of the Observer\n            will not be updated.\n        time_step (int, optional): how frequently the Observer should watch the actual\n            status of the resources.\n\n    \"\"\"\n\n    def __init__(self, cluster, resource, on_res_update, time_step=2):\n        super().__init__(resource, on_res_update, time_step)\n        self.cluster = cluster\n\n    async def poll_resource(self):\n        \"\"\"Fetch the current status of the Application monitored by the Observer.\n\n        Returns:\n            krake.data.core.Status: the status object created using information from the\n                real world Applications resource.\n\n        \"\"\"\n        app = self.resource\n\n        status = deepcopy(app.status)\n        status.last_observed_manifest = []\n        # For each observed kubernetes resource of the Application,\n        # get its current status on the cluster.\n        for desired_resource in app.status.last_applied_manifest:\n            kube = KubernetesClient(self.cluster.spec.kubeconfig)\n            idx_observed = get_kubernetes_resource_idx(\n                app.status.mangled_observer_schema, desired_resource\n            )\n            observed_resource = app.status.mangled_observer_schema[idx_observed]\n            async with kube:\n                try:\n                    group, version, kind, name, namespace = kube.get_immutables(\n                        desired_resource\n                    )\n                    resource_api = await kube.get_resource_api(group, version, kind)\n                    resp = await resource_api.read(kind, name, namespace)\n                except ApiException as err:\n                    if err.status == 404:\n                        # Resource does not exist\n                        continue\n                    # Otherwise, log the unexpected errors\n                    logger.error(err)\n\n            observed_manifest = update_last_observed_manifest_dict(\n                observed_resource, resp.to_dict()\n            )\n            status.last_observed_manifest.append(observed_manifest)\n\n        return status\n\n\nclass KubernetesClusterObserver(Observer):\n    \"\"\"Observer specific for Kubernetes Clusters. One observer is created for each\n    Cluster managed by the Controller.\n\n    The observer gets the actual status of the cluster using the\n    Kubernetes API, and compare it to the status stored in the API.\n\n    The observer is:\n     * started at initial Krake resource creation;\n\n     * deleted when a resource needs to be updated, then started again when it is done;\n\n     * simply deleted on resource deletion.\n\n    Args:\n        cluster (krake.data.kubernetes.Cluster): the cluster which will be observed.\n        on_res_update (coroutine): a coroutine called when a resource's actual status\n            differs from the status sent by the database. Its signature is:\n            ``(resource) -> updated_resource``. ``updated_resource`` is the instance of\n            the resource that is up-to-date with the API. The Observer internal instance\n            of the resource to observe will be updated. If the API cannot be contacted,\n            ``None`` can be returned. In this case the internal instance of the Observer\n            will not be updated.\n        time_step (int, optional): how frequently the Observer should watch the actual\n            status of the resources.\n\n    \"\"\"\n\n    def __init__(self, cluster, on_res_update, time_step=2):\n        super().__init__(cluster, on_res_update, time_step)\n        self.cluster = cluster\n\n    async def poll_resource(self):\n        \"\"\"Fetch the current status of the Cluster monitored by the Observer.\n\n        Returns:\n            krake.data.core.Status: the status object created using information from the\n                real world Cluster.\n\n        \"\"\"\n        status = deepcopy(self.cluster.status)\n        # For each observed kubernetes cluster registered in Krake,\n        # get its current node status.\n        loader = KubeConfigLoader(self.cluster.spec.kubeconfig)\n        config = Configuration()\n        await loader.load_and_set(config)\n        kube = ApiClient(config)\n\n        async with kube as api:\n            v1 = client.CoreV1Api(api)\n            try:\n                response = await v1.list_node()\n\n            except ClientConnectorError as err:\n                status.state = ClusterState.OFFLINE\n                self.cluster.status.state = ClusterState.OFFLINE\n                # Log the error\n                logger.debug(err)\n                return status\n\n            condition_dict = {\n                \"MemoryPressure\": [],\n                \"DiskPressure\": [],\n                \"PIDPressure\": [],\n                \"Ready\": [],\n            }\n\n            for item in response.items:\n                for condition in item.status.conditions:\n                    condition_dict[condition.type].append(condition.status)\n                if (\n                    condition_dict[\"MemoryPressure\"] == [\"True\"]\n                    or condition_dict[\"DiskPressure\"] == [\"True\"]\n                    or condition_dict[\"PIDPressure\"] == [\"True\"]\n                ):\n                    status.state = ClusterState.UNHEALTHY\n                    self.cluster.status.state = ClusterState.UNHEALTHY\n                    return status\n                elif (\n                    condition_dict[\"Ready\"] == [\"True\"]\n                    and status.state is ClusterState.OFFLINE\n                ):\n                    status.state = ClusterState.CONNECTING\n                    self.cluster.status.state = ClusterState.CONNECTING\n                    return status\n                elif condition_dict[\"Ready\"] == [\"True\"]:\n                    status.state = ClusterState.ONLINE\n                    self.cluster.status.state = ClusterState.ONLINE\n                    return status\n                else:\n                    status.state = ClusterState.NOTREADY\n                    self.cluster.status.state = ClusterState.NOTREADY\n                    return status\n\n\n@listen.on(HookType.ApplicationPostReconcile)\n@listen.on(HookType.ApplicationPostMigrate)\n@listen.on(HookType.ClusterCreation)\nasync def register_observer(controller, resource, start=True, **kwargs):\n    \"\"\"Create an observer for the given Application or Cluster, and start it as a\n    background task if wanted.\n\n    If an observer already existed for this Application or Cluster, it is stopped\n    and deleted.\n\n    Args:\n        controller (KubernetesController): the controller for which the observer will be\n            added in the list of working observers.\n        resource (krake.data.kubernetes.Application): the Application to observe or\n        resource (krake.data.kubernetes.Cluster): the Cluster to observe.\n        start (bool, optional): if False, does not start the observer as background\n            task.\n\n    \"\"\"\n    if resource.kind == Application.kind:\n        cluster = await controller.kubernetes_api.read_cluster(\n            namespace=resource.status.running_on.namespace,\n            name=resource.status.running_on.name,\n        )\n\n        observer = KubernetesApplicationObserver(\n            cluster,\n            resource,\n            controller.on_status_update,\n            time_step=controller.observer_time_step,\n        )\n\n    elif resource.kind == Cluster.kind:\n        observer = KubernetesClusterObserver(\n            resource,\n            controller.on_status_update,\n            time_step=controller.observer_time_step,\n        )\n    else:\n        logger.debug(\"Unknown resource kind. No observer was registered.\", resource)\n        return\n\n    logger.debug(f\"Start observer for {resource.kind} %r\", resource.metadata.name)\n    task = None\n    if start:\n        task = controller.loop.create_task(observer.run())\n\n    controller.observers[resource.metadata.uid] = (observer, task)\n\n\n@listen.on(HookType.ApplicationPreReconcile)\n@listen.on(HookType.ApplicationPreMigrate)\n@listen.on(HookType.ApplicationPreDelete)\n@listen.on(HookType.ClusterDeletion)\nasync def unregister_observer(controller, resource, **kwargs):\n    \"\"\"Stop and delete the observer for the given Application or Cluster. If no observer\n    is started, do nothing.\n\n    Args:\n        controller (KubernetesController): the controller for which the observer will be\n            removed from the list of working observers.\n        resource (krake.data.kubernetes.Application): the Application whose observer\n        will be stopped or\n        resource (krake.data.kubernetes.Cluster): the Cluster whose observer will be\n        stopped.\n\n    \"\"\"\n    if resource.metadata.uid not in controller.observers:\n        return\n\n    logger.debug(f\"Stop observer for {resource.kind} %r\", resource.metadata.name)\n    _, task = controller.observers.pop(resource.metadata.uid)\n    task.cancel()\n\n    with suppress(asyncio.CancelledError):\n        await task\n\n\ndef utc_difference():\n    \"\"\"Get the difference in seconds between the current time and the current UTC time.\n\n    Returns:\n        int: the time difference in seconds.\n\n    \"\"\"\n    delta = datetime.now() - datetime.utcnow()\n    return delta.seconds\n\n\ndef generate_certificate(config):\n    \"\"\"Create and sign a new certificate using the one defined in the complete hook\n    configuration as intermediate certificate.\n\n    Args:\n        config (krake.data.config.CompleteHookConfiguration): the configuration of the\n            complete hook.\n\n    Returns:\n        CertificatePair: the content of the certificate created and its corresponding\n            key.\n\n    \"\"\"\n    with open(config.intermediate_src, \"rb\") as f:\n        intermediate_src = crypto.load_certificate(crypto.FILETYPE_PEM, f.read())\n    with open(config.intermediate_key_src, \"rb\") as f:\n        intermediate_key_src = crypto.load_privatekey(crypto.FILETYPE_PEM, f.read())\n\n    client_cert = crypto.X509()\n\n    # Set general information\n    client_cert.set_version(3)\n    client_cert.set_serial_number(random.randint(50000000000000, 100000000000000))\n    # If not set before, TLS will not accept to use this certificate in UTC cases, as\n    # the server time may be earlier.\n    time_offset = utc_difference() * -1\n    client_cert.gmtime_adj_notBefore(time_offset)\n    client_cert.gmtime_adj_notAfter(1 * 365 * 24 * 60 * 60)\n\n    # Set issuer and subject\n    intermediate_subject = intermediate_src.get_subject()\n    client_cert.set_issuer(intermediate_subject)\n    client_subj = crypto.X509Name(intermediate_subject)\n    client_subj.CN = config.hook_user\n    client_cert.set_subject(client_subj)\n\n    # Create and set the private key\n    client_key = crypto.PKey()\n    client_key.generate_key(crypto.TYPE_RSA, 2048)\n    client_cert.set_pubkey(client_key)\n\n    client_cert.sign(intermediate_key_src, \"sha256\")\n\n    cert_dump = crypto.dump_certificate(crypto.FILETYPE_PEM, client_cert).decode()\n    key_dump = crypto.dump_privatekey(crypto.FILETYPE_PEM, client_key).decode()\n    return CertificatePair(cert=cert_dump, key=key_dump)\n\n\ndef generate_default_observer_schema(app):\n    \"\"\"Generate the default observer schema for each Kubernetes resource present in\n    ``spec.manifest`` for which a custom observer schema hasn't been specified.\n\n    Args:\n        app (krake.data.kubernetes.Application): The application for which to generate a\n            default observer schema\n    \"\"\"\n\n    app.status.mangled_observer_schema = deepcopy(app.spec.observer_schema)\n\n    for resource_manifest in app.spec.manifest:\n        try:\n            get_kubernetes_resource_idx(\n                app.status.mangled_observer_schema, resource_manifest\n            )\n\n        except IndexError:\n            # Only create a default observer schema, if a custom observer schema hasn't\n            # been set by the user.\n            app.status.mangled_observer_schema.append(\n                generate_default_observer_schema_dict(\n                    resource_manifest,\n                    first_level=True,\n                )\n            )\n\n", "contexts_below": "\n def generate_default_observer_schema_list(manifest_list):\n     \"\"\"Together with :func:``generate_default_observer_schema_dict``, this function is\n     called recursively to generate part of a default ``observer_schema`` from part of a\n     Kubernetes resource, defined respectively by ``manifest_list`` or ``manifest_dict``.\n \n     Args:\n         manifest_list (list): Partial Kubernetes resources\n \n     Returns:\n         list: Generated partial observer_schema\n \n     This function creates a new list from ``manifest_list`` and replaces all non-list\n     and non-dict elements by ``None``.\n \n     Additionally, it generates the default list control dictionary, using the current\n     length of the list as default minimum and maximum values.\n \n     \"\"\"\n     observer_schema_list = []\n \n     for value in manifest_list:\n \n         if isinstance(value, dict):\n             observer_schema_list.append(generate_default_observer_schema_dict(value))\n \n         elif isinstance(value, list):\n             observer_schema_list.append(generate_default_observer_schema_list(value))\n \n         else:\n             observer_schema_list.append(None)\n \n     observer_schema_list.append(\n         {\n             \"observer_schema_list_min_length\": len(manifest_list),\n             \"observer_schema_list_max_length\": len(manifest_list),\n         }\n     )\n \n     return observer_schema_list\n \n \n @listen.on(HookType.ApplicationMangling)\n async def complete(app, api_endpoint, ssl_context, config):\n     \"\"\"Execute application complete hook defined by :class:`Complete`.\n     Hook mangles given application and injects complete hooks variables.\n \n     Application complete hook is disabled by default.\n     User enables this hook by the --hook-complete argument in rok cli.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application object processed\n             when the hook is called\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         config (krake.data.config.HooksConfiguration): Complete hook\n             configuration.\n \n     \"\"\"\n     if \"complete\" not in app.spec.hooks:\n         return\n \n     # Use the endpoint of the API only if the external endpoint has not been set.\n     if config.complete.external_endpoint:\n         api_endpoint = config.complete.external_endpoint\n \n     app.status.complete_token = \\\n         app.status.complete_token if app.status.complete_token else token_urlsafe()\n \n     # Generate only once the certificate and key for a specific Application\n     generated_cert = CertificatePair(\n         cert=app.status.complete_cert, key=app.status.complete_key\n     )\n     if ssl_context and generated_cert == (None, None):\n         generated_cert = generate_certificate(config.complete)\n         app.status.complete_cert = generated_cert.cert\n         app.status.complete_key = generated_cert.key\n \n     hook = Complete(\n         api_endpoint,\n         ssl_context,\n         hook_user=config.complete.hook_user,\n         cert_dest=config.complete.cert_dest,\n         env_token=config.complete.env_token,\n         env_url=config.complete.env_url,\n     )\n     hook.mangle_app(\n         app.metadata.name,\n         app.metadata.namespace,\n         app.status.complete_token,\n         app.status.last_applied_manifest,\n         config.complete.intermediate_src,\n         generated_cert,\n         app.status.mangled_observer_schema,\n         \"complete\"\n     )\n \n \n @listen.on(HookType.ApplicationMangling)\n async def shutdown(app, api_endpoint, ssl_context, config):\n     \"\"\"Executes an application shutdown hook defined by :class:`Shutdown`.\n     The hook mangles the given application and injects shutdown hooks variables.\n \n     Application shutdown hook is disabled by default.\n     User enables this hook by the --hook-shutdown argument in rok cli.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application object processed\n             when the hook is called\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         config (krake.data.config.HooksConfiguration): Shutdown hook\n             configuration.\n \n     \"\"\"\n     if \"shutdown\" not in app.spec.hooks:\n         return\n \n     # Use the endpoint of the API only if the external endpoint has not been set.\n     if config.shutdown.external_endpoint:\n         api_endpoint = config.shutdown.external_endpoint\n \n     app.status.shutdown_token = \\\n         app.status.shutdown_token if app.status.shutdown_token else token_urlsafe()\n \n     # Generate only once the certificate and key for a specific Application\n     generated_cert = CertificatePair(\n         cert=app.status.shutdown_cert, key=app.status.shutdown_key\n     )\n     if ssl_context and generated_cert == (None, None):\n         generated_cert = generate_certificate(config.shutdown)\n         app.status.shutdown_cert = generated_cert.cert\n         app.status.shutdown_key = generated_cert.key\n \n     hook = Shutdown(\n         api_endpoint,\n         ssl_context,\n         hook_user=config.shutdown.hook_user,\n         cert_dest=config.shutdown.cert_dest,\n         env_token=config.shutdown.env_token,\n         env_url=config.shutdown.env_url,\n     )\n     hook.mangle_app(\n         app.metadata.name,\n         app.metadata.namespace,\n         app.status.shutdown_token,\n         app.status.last_applied_manifest,\n         config.shutdown.intermediate_src,\n         generated_cert,\n         app.status.mangled_observer_schema,\n         \"shutdown\"\n     )\n \n \n @listen.on(HookType.ResourcePreDelete)\n async def pre_shutdown(controller, app, **kwargs):\n     \"\"\"\n \n     Args:\n         app (krake.data.kubernetes.Application): Application object processed\n             when the hook is called\n     \"\"\"\n     if \"shutdown\" not in app.spec.hooks:\n         return\n \n     return\n \n \n class SubResource(NamedTuple):\n     group: str\n     name: str\n     body: dict\n     path: tuple\n \n \n class CertificatePair(NamedTuple):\n     \"\"\"Tuple which contains a certificate and its corresponding key.\n \n     Attributes:\n         cert (str): content of a certificate.\n         key (str): content of the key that corresponds to the certificate.\n \n     \"\"\"\n \n     cert: str\n     key: str\n \n \n class Hook(object):\n \n     hook_resources = ()\n \n     ca_name = \"ca-bundle.pem\"\n     cert_name = \"cert.pem\"\n     key_name = \"key.pem\"\n \n     def __init__(\n         self, api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n     ):\n         self.api_endpoint = api_endpoint\n         self.ssl_context = ssl_context\n         self.hook_user = hook_user\n         self.cert_dest = cert_dest\n         self.env_token = env_token\n         self.env_url = env_url\n \n     def mangle_app(\n         self,\n         name,\n         namespace,\n         token,\n         last_applied_manifest,\n         intermediate_src,\n         generated_cert,\n         mangled_observer_schema,\n         hook_type=\"\",\n     ):\n         \"\"\"Mangle a given application and inject complete hook resources and\n         sub-resources into the :attr:`last_applied_manifest` object by :meth:`mangle`.\n         Also mangle the observer_schema as new resources and sub-resources should\n         be observed.\n \n         :attr:`last_applied_manifest` is created as a deep copy of the desired\n         application resources, as defined by user. It can be updated by custom hook\n         resources or modified by custom hook sub-resources. It is used as a desired\n         state for the Krake deployment process.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             token (str): Complete hook authentication token\n             last_applied_manifest (list): Application resources\n             intermediate_src (str): content of the certificate that is used to sign new\n                 certificates for the complete hook.\n             generated_cert (CertificatePair): tuple that contains the content of the\n                 new signed certificate for the Application, and the content of its\n                 corresponding key.\n             mangled_observer_schema (list): Observed fields\n             hook_type (str, optional): Name of the hook the app should be mangled for\n \n         \"\"\"\n \n         secret_certs_name = \"-\".join([name, \"krake\", hook_type, \"secret\", \"certs\"])\n         secret_token_name = \"-\".join([name, \"krake\", hook_type, \"secret\", \"token\"])\n         volume_name = \"-\".join([name, \"krake\", hook_type, \"volume\"])\n         ca_certs = (\n             self.ssl_context.get_ca_certs(binary_form=True)\n             if self.ssl_context\n             else None\n         )\n \n         # Extract all different namespaces\n         # FIXME: too many assumptions here: do we create one ConfigMap for each\n         #  namespace?\n         resource_namespaces = {\n             resource[\"metadata\"].get(\"namespace\", \"default\")\n             for resource in last_applied_manifest\n         }\n \n         hook_resources = []\n         hook_sub_resources = []\n         if ca_certs:\n             hook_resources.extend(\n                 [\n                     self.secret_certs(\n                         secret_certs_name,\n                         resource_namespace,\n                         intermediate_src=intermediate_src,\n                         generated_cert=generated_cert,\n                         ca_certs=ca_certs,\n                     )\n                     for resource_namespace in resource_namespaces\n                 ]\n             )\n             hook_sub_resources.extend(\n                 [*self.volumes(secret_certs_name, volume_name, self.cert_dest)]\n             )\n \n         hook_resources.extend(\n             [\n                 self.secret_token(\n                     secret_token_name,\n                     name,\n                     namespace,\n                     resource_namespace,\n                     self.api_endpoint,\n                     token,\n                 )\n                 for resource_namespace in resource_namespaces\n             ]\n         )\n         hook_sub_resources.extend(\n             [\n                 *self.env_vars(secret_token_name),\n             ]\n         )\n \n         self.mangle(\n             hook_resources,\n             last_applied_manifest,\n             mangled_observer_schema,\n         )\n         self.mangle(\n             hook_sub_resources,\n             last_applied_manifest,\n             mangled_observer_schema,\n             is_sub_resource=True,\n         )\n \n     def mangle(\n         self,\n         items,\n         last_applied_manifest,\n         mangled_observer_schema,\n         is_sub_resource=False,\n     ):\n         \"\"\"Mangle applications desired state with custom hook resources or\n         sub-resources.\n \n         Example:\n             .. code:: python\n \n             last_applied_manifest = [\n                 {\n                     'apiVersion': 'v1',\n                     'kind': 'Pod',\n                     'metadata': {'name': 'test', 'namespace': 'default'},\n                     'spec': {'containers': [{'name': 'test'}]}\n                 }\n             ]\n             mangled_observer_schema = [\n                 {\n                     'apiVersion': 'v1',\n                     'kind': 'Pod',\n                     'metadata': {'name': 'test', 'namespace': 'default'},\n                     'spec': {\n                         'containers': [\n                             {'name': None},\n                             {\n                                 'observer_schema_list_max_length': 1,\n                                 'observer_schema_list_min_length': 1,\n                             },\n                         ]\n                     },\n                 }\n             ]\n             hook_resources = [\n                 {\n                     'apiVersion': 'v1',\n                     'kind': 'Secret',\n                     'metadata': {'name': 'sct', 'namespace': 'default'}\n                 }\n             ]\n             hook_sub_resources = [\n                 SubResource(\n                     group='env', name='env', body={'name': 'test', 'value': 'test'},\n                     path=(('spec', 'containers'),)\n                 )\n             ]\n \n             mangle(\n                 hook_resources,\n                 last_applied_manifest,\n                 mangled_observer_schema,\n             )\n             mangle(\n                 hook_sub_resources,\n                 last_applied_manifest,\n                 mangled_observer_schema,\n                 is_sub_resource=True\n             )\n \n             assert last_applied_manifest == [\n                 {\n                     \"apiVersion\": \"v1\",\n                     \"kind\": \"Pod\",\n                     \"metadata\": {\"name\": \"test\", 'namespace': 'default'},\n                     \"spec\": {\n                         \"containers\": [\n                             {\n                                 \"name\": \"test\",\n                                 \"env\": [{\"name\": \"test\", \"value\": \"test\"}]\n                             }\n                         ]\n                     },\n                 },\n                 {\"apiVersion\": \"v1\", \"kind\": \"Secret\", \"metadata\": {\"name\": \"sct\"}},\n             ]\n \n             assert mangled_observer_schema == [\n                 {\n                     \"apiVersion\": \"v1\",\n                     \"kind\": \"Pod\",\n                     \"metadata\": {\"name\": \"test\", \"namespace\": None},\n                     \"spec\": {\n                         \"containers\": [\n                             {\n                                 \"name\": None,\n                                 \"env\": [\n                                     {\"name\": None, \"value\": None},\n                                     {\n                                         \"observer_schema_list_max_length\": 1,\n                                         \"observer_schema_list_min_length\": 1,\n                                     },\n                                 ],\n                             },\n                             {\n                                 \"observer_schema_list_max_length\": 1,\n                                 \"observer_schema_list_min_length\": 1,\n                             },\n                         ]\n                     },\n                 },\n                 {\n                     \"apiVersion\": \"v1\",\n                     \"kind\": \"Secret\",\n                     \"metadata\": {\"name\": \"sct\", \"namespace\": None},\n                 },\n             ]\n \n         Args:\n             items (list[SubResource]): Custom hook resources or sub-resources\n             last_applied_manifest (list): Application resources\n             mangled_observer_schema (list): Observed resources\n             is_sub_resource (bool, optional): if False, the function only extend the\n                 list of Kubernetes resources defined in :attr:`last_applied_manifest`\n                 with new hook resources. Otherwise, the function injects each new hook\n                 sub-resource into the :attr:`last_applied_manifest` object\n                 sub-resources. Defaults to False.\n \n         \"\"\"\n \n         if not items:\n             return\n \n         if not is_sub_resource:\n             last_applied_manifest.extend(items)\n             for sub_resource in items:\n                 # Generate the default observer schema for each resource\n                 mangled_observer_schema.append(\n                     generate_default_observer_schema_dict(\n                         sub_resource,\n                         first_level=True,\n                     )\n                 )\n             return\n \n         def inject(sub_resource, sub_resource_to_mangle, observed_resource_to_mangle):\n             \"\"\"Inject a hooks defined sub-resource into a Kubernetes sub-resource.\n \n             Args:\n                 sub_resource (SubResource): Hook sub-resource that needs to be injected\n                     into :attr:`last_applied_manifest`\n                 sub_resource_to_mangle (object): Kubernetes sub-resources from\n                     :attr:`last_applied_manifest` which need to be processed\n                 observed_resource_to_mangle (dict): partial mangled_observer_schema\n                     corresponding to the Kubernetes sub-resource.\n \n             Raises:\n                 InvalidManifestError: if the sub-resource which will be mangled is not a\n                     list or a dict.\n \n             \"\"\"\n \n             # Create sub-resource group if not present in the Kubernetes sub-resource\n             if sub_resource.group not in sub_resource_to_mangle:\n                 # FIXME: This assumes the subresource group contains a list\n                 sub_resource_to_mangle.update({sub_resource.group: []})\n \n             # Create sub-resource group if not present in the observed fields\n             if sub_resource.group not in observed_resource_to_mangle:\n                 observed_resource_to_mangle.update(\n                     {\n                         sub_resource.group: [\n                             {\n                                 \"observer_schema_list_min_length\": 0,\n                                 \"observer_schema_list_max_length\": 0,\n                             }\n                         ]\n                     }\n                 )\n \n             # Inject sub-resource\n             # If sub-resource name is already there update it, if not, append it\n             if sub_resource.name in [\n                 g[\"name\"] for g in sub_resource_to_mangle[sub_resource.group]\n             ]:\n                 # FIXME: Assuming we are dealing with a list\n                 for idx, item in enumerate(sub_resource_to_mangle[sub_resource.group]):\n                     if item[\"name\"]:\n                         if hasattr(item, \"body\"):\n                             sub_resource_to_mangle[item.group][idx] = item[\"body\"]\n             else:\n                 sub_resource_to_mangle[sub_resource.group].append(sub_resource.body)\n \n             # Make sure the value is observed\n             if sub_resource.name not in [\n                 g[\"name\"] for g in observed_resource_to_mangle[sub_resource.group][:-1]\n             ]:\n                 observed_resource_to_mangle[sub_resource.group].insert(\n                     -1, generate_default_observer_schema_dict(sub_resource.body)\n                 )\n                 observed_resource_to_mangle[sub_resource.group][-1][\n                     \"observer_schema_list_min_length\"\n                 ] += 1\n                 observed_resource_to_mangle[sub_resource.group][-1][\n                     \"observer_schema_list_max_length\"\n                 ] += 1\n \n         for resource in last_applied_manifest:\n             # Complete hook is applied only on defined Kubernetes resources\n             if resource[\"kind\"] not in self.hook_resources:\n                 continue\n \n             for sub_resource in items:\n                 sub_resources_to_mangle = None\n                 idx_observed = get_kubernetes_resource_idx(\n                     mangled_observer_schema, resource\n                 )\n                 for keys in sub_resource.path:\n                     try:\n                         sub_resources_to_mangle = reduce(getitem, keys, resource)\n                     except KeyError:\n                         continue\n \n                     break\n \n                 # Create the path to the observed sub-resource, if it doesn't yet exist\n                 try:\n                     observed_sub_resources = reduce(\n                         getitem, keys, mangled_observer_schema[idx_observed]\n                     )\n                 except KeyError:\n                     Complete.create_path(\n                         mangled_observer_schema[idx_observed], list(keys)\n                     )\n                     observed_sub_resources = reduce(\n                         getitem, keys, mangled_observer_schema[idx_observed]\n                     )\n \n                 if isinstance(sub_resources_to_mangle, list):\n                     for idx, sub_resource_to_mangle in enumerate(\n                         sub_resources_to_mangle\n                     ):\n \n                         # Ensure that each element of the list is observed.\n                         idx_observed = idx\n                         if idx >= len(observed_sub_resources[:-1]):\n                             idx_observed = len(observed_sub_resources[:-1])\n                             # FIXME: Assuming each element of the list contains a\n                             # dictionary, therefore initializing new elements with an\n                             # empty dict\n                             observed_sub_resources.insert(-1, {})\n                         observed_sub_resource = observed_sub_resources[idx_observed]\n \n                         # FIXME: This is assuming a list always contains dict\n                         inject(\n                             sub_resource, sub_resource_to_mangle, observed_sub_resource\n                         )\n \n                 elif isinstance(sub_resources_to_mangle, dict):\n                     inject(\n                         sub_resource, sub_resources_to_mangle, observed_sub_resources\n                     )\n \n                 else:\n                     message = (\n                         f\"The sub-resource to mangle {sub_resources_to_mangle!r} has an\"\n                         \"invalid type, should be in '[dict, list]'\"\n                     )\n                     raise InvalidManifestError(message)\n \n     @staticmethod\n     def attribute_map(obj):\n         \"\"\"Convert a Kubernetes object to dict based on its attribute mapping\n \n         Example:\n             .. code:: python\n \n             from kubernetes_asyncio.client import V1VolumeMount\n \n             d = attribute_map(\n                     V1VolumeMount(name=\"name\", mount_path=\"path\")\n             )\n             assert d == {'mountPath': 'path', 'name': 'name'}\n \n         Args:\n             obj (object): Kubernetes object\n \n         Returns:\n             dict: Converted Kubernetes object\n \n         \"\"\"\n         return {\n             obj.attribute_map[attr]: getattr(obj, attr)\n             for attr, _ in obj.to_dict().items()\n             if getattr(obj, attr) is not None\n         }\n \n     @staticmethod\n     def create_path(mangled_observer_schema, keys):\n         \"\"\"Create the path to the observed field in the observer schema.\n \n         When a sub-resource is mangled, it should be observed. This function creates\n         the path to the subresource to observe.\n \n         Args:\n             mangled_observer_schema (dict): Partial observer schema of a resource\n             keys (list): list of keys forming the path to the sub-resource to\n                 observe\n \n         FIXME: This assumes we are only adding keys to dict. We don't consider lists\n \n         \"\"\"\n \n         # Unpack the first key first, as it contains the base directory\n         key = keys.pop(0)\n \n         # If the key is the last of the list, we reached the end of the path.\n         if len(keys) == 0:\n             mangled_observer_schema[key] = None\n             return\n \n         if key not in mangled_observer_schema:\n             mangled_observer_schema[key] = {}\n         Hook.create_path(mangled_observer_schema[key], keys)\n \n     def secret_certs(\n         self,\n         secret_name,\n         namespace,\n         ca_certs=None,\n         intermediate_src=None,\n         generated_cert=None,\n     ):\n         \"\"\"Create a complete hooks secret resource.\n \n         Complete hook secret stores Krake CAs and client certificates to communicate\n         with the Krake API.\n \n         Args:\n             secret_name (str): Secret name\n             namespace (str): Kubernetes namespace where the Secret will be created.\n             ca_certs (list): Krake CA list\n             intermediate_src (str): content of the certificate that is used to sign new\n                 certificates for the complete hook.\n             generated_cert (CertificatePair): tuple that contains the content of the\n                 new signed certificate for the Application, and the content of its\n                 corresponding key.\n \n         Returns:\n             dict: complete hook secret resource\n \n         \"\"\"\n         ca_certs_pem = \"\"\n         for ca_cert in ca_certs:\n             x509 = crypto.load_certificate(crypto.FILETYPE_ASN1, ca_cert)\n             ca_certs_pem += crypto.dump_certificate(crypto.FILETYPE_PEM, x509).decode()\n \n         # Add the intermediate certificate into the chain\n         with open(intermediate_src, \"r\") as f:\n             intermediate_src_content = f.read()\n         ca_certs_pem += intermediate_src_content\n \n         data = {\n             self.ca_name: self._encode_to_64(ca_certs_pem),\n             self.cert_name: self._encode_to_64(generated_cert.cert),\n             self.key_name: self._encode_to_64(generated_cert.key),\n         }\n         return self.secret(secret_name, data, namespace)\n \n     def secret_token(\n         self, secret_name, name, namespace, resource_namespace, api_endpoint, token\n     ):\n         \"\"\"Create a hooks secret resource.\n \n         The hook secret stores Krake authentication token\n         and hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n             name (str): Application name\n             namespace (str): Application namespace\n             resource_namespace (str): Kubernetes namespace where the\n                 Secret will be created.\n             api_endpoint (str): Krake API endpoint\n             token (str): Complete hook authentication token\n \n         Returns:\n             dict: complete hook secret resource\n \n         \"\"\"\n         pass\n \n     def volumes(self, secret_name, volume_name, mount_path):\n         \"\"\"Create complete hooks volume and volume mount sub-resources\n \n         Complete hook volume gives access to hook's secret, which stores\n         Krake CAs and client certificates to communicate with the Krake API.\n         Complete hook volume mount puts the volume into the application\n \n         Args:\n             secret_name (str): Secret name\n             volume_name (str): Volume name\n             mount_path (list): Volume mount path\n \n         Returns:\n             list: List of complete hook volume and volume mount sub-resources\n \n         \"\"\"\n         volume = V1Volume(name=volume_name, secret={\"secretName\": secret_name})\n         volume_mount = V1VolumeMount(name=volume_name, mount_path=mount_path)\n         return [\n             SubResource(\n                 group=\"volumes\",\n                 name=volume.name,\n                 body=self.attribute_map(volume),\n                 path=((\"spec\", \"template\", \"spec\"), (\"spec\",)),\n             ),\n             SubResource(\n                 group=\"volumeMounts\",\n                 name=volume_mount.name,\n                 body=self.attribute_map(volume_mount),\n                 path=(\n                     (\"spec\", \"template\", \"spec\", \"containers\"),\n                     (\"spec\", \"containers\"),  # kind: Pod\n                 ),\n             ),\n         ]\n \n     @staticmethod\n     def _encode_to_64(string):\n         \"\"\"Compute the base 64 encoding of a string.\n \n         Args:\n             string (str): the string to encode.\n \n         Returns:\n             str: the result of the encoding.\n \n         \"\"\"\n         return b64encode(string.encode()).decode()\n \n     def secret(self, secret_name, secret_data, namespace, _type=\"Opaque\"):\n         \"\"\"Create a secret resource.\n \n         Args:\n             secret_name (str): Secret name\n             secret_data (dict): Secret data\n             namespace (str): Kubernetes namespace where the Secret will be created.\n             _type (str, optional): Secret type. Defaults to Opaque.\n \n         Returns:\n             dict: secret resource\n \n         \"\"\"\n         return self.attribute_map(\n             V1Secret(\n                 api_version=\"v1\",\n                 kind=\"Secret\",\n                 data=secret_data,\n                 metadata={\"name\": secret_name, \"namespace\": namespace},\n                 type=_type,\n             )\n         )\n \n     @staticmethod\n     def create_hook_url(name, namespace, api_endpoint):\n         \"\"\"Create an applications' hook URL.\n         Function needs to be specified for each hook.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             api_endpoint (str): Krake API endpoint\n \n         Returns:\n             str: Application shutdown url\n \n         \"\"\"\n         pass\n \n     def env_vars(self, secret_name):\n         \"\"\"Create the hooks' environment variables sub-resources.\n         Function needs to be specified for each hook.\n \n         Creates hook environment variables to store Krake authentication token\n         and a hook URL for the given applications.\n \n         Args:\n             secret_name (str): Secret name\n \n         Returns:\n             list: List of shutdown hook environment variables sub-resources\n \n         \"\"\"\n         pass\n \n \n class Complete(Hook):\n     \"\"\"Mangle given application and inject complete hooks variables into it.\n \n     Hook injects a Kubernetes secret, which stores Krake authentication token\n     and the Krake complete hook URL for the given application. The variables\n     from Kubernetes secret are imported as environment variables\n     into the application resource definition. Only resources defined in\n     :args:`hook_resources` can be modified.\n \n     Names of environment variables are defined in the application controller\n     configuration file.\n \n     If TLS is enabled on the Krake API, the complete hook injects a Kubernetes secret,\n     and it's corresponding volume and volume mount definitions for the Krake CA,\n     the client certificate with the right CN, and its key. The directory where the\n     secret is mounted is defined in the configuration.\n \n     Args:\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         cert_dest (str, optional): Path of the directory where the CA, client\n             certificate and key to the Krake API will be stored.\n         env_token (str, optional): Name of the environment variable, which stores Krake\n             authentication token.\n         env_url (str, optional): Name of the environment variable,\n             which stores Krake complete hook URL.\n \n     \"\"\"\n \n     hook_resources = (\"Pod\", \"Deployment\", \"ReplicationController\")\n \n     def __init__(\n         self, api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n     ):\n         super().__init__(\n             api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n         )\n         self.env_url = env_url\n \n     def secret_token(\n         self, secret_name, name, namespace, resource_namespace, api_endpoint, token\n     ):\n         \"\"\"Create complete hooks secret resource.\n \n         Complete hook secret stores Krake authentication token\n         and complete hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n             name (str): Application name\n             namespace (str): Application namespace\n             resource_namespace (str): Kubernetes namespace where the\n                 Secret will be created.\n             api_endpoint (str): Krake API endpoint\n             token (str): Complete hook authentication token\n \n         Returns:\n             dict: complete hook secret resource\n \n         \"\"\"\n         complete_url = self.create_hook_url(name, namespace, api_endpoint)\n         data = {\n             self.env_token.lower(): self._encode_to_64(token),\n             self.env_url.lower(): self._encode_to_64(complete_url),\n         }\n         return self.secret(secret_name, data, resource_namespace)\n \n     @staticmethod\n     def create_hook_url(name, namespace, api_endpoint):\n         \"\"\"Create an applications' complete URL.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             api_endpoint (str): Krake API endpoint\n \n         Returns:\n             str: Application complete url\n \n         \"\"\"\n         api_url = URL(api_endpoint)\n         return str(\n             api_url.with_path(\n                 f\"/kubernetes/namespaces/{namespace}/applications/{name}/complete\"\n             )\n         )\n \n     def env_vars(self, secret_name):\n         \"\"\"Create complete hooks environment variables sub-resources\n \n         Create complete hook environment variables store Krake authentication token\n         and complete hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n \n         Returns:\n             list: List of complete hook environment variables sub-resources\n \n         \"\"\"\n         sub_resources = []\n \n         env_token = V1EnvVar(\n             name=self.env_token,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(\n                             name=secret_name, key=self.env_token.lower()\n                         )\n                     )\n                 )\n             ),\n         )\n         env_url = V1EnvVar(\n             name=self.env_url,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(name=secret_name, key=self.env_url.lower())\n                     )\n                 )\n             ),\n         )\n \n         for env in (env_token, env_url):\n             sub_resources.append(\n                 SubResource(\n                     group=\"env\",\n                     name=env.name,\n                     body=self.attribute_map(env),\n                     path=(\n                         (\"spec\", \"template\", \"spec\", \"containers\"),\n                         (\"spec\", \"containers\"),  # kind: Pod\n                     ),\n                 )\n             )\n         return sub_resources\n \n \n class Shutdown(Hook):\n     \"\"\"Mangle given application and inject shutdown hooks variables into it.\n \n     Hook injects a Kubernetes secret, which stores Krake authentication token\n     and the Krake complete hook URL for the given application. The variables\n     from the Kubernetes secret are imported as environment variables\n     into the application resource definition. Only resources defined in\n     :args:`hook_resources` can be modified.\n \n     Names of environment variables are defined in the application controller\n     configuration file.\n \n     If TLS is enabled on the Krake API, the shutdown hook injects a Kubernetes secret,\n     and it's corresponding volume and volume mount definitions for the Krake CA,\n     the client certificate with the right CN, and its key. The directory where the\n     secret is mounted is defined in the configuration.\n \n     Args:\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         cert_dest (str, optional): Path of the directory where the CA, client\n             certificate and key to the Krake API will be stored.\n         env_token (str, optional): Name of the environment variable, which stores Krake\n             authentication token.\n         env_url (str, optional): Name of the environment variable,\n             which stores Krake complete hook URL.\n \n     \"\"\"\n \n     hook_resources = (\"Pod\", \"Deployment\", \"ReplicationController\")\n \n     def __init__(\n         self, api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n     ):\n         super().__init__(\n             api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n         )\n         self.env_url = env_url\n \n     def secret_token(\n         self, secret_name, name, namespace, resource_namespace, api_endpoint, token\n     ):\n         \"\"\"Create shutdown hooks secret resource.\n \n         Shutdown hook secret stores Krake authentication token\n         and shutdown hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n             name (str): Application name\n             namespace (str): Application namespace\n             resource_namespace (str): Kubernetes namespace where the\n                 Secret will be created.\n             api_endpoint (str): Krake API endpoint\n             token (str): Shutdown hook authentication token\n \n         Returns:\n             dict: shutdown hook secret resource\n \n         \"\"\"\n         shutdown_url = self.create_hook_url(name, namespace, api_endpoint)\n         data = {\n             self.env_token.lower(): self._encode_to_64(token),\n             self.env_url.lower(): self._encode_to_64(shutdown_url),\n         }\n         return self.secret(secret_name, data, resource_namespace)\n \n     @staticmethod\n     def create_hook_url(name, namespace, api_endpoint):\n         \"\"\"Create an applications' shutdown URL.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             api_endpoint (str): Krake API endpoint\n \n         Returns:\n             str: Application shutdown url\n \n         \"\"\"\n         api_url = URL(api_endpoint)\n         return str(\n             api_url.with_path(\n                 f\"/kubernetes/namespaces/{namespace}/applications/{name}/shutdown\"\n             )\n         )\n \n     def env_vars(self, secret_name):\n         \"\"\"Create shutdown hooks environment variables sub-resources.\n \n         Creates shutdown hook environment variables to store Krake authentication token\n         and a shutdown hook URL for given applications.\n \n         Args:\n             secret_name (str): Secret name\n \n         Returns:\n             list: List of shutdown hook environment variables sub-resources\n \n         \"\"\"\n         sub_resources = []\n \n         env_resources = []\n \n         env_token = V1EnvVar(\n             name=self.env_token,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(\n                             name=secret_name,\n                             key=self.env_token.lower()\n                         )\n                     )\n                 )\n             )\n         )\n         env_resources.append(env_token)\n \n         env_url = V1EnvVar(\n             name=self.env_url,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(name=secret_name, key=self.env_url.lower())\n                     )\n                 )\n             ),\n         )\n         env_resources.append(env_url)\n \n         for env in env_resources:\n             sub_resources.append(\n                 SubResource(\n                     group=\"env\",\n                     name=env.name,\n                     body=self.attribute_map(env),\n                     path=(\n                         (\"spec\", \"template\", \"spec\", \"containers\"),\n                         (\"spec\", \"containers\"),  # kind: Pod\n                     ),\n                 )\n             )\n         return sub_resources\n ", "input_code": "def generate_default_observer_schema_dict(manifest_dict, first_level=False):\n\"\"\"\nTogether with :func:``generate_default_observer_schema_list``, this function is\ncalled recursively to generate part of a default ``observer_schema`` from part of a\nKubernetes resource, defined respectively by ``manifest_dict`` or ``manifest_list``.\n\nArgs:\n    manifest_dict (dict): Partial Kubernetes resources\n    first_level (bool, optional): If True, indicates that the dictionary represents\n        the whole observer schema of a Kubernetes resource\n\nReturns:\n    dict: Generated partial observer_schema\n\nThis function creates a new dictionary from ``manifest_dict`` and replaces all\nnon-list and non-dict values by ``None``.\n\nIn case of ``first_level`` dictionary (i.e. complete ``observer_schema`` for a\nresource), the values of the identifying fields are copied from the manifest file.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def generate_default_observer_schema_dict(manifest_dict, first_level=False):\n    \"\"\"Together with :func:``generate_default_observer_schema_list``, this function is\n    called recursively to generate part of a default ``observer_schema`` from part of a\n    Kubernetes resource, defined respectively by ``manifest_dict`` or ``manifest_list``.\n\n    Args:\n        manifest_dict (dict): Partial Kubernetes resources\n        first_level (bool, optional): If True, indicates that the dictionary represents\n            the whole observer schema of a Kubernetes resource\n\n    Returns:\n        dict: Generated partial observer_schema\n\n    This function creates a new dictionary from ``manifest_dict`` and replaces all\n    non-list and non-dict values by ``None``.\n\n    In case of ``first_level`` dictionary (i.e. complete ``observer_schema`` for a\n    resource), the values of the identifying fields are copied from the manifest file.\n\n    \"\"\"\n    observer_schema_dict = {}\n\n    for key, value in manifest_dict.items():\n\n        if isinstance(value, dict):\n            observer_schema_dict[key] = generate_default_observer_schema_dict(value)\n\n        elif isinstance(value, list):\n            observer_schema_dict[key] = generate_default_observer_schema_list(value)\n\n        else:\n            observer_schema_dict[key] = None\n\n    if first_level:\n        observer_schema_dict[\"apiVersion\"] = manifest_dict[\"apiVersion\"]\n        observer_schema_dict[\"kind\"] = manifest_dict[\"kind\"]\n        observer_schema_dict[\"metadata\"][\"name\"] = manifest_dict[\"metadata\"][\"name\"]\n\n        if (\n            \"spec\" in manifest_dict\n            and \"type\" in manifest_dict[\"spec\"]\n            and manifest_dict[\"spec\"][\"type\"] == \"LoadBalancer\"\n        ):\n            observer_schema_dict[\"status\"] = {\"load_balancer\": {\"ingress\": None}}\n\n    return observer_schema_dict", "signature": "def generate_default_observer_schema_dict(manifest_dict, first_level=False):", "completion_path": "krake/krake/controller/kubernetes/hooks.py"}
{"ce_id": "62b869ebb4d922cb0e688cc6", "namespace": "62b869ebb4d922cb0e688cc6", "namespace_real": "krake.krake.controller.kubernetes.hooks.update_last_applied_manifest_list_from_resp", "real_proj_path": "rak-n-rok---Krake/", "type": "function", "class_name": null, "function_name": "update_last_applied_manifest_list_from_resp", "contexts_above": "\"\"\"This module defines the Hook Dispatcher and listeners for registering and\nexecuting hooks. Hook Dispatcher emits hooks based on :class:`Hook` attributes which\ndefine when the hook will be executed.\n\n\"\"\"\nimport asyncio\nimport logging\nimport random\nfrom base64 import b64encode\nfrom collections import defaultdict\nfrom contextlib import suppress\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom functools import reduce\nfrom operator import getitem\nfrom enum import Enum, auto\nfrom inspect import iscoroutinefunction\nfrom OpenSSL import crypto\nfrom typing import NamedTuple\n\nimport yarl\nfrom aiohttp import ClientConnectorError\n\nfrom krake.controller import Observer\nfrom krake.controller.kubernetes.client import KubernetesClient, InvalidManifestError\nfrom krake.utils import camel_to_snake_case, get_kubernetes_resource_idx\nfrom kubernetes_asyncio.client.rest import ApiException\nfrom kubernetes_asyncio.client.api_client import ApiClient\nfrom kubernetes_asyncio import client\nfrom krake.data.kubernetes import ClusterState, Application, Cluster\nfrom yarl import URL\nfrom secrets import token_urlsafe\n\nfrom kubernetes_asyncio.client import (\n    Configuration,\n    V1Secret,\n    V1EnvVar,\n    V1VolumeMount,\n    V1Volume,\n    V1SecretKeySelector,\n    V1EnvVarSource,\n)\nfrom kubernetes_asyncio.config.kube_config import KubeConfigLoader\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass HookType(Enum):\n    ResourcePreCreate = auto()\n    ResourcePostCreate = auto()\n    ResourcePreUpdate = auto()\n    ResourcePostUpdate = auto()\n    ResourcePreDelete = auto()\n    ResourcePostDelete = auto()\n    ApplicationMangling = auto()\n    ApplicationPreMigrate = auto()\n    ApplicationPostMigrate = auto()\n    ApplicationPreReconcile = auto()\n    ApplicationPostReconcile = auto()\n    ApplicationPreDelete = auto()\n    ApplicationPostDelete = auto()\n    ClusterCreation = auto()\n    ClusterDeletion = auto()\n\n\nclass HookDispatcher(object):\n    \"\"\"Simple wrapper around a registry of handlers associated to :class:`Hook`\n     attributes. Each :class:`Hook` attribute defines when the handler will be\n     executed.\n\n    Listeners for certain hooks can be registered via :meth:`on`. Registered\n    listeners are executed via :meth:`hook`.\n\n    Example:\n        .. code:: python\n\n        listen = HookDispatcher()\n\n        @listen.on(HookType.PreApply)\n        def to_perform_before_app_creation(app, cluster, resource, controller):\n            # Do Stuff\n\n        @listen.on(HookType.PostApply)\n        def another_to_perform_after_app_creation(app, cluster, resource, resp):\n            # Do Stuff\n\n        @listen.on(HookType.PostDelete)\n        def to_perform_after_app_deletion(app, cluster, resource, resp):\n            # Do Stuff\n\n    \"\"\"\n\n    def __init__(self):\n        self.registry = defaultdict(list)\n\n    def on(self, hook):\n        \"\"\"Decorator function to add a new handler to the registry.\n\n        Args:\n            hook (HookType): Hook attribute for which to register the handler.\n\n        Returns:\n            callable: Decorator for registering listeners for the specified\n            hook.\n\n        \"\"\"\n\n        def decorator(handler):\n            self.registry[hook].append(handler)\n\n            return handler\n\n        return decorator\n\n    async def hook(self, hook, **kwargs):\n        \"\"\"Execute the list of handlers associated to the provided :class:`Hook`\n        attribute.\n\n        Args:\n            hook (HookType): The hook attribute for which to execute handlers.\n\n        \"\"\"\n        try:\n            handlers = self.registry[hook]\n        except KeyError:\n            pass\n        else:\n            for handler in handlers:\n                if iscoroutinefunction(handler):\n                    await handler(**kwargs)\n                else:\n                    handler(**kwargs)\n\n\nlisten = HookDispatcher()\n\n\n@listen.on(HookType.ResourcePostCreate)\n@listen.on(HookType.ResourcePostUpdate)\nasync def register_service(app, cluster, resource, response):\n    \"\"\"Register endpoint of Kubernetes Service object on creation and update.\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        cluster (krake.data.kubernetes.Cluster): The cluster on which the\n            application is running\n        resource (dict): Kubernetes object description as specified in the\n            specification of the application.\n        response (kubernetes_asyncio.client.V1Service): Response of the\n            Kubernetes API\n\n    \"\"\"\n    if resource[\"kind\"] != \"Service\":\n        return\n\n    service_name = resource[\"metadata\"][\"name\"]\n\n    if response.spec and response.spec.type == \"LoadBalancer\":\n        # For a \"LoadBalancer\" type of Service, an external IP is given in the cluster\n        # by a load balancer controller to the service. In this case, the \"port\"\n        # specified in the spec is reachable from the outside.\n        if (\n            not response.status.load_balancer\n            or not response.status.load_balancer.ingress\n        ):\n            # When a \"LoadBalancer\" type of service is created, the IP is given by an\n            # additional controller (e.g. a controller that requests a floating IP to an\n            # OpenStack infrastructure). This process can take some time, but the\n            # Service itself already exist before the IP is assigned. In the case of an\n            # error with the controller, the IP is also not given. This \"<pending>\" IP\n            # just expresses that the Service exists, but the IP is not ready yet.\n            external_ip = \"<pending>\"\n        else:\n            external_ip = response.status.load_balancer.ingress[0].ip\n\n        if not response.spec.ports:\n            external_port = \"<pending>\"\n        else:\n            external_port = response.spec.ports[0].port\n        app.status.services[service_name] = f\"{external_ip}:{external_port}\"\n        return\n\n    node_port = None\n    # Ensure that ports are specified\n    if response.spec and response.spec.ports:\n        node_port = response.spec.ports[0].node_port\n\n    # If the service does not have a node port, remove a potential reference\n    # and return.\n    if node_port is None:\n        try:\n            del app.status.services[service_name]\n        except KeyError:\n            pass\n        return\n\n    # Determine URL of Kubernetes cluster API\n    loader = KubeConfigLoader(cluster.spec.kubeconfig)\n    config = Configuration()\n    await loader.load_and_set(config)\n    cluster_url = yarl.URL(config.host)\n\n    app.status.services[service_name] = f\"{cluster_url.host}:{node_port}\"\n\n\n@listen.on(HookType.ResourcePostDelete)\nasync def unregister_service(app, resource, **kwargs):\n    \"\"\"Unregister endpoint of Kubernetes Service object on deletion.\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        resource (dict): Kubernetes object description as specified in the\n            specification of the application.\n\n    \"\"\"\n    if resource[\"kind\"] != \"Service\":\n        return\n\n    service_name = resource[\"metadata\"][\"name\"]\n    try:\n        del app.status.services[service_name]\n    except KeyError:\n        pass\n\n\n@listen.on(HookType.ResourcePostDelete)\nasync def remove_resource_from_last_observed_manifest(app, resource, **kwargs):\n    \"\"\"Remove a given resource from the last_observed_manifest after its deletion\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        resource (dict): Kubernetes object description as specified in the\n            specification of the application.\n\n    \"\"\"\n    try:\n        idx = get_kubernetes_resource_idx(app.status.last_observed_manifest, resource)\n    except IndexError:\n        return\n\n    app.status.last_observed_manifest.pop(idx)\n\n\ndef update_last_applied_manifest_dict_from_resp(\n    last_applied_manifest, observer_schema, response\n):\n    \"\"\"Together with :func:``update_last_applied_manifest_list_from_resp``, this\n    function is called recursively to update a partial ``last_applied_manifest``\n    from a partial Kubernetes response\n\n    Args:\n        last_applied_manifest (dict): partial ``last_applied_manifest`` being\n            updated\n        observer_schema (dict): partial ``observer_schema``\n        response (dict): partial response from the Kubernetes API.\n\n    Raises:\n        KeyError: If the observed field is not present in the Kubernetes response\n\n    This function go through all observed fields, and initialized their value in\n    last_applied_manifest if they are not yet present\n\n    \"\"\"\n    for key, value in observer_schema.items():\n\n        # Keys in the response are in camelCase\n        camel_key = camel_to_snake_case(key)\n\n        if camel_key not in response:\n            # An observed key should always be present in the k8s response\n            raise KeyError(\n                f\"Observed key {camel_key} is not present in response {response}\"\n            )\n\n        if isinstance(value, dict):\n            if key not in last_applied_manifest:\n                # The dictionary is observed, but not present in\n                # last_applied_manifest\n                last_applied_manifest[key] = {}\n\n            update_last_applied_manifest_dict_from_resp(\n                last_applied_manifest[key], observer_schema[key], response[camel_key]\n            )\n\n        elif isinstance(value, list):\n            if key not in last_applied_manifest:\n                # The list is observed, but not present in last_applied_manifest\n                last_applied_manifest[key] = []\n\n            update_last_applied_manifest_list_from_resp(\n                last_applied_manifest[key], observer_schema[key], response[camel_key]\n            )\n\n        elif key not in last_applied_manifest:\n            # If key not present in last_applied_manifest, and value is neither a\n            # dict nor a list, simply add it.\n            last_applied_manifest[key] = response[camel_key]\n\n", "contexts_below": "\n @listen.on(HookType.ResourcePostCreate)\n @listen.on(HookType.ResourcePostUpdate)\n def update_last_applied_manifest_from_resp(app, response, **kwargs):\n     \"\"\"Hook run after the creation or update of an application in order to update the\n     `status.last_applied_manifest` using the k8s response.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application the service belongs to\n         response (kubernetes_asyncio.client.V1Status): Response of the Kubernetes API\n \n     After a Kubernetes resource has been created/updated, the\n     `status.last_applied_manifest` has to be updated. All fields already initialized\n     (either from the mangling of `spec.manifest`, or by a previous call to this\n     function) should be left untouched. Only observed fields which are not present in\n     `status.last_applied_manifest` should be initialized.\n \n     \"\"\"\n \n     if isinstance(response, dict):\n         # The Kubernetes API couldn't deserialize the k8s response into an object\n         resp = response\n     else:\n         # The Kubernetes API deserialized the k8s response into an object\n         resp = response.to_dict()\n \n     idx_applied = get_kubernetes_resource_idx(app.status.last_applied_manifest, resp)\n \n     idx_observed = get_kubernetes_resource_idx(app.status.mangled_observer_schema, resp)\n \n     update_last_applied_manifest_dict_from_resp(\n         app.status.last_applied_manifest[idx_applied],\n         app.status.mangled_observer_schema[idx_observed],\n         resp,\n     )\n \n \n @listen.on(HookType.ResourcePostCreate)\n @listen.on(HookType.ResourcePostUpdate)\n def update_last_observed_manifest_from_resp(app, response, **kwargs):\n     \"\"\"Handler to run after the creation or update of a Kubernetes resource to update\n     the last_observed_manifest from the response of the Kubernetes API.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application the service belongs to\n         response (kubernetes_asyncio.client.V1Service): Response of the\n             Kubernetes API\n \n     The target last_observed_manifest holds the value of all observed fields plus the\n     special control dictionaries for the list length\n \n     \"\"\"\n     if isinstance(response, dict):\n         # The Kubernetes API couldn't deserialize the k8s response into an object\n         resp = response\n     else:\n         # The Kubernetes API deserialized the k8s response into an object\n         resp = response.to_dict()\n \n     try:\n         idx_observed = get_kubernetes_resource_idx(\n             app.status.mangled_observer_schema,\n             resp,\n         )\n     except IndexError:\n         # All created resources should be observed\n         raise\n \n     try:\n         idx_last_observed = get_kubernetes_resource_idx(\n             app.status.last_observed_manifest,\n             resp,\n         )\n     except IndexError:\n         # If the resource is not yes present in last_observed_manifest, append it.\n         idx_last_observed = len(app.status.last_observed_manifest)\n         app.status.last_observed_manifest.append({})\n \n     # Overwrite the last_observed_manifest for this resource\n     app.status.last_observed_manifest[\n         idx_last_observed\n     ] = update_last_observed_manifest_dict(\n         app.status.mangled_observer_schema[idx_observed], resp\n     )\n \n \n def update_last_observed_manifest_dict(observed_resource, response):\n     \"\"\"Together with :func:``update_last_observed_manifest_list``, recursively\n     crafts the ``last_observed_manifest`` from the Kubernetes :attr:``response``.\n \n     Args:\n         observed_resource (dict): The schema to observe for the partial given resource\n         response (dict): The partial Kubernetes response for this resource.\n \n     Raises:\n         KeyError: If an observed key is not present in the Kubernetes response\n \n     Returns:\n         dict: The dictionary of observed keys and their value\n \n     Get the value of all observed fields from the Kubernetes response\n     \"\"\"\n     res = {}\n     for key, value in observed_resource.items():\n \n         camel_key = camel_to_snake_case(key)\n         if camel_key not in response:\n             raise KeyError(\n                 f\"Observed key {camel_key} is not present in response {response}\"\n             )\n \n         if isinstance(value, dict):\n             res[key] = update_last_observed_manifest_dict(value, response[camel_key])\n \n         elif isinstance(value, list):\n             res[key] = update_last_observed_manifest_list(value, response[camel_key])\n \n         else:\n             res[key] = response[camel_key]\n \n     return res\n \n \n def update_last_observed_manifest_list(observed_resource, response):\n     \"\"\"Together with :func:``update_last_observed_manifest_dict``, recursively\n     crafts the ``last_observed_manifest`` from the Kubernetes :attr:``response``.\n \n     Args:\n         observed_resource (list): the schema to observe for the partial given resource\n         response (list): the partial Kubernetes response for this resource.\n \n     Returns:\n         list: The list of observed elements, plus the special list length control\n             dictionary\n \n     Get the value of all observed elements from the Kubernetes response\n     \"\"\"\n \n     if not response:\n         return [{\"observer_schema_list_current_length\": 0}]\n \n     res = []\n     # Looping over the observed resource, except the last element which is the special\n     # control dictionary\n     for idx, val in enumerate(observed_resource[:-1]):\n \n         if idx >= len(response):\n             # Element is not present in the Kubernetes response, nothing more to do\n             break\n \n         if type(response[idx]) == dict:\n             res.append(update_last_observed_manifest_dict(val, response[idx]))\n \n         elif type(response[idx]) == list:\n             res.append(update_last_observed_manifest_list(val, response[idx]))\n \n         else:\n             res.append(response[idx])\n \n     # Append the special control dictionary to the list\n     res.append({\"observer_schema_list_current_length\": len(response)})\n \n     return res\n \n \n def update_last_applied_manifest_dict_from_spec(\n     resource_status_new, resource_status_old, resource_observed\n ):\n     \"\"\"Together with :func:``update_last_applied_manifest_list_from_spec``, this\n     function is called recursively to update a partial ``last_applied_manifest``\n \n     Args:\n         resource_status_new (dict): partial ``last_applied_manifest`` being updated\n         resource_status_old (dict): partial of the current ``last_applied_manifest``\n         resource_observed (dict): partial observer_schema for the manifest file\n             being updated\n \n     \"\"\"\n     for key, value in resource_observed.items():\n \n         if key not in resource_status_old:\n             continue\n \n         if key in resource_status_new:\n \n             if isinstance(value, dict):\n                 update_last_applied_manifest_dict_from_spec(\n                     resource_status_new[key],\n                     resource_status_old[key],\n                     resource_observed[key],\n                 )\n \n             elif isinstance(value, list):\n                 update_last_applied_manifest_list_from_spec(\n                     resource_status_new[key],\n                     resource_status_old[key],\n                     resource_observed[key],\n                 )\n \n         else:\n             # If the key is not present the spec.manifest, we first need to\n             # initialize it\n \n             if isinstance(value, dict):\n                 resource_status_new[key] = {}\n                 update_last_applied_manifest_dict_from_spec(\n                     resource_status_new[key],\n                     resource_status_old[key],\n                     resource_observed[key],\n                 )\n \n             elif isinstance(value, list):\n                 resource_status_new[key] = []\n                 update_last_applied_manifest_list_from_spec(\n                     resource_status_new[key],\n                     resource_status_old[key],\n                     resource_observed[key],\n                 )\n \n             else:\n                 resource_status_new[key] = resource_status_old[key]\n \n \n def update_last_applied_manifest_list_from_spec(\n     resource_status_new, resource_status_old, resource_observed\n ):\n     \"\"\"Together with :func:``update_last_applied_manifest_dict_from_spec``, this\n     function is called recursively to update a partial ``last_applied_manifest``\n \n     Args:\n         resource_status_new (list): partial ``last_applied_manifest`` being updated\n         resource_status_old (list): partial of the current ``last_applied_manifest``\n         resource_observed (list): partial observer_schema for the manifest file\n             being updated\n \n     \"\"\"\n \n     # Looping over the observed resource, except the last element which is the\n     # special control dictionary\n     for idx, val in enumerate(resource_observed[:-1]):\n \n         if idx >= len(resource_status_old):\n             # The element in not in the current last_applied_manifest, and neither\n             # is the rest of the list\n             break\n \n         if idx < len(resource_status_new):\n             # The element is present in spec.manifest and in the current\n             # last_applied_manifest. Updating observed fields\n \n             if isinstance(val, dict):\n                 update_last_applied_manifest_dict_from_spec(\n                     resource_status_new[idx],\n                     resource_status_old[idx],\n                     resource_observed[idx],\n                 )\n \n             elif isinstance(val, list):\n                 update_last_applied_manifest_list_from_spec(\n                     resource_status_new[idx],\n                     resource_status_old[idx],\n                     resource_observed[idx],\n                 )\n \n         else:\n             # If the element is not present in the spec.manifest, we first have to\n             # initialize it.\n \n             if isinstance(val, dict):\n                 resource_status_new.append({})\n                 update_last_applied_manifest_dict_from_spec(\n                     resource_status_new[idx],\n                     resource_status_old[idx],\n                     resource_observed[idx],\n                 )\n \n             elif isinstance(val, list):\n                 resource_status_new.append([])\n                 update_last_applied_manifest_list_from_spec(\n                     resource_status_new[idx],\n                     resource_status_old[idx],\n                     resource_observed[idx],\n                 )\n \n             else:\n                 resource_status_new.append(resource_status_old[idx])\n \n \n def update_last_applied_manifest_from_spec(app):\n     \"\"\"Update the status.last_applied_manifest of an application from spec.manifests\n \n     Args:\n         app (krake.data.kubernetes.Application): Application to update\n \n     This function is called on application creation and updates. The\n     last_applied_manifest of an application is initialized as a copy of spec.manifest,\n     and is augmented by all known observed fields not yet initialized (i.e. all observed\n     fields or resources which are present in the current last_applied_manifest but not\n     in the spec.manifest)\n \n     \"\"\"\n \n     # The new last_applied_manifest is initialized as a copy of the spec.manifest, and\n     # augmented by all observed fields which are present in the current\n     # last_applied_manifest but not in the original spec.manifest\n     new_last_applied_manifest = deepcopy(app.spec.manifest)\n \n     # Loop over observed resources and observed fields, and check if they should be\n     # added to the new last_applied_manifest (i.e. present in the current\n     # last_applied_manifest but not in spec.manifest)\n     for resource_observed in app.status.mangled_observer_schema:\n \n         # If the resource is not present in the current last_applied_manifest, there is\n         # nothing to do. Whether the resource was initialized by spec.manifest doesn't\n         # matter.\n         try:\n             idx_status_old = get_kubernetes_resource_idx(\n                 app.status.last_applied_manifest, resource_observed\n             )\n         except IndexError:\n             continue\n \n         # As the resource is present in the current last_applied_manifest, we need to go\n         # through it to check if observed fields should be set to their current value\n         # (i.e. fields are present in the current last_applied_manifest, but not in\n         # spec.manifest)\n         try:\n             # Check if the observed resource is present in spec.manifest\n             idx_status_new = get_kubernetes_resource_idx(\n                 new_last_applied_manifest, resource_observed\n             )\n         except IndexError:\n             # The resource is observed but is not present in the spec.manifest.\n             # Create an empty resource, which will be augmented in\n             # update_last_applied_manifest_dict_from_spec with the observed and known\n             # fields.\n             new_last_applied_manifest.append({})\n             idx_status_new = len(new_last_applied_manifest) - 1\n \n         update_last_applied_manifest_dict_from_spec(\n             new_last_applied_manifest[idx_status_new],\n             app.status.last_applied_manifest[idx_status_old],\n             resource_observed,\n         )\n \n     app.status.last_applied_manifest = new_last_applied_manifest\n \n \n class KubernetesApplicationObserver(Observer):\n     \"\"\"Observer specific for Kubernetes Applications. One observer is created for each\n     Application managed by the Controller, but not one per Kubernetes resource\n     (Deployment, Service...). If several resources are defined by an Application, they\n     are all monitored by the same observer.\n \n     The observer gets the actual status of the resources on the cluster using the\n     Kubernetes API, and compare it to the status stored in the API.\n \n     The observer is:\n      * started at initial Krake resource creation;\n \n      * deleted when a resource needs to be updated, then started again when it is done;\n \n      * simply deleted on resource deletion.\n \n     Args:\n         cluster (krake.data.kubernetes.Cluster): the cluster on which the observed\n             Application is created.\n         resource (krake.data.kubernetes.Application): the application that will be\n             observed.\n         on_res_update (coroutine): a coroutine called when a resource's actual status\n             differs from the status sent by the database. Its signature is:\n             ``(resource) -> updated_resource``. ``updated_resource`` is the instance of\n             the resource that is up-to-date with the API. The Observer internal instance\n             of the resource to observe will be updated. If the API cannot be contacted,\n             ``None`` can be returned. In this case the internal instance of the Observer\n             will not be updated.\n         time_step (int, optional): how frequently the Observer should watch the actual\n             status of the resources.\n \n     \"\"\"\n \n     def __init__(self, cluster, resource, on_res_update, time_step=2):\n         super().__init__(resource, on_res_update, time_step)\n         self.cluster = cluster\n \n     async def poll_resource(self):\n         \"\"\"Fetch the current status of the Application monitored by the Observer.\n \n         Returns:\n             krake.data.core.Status: the status object created using information from the\n                 real world Applications resource.\n \n         \"\"\"\n         app = self.resource\n \n         status = deepcopy(app.status)\n         status.last_observed_manifest = []\n         # For each observed kubernetes resource of the Application,\n         # get its current status on the cluster.\n         for desired_resource in app.status.last_applied_manifest:\n             kube = KubernetesClient(self.cluster.spec.kubeconfig)\n             idx_observed = get_kubernetes_resource_idx(\n                 app.status.mangled_observer_schema, desired_resource\n             )\n             observed_resource = app.status.mangled_observer_schema[idx_observed]\n             async with kube:\n                 try:\n                     group, version, kind, name, namespace = kube.get_immutables(\n                         desired_resource\n                     )\n                     resource_api = await kube.get_resource_api(group, version, kind)\n                     resp = await resource_api.read(kind, name, namespace)\n                 except ApiException as err:\n                     if err.status == 404:\n                         # Resource does not exist\n                         continue\n                     # Otherwise, log the unexpected errors\n                     logger.error(err)\n \n             observed_manifest = update_last_observed_manifest_dict(\n                 observed_resource, resp.to_dict()\n             )\n             status.last_observed_manifest.append(observed_manifest)\n \n         return status\n \n \n class KubernetesClusterObserver(Observer):\n     \"\"\"Observer specific for Kubernetes Clusters. One observer is created for each\n     Cluster managed by the Controller.\n \n     The observer gets the actual status of the cluster using the\n     Kubernetes API, and compare it to the status stored in the API.\n \n     The observer is:\n      * started at initial Krake resource creation;\n \n      * deleted when a resource needs to be updated, then started again when it is done;\n \n      * simply deleted on resource deletion.\n \n     Args:\n         cluster (krake.data.kubernetes.Cluster): the cluster which will be observed.\n         on_res_update (coroutine): a coroutine called when a resource's actual status\n             differs from the status sent by the database. Its signature is:\n             ``(resource) -> updated_resource``. ``updated_resource`` is the instance of\n             the resource that is up-to-date with the API. The Observer internal instance\n             of the resource to observe will be updated. If the API cannot be contacted,\n             ``None`` can be returned. In this case the internal instance of the Observer\n             will not be updated.\n         time_step (int, optional): how frequently the Observer should watch the actual\n             status of the resources.\n \n     \"\"\"\n \n     def __init__(self, cluster, on_res_update, time_step=2):\n         super().__init__(cluster, on_res_update, time_step)\n         self.cluster = cluster\n \n     async def poll_resource(self):\n         \"\"\"Fetch the current status of the Cluster monitored by the Observer.\n \n         Returns:\n             krake.data.core.Status: the status object created using information from the\n                 real world Cluster.\n \n         \"\"\"\n         status = deepcopy(self.cluster.status)\n         # For each observed kubernetes cluster registered in Krake,\n         # get its current node status.\n         loader = KubeConfigLoader(self.cluster.spec.kubeconfig)\n         config = Configuration()\n         await loader.load_and_set(config)\n         kube = ApiClient(config)\n \n         async with kube as api:\n             v1 = client.CoreV1Api(api)\n             try:\n                 response = await v1.list_node()\n \n             except ClientConnectorError as err:\n                 status.state = ClusterState.OFFLINE\n                 self.cluster.status.state = ClusterState.OFFLINE\n                 # Log the error\n                 logger.debug(err)\n                 return status\n \n             condition_dict = {\n                 \"MemoryPressure\": [],\n                 \"DiskPressure\": [],\n                 \"PIDPressure\": [],\n                 \"Ready\": [],\n             }\n \n             for item in response.items:\n                 for condition in item.status.conditions:\n                     condition_dict[condition.type].append(condition.status)\n                 if (\n                     condition_dict[\"MemoryPressure\"] == [\"True\"]\n                     or condition_dict[\"DiskPressure\"] == [\"True\"]\n                     or condition_dict[\"PIDPressure\"] == [\"True\"]\n                 ):\n                     status.state = ClusterState.UNHEALTHY\n                     self.cluster.status.state = ClusterState.UNHEALTHY\n                     return status\n                 elif (\n                     condition_dict[\"Ready\"] == [\"True\"]\n                     and status.state is ClusterState.OFFLINE\n                 ):\n                     status.state = ClusterState.CONNECTING\n                     self.cluster.status.state = ClusterState.CONNECTING\n                     return status\n                 elif condition_dict[\"Ready\"] == [\"True\"]:\n                     status.state = ClusterState.ONLINE\n                     self.cluster.status.state = ClusterState.ONLINE\n                     return status\n                 else:\n                     status.state = ClusterState.NOTREADY\n                     self.cluster.status.state = ClusterState.NOTREADY\n                     return status\n \n \n @listen.on(HookType.ApplicationPostReconcile)\n @listen.on(HookType.ApplicationPostMigrate)\n @listen.on(HookType.ClusterCreation)\n async def register_observer(controller, resource, start=True, **kwargs):\n     \"\"\"Create an observer for the given Application or Cluster, and start it as a\n     background task if wanted.\n \n     If an observer already existed for this Application or Cluster, it is stopped\n     and deleted.\n \n     Args:\n         controller (KubernetesController): the controller for which the observer will be\n             added in the list of working observers.\n         resource (krake.data.kubernetes.Application): the Application to observe or\n         resource (krake.data.kubernetes.Cluster): the Cluster to observe.\n         start (bool, optional): if False, does not start the observer as background\n             task.\n \n     \"\"\"\n     if resource.kind == Application.kind:\n         cluster = await controller.kubernetes_api.read_cluster(\n             namespace=resource.status.running_on.namespace,\n             name=resource.status.running_on.name,\n         )\n \n         observer = KubernetesApplicationObserver(\n             cluster,\n             resource,\n             controller.on_status_update,\n             time_step=controller.observer_time_step,\n         )\n \n     elif resource.kind == Cluster.kind:\n         observer = KubernetesClusterObserver(\n             resource,\n             controller.on_status_update,\n             time_step=controller.observer_time_step,\n         )\n     else:\n         logger.debug(\"Unknown resource kind. No observer was registered.\", resource)\n         return\n \n     logger.debug(f\"Start observer for {resource.kind} %r\", resource.metadata.name)\n     task = None\n     if start:\n         task = controller.loop.create_task(observer.run())\n \n     controller.observers[resource.metadata.uid] = (observer, task)\n \n \n @listen.on(HookType.ApplicationPreReconcile)\n @listen.on(HookType.ApplicationPreMigrate)\n @listen.on(HookType.ApplicationPreDelete)\n @listen.on(HookType.ClusterDeletion)\n async def unregister_observer(controller, resource, **kwargs):\n     \"\"\"Stop and delete the observer for the given Application or Cluster. If no observer\n     is started, do nothing.\n \n     Args:\n         controller (KubernetesController): the controller for which the observer will be\n             removed from the list of working observers.\n         resource (krake.data.kubernetes.Application): the Application whose observer\n         will be stopped or\n         resource (krake.data.kubernetes.Cluster): the Cluster whose observer will be\n         stopped.\n \n     \"\"\"\n     if resource.metadata.uid not in controller.observers:\n         return\n \n     logger.debug(f\"Stop observer for {resource.kind} %r\", resource.metadata.name)\n     _, task = controller.observers.pop(resource.metadata.uid)\n     task.cancel()\n \n     with suppress(asyncio.CancelledError):\n         await task\n \n \n def utc_difference():\n     \"\"\"Get the difference in seconds between the current time and the current UTC time.\n \n     Returns:\n         int: the time difference in seconds.\n \n     \"\"\"\n     delta = datetime.now() - datetime.utcnow()\n     return delta.seconds\n \n \n def generate_certificate(config):\n     \"\"\"Create and sign a new certificate using the one defined in the complete hook\n     configuration as intermediate certificate.\n \n     Args:\n         config (krake.data.config.CompleteHookConfiguration): the configuration of the\n             complete hook.\n \n     Returns:\n         CertificatePair: the content of the certificate created and its corresponding\n             key.\n \n     \"\"\"\n     with open(config.intermediate_src, \"rb\") as f:\n         intermediate_src = crypto.load_certificate(crypto.FILETYPE_PEM, f.read())\n     with open(config.intermediate_key_src, \"rb\") as f:\n         intermediate_key_src = crypto.load_privatekey(crypto.FILETYPE_PEM, f.read())\n \n     client_cert = crypto.X509()\n \n     # Set general information\n     client_cert.set_version(3)\n     client_cert.set_serial_number(random.randint(50000000000000, 100000000000000))\n     # If not set before, TLS will not accept to use this certificate in UTC cases, as\n     # the server time may be earlier.\n     time_offset = utc_difference() * -1\n     client_cert.gmtime_adj_notBefore(time_offset)\n     client_cert.gmtime_adj_notAfter(1 * 365 * 24 * 60 * 60)\n \n     # Set issuer and subject\n     intermediate_subject = intermediate_src.get_subject()\n     client_cert.set_issuer(intermediate_subject)\n     client_subj = crypto.X509Name(intermediate_subject)\n     client_subj.CN = config.hook_user\n     client_cert.set_subject(client_subj)\n \n     # Create and set the private key\n     client_key = crypto.PKey()\n     client_key.generate_key(crypto.TYPE_RSA, 2048)\n     client_cert.set_pubkey(client_key)\n \n     client_cert.sign(intermediate_key_src, \"sha256\")\n \n     cert_dump = crypto.dump_certificate(crypto.FILETYPE_PEM, client_cert).decode()\n     key_dump = crypto.dump_privatekey(crypto.FILETYPE_PEM, client_key).decode()\n     return CertificatePair(cert=cert_dump, key=key_dump)\n \n \n def generate_default_observer_schema(app):\n     \"\"\"Generate the default observer schema for each Kubernetes resource present in\n     ``spec.manifest`` for which a custom observer schema hasn't been specified.\n \n     Args:\n         app (krake.data.kubernetes.Application): The application for which to generate a\n             default observer schema\n     \"\"\"\n \n     app.status.mangled_observer_schema = deepcopy(app.spec.observer_schema)\n \n     for resource_manifest in app.spec.manifest:\n         try:\n             get_kubernetes_resource_idx(\n                 app.status.mangled_observer_schema, resource_manifest\n             )\n \n         except IndexError:\n             # Only create a default observer schema, if a custom observer schema hasn't\n             # been set by the user.\n             app.status.mangled_observer_schema.append(\n                 generate_default_observer_schema_dict(\n                     resource_manifest,\n                     first_level=True,\n                 )\n             )\n \n \n def generate_default_observer_schema_dict(manifest_dict, first_level=False):\n     \"\"\"Together with :func:``generate_default_observer_schema_list``, this function is\n     called recursively to generate part of a default ``observer_schema`` from part of a\n     Kubernetes resource, defined respectively by ``manifest_dict`` or ``manifest_list``.\n \n     Args:\n         manifest_dict (dict): Partial Kubernetes resources\n         first_level (bool, optional): If True, indicates that the dictionary represents\n             the whole observer schema of a Kubernetes resource\n \n     Returns:\n         dict: Generated partial observer_schema\n \n     This function creates a new dictionary from ``manifest_dict`` and replaces all\n     non-list and non-dict values by ``None``.\n \n     In case of ``first_level`` dictionary (i.e. complete ``observer_schema`` for a\n     resource), the values of the identifying fields are copied from the manifest file.\n \n     \"\"\"\n     observer_schema_dict = {}\n \n     for key, value in manifest_dict.items():\n \n         if isinstance(value, dict):\n             observer_schema_dict[key] = generate_default_observer_schema_dict(value)\n \n         elif isinstance(value, list):\n             observer_schema_dict[key] = generate_default_observer_schema_list(value)\n \n         else:\n             observer_schema_dict[key] = None\n \n     if first_level:\n         observer_schema_dict[\"apiVersion\"] = manifest_dict[\"apiVersion\"]\n         observer_schema_dict[\"kind\"] = manifest_dict[\"kind\"]\n         observer_schema_dict[\"metadata\"][\"name\"] = manifest_dict[\"metadata\"][\"name\"]\n \n         if (\n             \"spec\" in manifest_dict\n             and \"type\" in manifest_dict[\"spec\"]\n             and manifest_dict[\"spec\"][\"type\"] == \"LoadBalancer\"\n         ):\n             observer_schema_dict[\"status\"] = {\"load_balancer\": {\"ingress\": None}}\n \n     return observer_schema_dict\n \n \n def generate_default_observer_schema_list(manifest_list):\n     \"\"\"Together with :func:``generate_default_observer_schema_dict``, this function is\n     called recursively to generate part of a default ``observer_schema`` from part of a\n     Kubernetes resource, defined respectively by ``manifest_list`` or ``manifest_dict``.\n \n     Args:\n         manifest_list (list): Partial Kubernetes resources\n \n     Returns:\n         list: Generated partial observer_schema\n \n     This function creates a new list from ``manifest_list`` and replaces all non-list\n     and non-dict elements by ``None``.\n \n     Additionally, it generates the default list control dictionary, using the current\n     length of the list as default minimum and maximum values.\n \n     \"\"\"\n     observer_schema_list = []\n \n     for value in manifest_list:\n \n         if isinstance(value, dict):\n             observer_schema_list.append(generate_default_observer_schema_dict(value))\n \n         elif isinstance(value, list):\n             observer_schema_list.append(generate_default_observer_schema_list(value))\n \n         else:\n             observer_schema_list.append(None)\n \n     observer_schema_list.append(\n         {\n             \"observer_schema_list_min_length\": len(manifest_list),\n             \"observer_schema_list_max_length\": len(manifest_list),\n         }\n     )\n \n     return observer_schema_list\n \n \n @listen.on(HookType.ApplicationMangling)\n async def complete(app, api_endpoint, ssl_context, config):\n     \"\"\"Execute application complete hook defined by :class:`Complete`.\n     Hook mangles given application and injects complete hooks variables.\n \n     Application complete hook is disabled by default.\n     User enables this hook by the --hook-complete argument in rok cli.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application object processed\n             when the hook is called\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         config (krake.data.config.HooksConfiguration): Complete hook\n             configuration.\n \n     \"\"\"\n     if \"complete\" not in app.spec.hooks:\n         return\n \n     # Use the endpoint of the API only if the external endpoint has not been set.\n     if config.complete.external_endpoint:\n         api_endpoint = config.complete.external_endpoint\n \n     app.status.complete_token = \\\n         app.status.complete_token if app.status.complete_token else token_urlsafe()\n \n     # Generate only once the certificate and key for a specific Application\n     generated_cert = CertificatePair(\n         cert=app.status.complete_cert, key=app.status.complete_key\n     )\n     if ssl_context and generated_cert == (None, None):\n         generated_cert = generate_certificate(config.complete)\n         app.status.complete_cert = generated_cert.cert\n         app.status.complete_key = generated_cert.key\n \n     hook = Complete(\n         api_endpoint,\n         ssl_context,\n         hook_user=config.complete.hook_user,\n         cert_dest=config.complete.cert_dest,\n         env_token=config.complete.env_token,\n         env_url=config.complete.env_url,\n     )\n     hook.mangle_app(\n         app.metadata.name,\n         app.metadata.namespace,\n         app.status.complete_token,\n         app.status.last_applied_manifest,\n         config.complete.intermediate_src,\n         generated_cert,\n         app.status.mangled_observer_schema,\n         \"complete\"\n     )\n \n \n @listen.on(HookType.ApplicationMangling)\n async def shutdown(app, api_endpoint, ssl_context, config):\n     \"\"\"Executes an application shutdown hook defined by :class:`Shutdown`.\n     The hook mangles the given application and injects shutdown hooks variables.\n \n     Application shutdown hook is disabled by default.\n     User enables this hook by the --hook-shutdown argument in rok cli.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application object processed\n             when the hook is called\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         config (krake.data.config.HooksConfiguration): Shutdown hook\n             configuration.\n \n     \"\"\"\n     if \"shutdown\" not in app.spec.hooks:\n         return\n \n     # Use the endpoint of the API only if the external endpoint has not been set.\n     if config.shutdown.external_endpoint:\n         api_endpoint = config.shutdown.external_endpoint\n \n     app.status.shutdown_token = \\\n         app.status.shutdown_token if app.status.shutdown_token else token_urlsafe()\n \n     # Generate only once the certificate and key for a specific Application\n     generated_cert = CertificatePair(\n         cert=app.status.shutdown_cert, key=app.status.shutdown_key\n     )\n     if ssl_context and generated_cert == (None, None):\n         generated_cert = generate_certificate(config.shutdown)\n         app.status.shutdown_cert = generated_cert.cert\n         app.status.shutdown_key = generated_cert.key\n \n     hook = Shutdown(\n         api_endpoint,\n         ssl_context,\n         hook_user=config.shutdown.hook_user,\n         cert_dest=config.shutdown.cert_dest,\n         env_token=config.shutdown.env_token,\n         env_url=config.shutdown.env_url,\n     )\n     hook.mangle_app(\n         app.metadata.name,\n         app.metadata.namespace,\n         app.status.shutdown_token,\n         app.status.last_applied_manifest,\n         config.shutdown.intermediate_src,\n         generated_cert,\n         app.status.mangled_observer_schema,\n         \"shutdown\"\n     )\n \n \n @listen.on(HookType.ResourcePreDelete)\n async def pre_shutdown(controller, app, **kwargs):\n     \"\"\"\n \n     Args:\n         app (krake.data.kubernetes.Application): Application object processed\n             when the hook is called\n     \"\"\"\n     if \"shutdown\" not in app.spec.hooks:\n         return\n \n     return\n \n \n class SubResource(NamedTuple):\n     group: str\n     name: str\n     body: dict\n     path: tuple\n \n \n class CertificatePair(NamedTuple):\n     \"\"\"Tuple which contains a certificate and its corresponding key.\n \n     Attributes:\n         cert (str): content of a certificate.\n         key (str): content of the key that corresponds to the certificate.\n \n     \"\"\"\n \n     cert: str\n     key: str\n \n \n class Hook(object):\n \n     hook_resources = ()\n \n     ca_name = \"ca-bundle.pem\"\n     cert_name = \"cert.pem\"\n     key_name = \"key.pem\"\n \n     def __init__(\n         self, api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n     ):\n         self.api_endpoint = api_endpoint\n         self.ssl_context = ssl_context\n         self.hook_user = hook_user\n         self.cert_dest = cert_dest\n         self.env_token = env_token\n         self.env_url = env_url\n \n     def mangle_app(\n         self,\n         name,\n         namespace,\n         token,\n         last_applied_manifest,\n         intermediate_src,\n         generated_cert,\n         mangled_observer_schema,\n         hook_type=\"\",\n     ):\n         \"\"\"Mangle a given application and inject complete hook resources and\n         sub-resources into the :attr:`last_applied_manifest` object by :meth:`mangle`.\n         Also mangle the observer_schema as new resources and sub-resources should\n         be observed.\n \n         :attr:`last_applied_manifest` is created as a deep copy of the desired\n         application resources, as defined by user. It can be updated by custom hook\n         resources or modified by custom hook sub-resources. It is used as a desired\n         state for the Krake deployment process.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             token (str): Complete hook authentication token\n             last_applied_manifest (list): Application resources\n             intermediate_src (str): content of the certificate that is used to sign new\n                 certificates for the complete hook.\n             generated_cert (CertificatePair): tuple that contains the content of the\n                 new signed certificate for the Application, and the content of its\n                 corresponding key.\n             mangled_observer_schema (list): Observed fields\n             hook_type (str, optional): Name of the hook the app should be mangled for\n \n         \"\"\"\n \n         secret_certs_name = \"-\".join([name, \"krake\", hook_type, \"secret\", \"certs\"])\n         secret_token_name = \"-\".join([name, \"krake\", hook_type, \"secret\", \"token\"])\n         volume_name = \"-\".join([name, \"krake\", hook_type, \"volume\"])\n         ca_certs = (\n             self.ssl_context.get_ca_certs(binary_form=True)\n             if self.ssl_context\n             else None\n         )\n \n         # Extract all different namespaces\n         # FIXME: too many assumptions here: do we create one ConfigMap for each\n         #  namespace?\n         resource_namespaces = {\n             resource[\"metadata\"].get(\"namespace\", \"default\")\n             for resource in last_applied_manifest\n         }\n \n         hook_resources = []\n         hook_sub_resources = []\n         if ca_certs:\n             hook_resources.extend(\n                 [\n                     self.secret_certs(\n                         secret_certs_name,\n                         resource_namespace,\n                         intermediate_src=intermediate_src,\n                         generated_cert=generated_cert,\n                         ca_certs=ca_certs,\n                     )\n                     for resource_namespace in resource_namespaces\n                 ]\n             )\n             hook_sub_resources.extend(\n                 [*self.volumes(secret_certs_name, volume_name, self.cert_dest)]\n             )\n \n         hook_resources.extend(\n             [\n                 self.secret_token(\n                     secret_token_name,\n                     name,\n                     namespace,\n                     resource_namespace,\n                     self.api_endpoint,\n                     token,\n                 )\n                 for resource_namespace in resource_namespaces\n             ]\n         )\n         hook_sub_resources.extend(\n             [\n                 *self.env_vars(secret_token_name),\n             ]\n         )\n \n         self.mangle(\n             hook_resources,\n             last_applied_manifest,\n             mangled_observer_schema,\n         )\n         self.mangle(\n             hook_sub_resources,\n             last_applied_manifest,\n             mangled_observer_schema,\n             is_sub_resource=True,\n         )\n \n     def mangle(\n         self,\n         items,\n         last_applied_manifest,\n         mangled_observer_schema,\n         is_sub_resource=False,\n     ):\n         \"\"\"Mangle applications desired state with custom hook resources or\n         sub-resources.\n \n         Example:\n             .. code:: python\n \n             last_applied_manifest = [\n                 {\n                     'apiVersion': 'v1',\n                     'kind': 'Pod',\n                     'metadata': {'name': 'test', 'namespace': 'default'},\n                     'spec': {'containers': [{'name': 'test'}]}\n                 }\n             ]\n             mangled_observer_schema = [\n                 {\n                     'apiVersion': 'v1',\n                     'kind': 'Pod',\n                     'metadata': {'name': 'test', 'namespace': 'default'},\n                     'spec': {\n                         'containers': [\n                             {'name': None},\n                             {\n                                 'observer_schema_list_max_length': 1,\n                                 'observer_schema_list_min_length': 1,\n                             },\n                         ]\n                     },\n                 }\n             ]\n             hook_resources = [\n                 {\n                     'apiVersion': 'v1',\n                     'kind': 'Secret',\n                     'metadata': {'name': 'sct', 'namespace': 'default'}\n                 }\n             ]\n             hook_sub_resources = [\n                 SubResource(\n                     group='env', name='env', body={'name': 'test', 'value': 'test'},\n                     path=(('spec', 'containers'),)\n                 )\n             ]\n \n             mangle(\n                 hook_resources,\n                 last_applied_manifest,\n                 mangled_observer_schema,\n             )\n             mangle(\n                 hook_sub_resources,\n                 last_applied_manifest,\n                 mangled_observer_schema,\n                 is_sub_resource=True\n             )\n \n             assert last_applied_manifest == [\n                 {\n                     \"apiVersion\": \"v1\",\n                     \"kind\": \"Pod\",\n                     \"metadata\": {\"name\": \"test\", 'namespace': 'default'},\n                     \"spec\": {\n                         \"containers\": [\n                             {\n                                 \"name\": \"test\",\n                                 \"env\": [{\"name\": \"test\", \"value\": \"test\"}]\n                             }\n                         ]\n                     },\n                 },\n                 {\"apiVersion\": \"v1\", \"kind\": \"Secret\", \"metadata\": {\"name\": \"sct\"}},\n             ]\n \n             assert mangled_observer_schema == [\n                 {\n                     \"apiVersion\": \"v1\",\n                     \"kind\": \"Pod\",\n                     \"metadata\": {\"name\": \"test\", \"namespace\": None},\n                     \"spec\": {\n                         \"containers\": [\n                             {\n                                 \"name\": None,\n                                 \"env\": [\n                                     {\"name\": None, \"value\": None},\n                                     {\n                                         \"observer_schema_list_max_length\": 1,\n                                         \"observer_schema_list_min_length\": 1,\n                                     },\n                                 ],\n                             },\n                             {\n                                 \"observer_schema_list_max_length\": 1,\n                                 \"observer_schema_list_min_length\": 1,\n                             },\n                         ]\n                     },\n                 },\n                 {\n                     \"apiVersion\": \"v1\",\n                     \"kind\": \"Secret\",\n                     \"metadata\": {\"name\": \"sct\", \"namespace\": None},\n                 },\n             ]\n \n         Args:\n             items (list[SubResource]): Custom hook resources or sub-resources\n             last_applied_manifest (list): Application resources\n             mangled_observer_schema (list): Observed resources\n             is_sub_resource (bool, optional): if False, the function only extend the\n                 list of Kubernetes resources defined in :attr:`last_applied_manifest`\n                 with new hook resources. Otherwise, the function injects each new hook\n                 sub-resource into the :attr:`last_applied_manifest` object\n                 sub-resources. Defaults to False.\n \n         \"\"\"\n \n         if not items:\n             return\n \n         if not is_sub_resource:\n             last_applied_manifest.extend(items)\n             for sub_resource in items:\n                 # Generate the default observer schema for each resource\n                 mangled_observer_schema.append(\n                     generate_default_observer_schema_dict(\n                         sub_resource,\n                         first_level=True,\n                     )\n                 )\n             return\n \n         def inject(sub_resource, sub_resource_to_mangle, observed_resource_to_mangle):\n             \"\"\"Inject a hooks defined sub-resource into a Kubernetes sub-resource.\n \n             Args:\n                 sub_resource (SubResource): Hook sub-resource that needs to be injected\n                     into :attr:`last_applied_manifest`\n                 sub_resource_to_mangle (object): Kubernetes sub-resources from\n                     :attr:`last_applied_manifest` which need to be processed\n                 observed_resource_to_mangle (dict): partial mangled_observer_schema\n                     corresponding to the Kubernetes sub-resource.\n \n             Raises:\n                 InvalidManifestError: if the sub-resource which will be mangled is not a\n                     list or a dict.\n \n             \"\"\"\n \n             # Create sub-resource group if not present in the Kubernetes sub-resource\n             if sub_resource.group not in sub_resource_to_mangle:\n                 # FIXME: This assumes the subresource group contains a list\n                 sub_resource_to_mangle.update({sub_resource.group: []})\n \n             # Create sub-resource group if not present in the observed fields\n             if sub_resource.group not in observed_resource_to_mangle:\n                 observed_resource_to_mangle.update(\n                     {\n                         sub_resource.group: [\n                             {\n                                 \"observer_schema_list_min_length\": 0,\n                                 \"observer_schema_list_max_length\": 0,\n                             }\n                         ]\n                     }\n                 )\n \n             # Inject sub-resource\n             # If sub-resource name is already there update it, if not, append it\n             if sub_resource.name in [\n                 g[\"name\"] for g in sub_resource_to_mangle[sub_resource.group]\n             ]:\n                 # FIXME: Assuming we are dealing with a list\n                 for idx, item in enumerate(sub_resource_to_mangle[sub_resource.group]):\n                     if item[\"name\"]:\n                         if hasattr(item, \"body\"):\n                             sub_resource_to_mangle[item.group][idx] = item[\"body\"]\n             else:\n                 sub_resource_to_mangle[sub_resource.group].append(sub_resource.body)\n \n             # Make sure the value is observed\n             if sub_resource.name not in [\n                 g[\"name\"] for g in observed_resource_to_mangle[sub_resource.group][:-1]\n             ]:\n                 observed_resource_to_mangle[sub_resource.group].insert(\n                     -1, generate_default_observer_schema_dict(sub_resource.body)\n                 )\n                 observed_resource_to_mangle[sub_resource.group][-1][\n                     \"observer_schema_list_min_length\"\n                 ] += 1\n                 observed_resource_to_mangle[sub_resource.group][-1][\n                     \"observer_schema_list_max_length\"\n                 ] += 1\n \n         for resource in last_applied_manifest:\n             # Complete hook is applied only on defined Kubernetes resources\n             if resource[\"kind\"] not in self.hook_resources:\n                 continue\n \n             for sub_resource in items:\n                 sub_resources_to_mangle = None\n                 idx_observed = get_kubernetes_resource_idx(\n                     mangled_observer_schema, resource\n                 )\n                 for keys in sub_resource.path:\n                     try:\n                         sub_resources_to_mangle = reduce(getitem, keys, resource)\n                     except KeyError:\n                         continue\n \n                     break\n \n                 # Create the path to the observed sub-resource, if it doesn't yet exist\n                 try:\n                     observed_sub_resources = reduce(\n                         getitem, keys, mangled_observer_schema[idx_observed]\n                     )\n                 except KeyError:\n                     Complete.create_path(\n                         mangled_observer_schema[idx_observed], list(keys)\n                     )\n                     observed_sub_resources = reduce(\n                         getitem, keys, mangled_observer_schema[idx_observed]\n                     )\n \n                 if isinstance(sub_resources_to_mangle, list):\n                     for idx, sub_resource_to_mangle in enumerate(\n                         sub_resources_to_mangle\n                     ):\n \n                         # Ensure that each element of the list is observed.\n                         idx_observed = idx\n                         if idx >= len(observed_sub_resources[:-1]):\n                             idx_observed = len(observed_sub_resources[:-1])\n                             # FIXME: Assuming each element of the list contains a\n                             # dictionary, therefore initializing new elements with an\n                             # empty dict\n                             observed_sub_resources.insert(-1, {})\n                         observed_sub_resource = observed_sub_resources[idx_observed]\n \n                         # FIXME: This is assuming a list always contains dict\n                         inject(\n                             sub_resource, sub_resource_to_mangle, observed_sub_resource\n                         )\n \n                 elif isinstance(sub_resources_to_mangle, dict):\n                     inject(\n                         sub_resource, sub_resources_to_mangle, observed_sub_resources\n                     )\n \n                 else:\n                     message = (\n                         f\"The sub-resource to mangle {sub_resources_to_mangle!r} has an\"\n                         \"invalid type, should be in '[dict, list]'\"\n                     )\n                     raise InvalidManifestError(message)\n \n     @staticmethod\n     def attribute_map(obj):\n         \"\"\"Convert a Kubernetes object to dict based on its attribute mapping\n \n         Example:\n             .. code:: python\n \n             from kubernetes_asyncio.client import V1VolumeMount\n \n             d = attribute_map(\n                     V1VolumeMount(name=\"name\", mount_path=\"path\")\n             )\n             assert d == {'mountPath': 'path', 'name': 'name'}\n \n         Args:\n             obj (object): Kubernetes object\n \n         Returns:\n             dict: Converted Kubernetes object\n \n         \"\"\"\n         return {\n             obj.attribute_map[attr]: getattr(obj, attr)\n             for attr, _ in obj.to_dict().items()\n             if getattr(obj, attr) is not None\n         }\n \n     @staticmethod\n     def create_path(mangled_observer_schema, keys):\n         \"\"\"Create the path to the observed field in the observer schema.\n \n         When a sub-resource is mangled, it should be observed. This function creates\n         the path to the subresource to observe.\n \n         Args:\n             mangled_observer_schema (dict): Partial observer schema of a resource\n             keys (list): list of keys forming the path to the sub-resource to\n                 observe\n \n         FIXME: This assumes we are only adding keys to dict. We don't consider lists\n \n         \"\"\"\n \n         # Unpack the first key first, as it contains the base directory\n         key = keys.pop(0)\n \n         # If the key is the last of the list, we reached the end of the path.\n         if len(keys) == 0:\n             mangled_observer_schema[key] = None\n             return\n \n         if key not in mangled_observer_schema:\n             mangled_observer_schema[key] = {}\n         Hook.create_path(mangled_observer_schema[key], keys)\n \n     def secret_certs(\n         self,\n         secret_name,\n         namespace,\n         ca_certs=None,\n         intermediate_src=None,\n         generated_cert=None,\n     ):\n         \"\"\"Create a complete hooks secret resource.\n \n         Complete hook secret stores Krake CAs and client certificates to communicate\n         with the Krake API.\n \n         Args:\n             secret_name (str): Secret name\n             namespace (str): Kubernetes namespace where the Secret will be created.\n             ca_certs (list): Krake CA list\n             intermediate_src (str): content of the certificate that is used to sign new\n                 certificates for the complete hook.\n             generated_cert (CertificatePair): tuple that contains the content of the\n                 new signed certificate for the Application, and the content of its\n                 corresponding key.\n \n         Returns:\n             dict: complete hook secret resource\n \n         \"\"\"\n         ca_certs_pem = \"\"\n         for ca_cert in ca_certs:\n             x509 = crypto.load_certificate(crypto.FILETYPE_ASN1, ca_cert)\n             ca_certs_pem += crypto.dump_certificate(crypto.FILETYPE_PEM, x509).decode()\n \n         # Add the intermediate certificate into the chain\n         with open(intermediate_src, \"r\") as f:\n             intermediate_src_content = f.read()\n         ca_certs_pem += intermediate_src_content\n \n         data = {\n             self.ca_name: self._encode_to_64(ca_certs_pem),\n             self.cert_name: self._encode_to_64(generated_cert.cert),\n             self.key_name: self._encode_to_64(generated_cert.key),\n         }\n         return self.secret(secret_name, data, namespace)\n \n     def secret_token(\n         self, secret_name, name, namespace, resource_namespace, api_endpoint, token\n     ):\n         \"\"\"Create a hooks secret resource.\n \n         The hook secret stores Krake authentication token\n         and hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n             name (str): Application name\n             namespace (str): Application namespace\n             resource_namespace (str): Kubernetes namespace where the\n                 Secret will be created.\n             api_endpoint (str): Krake API endpoint\n             token (str): Complete hook authentication token\n \n         Returns:\n             dict: complete hook secret resource\n \n         \"\"\"\n         pass\n \n     def volumes(self, secret_name, volume_name, mount_path):\n         \"\"\"Create complete hooks volume and volume mount sub-resources\n \n         Complete hook volume gives access to hook's secret, which stores\n         Krake CAs and client certificates to communicate with the Krake API.\n         Complete hook volume mount puts the volume into the application\n \n         Args:\n             secret_name (str): Secret name\n             volume_name (str): Volume name\n             mount_path (list): Volume mount path\n \n         Returns:\n             list: List of complete hook volume and volume mount sub-resources\n \n         \"\"\"\n         volume = V1Volume(name=volume_name, secret={\"secretName\": secret_name})\n         volume_mount = V1VolumeMount(name=volume_name, mount_path=mount_path)\n         return [\n             SubResource(\n                 group=\"volumes\",\n                 name=volume.name,\n                 body=self.attribute_map(volume),\n                 path=((\"spec\", \"template\", \"spec\"), (\"spec\",)),\n             ),\n             SubResource(\n                 group=\"volumeMounts\",\n                 name=volume_mount.name,\n                 body=self.attribute_map(volume_mount),\n                 path=(\n                     (\"spec\", \"template\", \"spec\", \"containers\"),\n                     (\"spec\", \"containers\"),  # kind: Pod\n                 ),\n             ),\n         ]\n \n     @staticmethod\n     def _encode_to_64(string):\n         \"\"\"Compute the base 64 encoding of a string.\n \n         Args:\n             string (str): the string to encode.\n \n         Returns:\n             str: the result of the encoding.\n \n         \"\"\"\n         return b64encode(string.encode()).decode()\n \n     def secret(self, secret_name, secret_data, namespace, _type=\"Opaque\"):\n         \"\"\"Create a secret resource.\n \n         Args:\n             secret_name (str): Secret name\n             secret_data (dict): Secret data\n             namespace (str): Kubernetes namespace where the Secret will be created.\n             _type (str, optional): Secret type. Defaults to Opaque.\n \n         Returns:\n             dict: secret resource\n \n         \"\"\"\n         return self.attribute_map(\n             V1Secret(\n                 api_version=\"v1\",\n                 kind=\"Secret\",\n                 data=secret_data,\n                 metadata={\"name\": secret_name, \"namespace\": namespace},\n                 type=_type,\n             )\n         )\n \n     @staticmethod\n     def create_hook_url(name, namespace, api_endpoint):\n         \"\"\"Create an applications' hook URL.\n         Function needs to be specified for each hook.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             api_endpoint (str): Krake API endpoint\n \n         Returns:\n             str: Application shutdown url\n \n         \"\"\"\n         pass\n \n     def env_vars(self, secret_name):\n         \"\"\"Create the hooks' environment variables sub-resources.\n         Function needs to be specified for each hook.\n \n         Creates hook environment variables to store Krake authentication token\n         and a hook URL for the given applications.\n \n         Args:\n             secret_name (str): Secret name\n \n         Returns:\n             list: List of shutdown hook environment variables sub-resources\n \n         \"\"\"\n         pass\n \n \n class Complete(Hook):\n     \"\"\"Mangle given application and inject complete hooks variables into it.\n \n     Hook injects a Kubernetes secret, which stores Krake authentication token\n     and the Krake complete hook URL for the given application. The variables\n     from Kubernetes secret are imported as environment variables\n     into the application resource definition. Only resources defined in\n     :args:`hook_resources` can be modified.\n \n     Names of environment variables are defined in the application controller\n     configuration file.\n \n     If TLS is enabled on the Krake API, the complete hook injects a Kubernetes secret,\n     and it's corresponding volume and volume mount definitions for the Krake CA,\n     the client certificate with the right CN, and its key. The directory where the\n     secret is mounted is defined in the configuration.\n \n     Args:\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         cert_dest (str, optional): Path of the directory where the CA, client\n             certificate and key to the Krake API will be stored.\n         env_token (str, optional): Name of the environment variable, which stores Krake\n             authentication token.\n         env_url (str, optional): Name of the environment variable,\n             which stores Krake complete hook URL.\n \n     \"\"\"\n \n     hook_resources = (\"Pod\", \"Deployment\", \"ReplicationController\")\n \n     def __init__(\n         self, api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n     ):\n         super().__init__(\n             api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n         )\n         self.env_url = env_url\n \n     def secret_token(\n         self, secret_name, name, namespace, resource_namespace, api_endpoint, token\n     ):\n         \"\"\"Create complete hooks secret resource.\n \n         Complete hook secret stores Krake authentication token\n         and complete hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n             name (str): Application name\n             namespace (str): Application namespace\n             resource_namespace (str): Kubernetes namespace where the\n                 Secret will be created.\n             api_endpoint (str): Krake API endpoint\n             token (str): Complete hook authentication token\n \n         Returns:\n             dict: complete hook secret resource\n \n         \"\"\"\n         complete_url = self.create_hook_url(name, namespace, api_endpoint)\n         data = {\n             self.env_token.lower(): self._encode_to_64(token),\n             self.env_url.lower(): self._encode_to_64(complete_url),\n         }\n         return self.secret(secret_name, data, resource_namespace)\n \n     @staticmethod\n     def create_hook_url(name, namespace, api_endpoint):\n         \"\"\"Create an applications' complete URL.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             api_endpoint (str): Krake API endpoint\n \n         Returns:\n             str: Application complete url\n \n         \"\"\"\n         api_url = URL(api_endpoint)\n         return str(\n             api_url.with_path(\n                 f\"/kubernetes/namespaces/{namespace}/applications/{name}/complete\"\n             )\n         )\n \n     def env_vars(self, secret_name):\n         \"\"\"Create complete hooks environment variables sub-resources\n \n         Create complete hook environment variables store Krake authentication token\n         and complete hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n \n         Returns:\n             list: List of complete hook environment variables sub-resources\n \n         \"\"\"\n         sub_resources = []\n \n         env_token = V1EnvVar(\n             name=self.env_token,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(\n                             name=secret_name, key=self.env_token.lower()\n                         )\n                     )\n                 )\n             ),\n         )\n         env_url = V1EnvVar(\n             name=self.env_url,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(name=secret_name, key=self.env_url.lower())\n                     )\n                 )\n             ),\n         )\n \n         for env in (env_token, env_url):\n             sub_resources.append(\n                 SubResource(\n                     group=\"env\",\n                     name=env.name,\n                     body=self.attribute_map(env),\n                     path=(\n                         (\"spec\", \"template\", \"spec\", \"containers\"),\n                         (\"spec\", \"containers\"),  # kind: Pod\n                     ),\n                 )\n             )\n         return sub_resources\n \n \n class Shutdown(Hook):\n     \"\"\"Mangle given application and inject shutdown hooks variables into it.\n \n     Hook injects a Kubernetes secret, which stores Krake authentication token\n     and the Krake complete hook URL for the given application. The variables\n     from the Kubernetes secret are imported as environment variables\n     into the application resource definition. Only resources defined in\n     :args:`hook_resources` can be modified.\n \n     Names of environment variables are defined in the application controller\n     configuration file.\n \n     If TLS is enabled on the Krake API, the shutdown hook injects a Kubernetes secret,\n     and it's corresponding volume and volume mount definitions for the Krake CA,\n     the client certificate with the right CN, and its key. The directory where the\n     secret is mounted is defined in the configuration.\n \n     Args:\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         cert_dest (str, optional): Path of the directory where the CA, client\n             certificate and key to the Krake API will be stored.\n         env_token (str, optional): Name of the environment variable, which stores Krake\n             authentication token.\n         env_url (str, optional): Name of the environment variable,\n             which stores Krake complete hook URL.\n \n     \"\"\"\n \n     hook_resources = (\"Pod\", \"Deployment\", \"ReplicationController\")\n \n     def __init__(\n         self, api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n     ):\n         super().__init__(\n             api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n         )\n         self.env_url = env_url\n \n     def secret_token(\n         self, secret_name, name, namespace, resource_namespace, api_endpoint, token\n     ):\n         \"\"\"Create shutdown hooks secret resource.\n \n         Shutdown hook secret stores Krake authentication token\n         and shutdown hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n             name (str): Application name\n             namespace (str): Application namespace\n             resource_namespace (str): Kubernetes namespace where the\n                 Secret will be created.\n             api_endpoint (str): Krake API endpoint\n             token (str): Shutdown hook authentication token\n \n         Returns:\n             dict: shutdown hook secret resource\n \n         \"\"\"\n         shutdown_url = self.create_hook_url(name, namespace, api_endpoint)\n         data = {\n             self.env_token.lower(): self._encode_to_64(token),\n             self.env_url.lower(): self._encode_to_64(shutdown_url),\n         }\n         return self.secret(secret_name, data, resource_namespace)\n \n     @staticmethod\n     def create_hook_url(name, namespace, api_endpoint):\n         \"\"\"Create an applications' shutdown URL.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             api_endpoint (str): Krake API endpoint\n \n         Returns:\n             str: Application shutdown url\n \n         \"\"\"\n         api_url = URL(api_endpoint)\n         return str(\n             api_url.with_path(\n                 f\"/kubernetes/namespaces/{namespace}/applications/{name}/shutdown\"\n             )\n         )\n \n     def env_vars(self, secret_name):\n         \"\"\"Create shutdown hooks environment variables sub-resources.\n \n         Creates shutdown hook environment variables to store Krake authentication token\n         and a shutdown hook URL for given applications.\n \n         Args:\n             secret_name (str): Secret name\n \n         Returns:\n             list: List of shutdown hook environment variables sub-resources\n \n         \"\"\"\n         sub_resources = []\n \n         env_resources = []\n \n         env_token = V1EnvVar(\n             name=self.env_token,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(\n                             name=secret_name,\n                             key=self.env_token.lower()\n                         )\n                     )\n                 )\n             )\n         )\n         env_resources.append(env_token)\n \n         env_url = V1EnvVar(\n             name=self.env_url,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(name=secret_name, key=self.env_url.lower())\n                     )\n                 )\n             ),\n         )\n         env_resources.append(env_url)\n \n         for env in env_resources:\n             sub_resources.append(\n                 SubResource(\n                     group=\"env\",\n                     name=env.name,\n                     body=self.attribute_map(env),\n                     path=(\n                         (\"spec\", \"template\", \"spec\", \"containers\"),\n                         (\"spec\", \"containers\"),  # kind: Pod\n                     ),\n                 )\n             )\n         return sub_resources\n ", "input_code": "def update_last_applied_manifest_list_from_resp(last_applied_manifest, observer_schema, response):\n\"\"\"\nTogether with :func:``update_last_applied_manifest_dict_from_resp``, this\nfunction is called recursively to update a partial ``last_applied_manifest``\nfrom a partial Kubernetes response\n\nArgs:\n    last_applied_manifest (list): partial ``last_applied_manifest`` being\n        updated\n    observer_schema (list): partial ``observer_schema``\n    response (list): partial response from the Kubernetes API.\n\nThis function go through all observed fields, and initialized their value in\nlast_applied_manifest if they are not yet present\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def update_last_applied_manifest_list_from_resp(\n    last_applied_manifest, observer_schema, response\n):\n    \"\"\"Together with :func:``update_last_applied_manifest_dict_from_resp``, this\n    function is called recursively to update a partial ``last_applied_manifest``\n    from a partial Kubernetes response\n\n    Args:\n        last_applied_manifest (list): partial ``last_applied_manifest`` being\n            updated\n        observer_schema (list): partial ``observer_schema``\n        response (list): partial response from the Kubernetes API.\n\n    This function go through all observed fields, and initialized their value in\n    last_applied_manifest if they are not yet present\n\n    \"\"\"\n    # Looping over the observed resource, except the last element which is the\n    # special control dictionary\n    for idx, val in enumerate(observer_schema[:-1]):\n\n        if idx >= len(response):\n            # Element is observed but not present in k8s response, so following\n            # elements will also not exist.\n            #\n            # This doesn't raise an Exception as observing the element of a list\n            # doesn't ensure its presence. The list length is controlled by the\n            # special control dictionary\n            return\n\n        if isinstance(val, dict):\n            if idx >= len(last_applied_manifest):\n                # The dict is observed, but not present in last_applied_manifest\n                last_applied_manifest.append({})\n\n            update_last_applied_manifest_dict_from_resp(\n                last_applied_manifest[idx], observer_schema[idx], response[idx]\n            )\n\n        elif isinstance(response[idx], list):\n            if idx >= len(last_applied_manifest):\n                # The list is observed, but not present in last_applied_manifest\n                last_applied_manifest.append([])\n\n            update_last_applied_manifest_list_from_resp(\n                last_applied_manifest[idx], observer_schema[idx], response[idx]\n            )\n\n        elif idx >= len(last_applied_manifest):\n            # Element is not yet present in last_applied_manifest. Adding it.\n            last_applied_manifest.append(response[idx])", "signature": "def update_last_applied_manifest_list_from_resp(last_applied_manifest, observer_schema, response):", "completion_path": "krake/krake/controller/kubernetes/hooks.py"}
{"ce_id": "62b869eab4d922cb0e688cc5", "namespace": "62b869eab4d922cb0e688cc5", "namespace_real": "krake.krake.controller.kubernetes.hooks.update_last_applied_manifest_dict_from_resp", "real_proj_path": "rak-n-rok---Krake/", "type": "function", "class_name": null, "function_name": "update_last_applied_manifest_dict_from_resp", "contexts_above": "\"\"\"This module defines the Hook Dispatcher and listeners for registering and\nexecuting hooks. Hook Dispatcher emits hooks based on :class:`Hook` attributes which\ndefine when the hook will be executed.\n\n\"\"\"\nimport asyncio\nimport logging\nimport random\nfrom base64 import b64encode\nfrom collections import defaultdict\nfrom contextlib import suppress\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom functools import reduce\nfrom operator import getitem\nfrom enum import Enum, auto\nfrom inspect import iscoroutinefunction\nfrom OpenSSL import crypto\nfrom typing import NamedTuple\n\nimport yarl\nfrom aiohttp import ClientConnectorError\n\nfrom krake.controller import Observer\nfrom krake.controller.kubernetes.client import KubernetesClient, InvalidManifestError\nfrom krake.utils import camel_to_snake_case, get_kubernetes_resource_idx\nfrom kubernetes_asyncio.client.rest import ApiException\nfrom kubernetes_asyncio.client.api_client import ApiClient\nfrom kubernetes_asyncio import client\nfrom krake.data.kubernetes import ClusterState, Application, Cluster\nfrom yarl import URL\nfrom secrets import token_urlsafe\n\nfrom kubernetes_asyncio.client import (\n    Configuration,\n    V1Secret,\n    V1EnvVar,\n    V1VolumeMount,\n    V1Volume,\n    V1SecretKeySelector,\n    V1EnvVarSource,\n)\nfrom kubernetes_asyncio.config.kube_config import KubeConfigLoader\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass HookType(Enum):\n    ResourcePreCreate = auto()\n    ResourcePostCreate = auto()\n    ResourcePreUpdate = auto()\n    ResourcePostUpdate = auto()\n    ResourcePreDelete = auto()\n    ResourcePostDelete = auto()\n    ApplicationMangling = auto()\n    ApplicationPreMigrate = auto()\n    ApplicationPostMigrate = auto()\n    ApplicationPreReconcile = auto()\n    ApplicationPostReconcile = auto()\n    ApplicationPreDelete = auto()\n    ApplicationPostDelete = auto()\n    ClusterCreation = auto()\n    ClusterDeletion = auto()\n\n\nclass HookDispatcher(object):\n    \"\"\"Simple wrapper around a registry of handlers associated to :class:`Hook`\n     attributes. Each :class:`Hook` attribute defines when the handler will be\n     executed.\n\n    Listeners for certain hooks can be registered via :meth:`on`. Registered\n    listeners are executed via :meth:`hook`.\n\n    Example:\n        .. code:: python\n\n        listen = HookDispatcher()\n\n        @listen.on(HookType.PreApply)\n        def to_perform_before_app_creation(app, cluster, resource, controller):\n            # Do Stuff\n\n        @listen.on(HookType.PostApply)\n        def another_to_perform_after_app_creation(app, cluster, resource, resp):\n            # Do Stuff\n\n        @listen.on(HookType.PostDelete)\n        def to_perform_after_app_deletion(app, cluster, resource, resp):\n            # Do Stuff\n\n    \"\"\"\n\n    def __init__(self):\n        self.registry = defaultdict(list)\n\n    def on(self, hook):\n        \"\"\"Decorator function to add a new handler to the registry.\n\n        Args:\n            hook (HookType): Hook attribute for which to register the handler.\n\n        Returns:\n            callable: Decorator for registering listeners for the specified\n            hook.\n\n        \"\"\"\n\n        def decorator(handler):\n            self.registry[hook].append(handler)\n\n            return handler\n\n        return decorator\n\n    async def hook(self, hook, **kwargs):\n        \"\"\"Execute the list of handlers associated to the provided :class:`Hook`\n        attribute.\n\n        Args:\n            hook (HookType): The hook attribute for which to execute handlers.\n\n        \"\"\"\n        try:\n            handlers = self.registry[hook]\n        except KeyError:\n            pass\n        else:\n            for handler in handlers:\n                if iscoroutinefunction(handler):\n                    await handler(**kwargs)\n                else:\n                    handler(**kwargs)\n\n\nlisten = HookDispatcher()\n\n\n@listen.on(HookType.ResourcePostCreate)\n@listen.on(HookType.ResourcePostUpdate)\nasync def register_service(app, cluster, resource, response):\n    \"\"\"Register endpoint of Kubernetes Service object on creation and update.\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        cluster (krake.data.kubernetes.Cluster): The cluster on which the\n            application is running\n        resource (dict): Kubernetes object description as specified in the\n            specification of the application.\n        response (kubernetes_asyncio.client.V1Service): Response of the\n            Kubernetes API\n\n    \"\"\"\n    if resource[\"kind\"] != \"Service\":\n        return\n\n    service_name = resource[\"metadata\"][\"name\"]\n\n    if response.spec and response.spec.type == \"LoadBalancer\":\n        # For a \"LoadBalancer\" type of Service, an external IP is given in the cluster\n        # by a load balancer controller to the service. In this case, the \"port\"\n        # specified in the spec is reachable from the outside.\n        if (\n            not response.status.load_balancer\n            or not response.status.load_balancer.ingress\n        ):\n            # When a \"LoadBalancer\" type of service is created, the IP is given by an\n            # additional controller (e.g. a controller that requests a floating IP to an\n            # OpenStack infrastructure). This process can take some time, but the\n            # Service itself already exist before the IP is assigned. In the case of an\n            # error with the controller, the IP is also not given. This \"<pending>\" IP\n            # just expresses that the Service exists, but the IP is not ready yet.\n            external_ip = \"<pending>\"\n        else:\n            external_ip = response.status.load_balancer.ingress[0].ip\n\n        if not response.spec.ports:\n            external_port = \"<pending>\"\n        else:\n            external_port = response.spec.ports[0].port\n        app.status.services[service_name] = f\"{external_ip}:{external_port}\"\n        return\n\n    node_port = None\n    # Ensure that ports are specified\n    if response.spec and response.spec.ports:\n        node_port = response.spec.ports[0].node_port\n\n    # If the service does not have a node port, remove a potential reference\n    # and return.\n    if node_port is None:\n        try:\n            del app.status.services[service_name]\n        except KeyError:\n            pass\n        return\n\n    # Determine URL of Kubernetes cluster API\n    loader = KubeConfigLoader(cluster.spec.kubeconfig)\n    config = Configuration()\n    await loader.load_and_set(config)\n    cluster_url = yarl.URL(config.host)\n\n    app.status.services[service_name] = f\"{cluster_url.host}:{node_port}\"\n\n\n@listen.on(HookType.ResourcePostDelete)\nasync def unregister_service(app, resource, **kwargs):\n    \"\"\"Unregister endpoint of Kubernetes Service object on deletion.\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        resource (dict): Kubernetes object description as specified in the\n            specification of the application.\n\n    \"\"\"\n    if resource[\"kind\"] != \"Service\":\n        return\n\n    service_name = resource[\"metadata\"][\"name\"]\n    try:\n        del app.status.services[service_name]\n    except KeyError:\n        pass\n\n\n@listen.on(HookType.ResourcePostDelete)\nasync def remove_resource_from_last_observed_manifest(app, resource, **kwargs):\n    \"\"\"Remove a given resource from the last_observed_manifest after its deletion\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        resource (dict): Kubernetes object description as specified in the\n            specification of the application.\n\n    \"\"\"\n    try:\n        idx = get_kubernetes_resource_idx(app.status.last_observed_manifest, resource)\n    except IndexError:\n        return\n\n    app.status.last_observed_manifest.pop(idx)\n\n", "contexts_below": "\n def update_last_applied_manifest_list_from_resp(\n     last_applied_manifest, observer_schema, response\n ):\n     \"\"\"Together with :func:``update_last_applied_manifest_dict_from_resp``, this\n     function is called recursively to update a partial ``last_applied_manifest``\n     from a partial Kubernetes response\n \n     Args:\n         last_applied_manifest (list): partial ``last_applied_manifest`` being\n             updated\n         observer_schema (list): partial ``observer_schema``\n         response (list): partial response from the Kubernetes API.\n \n     This function go through all observed fields, and initialized their value in\n     last_applied_manifest if they are not yet present\n \n     \"\"\"\n     # Looping over the observed resource, except the last element which is the\n     # special control dictionary\n     for idx, val in enumerate(observer_schema[:-1]):\n \n         if idx >= len(response):\n             # Element is observed but not present in k8s response, so following\n             # elements will also not exist.\n             #\n             # This doesn't raise an Exception as observing the element of a list\n             # doesn't ensure its presence. The list length is controlled by the\n             # special control dictionary\n             return\n \n         if isinstance(val, dict):\n             if idx >= len(last_applied_manifest):\n                 # The dict is observed, but not present in last_applied_manifest\n                 last_applied_manifest.append({})\n \n             update_last_applied_manifest_dict_from_resp(\n                 last_applied_manifest[idx], observer_schema[idx], response[idx]\n             )\n \n         elif isinstance(response[idx], list):\n             if idx >= len(last_applied_manifest):\n                 # The list is observed, but not present in last_applied_manifest\n                 last_applied_manifest.append([])\n \n             update_last_applied_manifest_list_from_resp(\n                 last_applied_manifest[idx], observer_schema[idx], response[idx]\n             )\n \n         elif idx >= len(last_applied_manifest):\n             # Element is not yet present in last_applied_manifest. Adding it.\n             last_applied_manifest.append(response[idx])\n \n \n @listen.on(HookType.ResourcePostCreate)\n @listen.on(HookType.ResourcePostUpdate)\n def update_last_applied_manifest_from_resp(app, response, **kwargs):\n     \"\"\"Hook run after the creation or update of an application in order to update the\n     `status.last_applied_manifest` using the k8s response.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application the service belongs to\n         response (kubernetes_asyncio.client.V1Status): Response of the Kubernetes API\n \n     After a Kubernetes resource has been created/updated, the\n     `status.last_applied_manifest` has to be updated. All fields already initialized\n     (either from the mangling of `spec.manifest`, or by a previous call to this\n     function) should be left untouched. Only observed fields which are not present in\n     `status.last_applied_manifest` should be initialized.\n \n     \"\"\"\n \n     if isinstance(response, dict):\n         # The Kubernetes API couldn't deserialize the k8s response into an object\n         resp = response\n     else:\n         # The Kubernetes API deserialized the k8s response into an object\n         resp = response.to_dict()\n \n     idx_applied = get_kubernetes_resource_idx(app.status.last_applied_manifest, resp)\n \n     idx_observed = get_kubernetes_resource_idx(app.status.mangled_observer_schema, resp)\n \n     update_last_applied_manifest_dict_from_resp(\n         app.status.last_applied_manifest[idx_applied],\n         app.status.mangled_observer_schema[idx_observed],\n         resp,\n     )\n \n \n @listen.on(HookType.ResourcePostCreate)\n @listen.on(HookType.ResourcePostUpdate)\n def update_last_observed_manifest_from_resp(app, response, **kwargs):\n     \"\"\"Handler to run after the creation or update of a Kubernetes resource to update\n     the last_observed_manifest from the response of the Kubernetes API.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application the service belongs to\n         response (kubernetes_asyncio.client.V1Service): Response of the\n             Kubernetes API\n \n     The target last_observed_manifest holds the value of all observed fields plus the\n     special control dictionaries for the list length\n \n     \"\"\"\n     if isinstance(response, dict):\n         # The Kubernetes API couldn't deserialize the k8s response into an object\n         resp = response\n     else:\n         # The Kubernetes API deserialized the k8s response into an object\n         resp = response.to_dict()\n \n     try:\n         idx_observed = get_kubernetes_resource_idx(\n             app.status.mangled_observer_schema,\n             resp,\n         )\n     except IndexError:\n         # All created resources should be observed\n         raise\n \n     try:\n         idx_last_observed = get_kubernetes_resource_idx(\n             app.status.last_observed_manifest,\n             resp,\n         )\n     except IndexError:\n         # If the resource is not yes present in last_observed_manifest, append it.\n         idx_last_observed = len(app.status.last_observed_manifest)\n         app.status.last_observed_manifest.append({})\n \n     # Overwrite the last_observed_manifest for this resource\n     app.status.last_observed_manifest[\n         idx_last_observed\n     ] = update_last_observed_manifest_dict(\n         app.status.mangled_observer_schema[idx_observed], resp\n     )\n \n \n def update_last_observed_manifest_dict(observed_resource, response):\n     \"\"\"Together with :func:``update_last_observed_manifest_list``, recursively\n     crafts the ``last_observed_manifest`` from the Kubernetes :attr:``response``.\n \n     Args:\n         observed_resource (dict): The schema to observe for the partial given resource\n         response (dict): The partial Kubernetes response for this resource.\n \n     Raises:\n         KeyError: If an observed key is not present in the Kubernetes response\n \n     Returns:\n         dict: The dictionary of observed keys and their value\n \n     Get the value of all observed fields from the Kubernetes response\n     \"\"\"\n     res = {}\n     for key, value in observed_resource.items():\n \n         camel_key = camel_to_snake_case(key)\n         if camel_key not in response:\n             raise KeyError(\n                 f\"Observed key {camel_key} is not present in response {response}\"\n             )\n \n         if isinstance(value, dict):\n             res[key] = update_last_observed_manifest_dict(value, response[camel_key])\n \n         elif isinstance(value, list):\n             res[key] = update_last_observed_manifest_list(value, response[camel_key])\n \n         else:\n             res[key] = response[camel_key]\n \n     return res\n \n \n def update_last_observed_manifest_list(observed_resource, response):\n     \"\"\"Together with :func:``update_last_observed_manifest_dict``, recursively\n     crafts the ``last_observed_manifest`` from the Kubernetes :attr:``response``.\n \n     Args:\n         observed_resource (list): the schema to observe for the partial given resource\n         response (list): the partial Kubernetes response for this resource.\n \n     Returns:\n         list: The list of observed elements, plus the special list length control\n             dictionary\n \n     Get the value of all observed elements from the Kubernetes response\n     \"\"\"\n \n     if not response:\n         return [{\"observer_schema_list_current_length\": 0}]\n \n     res = []\n     # Looping over the observed resource, except the last element which is the special\n     # control dictionary\n     for idx, val in enumerate(observed_resource[:-1]):\n \n         if idx >= len(response):\n             # Element is not present in the Kubernetes response, nothing more to do\n             break\n \n         if type(response[idx]) == dict:\n             res.append(update_last_observed_manifest_dict(val, response[idx]))\n \n         elif type(response[idx]) == list:\n             res.append(update_last_observed_manifest_list(val, response[idx]))\n \n         else:\n             res.append(response[idx])\n \n     # Append the special control dictionary to the list\n     res.append({\"observer_schema_list_current_length\": len(response)})\n \n     return res\n \n \n def update_last_applied_manifest_dict_from_spec(\n     resource_status_new, resource_status_old, resource_observed\n ):\n     \"\"\"Together with :func:``update_last_applied_manifest_list_from_spec``, this\n     function is called recursively to update a partial ``last_applied_manifest``\n \n     Args:\n         resource_status_new (dict): partial ``last_applied_manifest`` being updated\n         resource_status_old (dict): partial of the current ``last_applied_manifest``\n         resource_observed (dict): partial observer_schema for the manifest file\n             being updated\n \n     \"\"\"\n     for key, value in resource_observed.items():\n \n         if key not in resource_status_old:\n             continue\n \n         if key in resource_status_new:\n \n             if isinstance(value, dict):\n                 update_last_applied_manifest_dict_from_spec(\n                     resource_status_new[key],\n                     resource_status_old[key],\n                     resource_observed[key],\n                 )\n \n             elif isinstance(value, list):\n                 update_last_applied_manifest_list_from_spec(\n                     resource_status_new[key],\n                     resource_status_old[key],\n                     resource_observed[key],\n                 )\n \n         else:\n             # If the key is not present the spec.manifest, we first need to\n             # initialize it\n \n             if isinstance(value, dict):\n                 resource_status_new[key] = {}\n                 update_last_applied_manifest_dict_from_spec(\n                     resource_status_new[key],\n                     resource_status_old[key],\n                     resource_observed[key],\n                 )\n \n             elif isinstance(value, list):\n                 resource_status_new[key] = []\n                 update_last_applied_manifest_list_from_spec(\n                     resource_status_new[key],\n                     resource_status_old[key],\n                     resource_observed[key],\n                 )\n \n             else:\n                 resource_status_new[key] = resource_status_old[key]\n \n \n def update_last_applied_manifest_list_from_spec(\n     resource_status_new, resource_status_old, resource_observed\n ):\n     \"\"\"Together with :func:``update_last_applied_manifest_dict_from_spec``, this\n     function is called recursively to update a partial ``last_applied_manifest``\n \n     Args:\n         resource_status_new (list): partial ``last_applied_manifest`` being updated\n         resource_status_old (list): partial of the current ``last_applied_manifest``\n         resource_observed (list): partial observer_schema for the manifest file\n             being updated\n \n     \"\"\"\n \n     # Looping over the observed resource, except the last element which is the\n     # special control dictionary\n     for idx, val in enumerate(resource_observed[:-1]):\n \n         if idx >= len(resource_status_old):\n             # The element in not in the current last_applied_manifest, and neither\n             # is the rest of the list\n             break\n \n         if idx < len(resource_status_new):\n             # The element is present in spec.manifest and in the current\n             # last_applied_manifest. Updating observed fields\n \n             if isinstance(val, dict):\n                 update_last_applied_manifest_dict_from_spec(\n                     resource_status_new[idx],\n                     resource_status_old[idx],\n                     resource_observed[idx],\n                 )\n \n             elif isinstance(val, list):\n                 update_last_applied_manifest_list_from_spec(\n                     resource_status_new[idx],\n                     resource_status_old[idx],\n                     resource_observed[idx],\n                 )\n \n         else:\n             # If the element is not present in the spec.manifest, we first have to\n             # initialize it.\n \n             if isinstance(val, dict):\n                 resource_status_new.append({})\n                 update_last_applied_manifest_dict_from_spec(\n                     resource_status_new[idx],\n                     resource_status_old[idx],\n                     resource_observed[idx],\n                 )\n \n             elif isinstance(val, list):\n                 resource_status_new.append([])\n                 update_last_applied_manifest_list_from_spec(\n                     resource_status_new[idx],\n                     resource_status_old[idx],\n                     resource_observed[idx],\n                 )\n \n             else:\n                 resource_status_new.append(resource_status_old[idx])\n \n \n def update_last_applied_manifest_from_spec(app):\n     \"\"\"Update the status.last_applied_manifest of an application from spec.manifests\n \n     Args:\n         app (krake.data.kubernetes.Application): Application to update\n \n     This function is called on application creation and updates. The\n     last_applied_manifest of an application is initialized as a copy of spec.manifest,\n     and is augmented by all known observed fields not yet initialized (i.e. all observed\n     fields or resources which are present in the current last_applied_manifest but not\n     in the spec.manifest)\n \n     \"\"\"\n \n     # The new last_applied_manifest is initialized as a copy of the spec.manifest, and\n     # augmented by all observed fields which are present in the current\n     # last_applied_manifest but not in the original spec.manifest\n     new_last_applied_manifest = deepcopy(app.spec.manifest)\n \n     # Loop over observed resources and observed fields, and check if they should be\n     # added to the new last_applied_manifest (i.e. present in the current\n     # last_applied_manifest but not in spec.manifest)\n     for resource_observed in app.status.mangled_observer_schema:\n \n         # If the resource is not present in the current last_applied_manifest, there is\n         # nothing to do. Whether the resource was initialized by spec.manifest doesn't\n         # matter.\n         try:\n             idx_status_old = get_kubernetes_resource_idx(\n                 app.status.last_applied_manifest, resource_observed\n             )\n         except IndexError:\n             continue\n \n         # As the resource is present in the current last_applied_manifest, we need to go\n         # through it to check if observed fields should be set to their current value\n         # (i.e. fields are present in the current last_applied_manifest, but not in\n         # spec.manifest)\n         try:\n             # Check if the observed resource is present in spec.manifest\n             idx_status_new = get_kubernetes_resource_idx(\n                 new_last_applied_manifest, resource_observed\n             )\n         except IndexError:\n             # The resource is observed but is not present in the spec.manifest.\n             # Create an empty resource, which will be augmented in\n             # update_last_applied_manifest_dict_from_spec with the observed and known\n             # fields.\n             new_last_applied_manifest.append({})\n             idx_status_new = len(new_last_applied_manifest) - 1\n \n         update_last_applied_manifest_dict_from_spec(\n             new_last_applied_manifest[idx_status_new],\n             app.status.last_applied_manifest[idx_status_old],\n             resource_observed,\n         )\n \n     app.status.last_applied_manifest = new_last_applied_manifest\n \n \n class KubernetesApplicationObserver(Observer):\n     \"\"\"Observer specific for Kubernetes Applications. One observer is created for each\n     Application managed by the Controller, but not one per Kubernetes resource\n     (Deployment, Service...). If several resources are defined by an Application, they\n     are all monitored by the same observer.\n \n     The observer gets the actual status of the resources on the cluster using the\n     Kubernetes API, and compare it to the status stored in the API.\n \n     The observer is:\n      * started at initial Krake resource creation;\n \n      * deleted when a resource needs to be updated, then started again when it is done;\n \n      * simply deleted on resource deletion.\n \n     Args:\n         cluster (krake.data.kubernetes.Cluster): the cluster on which the observed\n             Application is created.\n         resource (krake.data.kubernetes.Application): the application that will be\n             observed.\n         on_res_update (coroutine): a coroutine called when a resource's actual status\n             differs from the status sent by the database. Its signature is:\n             ``(resource) -> updated_resource``. ``updated_resource`` is the instance of\n             the resource that is up-to-date with the API. The Observer internal instance\n             of the resource to observe will be updated. If the API cannot be contacted,\n             ``None`` can be returned. In this case the internal instance of the Observer\n             will not be updated.\n         time_step (int, optional): how frequently the Observer should watch the actual\n             status of the resources.\n \n     \"\"\"\n \n     def __init__(self, cluster, resource, on_res_update, time_step=2):\n         super().__init__(resource, on_res_update, time_step)\n         self.cluster = cluster\n \n     async def poll_resource(self):\n         \"\"\"Fetch the current status of the Application monitored by the Observer.\n \n         Returns:\n             krake.data.core.Status: the status object created using information from the\n                 real world Applications resource.\n \n         \"\"\"\n         app = self.resource\n \n         status = deepcopy(app.status)\n         status.last_observed_manifest = []\n         # For each observed kubernetes resource of the Application,\n         # get its current status on the cluster.\n         for desired_resource in app.status.last_applied_manifest:\n             kube = KubernetesClient(self.cluster.spec.kubeconfig)\n             idx_observed = get_kubernetes_resource_idx(\n                 app.status.mangled_observer_schema, desired_resource\n             )\n             observed_resource = app.status.mangled_observer_schema[idx_observed]\n             async with kube:\n                 try:\n                     group, version, kind, name, namespace = kube.get_immutables(\n                         desired_resource\n                     )\n                     resource_api = await kube.get_resource_api(group, version, kind)\n                     resp = await resource_api.read(kind, name, namespace)\n                 except ApiException as err:\n                     if err.status == 404:\n                         # Resource does not exist\n                         continue\n                     # Otherwise, log the unexpected errors\n                     logger.error(err)\n \n             observed_manifest = update_last_observed_manifest_dict(\n                 observed_resource, resp.to_dict()\n             )\n             status.last_observed_manifest.append(observed_manifest)\n \n         return status\n \n \n class KubernetesClusterObserver(Observer):\n     \"\"\"Observer specific for Kubernetes Clusters. One observer is created for each\n     Cluster managed by the Controller.\n \n     The observer gets the actual status of the cluster using the\n     Kubernetes API, and compare it to the status stored in the API.\n \n     The observer is:\n      * started at initial Krake resource creation;\n \n      * deleted when a resource needs to be updated, then started again when it is done;\n \n      * simply deleted on resource deletion.\n \n     Args:\n         cluster (krake.data.kubernetes.Cluster): the cluster which will be observed.\n         on_res_update (coroutine): a coroutine called when a resource's actual status\n             differs from the status sent by the database. Its signature is:\n             ``(resource) -> updated_resource``. ``updated_resource`` is the instance of\n             the resource that is up-to-date with the API. The Observer internal instance\n             of the resource to observe will be updated. If the API cannot be contacted,\n             ``None`` can be returned. In this case the internal instance of the Observer\n             will not be updated.\n         time_step (int, optional): how frequently the Observer should watch the actual\n             status of the resources.\n \n     \"\"\"\n \n     def __init__(self, cluster, on_res_update, time_step=2):\n         super().__init__(cluster, on_res_update, time_step)\n         self.cluster = cluster\n \n     async def poll_resource(self):\n         \"\"\"Fetch the current status of the Cluster monitored by the Observer.\n \n         Returns:\n             krake.data.core.Status: the status object created using information from the\n                 real world Cluster.\n \n         \"\"\"\n         status = deepcopy(self.cluster.status)\n         # For each observed kubernetes cluster registered in Krake,\n         # get its current node status.\n         loader = KubeConfigLoader(self.cluster.spec.kubeconfig)\n         config = Configuration()\n         await loader.load_and_set(config)\n         kube = ApiClient(config)\n \n         async with kube as api:\n             v1 = client.CoreV1Api(api)\n             try:\n                 response = await v1.list_node()\n \n             except ClientConnectorError as err:\n                 status.state = ClusterState.OFFLINE\n                 self.cluster.status.state = ClusterState.OFFLINE\n                 # Log the error\n                 logger.debug(err)\n                 return status\n \n             condition_dict = {\n                 \"MemoryPressure\": [],\n                 \"DiskPressure\": [],\n                 \"PIDPressure\": [],\n                 \"Ready\": [],\n             }\n \n             for item in response.items:\n                 for condition in item.status.conditions:\n                     condition_dict[condition.type].append(condition.status)\n                 if (\n                     condition_dict[\"MemoryPressure\"] == [\"True\"]\n                     or condition_dict[\"DiskPressure\"] == [\"True\"]\n                     or condition_dict[\"PIDPressure\"] == [\"True\"]\n                 ):\n                     status.state = ClusterState.UNHEALTHY\n                     self.cluster.status.state = ClusterState.UNHEALTHY\n                     return status\n                 elif (\n                     condition_dict[\"Ready\"] == [\"True\"]\n                     and status.state is ClusterState.OFFLINE\n                 ):\n                     status.state = ClusterState.CONNECTING\n                     self.cluster.status.state = ClusterState.CONNECTING\n                     return status\n                 elif condition_dict[\"Ready\"] == [\"True\"]:\n                     status.state = ClusterState.ONLINE\n                     self.cluster.status.state = ClusterState.ONLINE\n                     return status\n                 else:\n                     status.state = ClusterState.NOTREADY\n                     self.cluster.status.state = ClusterState.NOTREADY\n                     return status\n \n \n @listen.on(HookType.ApplicationPostReconcile)\n @listen.on(HookType.ApplicationPostMigrate)\n @listen.on(HookType.ClusterCreation)\n async def register_observer(controller, resource, start=True, **kwargs):\n     \"\"\"Create an observer for the given Application or Cluster, and start it as a\n     background task if wanted.\n \n     If an observer already existed for this Application or Cluster, it is stopped\n     and deleted.\n \n     Args:\n         controller (KubernetesController): the controller for which the observer will be\n             added in the list of working observers.\n         resource (krake.data.kubernetes.Application): the Application to observe or\n         resource (krake.data.kubernetes.Cluster): the Cluster to observe.\n         start (bool, optional): if False, does not start the observer as background\n             task.\n \n     \"\"\"\n     if resource.kind == Application.kind:\n         cluster = await controller.kubernetes_api.read_cluster(\n             namespace=resource.status.running_on.namespace,\n             name=resource.status.running_on.name,\n         )\n \n         observer = KubernetesApplicationObserver(\n             cluster,\n             resource,\n             controller.on_status_update,\n             time_step=controller.observer_time_step,\n         )\n \n     elif resource.kind == Cluster.kind:\n         observer = KubernetesClusterObserver(\n             resource,\n             controller.on_status_update,\n             time_step=controller.observer_time_step,\n         )\n     else:\n         logger.debug(\"Unknown resource kind. No observer was registered.\", resource)\n         return\n \n     logger.debug(f\"Start observer for {resource.kind} %r\", resource.metadata.name)\n     task = None\n     if start:\n         task = controller.loop.create_task(observer.run())\n \n     controller.observers[resource.metadata.uid] = (observer, task)\n \n \n @listen.on(HookType.ApplicationPreReconcile)\n @listen.on(HookType.ApplicationPreMigrate)\n @listen.on(HookType.ApplicationPreDelete)\n @listen.on(HookType.ClusterDeletion)\n async def unregister_observer(controller, resource, **kwargs):\n     \"\"\"Stop and delete the observer for the given Application or Cluster. If no observer\n     is started, do nothing.\n \n     Args:\n         controller (KubernetesController): the controller for which the observer will be\n             removed from the list of working observers.\n         resource (krake.data.kubernetes.Application): the Application whose observer\n         will be stopped or\n         resource (krake.data.kubernetes.Cluster): the Cluster whose observer will be\n         stopped.\n \n     \"\"\"\n     if resource.metadata.uid not in controller.observers:\n         return\n \n     logger.debug(f\"Stop observer for {resource.kind} %r\", resource.metadata.name)\n     _, task = controller.observers.pop(resource.metadata.uid)\n     task.cancel()\n \n     with suppress(asyncio.CancelledError):\n         await task\n \n \n def utc_difference():\n     \"\"\"Get the difference in seconds between the current time and the current UTC time.\n \n     Returns:\n         int: the time difference in seconds.\n \n     \"\"\"\n     delta = datetime.now() - datetime.utcnow()\n     return delta.seconds\n \n \n def generate_certificate(config):\n     \"\"\"Create and sign a new certificate using the one defined in the complete hook\n     configuration as intermediate certificate.\n \n     Args:\n         config (krake.data.config.CompleteHookConfiguration): the configuration of the\n             complete hook.\n \n     Returns:\n         CertificatePair: the content of the certificate created and its corresponding\n             key.\n \n     \"\"\"\n     with open(config.intermediate_src, \"rb\") as f:\n         intermediate_src = crypto.load_certificate(crypto.FILETYPE_PEM, f.read())\n     with open(config.intermediate_key_src, \"rb\") as f:\n         intermediate_key_src = crypto.load_privatekey(crypto.FILETYPE_PEM, f.read())\n \n     client_cert = crypto.X509()\n \n     # Set general information\n     client_cert.set_version(3)\n     client_cert.set_serial_number(random.randint(50000000000000, 100000000000000))\n     # If not set before, TLS will not accept to use this certificate in UTC cases, as\n     # the server time may be earlier.\n     time_offset = utc_difference() * -1\n     client_cert.gmtime_adj_notBefore(time_offset)\n     client_cert.gmtime_adj_notAfter(1 * 365 * 24 * 60 * 60)\n \n     # Set issuer and subject\n     intermediate_subject = intermediate_src.get_subject()\n     client_cert.set_issuer(intermediate_subject)\n     client_subj = crypto.X509Name(intermediate_subject)\n     client_subj.CN = config.hook_user\n     client_cert.set_subject(client_subj)\n \n     # Create and set the private key\n     client_key = crypto.PKey()\n     client_key.generate_key(crypto.TYPE_RSA, 2048)\n     client_cert.set_pubkey(client_key)\n \n     client_cert.sign(intermediate_key_src, \"sha256\")\n \n     cert_dump = crypto.dump_certificate(crypto.FILETYPE_PEM, client_cert).decode()\n     key_dump = crypto.dump_privatekey(crypto.FILETYPE_PEM, client_key).decode()\n     return CertificatePair(cert=cert_dump, key=key_dump)\n \n \n def generate_default_observer_schema(app):\n     \"\"\"Generate the default observer schema for each Kubernetes resource present in\n     ``spec.manifest`` for which a custom observer schema hasn't been specified.\n \n     Args:\n         app (krake.data.kubernetes.Application): The application for which to generate a\n             default observer schema\n     \"\"\"\n \n     app.status.mangled_observer_schema = deepcopy(app.spec.observer_schema)\n \n     for resource_manifest in app.spec.manifest:\n         try:\n             get_kubernetes_resource_idx(\n                 app.status.mangled_observer_schema, resource_manifest\n             )\n \n         except IndexError:\n             # Only create a default observer schema, if a custom observer schema hasn't\n             # been set by the user.\n             app.status.mangled_observer_schema.append(\n                 generate_default_observer_schema_dict(\n                     resource_manifest,\n                     first_level=True,\n                 )\n             )\n \n \n def generate_default_observer_schema_dict(manifest_dict, first_level=False):\n     \"\"\"Together with :func:``generate_default_observer_schema_list``, this function is\n     called recursively to generate part of a default ``observer_schema`` from part of a\n     Kubernetes resource, defined respectively by ``manifest_dict`` or ``manifest_list``.\n \n     Args:\n         manifest_dict (dict): Partial Kubernetes resources\n         first_level (bool, optional): If True, indicates that the dictionary represents\n             the whole observer schema of a Kubernetes resource\n \n     Returns:\n         dict: Generated partial observer_schema\n \n     This function creates a new dictionary from ``manifest_dict`` and replaces all\n     non-list and non-dict values by ``None``.\n \n     In case of ``first_level`` dictionary (i.e. complete ``observer_schema`` for a\n     resource), the values of the identifying fields are copied from the manifest file.\n \n     \"\"\"\n     observer_schema_dict = {}\n \n     for key, value in manifest_dict.items():\n \n         if isinstance(value, dict):\n             observer_schema_dict[key] = generate_default_observer_schema_dict(value)\n \n         elif isinstance(value, list):\n             observer_schema_dict[key] = generate_default_observer_schema_list(value)\n \n         else:\n             observer_schema_dict[key] = None\n \n     if first_level:\n         observer_schema_dict[\"apiVersion\"] = manifest_dict[\"apiVersion\"]\n         observer_schema_dict[\"kind\"] = manifest_dict[\"kind\"]\n         observer_schema_dict[\"metadata\"][\"name\"] = manifest_dict[\"metadata\"][\"name\"]\n \n         if (\n             \"spec\" in manifest_dict\n             and \"type\" in manifest_dict[\"spec\"]\n             and manifest_dict[\"spec\"][\"type\"] == \"LoadBalancer\"\n         ):\n             observer_schema_dict[\"status\"] = {\"load_balancer\": {\"ingress\": None}}\n \n     return observer_schema_dict\n \n \n def generate_default_observer_schema_list(manifest_list):\n     \"\"\"Together with :func:``generate_default_observer_schema_dict``, this function is\n     called recursively to generate part of a default ``observer_schema`` from part of a\n     Kubernetes resource, defined respectively by ``manifest_list`` or ``manifest_dict``.\n \n     Args:\n         manifest_list (list): Partial Kubernetes resources\n \n     Returns:\n         list: Generated partial observer_schema\n \n     This function creates a new list from ``manifest_list`` and replaces all non-list\n     and non-dict elements by ``None``.\n \n     Additionally, it generates the default list control dictionary, using the current\n     length of the list as default minimum and maximum values.\n \n     \"\"\"\n     observer_schema_list = []\n \n     for value in manifest_list:\n \n         if isinstance(value, dict):\n             observer_schema_list.append(generate_default_observer_schema_dict(value))\n \n         elif isinstance(value, list):\n             observer_schema_list.append(generate_default_observer_schema_list(value))\n \n         else:\n             observer_schema_list.append(None)\n \n     observer_schema_list.append(\n         {\n             \"observer_schema_list_min_length\": len(manifest_list),\n             \"observer_schema_list_max_length\": len(manifest_list),\n         }\n     )\n \n     return observer_schema_list\n \n \n @listen.on(HookType.ApplicationMangling)\n async def complete(app, api_endpoint, ssl_context, config):\n     \"\"\"Execute application complete hook defined by :class:`Complete`.\n     Hook mangles given application and injects complete hooks variables.\n \n     Application complete hook is disabled by default.\n     User enables this hook by the --hook-complete argument in rok cli.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application object processed\n             when the hook is called\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         config (krake.data.config.HooksConfiguration): Complete hook\n             configuration.\n \n     \"\"\"\n     if \"complete\" not in app.spec.hooks:\n         return\n \n     # Use the endpoint of the API only if the external endpoint has not been set.\n     if config.complete.external_endpoint:\n         api_endpoint = config.complete.external_endpoint\n \n     app.status.complete_token = \\\n         app.status.complete_token if app.status.complete_token else token_urlsafe()\n \n     # Generate only once the certificate and key for a specific Application\n     generated_cert = CertificatePair(\n         cert=app.status.complete_cert, key=app.status.complete_key\n     )\n     if ssl_context and generated_cert == (None, None):\n         generated_cert = generate_certificate(config.complete)\n         app.status.complete_cert = generated_cert.cert\n         app.status.complete_key = generated_cert.key\n \n     hook = Complete(\n         api_endpoint,\n         ssl_context,\n         hook_user=config.complete.hook_user,\n         cert_dest=config.complete.cert_dest,\n         env_token=config.complete.env_token,\n         env_url=config.complete.env_url,\n     )\n     hook.mangle_app(\n         app.metadata.name,\n         app.metadata.namespace,\n         app.status.complete_token,\n         app.status.last_applied_manifest,\n         config.complete.intermediate_src,\n         generated_cert,\n         app.status.mangled_observer_schema,\n         \"complete\"\n     )\n \n \n @listen.on(HookType.ApplicationMangling)\n async def shutdown(app, api_endpoint, ssl_context, config):\n     \"\"\"Executes an application shutdown hook defined by :class:`Shutdown`.\n     The hook mangles the given application and injects shutdown hooks variables.\n \n     Application shutdown hook is disabled by default.\n     User enables this hook by the --hook-shutdown argument in rok cli.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application object processed\n             when the hook is called\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         config (krake.data.config.HooksConfiguration): Shutdown hook\n             configuration.\n \n     \"\"\"\n     if \"shutdown\" not in app.spec.hooks:\n         return\n \n     # Use the endpoint of the API only if the external endpoint has not been set.\n     if config.shutdown.external_endpoint:\n         api_endpoint = config.shutdown.external_endpoint\n \n     app.status.shutdown_token = \\\n         app.status.shutdown_token if app.status.shutdown_token else token_urlsafe()\n \n     # Generate only once the certificate and key for a specific Application\n     generated_cert = CertificatePair(\n         cert=app.status.shutdown_cert, key=app.status.shutdown_key\n     )\n     if ssl_context and generated_cert == (None, None):\n         generated_cert = generate_certificate(config.shutdown)\n         app.status.shutdown_cert = generated_cert.cert\n         app.status.shutdown_key = generated_cert.key\n \n     hook = Shutdown(\n         api_endpoint,\n         ssl_context,\n         hook_user=config.shutdown.hook_user,\n         cert_dest=config.shutdown.cert_dest,\n         env_token=config.shutdown.env_token,\n         env_url=config.shutdown.env_url,\n     )\n     hook.mangle_app(\n         app.metadata.name,\n         app.metadata.namespace,\n         app.status.shutdown_token,\n         app.status.last_applied_manifest,\n         config.shutdown.intermediate_src,\n         generated_cert,\n         app.status.mangled_observer_schema,\n         \"shutdown\"\n     )\n \n \n @listen.on(HookType.ResourcePreDelete)\n async def pre_shutdown(controller, app, **kwargs):\n     \"\"\"\n \n     Args:\n         app (krake.data.kubernetes.Application): Application object processed\n             when the hook is called\n     \"\"\"\n     if \"shutdown\" not in app.spec.hooks:\n         return\n \n     return\n \n \n class SubResource(NamedTuple):\n     group: str\n     name: str\n     body: dict\n     path: tuple\n \n \n class CertificatePair(NamedTuple):\n     \"\"\"Tuple which contains a certificate and its corresponding key.\n \n     Attributes:\n         cert (str): content of a certificate.\n         key (str): content of the key that corresponds to the certificate.\n \n     \"\"\"\n \n     cert: str\n     key: str\n \n \n class Hook(object):\n \n     hook_resources = ()\n \n     ca_name = \"ca-bundle.pem\"\n     cert_name = \"cert.pem\"\n     key_name = \"key.pem\"\n \n     def __init__(\n         self, api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n     ):\n         self.api_endpoint = api_endpoint\n         self.ssl_context = ssl_context\n         self.hook_user = hook_user\n         self.cert_dest = cert_dest\n         self.env_token = env_token\n         self.env_url = env_url\n \n     def mangle_app(\n         self,\n         name,\n         namespace,\n         token,\n         last_applied_manifest,\n         intermediate_src,\n         generated_cert,\n         mangled_observer_schema,\n         hook_type=\"\",\n     ):\n         \"\"\"Mangle a given application and inject complete hook resources and\n         sub-resources into the :attr:`last_applied_manifest` object by :meth:`mangle`.\n         Also mangle the observer_schema as new resources and sub-resources should\n         be observed.\n \n         :attr:`last_applied_manifest` is created as a deep copy of the desired\n         application resources, as defined by user. It can be updated by custom hook\n         resources or modified by custom hook sub-resources. It is used as a desired\n         state for the Krake deployment process.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             token (str): Complete hook authentication token\n             last_applied_manifest (list): Application resources\n             intermediate_src (str): content of the certificate that is used to sign new\n                 certificates for the complete hook.\n             generated_cert (CertificatePair): tuple that contains the content of the\n                 new signed certificate for the Application, and the content of its\n                 corresponding key.\n             mangled_observer_schema (list): Observed fields\n             hook_type (str, optional): Name of the hook the app should be mangled for\n \n         \"\"\"\n \n         secret_certs_name = \"-\".join([name, \"krake\", hook_type, \"secret\", \"certs\"])\n         secret_token_name = \"-\".join([name, \"krake\", hook_type, \"secret\", \"token\"])\n         volume_name = \"-\".join([name, \"krake\", hook_type, \"volume\"])\n         ca_certs = (\n             self.ssl_context.get_ca_certs(binary_form=True)\n             if self.ssl_context\n             else None\n         )\n \n         # Extract all different namespaces\n         # FIXME: too many assumptions here: do we create one ConfigMap for each\n         #  namespace?\n         resource_namespaces = {\n             resource[\"metadata\"].get(\"namespace\", \"default\")\n             for resource in last_applied_manifest\n         }\n \n         hook_resources = []\n         hook_sub_resources = []\n         if ca_certs:\n             hook_resources.extend(\n                 [\n                     self.secret_certs(\n                         secret_certs_name,\n                         resource_namespace,\n                         intermediate_src=intermediate_src,\n                         generated_cert=generated_cert,\n                         ca_certs=ca_certs,\n                     )\n                     for resource_namespace in resource_namespaces\n                 ]\n             )\n             hook_sub_resources.extend(\n                 [*self.volumes(secret_certs_name, volume_name, self.cert_dest)]\n             )\n \n         hook_resources.extend(\n             [\n                 self.secret_token(\n                     secret_token_name,\n                     name,\n                     namespace,\n                     resource_namespace,\n                     self.api_endpoint,\n                     token,\n                 )\n                 for resource_namespace in resource_namespaces\n             ]\n         )\n         hook_sub_resources.extend(\n             [\n                 *self.env_vars(secret_token_name),\n             ]\n         )\n \n         self.mangle(\n             hook_resources,\n             last_applied_manifest,\n             mangled_observer_schema,\n         )\n         self.mangle(\n             hook_sub_resources,\n             last_applied_manifest,\n             mangled_observer_schema,\n             is_sub_resource=True,\n         )\n \n     def mangle(\n         self,\n         items,\n         last_applied_manifest,\n         mangled_observer_schema,\n         is_sub_resource=False,\n     ):\n         \"\"\"Mangle applications desired state with custom hook resources or\n         sub-resources.\n \n         Example:\n             .. code:: python\n \n             last_applied_manifest = [\n                 {\n                     'apiVersion': 'v1',\n                     'kind': 'Pod',\n                     'metadata': {'name': 'test', 'namespace': 'default'},\n                     'spec': {'containers': [{'name': 'test'}]}\n                 }\n             ]\n             mangled_observer_schema = [\n                 {\n                     'apiVersion': 'v1',\n                     'kind': 'Pod',\n                     'metadata': {'name': 'test', 'namespace': 'default'},\n                     'spec': {\n                         'containers': [\n                             {'name': None},\n                             {\n                                 'observer_schema_list_max_length': 1,\n                                 'observer_schema_list_min_length': 1,\n                             },\n                         ]\n                     },\n                 }\n             ]\n             hook_resources = [\n                 {\n                     'apiVersion': 'v1',\n                     'kind': 'Secret',\n                     'metadata': {'name': 'sct', 'namespace': 'default'}\n                 }\n             ]\n             hook_sub_resources = [\n                 SubResource(\n                     group='env', name='env', body={'name': 'test', 'value': 'test'},\n                     path=(('spec', 'containers'),)\n                 )\n             ]\n \n             mangle(\n                 hook_resources,\n                 last_applied_manifest,\n                 mangled_observer_schema,\n             )\n             mangle(\n                 hook_sub_resources,\n                 last_applied_manifest,\n                 mangled_observer_schema,\n                 is_sub_resource=True\n             )\n \n             assert last_applied_manifest == [\n                 {\n                     \"apiVersion\": \"v1\",\n                     \"kind\": \"Pod\",\n                     \"metadata\": {\"name\": \"test\", 'namespace': 'default'},\n                     \"spec\": {\n                         \"containers\": [\n                             {\n                                 \"name\": \"test\",\n                                 \"env\": [{\"name\": \"test\", \"value\": \"test\"}]\n                             }\n                         ]\n                     },\n                 },\n                 {\"apiVersion\": \"v1\", \"kind\": \"Secret\", \"metadata\": {\"name\": \"sct\"}},\n             ]\n \n             assert mangled_observer_schema == [\n                 {\n                     \"apiVersion\": \"v1\",\n                     \"kind\": \"Pod\",\n                     \"metadata\": {\"name\": \"test\", \"namespace\": None},\n                     \"spec\": {\n                         \"containers\": [\n                             {\n                                 \"name\": None,\n                                 \"env\": [\n                                     {\"name\": None, \"value\": None},\n                                     {\n                                         \"observer_schema_list_max_length\": 1,\n                                         \"observer_schema_list_min_length\": 1,\n                                     },\n                                 ],\n                             },\n                             {\n                                 \"observer_schema_list_max_length\": 1,\n                                 \"observer_schema_list_min_length\": 1,\n                             },\n                         ]\n                     },\n                 },\n                 {\n                     \"apiVersion\": \"v1\",\n                     \"kind\": \"Secret\",\n                     \"metadata\": {\"name\": \"sct\", \"namespace\": None},\n                 },\n             ]\n \n         Args:\n             items (list[SubResource]): Custom hook resources or sub-resources\n             last_applied_manifest (list): Application resources\n             mangled_observer_schema (list): Observed resources\n             is_sub_resource (bool, optional): if False, the function only extend the\n                 list of Kubernetes resources defined in :attr:`last_applied_manifest`\n                 with new hook resources. Otherwise, the function injects each new hook\n                 sub-resource into the :attr:`last_applied_manifest` object\n                 sub-resources. Defaults to False.\n \n         \"\"\"\n \n         if not items:\n             return\n \n         if not is_sub_resource:\n             last_applied_manifest.extend(items)\n             for sub_resource in items:\n                 # Generate the default observer schema for each resource\n                 mangled_observer_schema.append(\n                     generate_default_observer_schema_dict(\n                         sub_resource,\n                         first_level=True,\n                     )\n                 )\n             return\n \n         def inject(sub_resource, sub_resource_to_mangle, observed_resource_to_mangle):\n             \"\"\"Inject a hooks defined sub-resource into a Kubernetes sub-resource.\n \n             Args:\n                 sub_resource (SubResource): Hook sub-resource that needs to be injected\n                     into :attr:`last_applied_manifest`\n                 sub_resource_to_mangle (object): Kubernetes sub-resources from\n                     :attr:`last_applied_manifest` which need to be processed\n                 observed_resource_to_mangle (dict): partial mangled_observer_schema\n                     corresponding to the Kubernetes sub-resource.\n \n             Raises:\n                 InvalidManifestError: if the sub-resource which will be mangled is not a\n                     list or a dict.\n \n             \"\"\"\n \n             # Create sub-resource group if not present in the Kubernetes sub-resource\n             if sub_resource.group not in sub_resource_to_mangle:\n                 # FIXME: This assumes the subresource group contains a list\n                 sub_resource_to_mangle.update({sub_resource.group: []})\n \n             # Create sub-resource group if not present in the observed fields\n             if sub_resource.group not in observed_resource_to_mangle:\n                 observed_resource_to_mangle.update(\n                     {\n                         sub_resource.group: [\n                             {\n                                 \"observer_schema_list_min_length\": 0,\n                                 \"observer_schema_list_max_length\": 0,\n                             }\n                         ]\n                     }\n                 )\n \n             # Inject sub-resource\n             # If sub-resource name is already there update it, if not, append it\n             if sub_resource.name in [\n                 g[\"name\"] for g in sub_resource_to_mangle[sub_resource.group]\n             ]:\n                 # FIXME: Assuming we are dealing with a list\n                 for idx, item in enumerate(sub_resource_to_mangle[sub_resource.group]):\n                     if item[\"name\"]:\n                         if hasattr(item, \"body\"):\n                             sub_resource_to_mangle[item.group][idx] = item[\"body\"]\n             else:\n                 sub_resource_to_mangle[sub_resource.group].append(sub_resource.body)\n \n             # Make sure the value is observed\n             if sub_resource.name not in [\n                 g[\"name\"] for g in observed_resource_to_mangle[sub_resource.group][:-1]\n             ]:\n                 observed_resource_to_mangle[sub_resource.group].insert(\n                     -1, generate_default_observer_schema_dict(sub_resource.body)\n                 )\n                 observed_resource_to_mangle[sub_resource.group][-1][\n                     \"observer_schema_list_min_length\"\n                 ] += 1\n                 observed_resource_to_mangle[sub_resource.group][-1][\n                     \"observer_schema_list_max_length\"\n                 ] += 1\n \n         for resource in last_applied_manifest:\n             # Complete hook is applied only on defined Kubernetes resources\n             if resource[\"kind\"] not in self.hook_resources:\n                 continue\n \n             for sub_resource in items:\n                 sub_resources_to_mangle = None\n                 idx_observed = get_kubernetes_resource_idx(\n                     mangled_observer_schema, resource\n                 )\n                 for keys in sub_resource.path:\n                     try:\n                         sub_resources_to_mangle = reduce(getitem, keys, resource)\n                     except KeyError:\n                         continue\n \n                     break\n \n                 # Create the path to the observed sub-resource, if it doesn't yet exist\n                 try:\n                     observed_sub_resources = reduce(\n                         getitem, keys, mangled_observer_schema[idx_observed]\n                     )\n                 except KeyError:\n                     Complete.create_path(\n                         mangled_observer_schema[idx_observed], list(keys)\n                     )\n                     observed_sub_resources = reduce(\n                         getitem, keys, mangled_observer_schema[idx_observed]\n                     )\n \n                 if isinstance(sub_resources_to_mangle, list):\n                     for idx, sub_resource_to_mangle in enumerate(\n                         sub_resources_to_mangle\n                     ):\n \n                         # Ensure that each element of the list is observed.\n                         idx_observed = idx\n                         if idx >= len(observed_sub_resources[:-1]):\n                             idx_observed = len(observed_sub_resources[:-1])\n                             # FIXME: Assuming each element of the list contains a\n                             # dictionary, therefore initializing new elements with an\n                             # empty dict\n                             observed_sub_resources.insert(-1, {})\n                         observed_sub_resource = observed_sub_resources[idx_observed]\n \n                         # FIXME: This is assuming a list always contains dict\n                         inject(\n                             sub_resource, sub_resource_to_mangle, observed_sub_resource\n                         )\n \n                 elif isinstance(sub_resources_to_mangle, dict):\n                     inject(\n                         sub_resource, sub_resources_to_mangle, observed_sub_resources\n                     )\n \n                 else:\n                     message = (\n                         f\"The sub-resource to mangle {sub_resources_to_mangle!r} has an\"\n                         \"invalid type, should be in '[dict, list]'\"\n                     )\n                     raise InvalidManifestError(message)\n \n     @staticmethod\n     def attribute_map(obj):\n         \"\"\"Convert a Kubernetes object to dict based on its attribute mapping\n \n         Example:\n             .. code:: python\n \n             from kubernetes_asyncio.client import V1VolumeMount\n \n             d = attribute_map(\n                     V1VolumeMount(name=\"name\", mount_path=\"path\")\n             )\n             assert d == {'mountPath': 'path', 'name': 'name'}\n \n         Args:\n             obj (object): Kubernetes object\n \n         Returns:\n             dict: Converted Kubernetes object\n \n         \"\"\"\n         return {\n             obj.attribute_map[attr]: getattr(obj, attr)\n             for attr, _ in obj.to_dict().items()\n             if getattr(obj, attr) is not None\n         }\n \n     @staticmethod\n     def create_path(mangled_observer_schema, keys):\n         \"\"\"Create the path to the observed field in the observer schema.\n \n         When a sub-resource is mangled, it should be observed. This function creates\n         the path to the subresource to observe.\n \n         Args:\n             mangled_observer_schema (dict): Partial observer schema of a resource\n             keys (list): list of keys forming the path to the sub-resource to\n                 observe\n \n         FIXME: This assumes we are only adding keys to dict. We don't consider lists\n \n         \"\"\"\n \n         # Unpack the first key first, as it contains the base directory\n         key = keys.pop(0)\n \n         # If the key is the last of the list, we reached the end of the path.\n         if len(keys) == 0:\n             mangled_observer_schema[key] = None\n             return\n \n         if key not in mangled_observer_schema:\n             mangled_observer_schema[key] = {}\n         Hook.create_path(mangled_observer_schema[key], keys)\n \n     def secret_certs(\n         self,\n         secret_name,\n         namespace,\n         ca_certs=None,\n         intermediate_src=None,\n         generated_cert=None,\n     ):\n         \"\"\"Create a complete hooks secret resource.\n \n         Complete hook secret stores Krake CAs and client certificates to communicate\n         with the Krake API.\n \n         Args:\n             secret_name (str): Secret name\n             namespace (str): Kubernetes namespace where the Secret will be created.\n             ca_certs (list): Krake CA list\n             intermediate_src (str): content of the certificate that is used to sign new\n                 certificates for the complete hook.\n             generated_cert (CertificatePair): tuple that contains the content of the\n                 new signed certificate for the Application, and the content of its\n                 corresponding key.\n \n         Returns:\n             dict: complete hook secret resource\n \n         \"\"\"\n         ca_certs_pem = \"\"\n         for ca_cert in ca_certs:\n             x509 = crypto.load_certificate(crypto.FILETYPE_ASN1, ca_cert)\n             ca_certs_pem += crypto.dump_certificate(crypto.FILETYPE_PEM, x509).decode()\n \n         # Add the intermediate certificate into the chain\n         with open(intermediate_src, \"r\") as f:\n             intermediate_src_content = f.read()\n         ca_certs_pem += intermediate_src_content\n \n         data = {\n             self.ca_name: self._encode_to_64(ca_certs_pem),\n             self.cert_name: self._encode_to_64(generated_cert.cert),\n             self.key_name: self._encode_to_64(generated_cert.key),\n         }\n         return self.secret(secret_name, data, namespace)\n \n     def secret_token(\n         self, secret_name, name, namespace, resource_namespace, api_endpoint, token\n     ):\n         \"\"\"Create a hooks secret resource.\n \n         The hook secret stores Krake authentication token\n         and hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n             name (str): Application name\n             namespace (str): Application namespace\n             resource_namespace (str): Kubernetes namespace where the\n                 Secret will be created.\n             api_endpoint (str): Krake API endpoint\n             token (str): Complete hook authentication token\n \n         Returns:\n             dict: complete hook secret resource\n \n         \"\"\"\n         pass\n \n     def volumes(self, secret_name, volume_name, mount_path):\n         \"\"\"Create complete hooks volume and volume mount sub-resources\n \n         Complete hook volume gives access to hook's secret, which stores\n         Krake CAs and client certificates to communicate with the Krake API.\n         Complete hook volume mount puts the volume into the application\n \n         Args:\n             secret_name (str): Secret name\n             volume_name (str): Volume name\n             mount_path (list): Volume mount path\n \n         Returns:\n             list: List of complete hook volume and volume mount sub-resources\n \n         \"\"\"\n         volume = V1Volume(name=volume_name, secret={\"secretName\": secret_name})\n         volume_mount = V1VolumeMount(name=volume_name, mount_path=mount_path)\n         return [\n             SubResource(\n                 group=\"volumes\",\n                 name=volume.name,\n                 body=self.attribute_map(volume),\n                 path=((\"spec\", \"template\", \"spec\"), (\"spec\",)),\n             ),\n             SubResource(\n                 group=\"volumeMounts\",\n                 name=volume_mount.name,\n                 body=self.attribute_map(volume_mount),\n                 path=(\n                     (\"spec\", \"template\", \"spec\", \"containers\"),\n                     (\"spec\", \"containers\"),  # kind: Pod\n                 ),\n             ),\n         ]\n \n     @staticmethod\n     def _encode_to_64(string):\n         \"\"\"Compute the base 64 encoding of a string.\n \n         Args:\n             string (str): the string to encode.\n \n         Returns:\n             str: the result of the encoding.\n \n         \"\"\"\n         return b64encode(string.encode()).decode()\n \n     def secret(self, secret_name, secret_data, namespace, _type=\"Opaque\"):\n         \"\"\"Create a secret resource.\n \n         Args:\n             secret_name (str): Secret name\n             secret_data (dict): Secret data\n             namespace (str): Kubernetes namespace where the Secret will be created.\n             _type (str, optional): Secret type. Defaults to Opaque.\n \n         Returns:\n             dict: secret resource\n \n         \"\"\"\n         return self.attribute_map(\n             V1Secret(\n                 api_version=\"v1\",\n                 kind=\"Secret\",\n                 data=secret_data,\n                 metadata={\"name\": secret_name, \"namespace\": namespace},\n                 type=_type,\n             )\n         )\n \n     @staticmethod\n     def create_hook_url(name, namespace, api_endpoint):\n         \"\"\"Create an applications' hook URL.\n         Function needs to be specified for each hook.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             api_endpoint (str): Krake API endpoint\n \n         Returns:\n             str: Application shutdown url\n \n         \"\"\"\n         pass\n \n     def env_vars(self, secret_name):\n         \"\"\"Create the hooks' environment variables sub-resources.\n         Function needs to be specified for each hook.\n \n         Creates hook environment variables to store Krake authentication token\n         and a hook URL for the given applications.\n \n         Args:\n             secret_name (str): Secret name\n \n         Returns:\n             list: List of shutdown hook environment variables sub-resources\n \n         \"\"\"\n         pass\n \n \n class Complete(Hook):\n     \"\"\"Mangle given application and inject complete hooks variables into it.\n \n     Hook injects a Kubernetes secret, which stores Krake authentication token\n     and the Krake complete hook URL for the given application. The variables\n     from Kubernetes secret are imported as environment variables\n     into the application resource definition. Only resources defined in\n     :args:`hook_resources` can be modified.\n \n     Names of environment variables are defined in the application controller\n     configuration file.\n \n     If TLS is enabled on the Krake API, the complete hook injects a Kubernetes secret,\n     and it's corresponding volume and volume mount definitions for the Krake CA,\n     the client certificate with the right CN, and its key. The directory where the\n     secret is mounted is defined in the configuration.\n \n     Args:\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         cert_dest (str, optional): Path of the directory where the CA, client\n             certificate and key to the Krake API will be stored.\n         env_token (str, optional): Name of the environment variable, which stores Krake\n             authentication token.\n         env_url (str, optional): Name of the environment variable,\n             which stores Krake complete hook URL.\n \n     \"\"\"\n \n     hook_resources = (\"Pod\", \"Deployment\", \"ReplicationController\")\n \n     def __init__(\n         self, api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n     ):\n         super().__init__(\n             api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n         )\n         self.env_url = env_url\n \n     def secret_token(\n         self, secret_name, name, namespace, resource_namespace, api_endpoint, token\n     ):\n         \"\"\"Create complete hooks secret resource.\n \n         Complete hook secret stores Krake authentication token\n         and complete hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n             name (str): Application name\n             namespace (str): Application namespace\n             resource_namespace (str): Kubernetes namespace where the\n                 Secret will be created.\n             api_endpoint (str): Krake API endpoint\n             token (str): Complete hook authentication token\n \n         Returns:\n             dict: complete hook secret resource\n \n         \"\"\"\n         complete_url = self.create_hook_url(name, namespace, api_endpoint)\n         data = {\n             self.env_token.lower(): self._encode_to_64(token),\n             self.env_url.lower(): self._encode_to_64(complete_url),\n         }\n         return self.secret(secret_name, data, resource_namespace)\n \n     @staticmethod\n     def create_hook_url(name, namespace, api_endpoint):\n         \"\"\"Create an applications' complete URL.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             api_endpoint (str): Krake API endpoint\n \n         Returns:\n             str: Application complete url\n \n         \"\"\"\n         api_url = URL(api_endpoint)\n         return str(\n             api_url.with_path(\n                 f\"/kubernetes/namespaces/{namespace}/applications/{name}/complete\"\n             )\n         )\n \n     def env_vars(self, secret_name):\n         \"\"\"Create complete hooks environment variables sub-resources\n \n         Create complete hook environment variables store Krake authentication token\n         and complete hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n \n         Returns:\n             list: List of complete hook environment variables sub-resources\n \n         \"\"\"\n         sub_resources = []\n \n         env_token = V1EnvVar(\n             name=self.env_token,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(\n                             name=secret_name, key=self.env_token.lower()\n                         )\n                     )\n                 )\n             ),\n         )\n         env_url = V1EnvVar(\n             name=self.env_url,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(name=secret_name, key=self.env_url.lower())\n                     )\n                 )\n             ),\n         )\n \n         for env in (env_token, env_url):\n             sub_resources.append(\n                 SubResource(\n                     group=\"env\",\n                     name=env.name,\n                     body=self.attribute_map(env),\n                     path=(\n                         (\"spec\", \"template\", \"spec\", \"containers\"),\n                         (\"spec\", \"containers\"),  # kind: Pod\n                     ),\n                 )\n             )\n         return sub_resources\n \n \n class Shutdown(Hook):\n     \"\"\"Mangle given application and inject shutdown hooks variables into it.\n \n     Hook injects a Kubernetes secret, which stores Krake authentication token\n     and the Krake complete hook URL for the given application. The variables\n     from the Kubernetes secret are imported as environment variables\n     into the application resource definition. Only resources defined in\n     :args:`hook_resources` can be modified.\n \n     Names of environment variables are defined in the application controller\n     configuration file.\n \n     If TLS is enabled on the Krake API, the shutdown hook injects a Kubernetes secret,\n     and it's corresponding volume and volume mount definitions for the Krake CA,\n     the client certificate with the right CN, and its key. The directory where the\n     secret is mounted is defined in the configuration.\n \n     Args:\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         cert_dest (str, optional): Path of the directory where the CA, client\n             certificate and key to the Krake API will be stored.\n         env_token (str, optional): Name of the environment variable, which stores Krake\n             authentication token.\n         env_url (str, optional): Name of the environment variable,\n             which stores Krake complete hook URL.\n \n     \"\"\"\n \n     hook_resources = (\"Pod\", \"Deployment\", \"ReplicationController\")\n \n     def __init__(\n         self, api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n     ):\n         super().__init__(\n             api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n         )\n         self.env_url = env_url\n \n     def secret_token(\n         self, secret_name, name, namespace, resource_namespace, api_endpoint, token\n     ):\n         \"\"\"Create shutdown hooks secret resource.\n \n         Shutdown hook secret stores Krake authentication token\n         and shutdown hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n             name (str): Application name\n             namespace (str): Application namespace\n             resource_namespace (str): Kubernetes namespace where the\n                 Secret will be created.\n             api_endpoint (str): Krake API endpoint\n             token (str): Shutdown hook authentication token\n \n         Returns:\n             dict: shutdown hook secret resource\n \n         \"\"\"\n         shutdown_url = self.create_hook_url(name, namespace, api_endpoint)\n         data = {\n             self.env_token.lower(): self._encode_to_64(token),\n             self.env_url.lower(): self._encode_to_64(shutdown_url),\n         }\n         return self.secret(secret_name, data, resource_namespace)\n \n     @staticmethod\n     def create_hook_url(name, namespace, api_endpoint):\n         \"\"\"Create an applications' shutdown URL.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             api_endpoint (str): Krake API endpoint\n \n         Returns:\n             str: Application shutdown url\n \n         \"\"\"\n         api_url = URL(api_endpoint)\n         return str(\n             api_url.with_path(\n                 f\"/kubernetes/namespaces/{namespace}/applications/{name}/shutdown\"\n             )\n         )\n \n     def env_vars(self, secret_name):\n         \"\"\"Create shutdown hooks environment variables sub-resources.\n \n         Creates shutdown hook environment variables to store Krake authentication token\n         and a shutdown hook URL for given applications.\n \n         Args:\n             secret_name (str): Secret name\n \n         Returns:\n             list: List of shutdown hook environment variables sub-resources\n \n         \"\"\"\n         sub_resources = []\n \n         env_resources = []\n \n         env_token = V1EnvVar(\n             name=self.env_token,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(\n                             name=secret_name,\n                             key=self.env_token.lower()\n                         )\n                     )\n                 )\n             )\n         )\n         env_resources.append(env_token)\n \n         env_url = V1EnvVar(\n             name=self.env_url,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(name=secret_name, key=self.env_url.lower())\n                     )\n                 )\n             ),\n         )\n         env_resources.append(env_url)\n \n         for env in env_resources:\n             sub_resources.append(\n                 SubResource(\n                     group=\"env\",\n                     name=env.name,\n                     body=self.attribute_map(env),\n                     path=(\n                         (\"spec\", \"template\", \"spec\", \"containers\"),\n                         (\"spec\", \"containers\"),  # kind: Pod\n                     ),\n                 )\n             )\n         return sub_resources\n ", "input_code": "def update_last_applied_manifest_dict_from_resp(last_applied_manifest, observer_schema, response):\n\"\"\"\nTogether with :func:``update_last_applied_manifest_list_from_resp``, this\nfunction is called recursively to update a partial ``last_applied_manifest``\nfrom a partial Kubernetes response\n\nArgs:\n    last_applied_manifest (dict): partial ``last_applied_manifest`` being\n        updated\n    observer_schema (dict): partial ``observer_schema``\n    response (dict): partial response from the Kubernetes API.\n\nRaises:\n    KeyError: If the observed field is not present in the Kubernetes response\n\nThis function go through all observed fields, and initialized their value in\nlast_applied_manifest if they are not yet present\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def update_last_applied_manifest_dict_from_resp(\n    last_applied_manifest, observer_schema, response\n):\n    \"\"\"Together with :func:``update_last_applied_manifest_list_from_resp``, this\n    function is called recursively to update a partial ``last_applied_manifest``\n    from a partial Kubernetes response\n\n    Args:\n        last_applied_manifest (dict): partial ``last_applied_manifest`` being\n            updated\n        observer_schema (dict): partial ``observer_schema``\n        response (dict): partial response from the Kubernetes API.\n\n    Raises:\n        KeyError: If the observed field is not present in the Kubernetes response\n\n    This function go through all observed fields, and initialized their value in\n    last_applied_manifest if they are not yet present\n\n    \"\"\"\n    for key, value in observer_schema.items():\n\n        # Keys in the response are in camelCase\n        camel_key = camel_to_snake_case(key)\n\n        if camel_key not in response:\n            # An observed key should always be present in the k8s response\n            raise KeyError(\n                f\"Observed key {camel_key} is not present in response {response}\"\n            )\n\n        if isinstance(value, dict):\n            if key not in last_applied_manifest:\n                # The dictionary is observed, but not present in\n                # last_applied_manifest\n                last_applied_manifest[key] = {}\n\n            update_last_applied_manifest_dict_from_resp(\n                last_applied_manifest[key], observer_schema[key], response[camel_key]\n            )\n\n        elif isinstance(value, list):\n            if key not in last_applied_manifest:\n                # The list is observed, but not present in last_applied_manifest\n                last_applied_manifest[key] = []\n\n            update_last_applied_manifest_list_from_resp(\n                last_applied_manifest[key], observer_schema[key], response[camel_key]\n            )\n\n        elif key not in last_applied_manifest:\n            # If key not present in last_applied_manifest, and value is neither a\n            # dict nor a list, simply add it.\n            last_applied_manifest[key] = response[camel_key]", "signature": "def update_last_applied_manifest_dict_from_resp(last_applied_manifest, observer_schema, response):", "completion_path": "krake/krake/controller/kubernetes/hooks.py"}
{"ce_id": "62b869eab4d922cb0e688cbf", "namespace": "62b869eab4d922cb0e688cbf", "namespace_real": "krake.krake.controller.kubernetes.hooks.generate_default_observer_schema", "real_proj_path": "rak-n-rok---Krake/", "type": "function", "class_name": null, "function_name": "generate_default_observer_schema", "contexts_above": "\"\"\"This module defines the Hook Dispatcher and listeners for registering and\nexecuting hooks. Hook Dispatcher emits hooks based on :class:`Hook` attributes which\ndefine when the hook will be executed.\n\n\"\"\"\nimport asyncio\nimport logging\nimport random\nfrom base64 import b64encode\nfrom collections import defaultdict\nfrom contextlib import suppress\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom functools import reduce\nfrom operator import getitem\nfrom enum import Enum, auto\nfrom inspect import iscoroutinefunction\nfrom OpenSSL import crypto\nfrom typing import NamedTuple\n\nimport yarl\nfrom aiohttp import ClientConnectorError\n\nfrom krake.controller import Observer\nfrom krake.controller.kubernetes.client import KubernetesClient, InvalidManifestError\nfrom krake.utils import camel_to_snake_case, get_kubernetes_resource_idx\nfrom kubernetes_asyncio.client.rest import ApiException\nfrom kubernetes_asyncio.client.api_client import ApiClient\nfrom kubernetes_asyncio import client\nfrom krake.data.kubernetes import ClusterState, Application, Cluster\nfrom yarl import URL\nfrom secrets import token_urlsafe\n\nfrom kubernetes_asyncio.client import (\n    Configuration,\n    V1Secret,\n    V1EnvVar,\n    V1VolumeMount,\n    V1Volume,\n    V1SecretKeySelector,\n    V1EnvVarSource,\n)\nfrom kubernetes_asyncio.config.kube_config import KubeConfigLoader\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass HookType(Enum):\n    ResourcePreCreate = auto()\n    ResourcePostCreate = auto()\n    ResourcePreUpdate = auto()\n    ResourcePostUpdate = auto()\n    ResourcePreDelete = auto()\n    ResourcePostDelete = auto()\n    ApplicationMangling = auto()\n    ApplicationPreMigrate = auto()\n    ApplicationPostMigrate = auto()\n    ApplicationPreReconcile = auto()\n    ApplicationPostReconcile = auto()\n    ApplicationPreDelete = auto()\n    ApplicationPostDelete = auto()\n    ClusterCreation = auto()\n    ClusterDeletion = auto()\n\n\nclass HookDispatcher(object):\n    \"\"\"Simple wrapper around a registry of handlers associated to :class:`Hook`\n     attributes. Each :class:`Hook` attribute defines when the handler will be\n     executed.\n\n    Listeners for certain hooks can be registered via :meth:`on`. Registered\n    listeners are executed via :meth:`hook`.\n\n    Example:\n        .. code:: python\n\n        listen = HookDispatcher()\n\n        @listen.on(HookType.PreApply)\n        def to_perform_before_app_creation(app, cluster, resource, controller):\n            # Do Stuff\n\n        @listen.on(HookType.PostApply)\n        def another_to_perform_after_app_creation(app, cluster, resource, resp):\n            # Do Stuff\n\n        @listen.on(HookType.PostDelete)\n        def to_perform_after_app_deletion(app, cluster, resource, resp):\n            # Do Stuff\n\n    \"\"\"\n\n    def __init__(self):\n        self.registry = defaultdict(list)\n\n    def on(self, hook):\n        \"\"\"Decorator function to add a new handler to the registry.\n\n        Args:\n            hook (HookType): Hook attribute for which to register the handler.\n\n        Returns:\n            callable: Decorator for registering listeners for the specified\n            hook.\n\n        \"\"\"\n\n        def decorator(handler):\n            self.registry[hook].append(handler)\n\n            return handler\n\n        return decorator\n\n    async def hook(self, hook, **kwargs):\n        \"\"\"Execute the list of handlers associated to the provided :class:`Hook`\n        attribute.\n\n        Args:\n            hook (HookType): The hook attribute for which to execute handlers.\n\n        \"\"\"\n        try:\n            handlers = self.registry[hook]\n        except KeyError:\n            pass\n        else:\n            for handler in handlers:\n                if iscoroutinefunction(handler):\n                    await handler(**kwargs)\n                else:\n                    handler(**kwargs)\n\n\nlisten = HookDispatcher()\n\n\n@listen.on(HookType.ResourcePostCreate)\n@listen.on(HookType.ResourcePostUpdate)\nasync def register_service(app, cluster, resource, response):\n    \"\"\"Register endpoint of Kubernetes Service object on creation and update.\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        cluster (krake.data.kubernetes.Cluster): The cluster on which the\n            application is running\n        resource (dict): Kubernetes object description as specified in the\n            specification of the application.\n        response (kubernetes_asyncio.client.V1Service): Response of the\n            Kubernetes API\n\n    \"\"\"\n    if resource[\"kind\"] != \"Service\":\n        return\n\n    service_name = resource[\"metadata\"][\"name\"]\n\n    if response.spec and response.spec.type == \"LoadBalancer\":\n        # For a \"LoadBalancer\" type of Service, an external IP is given in the cluster\n        # by a load balancer controller to the service. In this case, the \"port\"\n        # specified in the spec is reachable from the outside.\n        if (\n            not response.status.load_balancer\n            or not response.status.load_balancer.ingress\n        ):\n            # When a \"LoadBalancer\" type of service is created, the IP is given by an\n            # additional controller (e.g. a controller that requests a floating IP to an\n            # OpenStack infrastructure). This process can take some time, but the\n            # Service itself already exist before the IP is assigned. In the case of an\n            # error with the controller, the IP is also not given. This \"<pending>\" IP\n            # just expresses that the Service exists, but the IP is not ready yet.\n            external_ip = \"<pending>\"\n        else:\n            external_ip = response.status.load_balancer.ingress[0].ip\n\n        if not response.spec.ports:\n            external_port = \"<pending>\"\n        else:\n            external_port = response.spec.ports[0].port\n        app.status.services[service_name] = f\"{external_ip}:{external_port}\"\n        return\n\n    node_port = None\n    # Ensure that ports are specified\n    if response.spec and response.spec.ports:\n        node_port = response.spec.ports[0].node_port\n\n    # If the service does not have a node port, remove a potential reference\n    # and return.\n    if node_port is None:\n        try:\n            del app.status.services[service_name]\n        except KeyError:\n            pass\n        return\n\n    # Determine URL of Kubernetes cluster API\n    loader = KubeConfigLoader(cluster.spec.kubeconfig)\n    config = Configuration()\n    await loader.load_and_set(config)\n    cluster_url = yarl.URL(config.host)\n\n    app.status.services[service_name] = f\"{cluster_url.host}:{node_port}\"\n\n\n@listen.on(HookType.ResourcePostDelete)\nasync def unregister_service(app, resource, **kwargs):\n    \"\"\"Unregister endpoint of Kubernetes Service object on deletion.\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        resource (dict): Kubernetes object description as specified in the\n            specification of the application.\n\n    \"\"\"\n    if resource[\"kind\"] != \"Service\":\n        return\n\n    service_name = resource[\"metadata\"][\"name\"]\n    try:\n        del app.status.services[service_name]\n    except KeyError:\n        pass\n\n\n@listen.on(HookType.ResourcePostDelete)\nasync def remove_resource_from_last_observed_manifest(app, resource, **kwargs):\n    \"\"\"Remove a given resource from the last_observed_manifest after its deletion\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        resource (dict): Kubernetes object description as specified in the\n            specification of the application.\n\n    \"\"\"\n    try:\n        idx = get_kubernetes_resource_idx(app.status.last_observed_manifest, resource)\n    except IndexError:\n        return\n\n    app.status.last_observed_manifest.pop(idx)\n\n\ndef update_last_applied_manifest_dict_from_resp(\n    last_applied_manifest, observer_schema, response\n):\n    \"\"\"Together with :func:``update_last_applied_manifest_list_from_resp``, this\n    function is called recursively to update a partial ``last_applied_manifest``\n    from a partial Kubernetes response\n\n    Args:\n        last_applied_manifest (dict): partial ``last_applied_manifest`` being\n            updated\n        observer_schema (dict): partial ``observer_schema``\n        response (dict): partial response from the Kubernetes API.\n\n    Raises:\n        KeyError: If the observed field is not present in the Kubernetes response\n\n    This function go through all observed fields, and initialized their value in\n    last_applied_manifest if they are not yet present\n\n    \"\"\"\n    for key, value in observer_schema.items():\n\n        # Keys in the response are in camelCase\n        camel_key = camel_to_snake_case(key)\n\n        if camel_key not in response:\n            # An observed key should always be present in the k8s response\n            raise KeyError(\n                f\"Observed key {camel_key} is not present in response {response}\"\n            )\n\n        if isinstance(value, dict):\n            if key not in last_applied_manifest:\n                # The dictionary is observed, but not present in\n                # last_applied_manifest\n                last_applied_manifest[key] = {}\n\n            update_last_applied_manifest_dict_from_resp(\n                last_applied_manifest[key], observer_schema[key], response[camel_key]\n            )\n\n        elif isinstance(value, list):\n            if key not in last_applied_manifest:\n                # The list is observed, but not present in last_applied_manifest\n                last_applied_manifest[key] = []\n\n            update_last_applied_manifest_list_from_resp(\n                last_applied_manifest[key], observer_schema[key], response[camel_key]\n            )\n\n        elif key not in last_applied_manifest:\n            # If key not present in last_applied_manifest, and value is neither a\n            # dict nor a list, simply add it.\n            last_applied_manifest[key] = response[camel_key]\n\n\ndef update_last_applied_manifest_list_from_resp(\n    last_applied_manifest, observer_schema, response\n):\n    \"\"\"Together with :func:``update_last_applied_manifest_dict_from_resp``, this\n    function is called recursively to update a partial ``last_applied_manifest``\n    from a partial Kubernetes response\n\n    Args:\n        last_applied_manifest (list): partial ``last_applied_manifest`` being\n            updated\n        observer_schema (list): partial ``observer_schema``\n        response (list): partial response from the Kubernetes API.\n\n    This function go through all observed fields, and initialized their value in\n    last_applied_manifest if they are not yet present\n\n    \"\"\"\n    # Looping over the observed resource, except the last element which is the\n    # special control dictionary\n    for idx, val in enumerate(observer_schema[:-1]):\n\n        if idx >= len(response):\n            # Element is observed but not present in k8s response, so following\n            # elements will also not exist.\n            #\n            # This doesn't raise an Exception as observing the element of a list\n            # doesn't ensure its presence. The list length is controlled by the\n            # special control dictionary\n            return\n\n        if isinstance(val, dict):\n            if idx >= len(last_applied_manifest):\n                # The dict is observed, but not present in last_applied_manifest\n                last_applied_manifest.append({})\n\n            update_last_applied_manifest_dict_from_resp(\n                last_applied_manifest[idx], observer_schema[idx], response[idx]\n            )\n\n        elif isinstance(response[idx], list):\n            if idx >= len(last_applied_manifest):\n                # The list is observed, but not present in last_applied_manifest\n                last_applied_manifest.append([])\n\n            update_last_applied_manifest_list_from_resp(\n                last_applied_manifest[idx], observer_schema[idx], response[idx]\n            )\n\n        elif idx >= len(last_applied_manifest):\n            # Element is not yet present in last_applied_manifest. Adding it.\n            last_applied_manifest.append(response[idx])\n\n\n@listen.on(HookType.ResourcePostCreate)\n@listen.on(HookType.ResourcePostUpdate)\ndef update_last_applied_manifest_from_resp(app, response, **kwargs):\n    \"\"\"Hook run after the creation or update of an application in order to update the\n    `status.last_applied_manifest` using the k8s response.\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        response (kubernetes_asyncio.client.V1Status): Response of the Kubernetes API\n\n    After a Kubernetes resource has been created/updated, the\n    `status.last_applied_manifest` has to be updated. All fields already initialized\n    (either from the mangling of `spec.manifest`, or by a previous call to this\n    function) should be left untouched. Only observed fields which are not present in\n    `status.last_applied_manifest` should be initialized.\n\n    \"\"\"\n\n    if isinstance(response, dict):\n        # The Kubernetes API couldn't deserialize the k8s response into an object\n        resp = response\n    else:\n        # The Kubernetes API deserialized the k8s response into an object\n        resp = response.to_dict()\n\n    idx_applied = get_kubernetes_resource_idx(app.status.last_applied_manifest, resp)\n\n    idx_observed = get_kubernetes_resource_idx(app.status.mangled_observer_schema, resp)\n\n    update_last_applied_manifest_dict_from_resp(\n        app.status.last_applied_manifest[idx_applied],\n        app.status.mangled_observer_schema[idx_observed],\n        resp,\n    )\n\n\n@listen.on(HookType.ResourcePostCreate)\n@listen.on(HookType.ResourcePostUpdate)\ndef update_last_observed_manifest_from_resp(app, response, **kwargs):\n    \"\"\"Handler to run after the creation or update of a Kubernetes resource to update\n    the last_observed_manifest from the response of the Kubernetes API.\n\n    Args:\n        app (krake.data.kubernetes.Application): Application the service belongs to\n        response (kubernetes_asyncio.client.V1Service): Response of the\n            Kubernetes API\n\n    The target last_observed_manifest holds the value of all observed fields plus the\n    special control dictionaries for the list length\n\n    \"\"\"\n    if isinstance(response, dict):\n        # The Kubernetes API couldn't deserialize the k8s response into an object\n        resp = response\n    else:\n        # The Kubernetes API deserialized the k8s response into an object\n        resp = response.to_dict()\n\n    try:\n        idx_observed = get_kubernetes_resource_idx(\n            app.status.mangled_observer_schema,\n            resp,\n        )\n    except IndexError:\n        # All created resources should be observed\n        raise\n\n    try:\n        idx_last_observed = get_kubernetes_resource_idx(\n            app.status.last_observed_manifest,\n            resp,\n        )\n    except IndexError:\n        # If the resource is not yes present in last_observed_manifest, append it.\n        idx_last_observed = len(app.status.last_observed_manifest)\n        app.status.last_observed_manifest.append({})\n\n    # Overwrite the last_observed_manifest for this resource\n    app.status.last_observed_manifest[\n        idx_last_observed\n    ] = update_last_observed_manifest_dict(\n        app.status.mangled_observer_schema[idx_observed], resp\n    )\n\n\ndef update_last_observed_manifest_dict(observed_resource, response):\n    \"\"\"Together with :func:``update_last_observed_manifest_list``, recursively\n    crafts the ``last_observed_manifest`` from the Kubernetes :attr:``response``.\n\n    Args:\n        observed_resource (dict): The schema to observe for the partial given resource\n        response (dict): The partial Kubernetes response for this resource.\n\n    Raises:\n        KeyError: If an observed key is not present in the Kubernetes response\n\n    Returns:\n        dict: The dictionary of observed keys and their value\n\n    Get the value of all observed fields from the Kubernetes response\n    \"\"\"\n    res = {}\n    for key, value in observed_resource.items():\n\n        camel_key = camel_to_snake_case(key)\n        if camel_key not in response:\n            raise KeyError(\n                f\"Observed key {camel_key} is not present in response {response}\"\n            )\n\n        if isinstance(value, dict):\n            res[key] = update_last_observed_manifest_dict(value, response[camel_key])\n\n        elif isinstance(value, list):\n            res[key] = update_last_observed_manifest_list(value, response[camel_key])\n\n        else:\n            res[key] = response[camel_key]\n\n    return res\n\n\ndef update_last_observed_manifest_list(observed_resource, response):\n    \"\"\"Together with :func:``update_last_observed_manifest_dict``, recursively\n    crafts the ``last_observed_manifest`` from the Kubernetes :attr:``response``.\n\n    Args:\n        observed_resource (list): the schema to observe for the partial given resource\n        response (list): the partial Kubernetes response for this resource.\n\n    Returns:\n        list: The list of observed elements, plus the special list length control\n            dictionary\n\n    Get the value of all observed elements from the Kubernetes response\n    \"\"\"\n\n    if not response:\n        return [{\"observer_schema_list_current_length\": 0}]\n\n    res = []\n    # Looping over the observed resource, except the last element which is the special\n    # control dictionary\n    for idx, val in enumerate(observed_resource[:-1]):\n\n        if idx >= len(response):\n            # Element is not present in the Kubernetes response, nothing more to do\n            break\n\n        if type(response[idx]) == dict:\n            res.append(update_last_observed_manifest_dict(val, response[idx]))\n\n        elif type(response[idx]) == list:\n            res.append(update_last_observed_manifest_list(val, response[idx]))\n\n        else:\n            res.append(response[idx])\n\n    # Append the special control dictionary to the list\n    res.append({\"observer_schema_list_current_length\": len(response)})\n\n    return res\n\n\ndef update_last_applied_manifest_dict_from_spec(\n    resource_status_new, resource_status_old, resource_observed\n):\n    \"\"\"Together with :func:``update_last_applied_manifest_list_from_spec``, this\n    function is called recursively to update a partial ``last_applied_manifest``\n\n    Args:\n        resource_status_new (dict): partial ``last_applied_manifest`` being updated\n        resource_status_old (dict): partial of the current ``last_applied_manifest``\n        resource_observed (dict): partial observer_schema for the manifest file\n            being updated\n\n    \"\"\"\n    for key, value in resource_observed.items():\n\n        if key not in resource_status_old:\n            continue\n\n        if key in resource_status_new:\n\n            if isinstance(value, dict):\n                update_last_applied_manifest_dict_from_spec(\n                    resource_status_new[key],\n                    resource_status_old[key],\n                    resource_observed[key],\n                )\n\n            elif isinstance(value, list):\n                update_last_applied_manifest_list_from_spec(\n                    resource_status_new[key],\n                    resource_status_old[key],\n                    resource_observed[key],\n                )\n\n        else:\n            # If the key is not present the spec.manifest, we first need to\n            # initialize it\n\n            if isinstance(value, dict):\n                resource_status_new[key] = {}\n                update_last_applied_manifest_dict_from_spec(\n                    resource_status_new[key],\n                    resource_status_old[key],\n                    resource_observed[key],\n                )\n\n            elif isinstance(value, list):\n                resource_status_new[key] = []\n                update_last_applied_manifest_list_from_spec(\n                    resource_status_new[key],\n                    resource_status_old[key],\n                    resource_observed[key],\n                )\n\n            else:\n                resource_status_new[key] = resource_status_old[key]\n\n\ndef update_last_applied_manifest_list_from_spec(\n    resource_status_new, resource_status_old, resource_observed\n):\n    \"\"\"Together with :func:``update_last_applied_manifest_dict_from_spec``, this\n    function is called recursively to update a partial ``last_applied_manifest``\n\n    Args:\n        resource_status_new (list): partial ``last_applied_manifest`` being updated\n        resource_status_old (list): partial of the current ``last_applied_manifest``\n        resource_observed (list): partial observer_schema for the manifest file\n            being updated\n\n    \"\"\"\n\n    # Looping over the observed resource, except the last element which is the\n    # special control dictionary\n    for idx, val in enumerate(resource_observed[:-1]):\n\n        if idx >= len(resource_status_old):\n            # The element in not in the current last_applied_manifest, and neither\n            # is the rest of the list\n            break\n\n        if idx < len(resource_status_new):\n            # The element is present in spec.manifest and in the current\n            # last_applied_manifest. Updating observed fields\n\n            if isinstance(val, dict):\n                update_last_applied_manifest_dict_from_spec(\n                    resource_status_new[idx],\n                    resource_status_old[idx],\n                    resource_observed[idx],\n                )\n\n            elif isinstance(val, list):\n                update_last_applied_manifest_list_from_spec(\n                    resource_status_new[idx],\n                    resource_status_old[idx],\n                    resource_observed[idx],\n                )\n\n        else:\n            # If the element is not present in the spec.manifest, we first have to\n            # initialize it.\n\n            if isinstance(val, dict):\n                resource_status_new.append({})\n                update_last_applied_manifest_dict_from_spec(\n                    resource_status_new[idx],\n                    resource_status_old[idx],\n                    resource_observed[idx],\n                )\n\n            elif isinstance(val, list):\n                resource_status_new.append([])\n                update_last_applied_manifest_list_from_spec(\n                    resource_status_new[idx],\n                    resource_status_old[idx],\n                    resource_observed[idx],\n                )\n\n            else:\n                resource_status_new.append(resource_status_old[idx])\n\n\ndef update_last_applied_manifest_from_spec(app):\n    \"\"\"Update the status.last_applied_manifest of an application from spec.manifests\n\n    Args:\n        app (krake.data.kubernetes.Application): Application to update\n\n    This function is called on application creation and updates. The\n    last_applied_manifest of an application is initialized as a copy of spec.manifest,\n    and is augmented by all known observed fields not yet initialized (i.e. all observed\n    fields or resources which are present in the current last_applied_manifest but not\n    in the spec.manifest)\n\n    \"\"\"\n\n    # The new last_applied_manifest is initialized as a copy of the spec.manifest, and\n    # augmented by all observed fields which are present in the current\n    # last_applied_manifest but not in the original spec.manifest\n    new_last_applied_manifest = deepcopy(app.spec.manifest)\n\n    # Loop over observed resources and observed fields, and check if they should be\n    # added to the new last_applied_manifest (i.e. present in the current\n    # last_applied_manifest but not in spec.manifest)\n    for resource_observed in app.status.mangled_observer_schema:\n\n        # If the resource is not present in the current last_applied_manifest, there is\n        # nothing to do. Whether the resource was initialized by spec.manifest doesn't\n        # matter.\n        try:\n            idx_status_old = get_kubernetes_resource_idx(\n                app.status.last_applied_manifest, resource_observed\n            )\n        except IndexError:\n            continue\n\n        # As the resource is present in the current last_applied_manifest, we need to go\n        # through it to check if observed fields should be set to their current value\n        # (i.e. fields are present in the current last_applied_manifest, but not in\n        # spec.manifest)\n        try:\n            # Check if the observed resource is present in spec.manifest\n            idx_status_new = get_kubernetes_resource_idx(\n                new_last_applied_manifest, resource_observed\n            )\n        except IndexError:\n            # The resource is observed but is not present in the spec.manifest.\n            # Create an empty resource, which will be augmented in\n            # update_last_applied_manifest_dict_from_spec with the observed and known\n            # fields.\n            new_last_applied_manifest.append({})\n            idx_status_new = len(new_last_applied_manifest) - 1\n\n        update_last_applied_manifest_dict_from_spec(\n            new_last_applied_manifest[idx_status_new],\n            app.status.last_applied_manifest[idx_status_old],\n            resource_observed,\n        )\n\n    app.status.last_applied_manifest = new_last_applied_manifest\n\n\nclass KubernetesApplicationObserver(Observer):\n    \"\"\"Observer specific for Kubernetes Applications. One observer is created for each\n    Application managed by the Controller, but not one per Kubernetes resource\n    (Deployment, Service...). If several resources are defined by an Application, they\n    are all monitored by the same observer.\n\n    The observer gets the actual status of the resources on the cluster using the\n    Kubernetes API, and compare it to the status stored in the API.\n\n    The observer is:\n     * started at initial Krake resource creation;\n\n     * deleted when a resource needs to be updated, then started again when it is done;\n\n     * simply deleted on resource deletion.\n\n    Args:\n        cluster (krake.data.kubernetes.Cluster): the cluster on which the observed\n            Application is created.\n        resource (krake.data.kubernetes.Application): the application that will be\n            observed.\n        on_res_update (coroutine): a coroutine called when a resource's actual status\n            differs from the status sent by the database. Its signature is:\n            ``(resource) -> updated_resource``. ``updated_resource`` is the instance of\n            the resource that is up-to-date with the API. The Observer internal instance\n            of the resource to observe will be updated. If the API cannot be contacted,\n            ``None`` can be returned. In this case the internal instance of the Observer\n            will not be updated.\n        time_step (int, optional): how frequently the Observer should watch the actual\n            status of the resources.\n\n    \"\"\"\n\n    def __init__(self, cluster, resource, on_res_update, time_step=2):\n        super().__init__(resource, on_res_update, time_step)\n        self.cluster = cluster\n\n    async def poll_resource(self):\n        \"\"\"Fetch the current status of the Application monitored by the Observer.\n\n        Returns:\n            krake.data.core.Status: the status object created using information from the\n                real world Applications resource.\n\n        \"\"\"\n        app = self.resource\n\n        status = deepcopy(app.status)\n        status.last_observed_manifest = []\n        # For each observed kubernetes resource of the Application,\n        # get its current status on the cluster.\n        for desired_resource in app.status.last_applied_manifest:\n            kube = KubernetesClient(self.cluster.spec.kubeconfig)\n            idx_observed = get_kubernetes_resource_idx(\n                app.status.mangled_observer_schema, desired_resource\n            )\n            observed_resource = app.status.mangled_observer_schema[idx_observed]\n            async with kube:\n                try:\n                    group, version, kind, name, namespace = kube.get_immutables(\n                        desired_resource\n                    )\n                    resource_api = await kube.get_resource_api(group, version, kind)\n                    resp = await resource_api.read(kind, name, namespace)\n                except ApiException as err:\n                    if err.status == 404:\n                        # Resource does not exist\n                        continue\n                    # Otherwise, log the unexpected errors\n                    logger.error(err)\n\n            observed_manifest = update_last_observed_manifest_dict(\n                observed_resource, resp.to_dict()\n            )\n            status.last_observed_manifest.append(observed_manifest)\n\n        return status\n\n\nclass KubernetesClusterObserver(Observer):\n    \"\"\"Observer specific for Kubernetes Clusters. One observer is created for each\n    Cluster managed by the Controller.\n\n    The observer gets the actual status of the cluster using the\n    Kubernetes API, and compare it to the status stored in the API.\n\n    The observer is:\n     * started at initial Krake resource creation;\n\n     * deleted when a resource needs to be updated, then started again when it is done;\n\n     * simply deleted on resource deletion.\n\n    Args:\n        cluster (krake.data.kubernetes.Cluster): the cluster which will be observed.\n        on_res_update (coroutine): a coroutine called when a resource's actual status\n            differs from the status sent by the database. Its signature is:\n            ``(resource) -> updated_resource``. ``updated_resource`` is the instance of\n            the resource that is up-to-date with the API. The Observer internal instance\n            of the resource to observe will be updated. If the API cannot be contacted,\n            ``None`` can be returned. In this case the internal instance of the Observer\n            will not be updated.\n        time_step (int, optional): how frequently the Observer should watch the actual\n            status of the resources.\n\n    \"\"\"\n\n    def __init__(self, cluster, on_res_update, time_step=2):\n        super().__init__(cluster, on_res_update, time_step)\n        self.cluster = cluster\n\n    async def poll_resource(self):\n        \"\"\"Fetch the current status of the Cluster monitored by the Observer.\n\n        Returns:\n            krake.data.core.Status: the status object created using information from the\n                real world Cluster.\n\n        \"\"\"\n        status = deepcopy(self.cluster.status)\n        # For each observed kubernetes cluster registered in Krake,\n        # get its current node status.\n        loader = KubeConfigLoader(self.cluster.spec.kubeconfig)\n        config = Configuration()\n        await loader.load_and_set(config)\n        kube = ApiClient(config)\n\n        async with kube as api:\n            v1 = client.CoreV1Api(api)\n            try:\n                response = await v1.list_node()\n\n            except ClientConnectorError as err:\n                status.state = ClusterState.OFFLINE\n                self.cluster.status.state = ClusterState.OFFLINE\n                # Log the error\n                logger.debug(err)\n                return status\n\n            condition_dict = {\n                \"MemoryPressure\": [],\n                \"DiskPressure\": [],\n                \"PIDPressure\": [],\n                \"Ready\": [],\n            }\n\n            for item in response.items:\n                for condition in item.status.conditions:\n                    condition_dict[condition.type].append(condition.status)\n                if (\n                    condition_dict[\"MemoryPressure\"] == [\"True\"]\n                    or condition_dict[\"DiskPressure\"] == [\"True\"]\n                    or condition_dict[\"PIDPressure\"] == [\"True\"]\n                ):\n                    status.state = ClusterState.UNHEALTHY\n                    self.cluster.status.state = ClusterState.UNHEALTHY\n                    return status\n                elif (\n                    condition_dict[\"Ready\"] == [\"True\"]\n                    and status.state is ClusterState.OFFLINE\n                ):\n                    status.state = ClusterState.CONNECTING\n                    self.cluster.status.state = ClusterState.CONNECTING\n                    return status\n                elif condition_dict[\"Ready\"] == [\"True\"]:\n                    status.state = ClusterState.ONLINE\n                    self.cluster.status.state = ClusterState.ONLINE\n                    return status\n                else:\n                    status.state = ClusterState.NOTREADY\n                    self.cluster.status.state = ClusterState.NOTREADY\n                    return status\n\n\n@listen.on(HookType.ApplicationPostReconcile)\n@listen.on(HookType.ApplicationPostMigrate)\n@listen.on(HookType.ClusterCreation)\nasync def register_observer(controller, resource, start=True, **kwargs):\n    \"\"\"Create an observer for the given Application or Cluster, and start it as a\n    background task if wanted.\n\n    If an observer already existed for this Application or Cluster, it is stopped\n    and deleted.\n\n    Args:\n        controller (KubernetesController): the controller for which the observer will be\n            added in the list of working observers.\n        resource (krake.data.kubernetes.Application): the Application to observe or\n        resource (krake.data.kubernetes.Cluster): the Cluster to observe.\n        start (bool, optional): if False, does not start the observer as background\n            task.\n\n    \"\"\"\n    if resource.kind == Application.kind:\n        cluster = await controller.kubernetes_api.read_cluster(\n            namespace=resource.status.running_on.namespace,\n            name=resource.status.running_on.name,\n        )\n\n        observer = KubernetesApplicationObserver(\n            cluster,\n            resource,\n            controller.on_status_update,\n            time_step=controller.observer_time_step,\n        )\n\n    elif resource.kind == Cluster.kind:\n        observer = KubernetesClusterObserver(\n            resource,\n            controller.on_status_update,\n            time_step=controller.observer_time_step,\n        )\n    else:\n        logger.debug(\"Unknown resource kind. No observer was registered.\", resource)\n        return\n\n    logger.debug(f\"Start observer for {resource.kind} %r\", resource.metadata.name)\n    task = None\n    if start:\n        task = controller.loop.create_task(observer.run())\n\n    controller.observers[resource.metadata.uid] = (observer, task)\n\n\n@listen.on(HookType.ApplicationPreReconcile)\n@listen.on(HookType.ApplicationPreMigrate)\n@listen.on(HookType.ApplicationPreDelete)\n@listen.on(HookType.ClusterDeletion)\nasync def unregister_observer(controller, resource, **kwargs):\n    \"\"\"Stop and delete the observer for the given Application or Cluster. If no observer\n    is started, do nothing.\n\n    Args:\n        controller (KubernetesController): the controller for which the observer will be\n            removed from the list of working observers.\n        resource (krake.data.kubernetes.Application): the Application whose observer\n        will be stopped or\n        resource (krake.data.kubernetes.Cluster): the Cluster whose observer will be\n        stopped.\n\n    \"\"\"\n    if resource.metadata.uid not in controller.observers:\n        return\n\n    logger.debug(f\"Stop observer for {resource.kind} %r\", resource.metadata.name)\n    _, task = controller.observers.pop(resource.metadata.uid)\n    task.cancel()\n\n    with suppress(asyncio.CancelledError):\n        await task\n\n\ndef utc_difference():\n    \"\"\"Get the difference in seconds between the current time and the current UTC time.\n\n    Returns:\n        int: the time difference in seconds.\n\n    \"\"\"\n    delta = datetime.now() - datetime.utcnow()\n    return delta.seconds\n\n\ndef generate_certificate(config):\n    \"\"\"Create and sign a new certificate using the one defined in the complete hook\n    configuration as intermediate certificate.\n\n    Args:\n        config (krake.data.config.CompleteHookConfiguration): the configuration of the\n            complete hook.\n\n    Returns:\n        CertificatePair: the content of the certificate created and its corresponding\n            key.\n\n    \"\"\"\n    with open(config.intermediate_src, \"rb\") as f:\n        intermediate_src = crypto.load_certificate(crypto.FILETYPE_PEM, f.read())\n    with open(config.intermediate_key_src, \"rb\") as f:\n        intermediate_key_src = crypto.load_privatekey(crypto.FILETYPE_PEM, f.read())\n\n    client_cert = crypto.X509()\n\n    # Set general information\n    client_cert.set_version(3)\n    client_cert.set_serial_number(random.randint(50000000000000, 100000000000000))\n    # If not set before, TLS will not accept to use this certificate in UTC cases, as\n    # the server time may be earlier.\n    time_offset = utc_difference() * -1\n    client_cert.gmtime_adj_notBefore(time_offset)\n    client_cert.gmtime_adj_notAfter(1 * 365 * 24 * 60 * 60)\n\n    # Set issuer and subject\n    intermediate_subject = intermediate_src.get_subject()\n    client_cert.set_issuer(intermediate_subject)\n    client_subj = crypto.X509Name(intermediate_subject)\n    client_subj.CN = config.hook_user\n    client_cert.set_subject(client_subj)\n\n    # Create and set the private key\n    client_key = crypto.PKey()\n    client_key.generate_key(crypto.TYPE_RSA, 2048)\n    client_cert.set_pubkey(client_key)\n\n    client_cert.sign(intermediate_key_src, \"sha256\")\n\n    cert_dump = crypto.dump_certificate(crypto.FILETYPE_PEM, client_cert).decode()\n    key_dump = crypto.dump_privatekey(crypto.FILETYPE_PEM, client_key).decode()\n    return CertificatePair(cert=cert_dump, key=key_dump)\n\n", "contexts_below": "\n def generate_default_observer_schema_dict(manifest_dict, first_level=False):\n     \"\"\"Together with :func:``generate_default_observer_schema_list``, this function is\n     called recursively to generate part of a default ``observer_schema`` from part of a\n     Kubernetes resource, defined respectively by ``manifest_dict`` or ``manifest_list``.\n \n     Args:\n         manifest_dict (dict): Partial Kubernetes resources\n         first_level (bool, optional): If True, indicates that the dictionary represents\n             the whole observer schema of a Kubernetes resource\n \n     Returns:\n         dict: Generated partial observer_schema\n \n     This function creates a new dictionary from ``manifest_dict`` and replaces all\n     non-list and non-dict values by ``None``.\n \n     In case of ``first_level`` dictionary (i.e. complete ``observer_schema`` for a\n     resource), the values of the identifying fields are copied from the manifest file.\n \n     \"\"\"\n     observer_schema_dict = {}\n \n     for key, value in manifest_dict.items():\n \n         if isinstance(value, dict):\n             observer_schema_dict[key] = generate_default_observer_schema_dict(value)\n \n         elif isinstance(value, list):\n             observer_schema_dict[key] = generate_default_observer_schema_list(value)\n \n         else:\n             observer_schema_dict[key] = None\n \n     if first_level:\n         observer_schema_dict[\"apiVersion\"] = manifest_dict[\"apiVersion\"]\n         observer_schema_dict[\"kind\"] = manifest_dict[\"kind\"]\n         observer_schema_dict[\"metadata\"][\"name\"] = manifest_dict[\"metadata\"][\"name\"]\n \n         if (\n             \"spec\" in manifest_dict\n             and \"type\" in manifest_dict[\"spec\"]\n             and manifest_dict[\"spec\"][\"type\"] == \"LoadBalancer\"\n         ):\n             observer_schema_dict[\"status\"] = {\"load_balancer\": {\"ingress\": None}}\n \n     return observer_schema_dict\n \n \n def generate_default_observer_schema_list(manifest_list):\n     \"\"\"Together with :func:``generate_default_observer_schema_dict``, this function is\n     called recursively to generate part of a default ``observer_schema`` from part of a\n     Kubernetes resource, defined respectively by ``manifest_list`` or ``manifest_dict``.\n \n     Args:\n         manifest_list (list): Partial Kubernetes resources\n \n     Returns:\n         list: Generated partial observer_schema\n \n     This function creates a new list from ``manifest_list`` and replaces all non-list\n     and non-dict elements by ``None``.\n \n     Additionally, it generates the default list control dictionary, using the current\n     length of the list as default minimum and maximum values.\n \n     \"\"\"\n     observer_schema_list = []\n \n     for value in manifest_list:\n \n         if isinstance(value, dict):\n             observer_schema_list.append(generate_default_observer_schema_dict(value))\n \n         elif isinstance(value, list):\n             observer_schema_list.append(generate_default_observer_schema_list(value))\n \n         else:\n             observer_schema_list.append(None)\n \n     observer_schema_list.append(\n         {\n             \"observer_schema_list_min_length\": len(manifest_list),\n             \"observer_schema_list_max_length\": len(manifest_list),\n         }\n     )\n \n     return observer_schema_list\n \n \n @listen.on(HookType.ApplicationMangling)\n async def complete(app, api_endpoint, ssl_context, config):\n     \"\"\"Execute application complete hook defined by :class:`Complete`.\n     Hook mangles given application and injects complete hooks variables.\n \n     Application complete hook is disabled by default.\n     User enables this hook by the --hook-complete argument in rok cli.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application object processed\n             when the hook is called\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         config (krake.data.config.HooksConfiguration): Complete hook\n             configuration.\n \n     \"\"\"\n     if \"complete\" not in app.spec.hooks:\n         return\n \n     # Use the endpoint of the API only if the external endpoint has not been set.\n     if config.complete.external_endpoint:\n         api_endpoint = config.complete.external_endpoint\n \n     app.status.complete_token = \\\n         app.status.complete_token if app.status.complete_token else token_urlsafe()\n \n     # Generate only once the certificate and key for a specific Application\n     generated_cert = CertificatePair(\n         cert=app.status.complete_cert, key=app.status.complete_key\n     )\n     if ssl_context and generated_cert == (None, None):\n         generated_cert = generate_certificate(config.complete)\n         app.status.complete_cert = generated_cert.cert\n         app.status.complete_key = generated_cert.key\n \n     hook = Complete(\n         api_endpoint,\n         ssl_context,\n         hook_user=config.complete.hook_user,\n         cert_dest=config.complete.cert_dest,\n         env_token=config.complete.env_token,\n         env_url=config.complete.env_url,\n     )\n     hook.mangle_app(\n         app.metadata.name,\n         app.metadata.namespace,\n         app.status.complete_token,\n         app.status.last_applied_manifest,\n         config.complete.intermediate_src,\n         generated_cert,\n         app.status.mangled_observer_schema,\n         \"complete\"\n     )\n \n \n @listen.on(HookType.ApplicationMangling)\n async def shutdown(app, api_endpoint, ssl_context, config):\n     \"\"\"Executes an application shutdown hook defined by :class:`Shutdown`.\n     The hook mangles the given application and injects shutdown hooks variables.\n \n     Application shutdown hook is disabled by default.\n     User enables this hook by the --hook-shutdown argument in rok cli.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application object processed\n             when the hook is called\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         config (krake.data.config.HooksConfiguration): Shutdown hook\n             configuration.\n \n     \"\"\"\n     if \"shutdown\" not in app.spec.hooks:\n         return\n \n     # Use the endpoint of the API only if the external endpoint has not been set.\n     if config.shutdown.external_endpoint:\n         api_endpoint = config.shutdown.external_endpoint\n \n     app.status.shutdown_token = \\\n         app.status.shutdown_token if app.status.shutdown_token else token_urlsafe()\n \n     # Generate only once the certificate and key for a specific Application\n     generated_cert = CertificatePair(\n         cert=app.status.shutdown_cert, key=app.status.shutdown_key\n     )\n     if ssl_context and generated_cert == (None, None):\n         generated_cert = generate_certificate(config.shutdown)\n         app.status.shutdown_cert = generated_cert.cert\n         app.status.shutdown_key = generated_cert.key\n \n     hook = Shutdown(\n         api_endpoint,\n         ssl_context,\n         hook_user=config.shutdown.hook_user,\n         cert_dest=config.shutdown.cert_dest,\n         env_token=config.shutdown.env_token,\n         env_url=config.shutdown.env_url,\n     )\n     hook.mangle_app(\n         app.metadata.name,\n         app.metadata.namespace,\n         app.status.shutdown_token,\n         app.status.last_applied_manifest,\n         config.shutdown.intermediate_src,\n         generated_cert,\n         app.status.mangled_observer_schema,\n         \"shutdown\"\n     )\n \n \n @listen.on(HookType.ResourcePreDelete)\n async def pre_shutdown(controller, app, **kwargs):\n     \"\"\"\n \n     Args:\n         app (krake.data.kubernetes.Application): Application object processed\n             when the hook is called\n     \"\"\"\n     if \"shutdown\" not in app.spec.hooks:\n         return\n \n     return\n \n \n class SubResource(NamedTuple):\n     group: str\n     name: str\n     body: dict\n     path: tuple\n \n \n class CertificatePair(NamedTuple):\n     \"\"\"Tuple which contains a certificate and its corresponding key.\n \n     Attributes:\n         cert (str): content of a certificate.\n         key (str): content of the key that corresponds to the certificate.\n \n     \"\"\"\n \n     cert: str\n     key: str\n \n \n class Hook(object):\n \n     hook_resources = ()\n \n     ca_name = \"ca-bundle.pem\"\n     cert_name = \"cert.pem\"\n     key_name = \"key.pem\"\n \n     def __init__(\n         self, api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n     ):\n         self.api_endpoint = api_endpoint\n         self.ssl_context = ssl_context\n         self.hook_user = hook_user\n         self.cert_dest = cert_dest\n         self.env_token = env_token\n         self.env_url = env_url\n \n     def mangle_app(\n         self,\n         name,\n         namespace,\n         token,\n         last_applied_manifest,\n         intermediate_src,\n         generated_cert,\n         mangled_observer_schema,\n         hook_type=\"\",\n     ):\n         \"\"\"Mangle a given application and inject complete hook resources and\n         sub-resources into the :attr:`last_applied_manifest` object by :meth:`mangle`.\n         Also mangle the observer_schema as new resources and sub-resources should\n         be observed.\n \n         :attr:`last_applied_manifest` is created as a deep copy of the desired\n         application resources, as defined by user. It can be updated by custom hook\n         resources or modified by custom hook sub-resources. It is used as a desired\n         state for the Krake deployment process.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             token (str): Complete hook authentication token\n             last_applied_manifest (list): Application resources\n             intermediate_src (str): content of the certificate that is used to sign new\n                 certificates for the complete hook.\n             generated_cert (CertificatePair): tuple that contains the content of the\n                 new signed certificate for the Application, and the content of its\n                 corresponding key.\n             mangled_observer_schema (list): Observed fields\n             hook_type (str, optional): Name of the hook the app should be mangled for\n \n         \"\"\"\n \n         secret_certs_name = \"-\".join([name, \"krake\", hook_type, \"secret\", \"certs\"])\n         secret_token_name = \"-\".join([name, \"krake\", hook_type, \"secret\", \"token\"])\n         volume_name = \"-\".join([name, \"krake\", hook_type, \"volume\"])\n         ca_certs = (\n             self.ssl_context.get_ca_certs(binary_form=True)\n             if self.ssl_context\n             else None\n         )\n \n         # Extract all different namespaces\n         # FIXME: too many assumptions here: do we create one ConfigMap for each\n         #  namespace?\n         resource_namespaces = {\n             resource[\"metadata\"].get(\"namespace\", \"default\")\n             for resource in last_applied_manifest\n         }\n \n         hook_resources = []\n         hook_sub_resources = []\n         if ca_certs:\n             hook_resources.extend(\n                 [\n                     self.secret_certs(\n                         secret_certs_name,\n                         resource_namespace,\n                         intermediate_src=intermediate_src,\n                         generated_cert=generated_cert,\n                         ca_certs=ca_certs,\n                     )\n                     for resource_namespace in resource_namespaces\n                 ]\n             )\n             hook_sub_resources.extend(\n                 [*self.volumes(secret_certs_name, volume_name, self.cert_dest)]\n             )\n \n         hook_resources.extend(\n             [\n                 self.secret_token(\n                     secret_token_name,\n                     name,\n                     namespace,\n                     resource_namespace,\n                     self.api_endpoint,\n                     token,\n                 )\n                 for resource_namespace in resource_namespaces\n             ]\n         )\n         hook_sub_resources.extend(\n             [\n                 *self.env_vars(secret_token_name),\n             ]\n         )\n \n         self.mangle(\n             hook_resources,\n             last_applied_manifest,\n             mangled_observer_schema,\n         )\n         self.mangle(\n             hook_sub_resources,\n             last_applied_manifest,\n             mangled_observer_schema,\n             is_sub_resource=True,\n         )\n \n     def mangle(\n         self,\n         items,\n         last_applied_manifest,\n         mangled_observer_schema,\n         is_sub_resource=False,\n     ):\n         \"\"\"Mangle applications desired state with custom hook resources or\n         sub-resources.\n \n         Example:\n             .. code:: python\n \n             last_applied_manifest = [\n                 {\n                     'apiVersion': 'v1',\n                     'kind': 'Pod',\n                     'metadata': {'name': 'test', 'namespace': 'default'},\n                     'spec': {'containers': [{'name': 'test'}]}\n                 }\n             ]\n             mangled_observer_schema = [\n                 {\n                     'apiVersion': 'v1',\n                     'kind': 'Pod',\n                     'metadata': {'name': 'test', 'namespace': 'default'},\n                     'spec': {\n                         'containers': [\n                             {'name': None},\n                             {\n                                 'observer_schema_list_max_length': 1,\n                                 'observer_schema_list_min_length': 1,\n                             },\n                         ]\n                     },\n                 }\n             ]\n             hook_resources = [\n                 {\n                     'apiVersion': 'v1',\n                     'kind': 'Secret',\n                     'metadata': {'name': 'sct', 'namespace': 'default'}\n                 }\n             ]\n             hook_sub_resources = [\n                 SubResource(\n                     group='env', name='env', body={'name': 'test', 'value': 'test'},\n                     path=(('spec', 'containers'),)\n                 )\n             ]\n \n             mangle(\n                 hook_resources,\n                 last_applied_manifest,\n                 mangled_observer_schema,\n             )\n             mangle(\n                 hook_sub_resources,\n                 last_applied_manifest,\n                 mangled_observer_schema,\n                 is_sub_resource=True\n             )\n \n             assert last_applied_manifest == [\n                 {\n                     \"apiVersion\": \"v1\",\n                     \"kind\": \"Pod\",\n                     \"metadata\": {\"name\": \"test\", 'namespace': 'default'},\n                     \"spec\": {\n                         \"containers\": [\n                             {\n                                 \"name\": \"test\",\n                                 \"env\": [{\"name\": \"test\", \"value\": \"test\"}]\n                             }\n                         ]\n                     },\n                 },\n                 {\"apiVersion\": \"v1\", \"kind\": \"Secret\", \"metadata\": {\"name\": \"sct\"}},\n             ]\n \n             assert mangled_observer_schema == [\n                 {\n                     \"apiVersion\": \"v1\",\n                     \"kind\": \"Pod\",\n                     \"metadata\": {\"name\": \"test\", \"namespace\": None},\n                     \"spec\": {\n                         \"containers\": [\n                             {\n                                 \"name\": None,\n                                 \"env\": [\n                                     {\"name\": None, \"value\": None},\n                                     {\n                                         \"observer_schema_list_max_length\": 1,\n                                         \"observer_schema_list_min_length\": 1,\n                                     },\n                                 ],\n                             },\n                             {\n                                 \"observer_schema_list_max_length\": 1,\n                                 \"observer_schema_list_min_length\": 1,\n                             },\n                         ]\n                     },\n                 },\n                 {\n                     \"apiVersion\": \"v1\",\n                     \"kind\": \"Secret\",\n                     \"metadata\": {\"name\": \"sct\", \"namespace\": None},\n                 },\n             ]\n \n         Args:\n             items (list[SubResource]): Custom hook resources or sub-resources\n             last_applied_manifest (list): Application resources\n             mangled_observer_schema (list): Observed resources\n             is_sub_resource (bool, optional): if False, the function only extend the\n                 list of Kubernetes resources defined in :attr:`last_applied_manifest`\n                 with new hook resources. Otherwise, the function injects each new hook\n                 sub-resource into the :attr:`last_applied_manifest` object\n                 sub-resources. Defaults to False.\n \n         \"\"\"\n \n         if not items:\n             return\n \n         if not is_sub_resource:\n             last_applied_manifest.extend(items)\n             for sub_resource in items:\n                 # Generate the default observer schema for each resource\n                 mangled_observer_schema.append(\n                     generate_default_observer_schema_dict(\n                         sub_resource,\n                         first_level=True,\n                     )\n                 )\n             return\n \n         def inject(sub_resource, sub_resource_to_mangle, observed_resource_to_mangle):\n             \"\"\"Inject a hooks defined sub-resource into a Kubernetes sub-resource.\n \n             Args:\n                 sub_resource (SubResource): Hook sub-resource that needs to be injected\n                     into :attr:`last_applied_manifest`\n                 sub_resource_to_mangle (object): Kubernetes sub-resources from\n                     :attr:`last_applied_manifest` which need to be processed\n                 observed_resource_to_mangle (dict): partial mangled_observer_schema\n                     corresponding to the Kubernetes sub-resource.\n \n             Raises:\n                 InvalidManifestError: if the sub-resource which will be mangled is not a\n                     list or a dict.\n \n             \"\"\"\n \n             # Create sub-resource group if not present in the Kubernetes sub-resource\n             if sub_resource.group not in sub_resource_to_mangle:\n                 # FIXME: This assumes the subresource group contains a list\n                 sub_resource_to_mangle.update({sub_resource.group: []})\n \n             # Create sub-resource group if not present in the observed fields\n             if sub_resource.group not in observed_resource_to_mangle:\n                 observed_resource_to_mangle.update(\n                     {\n                         sub_resource.group: [\n                             {\n                                 \"observer_schema_list_min_length\": 0,\n                                 \"observer_schema_list_max_length\": 0,\n                             }\n                         ]\n                     }\n                 )\n \n             # Inject sub-resource\n             # If sub-resource name is already there update it, if not, append it\n             if sub_resource.name in [\n                 g[\"name\"] for g in sub_resource_to_mangle[sub_resource.group]\n             ]:\n                 # FIXME: Assuming we are dealing with a list\n                 for idx, item in enumerate(sub_resource_to_mangle[sub_resource.group]):\n                     if item[\"name\"]:\n                         if hasattr(item, \"body\"):\n                             sub_resource_to_mangle[item.group][idx] = item[\"body\"]\n             else:\n                 sub_resource_to_mangle[sub_resource.group].append(sub_resource.body)\n \n             # Make sure the value is observed\n             if sub_resource.name not in [\n                 g[\"name\"] for g in observed_resource_to_mangle[sub_resource.group][:-1]\n             ]:\n                 observed_resource_to_mangle[sub_resource.group].insert(\n                     -1, generate_default_observer_schema_dict(sub_resource.body)\n                 )\n                 observed_resource_to_mangle[sub_resource.group][-1][\n                     \"observer_schema_list_min_length\"\n                 ] += 1\n                 observed_resource_to_mangle[sub_resource.group][-1][\n                     \"observer_schema_list_max_length\"\n                 ] += 1\n \n         for resource in last_applied_manifest:\n             # Complete hook is applied only on defined Kubernetes resources\n             if resource[\"kind\"] not in self.hook_resources:\n                 continue\n \n             for sub_resource in items:\n                 sub_resources_to_mangle = None\n                 idx_observed = get_kubernetes_resource_idx(\n                     mangled_observer_schema, resource\n                 )\n                 for keys in sub_resource.path:\n                     try:\n                         sub_resources_to_mangle = reduce(getitem, keys, resource)\n                     except KeyError:\n                         continue\n \n                     break\n \n                 # Create the path to the observed sub-resource, if it doesn't yet exist\n                 try:\n                     observed_sub_resources = reduce(\n                         getitem, keys, mangled_observer_schema[idx_observed]\n                     )\n                 except KeyError:\n                     Complete.create_path(\n                         mangled_observer_schema[idx_observed], list(keys)\n                     )\n                     observed_sub_resources = reduce(\n                         getitem, keys, mangled_observer_schema[idx_observed]\n                     )\n \n                 if isinstance(sub_resources_to_mangle, list):\n                     for idx, sub_resource_to_mangle in enumerate(\n                         sub_resources_to_mangle\n                     ):\n \n                         # Ensure that each element of the list is observed.\n                         idx_observed = idx\n                         if idx >= len(observed_sub_resources[:-1]):\n                             idx_observed = len(observed_sub_resources[:-1])\n                             # FIXME: Assuming each element of the list contains a\n                             # dictionary, therefore initializing new elements with an\n                             # empty dict\n                             observed_sub_resources.insert(-1, {})\n                         observed_sub_resource = observed_sub_resources[idx_observed]\n \n                         # FIXME: This is assuming a list always contains dict\n                         inject(\n                             sub_resource, sub_resource_to_mangle, observed_sub_resource\n                         )\n \n                 elif isinstance(sub_resources_to_mangle, dict):\n                     inject(\n                         sub_resource, sub_resources_to_mangle, observed_sub_resources\n                     )\n \n                 else:\n                     message = (\n                         f\"The sub-resource to mangle {sub_resources_to_mangle!r} has an\"\n                         \"invalid type, should be in '[dict, list]'\"\n                     )\n                     raise InvalidManifestError(message)\n \n     @staticmethod\n     def attribute_map(obj):\n         \"\"\"Convert a Kubernetes object to dict based on its attribute mapping\n \n         Example:\n             .. code:: python\n \n             from kubernetes_asyncio.client import V1VolumeMount\n \n             d = attribute_map(\n                     V1VolumeMount(name=\"name\", mount_path=\"path\")\n             )\n             assert d == {'mountPath': 'path', 'name': 'name'}\n \n         Args:\n             obj (object): Kubernetes object\n \n         Returns:\n             dict: Converted Kubernetes object\n \n         \"\"\"\n         return {\n             obj.attribute_map[attr]: getattr(obj, attr)\n             for attr, _ in obj.to_dict().items()\n             if getattr(obj, attr) is not None\n         }\n \n     @staticmethod\n     def create_path(mangled_observer_schema, keys):\n         \"\"\"Create the path to the observed field in the observer schema.\n \n         When a sub-resource is mangled, it should be observed. This function creates\n         the path to the subresource to observe.\n \n         Args:\n             mangled_observer_schema (dict): Partial observer schema of a resource\n             keys (list): list of keys forming the path to the sub-resource to\n                 observe\n \n         FIXME: This assumes we are only adding keys to dict. We don't consider lists\n \n         \"\"\"\n \n         # Unpack the first key first, as it contains the base directory\n         key = keys.pop(0)\n \n         # If the key is the last of the list, we reached the end of the path.\n         if len(keys) == 0:\n             mangled_observer_schema[key] = None\n             return\n \n         if key not in mangled_observer_schema:\n             mangled_observer_schema[key] = {}\n         Hook.create_path(mangled_observer_schema[key], keys)\n \n     def secret_certs(\n         self,\n         secret_name,\n         namespace,\n         ca_certs=None,\n         intermediate_src=None,\n         generated_cert=None,\n     ):\n         \"\"\"Create a complete hooks secret resource.\n \n         Complete hook secret stores Krake CAs and client certificates to communicate\n         with the Krake API.\n \n         Args:\n             secret_name (str): Secret name\n             namespace (str): Kubernetes namespace where the Secret will be created.\n             ca_certs (list): Krake CA list\n             intermediate_src (str): content of the certificate that is used to sign new\n                 certificates for the complete hook.\n             generated_cert (CertificatePair): tuple that contains the content of the\n                 new signed certificate for the Application, and the content of its\n                 corresponding key.\n \n         Returns:\n             dict: complete hook secret resource\n \n         \"\"\"\n         ca_certs_pem = \"\"\n         for ca_cert in ca_certs:\n             x509 = crypto.load_certificate(crypto.FILETYPE_ASN1, ca_cert)\n             ca_certs_pem += crypto.dump_certificate(crypto.FILETYPE_PEM, x509).decode()\n \n         # Add the intermediate certificate into the chain\n         with open(intermediate_src, \"r\") as f:\n             intermediate_src_content = f.read()\n         ca_certs_pem += intermediate_src_content\n \n         data = {\n             self.ca_name: self._encode_to_64(ca_certs_pem),\n             self.cert_name: self._encode_to_64(generated_cert.cert),\n             self.key_name: self._encode_to_64(generated_cert.key),\n         }\n         return self.secret(secret_name, data, namespace)\n \n     def secret_token(\n         self, secret_name, name, namespace, resource_namespace, api_endpoint, token\n     ):\n         \"\"\"Create a hooks secret resource.\n \n         The hook secret stores Krake authentication token\n         and hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n             name (str): Application name\n             namespace (str): Application namespace\n             resource_namespace (str): Kubernetes namespace where the\n                 Secret will be created.\n             api_endpoint (str): Krake API endpoint\n             token (str): Complete hook authentication token\n \n         Returns:\n             dict: complete hook secret resource\n \n         \"\"\"\n         pass\n \n     def volumes(self, secret_name, volume_name, mount_path):\n         \"\"\"Create complete hooks volume and volume mount sub-resources\n \n         Complete hook volume gives access to hook's secret, which stores\n         Krake CAs and client certificates to communicate with the Krake API.\n         Complete hook volume mount puts the volume into the application\n \n         Args:\n             secret_name (str): Secret name\n             volume_name (str): Volume name\n             mount_path (list): Volume mount path\n \n         Returns:\n             list: List of complete hook volume and volume mount sub-resources\n \n         \"\"\"\n         volume = V1Volume(name=volume_name, secret={\"secretName\": secret_name})\n         volume_mount = V1VolumeMount(name=volume_name, mount_path=mount_path)\n         return [\n             SubResource(\n                 group=\"volumes\",\n                 name=volume.name,\n                 body=self.attribute_map(volume),\n                 path=((\"spec\", \"template\", \"spec\"), (\"spec\",)),\n             ),\n             SubResource(\n                 group=\"volumeMounts\",\n                 name=volume_mount.name,\n                 body=self.attribute_map(volume_mount),\n                 path=(\n                     (\"spec\", \"template\", \"spec\", \"containers\"),\n                     (\"spec\", \"containers\"),  # kind: Pod\n                 ),\n             ),\n         ]\n \n     @staticmethod\n     def _encode_to_64(string):\n         \"\"\"Compute the base 64 encoding of a string.\n \n         Args:\n             string (str): the string to encode.\n \n         Returns:\n             str: the result of the encoding.\n \n         \"\"\"\n         return b64encode(string.encode()).decode()\n \n     def secret(self, secret_name, secret_data, namespace, _type=\"Opaque\"):\n         \"\"\"Create a secret resource.\n \n         Args:\n             secret_name (str): Secret name\n             secret_data (dict): Secret data\n             namespace (str): Kubernetes namespace where the Secret will be created.\n             _type (str, optional): Secret type. Defaults to Opaque.\n \n         Returns:\n             dict: secret resource\n \n         \"\"\"\n         return self.attribute_map(\n             V1Secret(\n                 api_version=\"v1\",\n                 kind=\"Secret\",\n                 data=secret_data,\n                 metadata={\"name\": secret_name, \"namespace\": namespace},\n                 type=_type,\n             )\n         )\n \n     @staticmethod\n     def create_hook_url(name, namespace, api_endpoint):\n         \"\"\"Create an applications' hook URL.\n         Function needs to be specified for each hook.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             api_endpoint (str): Krake API endpoint\n \n         Returns:\n             str: Application shutdown url\n \n         \"\"\"\n         pass\n \n     def env_vars(self, secret_name):\n         \"\"\"Create the hooks' environment variables sub-resources.\n         Function needs to be specified for each hook.\n \n         Creates hook environment variables to store Krake authentication token\n         and a hook URL for the given applications.\n \n         Args:\n             secret_name (str): Secret name\n \n         Returns:\n             list: List of shutdown hook environment variables sub-resources\n \n         \"\"\"\n         pass\n \n \n class Complete(Hook):\n     \"\"\"Mangle given application and inject complete hooks variables into it.\n \n     Hook injects a Kubernetes secret, which stores Krake authentication token\n     and the Krake complete hook URL for the given application. The variables\n     from Kubernetes secret are imported as environment variables\n     into the application resource definition. Only resources defined in\n     :args:`hook_resources` can be modified.\n \n     Names of environment variables are defined in the application controller\n     configuration file.\n \n     If TLS is enabled on the Krake API, the complete hook injects a Kubernetes secret,\n     and it's corresponding volume and volume mount definitions for the Krake CA,\n     the client certificate with the right CN, and its key. The directory where the\n     secret is mounted is defined in the configuration.\n \n     Args:\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         cert_dest (str, optional): Path of the directory where the CA, client\n             certificate and key to the Krake API will be stored.\n         env_token (str, optional): Name of the environment variable, which stores Krake\n             authentication token.\n         env_url (str, optional): Name of the environment variable,\n             which stores Krake complete hook URL.\n \n     \"\"\"\n \n     hook_resources = (\"Pod\", \"Deployment\", \"ReplicationController\")\n \n     def __init__(\n         self, api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n     ):\n         super().__init__(\n             api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n         )\n         self.env_url = env_url\n \n     def secret_token(\n         self, secret_name, name, namespace, resource_namespace, api_endpoint, token\n     ):\n         \"\"\"Create complete hooks secret resource.\n \n         Complete hook secret stores Krake authentication token\n         and complete hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n             name (str): Application name\n             namespace (str): Application namespace\n             resource_namespace (str): Kubernetes namespace where the\n                 Secret will be created.\n             api_endpoint (str): Krake API endpoint\n             token (str): Complete hook authentication token\n \n         Returns:\n             dict: complete hook secret resource\n \n         \"\"\"\n         complete_url = self.create_hook_url(name, namespace, api_endpoint)\n         data = {\n             self.env_token.lower(): self._encode_to_64(token),\n             self.env_url.lower(): self._encode_to_64(complete_url),\n         }\n         return self.secret(secret_name, data, resource_namespace)\n \n     @staticmethod\n     def create_hook_url(name, namespace, api_endpoint):\n         \"\"\"Create an applications' complete URL.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             api_endpoint (str): Krake API endpoint\n \n         Returns:\n             str: Application complete url\n \n         \"\"\"\n         api_url = URL(api_endpoint)\n         return str(\n             api_url.with_path(\n                 f\"/kubernetes/namespaces/{namespace}/applications/{name}/complete\"\n             )\n         )\n \n     def env_vars(self, secret_name):\n         \"\"\"Create complete hooks environment variables sub-resources\n \n         Create complete hook environment variables store Krake authentication token\n         and complete hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n \n         Returns:\n             list: List of complete hook environment variables sub-resources\n \n         \"\"\"\n         sub_resources = []\n \n         env_token = V1EnvVar(\n             name=self.env_token,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(\n                             name=secret_name, key=self.env_token.lower()\n                         )\n                     )\n                 )\n             ),\n         )\n         env_url = V1EnvVar(\n             name=self.env_url,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(name=secret_name, key=self.env_url.lower())\n                     )\n                 )\n             ),\n         )\n \n         for env in (env_token, env_url):\n             sub_resources.append(\n                 SubResource(\n                     group=\"env\",\n                     name=env.name,\n                     body=self.attribute_map(env),\n                     path=(\n                         (\"spec\", \"template\", \"spec\", \"containers\"),\n                         (\"spec\", \"containers\"),  # kind: Pod\n                     ),\n                 )\n             )\n         return sub_resources\n \n \n class Shutdown(Hook):\n     \"\"\"Mangle given application and inject shutdown hooks variables into it.\n \n     Hook injects a Kubernetes secret, which stores Krake authentication token\n     and the Krake complete hook URL for the given application. The variables\n     from the Kubernetes secret are imported as environment variables\n     into the application resource definition. Only resources defined in\n     :args:`hook_resources` can be modified.\n \n     Names of environment variables are defined in the application controller\n     configuration file.\n \n     If TLS is enabled on the Krake API, the shutdown hook injects a Kubernetes secret,\n     and it's corresponding volume and volume mount definitions for the Krake CA,\n     the client certificate with the right CN, and its key. The directory where the\n     secret is mounted is defined in the configuration.\n \n     Args:\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         cert_dest (str, optional): Path of the directory where the CA, client\n             certificate and key to the Krake API will be stored.\n         env_token (str, optional): Name of the environment variable, which stores Krake\n             authentication token.\n         env_url (str, optional): Name of the environment variable,\n             which stores Krake complete hook URL.\n \n     \"\"\"\n \n     hook_resources = (\"Pod\", \"Deployment\", \"ReplicationController\")\n \n     def __init__(\n         self, api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n     ):\n         super().__init__(\n             api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n         )\n         self.env_url = env_url\n \n     def secret_token(\n         self, secret_name, name, namespace, resource_namespace, api_endpoint, token\n     ):\n         \"\"\"Create shutdown hooks secret resource.\n \n         Shutdown hook secret stores Krake authentication token\n         and shutdown hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n             name (str): Application name\n             namespace (str): Application namespace\n             resource_namespace (str): Kubernetes namespace where the\n                 Secret will be created.\n             api_endpoint (str): Krake API endpoint\n             token (str): Shutdown hook authentication token\n \n         Returns:\n             dict: shutdown hook secret resource\n \n         \"\"\"\n         shutdown_url = self.create_hook_url(name, namespace, api_endpoint)\n         data = {\n             self.env_token.lower(): self._encode_to_64(token),\n             self.env_url.lower(): self._encode_to_64(shutdown_url),\n         }\n         return self.secret(secret_name, data, resource_namespace)\n \n     @staticmethod\n     def create_hook_url(name, namespace, api_endpoint):\n         \"\"\"Create an applications' shutdown URL.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             api_endpoint (str): Krake API endpoint\n \n         Returns:\n             str: Application shutdown url\n \n         \"\"\"\n         api_url = URL(api_endpoint)\n         return str(\n             api_url.with_path(\n                 f\"/kubernetes/namespaces/{namespace}/applications/{name}/shutdown\"\n             )\n         )\n \n     def env_vars(self, secret_name):\n         \"\"\"Create shutdown hooks environment variables sub-resources.\n \n         Creates shutdown hook environment variables to store Krake authentication token\n         and a shutdown hook URL for given applications.\n \n         Args:\n             secret_name (str): Secret name\n \n         Returns:\n             list: List of shutdown hook environment variables sub-resources\n \n         \"\"\"\n         sub_resources = []\n \n         env_resources = []\n \n         env_token = V1EnvVar(\n             name=self.env_token,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(\n                             name=secret_name,\n                             key=self.env_token.lower()\n                         )\n                     )\n                 )\n             )\n         )\n         env_resources.append(env_token)\n \n         env_url = V1EnvVar(\n             name=self.env_url,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(name=secret_name, key=self.env_url.lower())\n                     )\n                 )\n             ),\n         )\n         env_resources.append(env_url)\n \n         for env in env_resources:\n             sub_resources.append(\n                 SubResource(\n                     group=\"env\",\n                     name=env.name,\n                     body=self.attribute_map(env),\n                     path=(\n                         (\"spec\", \"template\", \"spec\", \"containers\"),\n                         (\"spec\", \"containers\"),  # kind: Pod\n                     ),\n                 )\n             )\n         return sub_resources\n ", "input_code": "def generate_default_observer_schema(app):\n\"\"\"\nGenerate the default observer schema for each Kubernetes resource present in\n``spec.manifest`` for which a custom observer schema hasn't been specified.\n\nArgs:\n    app (krake.data.kubernetes.Application): The application for which to generate a\n        default observer schema\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def generate_default_observer_schema(app):\n    \"\"\"Generate the default observer schema for each Kubernetes resource present in\n    ``spec.manifest`` for which a custom observer schema hasn't been specified.\n\n    Args:\n        app (krake.data.kubernetes.Application): The application for which to generate a\n            default observer schema\n    \"\"\"\n\n    app.status.mangled_observer_schema = deepcopy(app.spec.observer_schema)\n\n    for resource_manifest in app.spec.manifest:\n        try:\n            get_kubernetes_resource_idx(\n                app.status.mangled_observer_schema, resource_manifest\n            )\n\n        except IndexError:\n            # Only create a default observer schema, if a custom observer schema hasn't\n            # been set by the user.\n            app.status.mangled_observer_schema.append(\n                generate_default_observer_schema_dict(\n                    resource_manifest,\n                    first_level=True,\n                )\n            )", "signature": "def generate_default_observer_schema(app):", "completion_path": "krake/krake/controller/kubernetes/hooks.py"}
{"ce_id": "62b43427903eeb48555d3ea5", "namespace": "62b43427903eeb48555d3ea5", "namespace_real": "sqlparams.__init__.format", "real_proj_path": "cpburnz---python-sql-parameters/", "type": "class", "class_name": "__init__", "function_name": "format", "contexts_above": "\"\"\"\n:mod:`sqlparams` is a utility package for converting between various SQL\nparameter styles.\n\"\"\"\n\nimport re\nfrom typing import (\n\tAny,\n\tAnyStr,\n\tDict,\n\tIterable,\n\tList,\n\tOptional,\n\tPattern,\n\tSequence,\n\tTuple,\n\tType,\n\tUnion)\n\nfrom . import _converting\nfrom . import _styles\nfrom ._util import _is_iterable\n\nfrom ._meta import (\n\t__author__,\n\t__copyright__,\n\t__credits__,\n\t__license__,\n\t__version__,\n)\n\n_BYTES_ENCODING = 'latin1'\n\"\"\"\nThe encoding to use when parsing a byte query string.\n\"\"\"\n\n_STYLES = {}\n\"\"\"\nMaps parameter style by name.\n\"\"\"\n\n\nclass SQLParams(object):\n\t\"\"\"\n\tThe :class:`.SQLParams` class is used to support named parameters in\n\tSQL queries where they are not otherwise supported (e.g., pyodbc).\n\tThis is done by converting from one parameter style query to another\n\tparameter style query.\n\n\tBy default, when converting to a numeric or ordinal style any\n\t:class:`tuple` parameter will be expanded into \"(?,?,...)\" to support\n\tthe widely used \"IN {tuple}\" SQL expression without leaking any\n\tunescaped values.\n\t\"\"\"\n\n\tdef __init__(\n\t\tself,\n\t\tin_style: str,\n\t\tout_style: str,\n\t\tescape_char: Union[str, bool, None] = None,\n\t\texpand_tuples: Optional[bool] = None,\n\t) -> None:\n\t\t\"\"\"\n\t\tInstantiates the :class:`.SQLParams` instance.\n\n\t\t*in_style* (:class:`str`) is the parameter style that will be used\n\t\tin an SQL query before being parsed and converted to :attr:`.SQLParams.out_style`.\n\n\t\t*out_style* (:class:`str`) is the parameter style that the SQL query\n\t\twill be converted to.\n\n\t\t*escape_char* (:class:`str`, :class:`bool`, or :data:`None`) is the\n\t\tescape character used to prevent matching a in-style parameter. If\n\t\t:data:`True`, use the default escape character (repeat the initial\n\t\tcharacter to escape it; e.g., \"%%\"). If :data:`False`, do not use an\n\t\tescape character. Default is :data:`None` for :data:`False`.\n\n\t\t*expand_tuples* (:class:`bool` or :data:`None`) is whether to\n\t\texpand tuples into a sequence of parameters. Default is :data:`None`\n\t\tto let it be determined by *out_style* (to maintain backward\n\t\tcompatibility). If *out_style* is a numeric or ordinal style, expand\n\t\ttuples by default (:data:`True`). If *out_style* is a named style,\n\t\tdo not expand tuples by default (:data:`False`).\n\n\t\tThe following parameter styles are supported by both *in_style* and\n\t\t*out_style*:\n\n\t\t-\tFor all named styles the parameter keys must be valid `Python identifiers`_.\n\t\t\tThey cannot start with a digit. This is to help prevent\n\t\t\tincorrectly matching common strings such as datetimes.\n\n\t\t\tNamed styles:\n\n\t\t\t-\t\"named\" indicates parameters will use the named style::\n\n\t\t\t\t\t... WHERE name = :name\n\n\t\t\t-\t\"named_dollar\" indicates parameters will use the named dollar\n\t\t\t\tsign style::\n\n\t\t\t\t\t... WHERE name = $name\n\n\t\t\t\t.. NOTE:: This is not defined by `PEP 249`_.\n\n\t\t\t-\t\"pyformat\" indicates parameters will use the named Python\n\t\t\t\textended format style::\n\n\t\t\t\t\t... WHERE name = %(name)s\n\n\t\t\t\t.. NOTE:: Strictly speaking, `PEP 249`_ only specifies\n\t\t\t\t   \"%(name)s\" for the \"pyformat\" parameter style so only that\n\t\t\t\t   form (without any other conversions or flags) is supported.\n\n\t\t-\tAll numeric styles start at :data:`1`. When using a\n\t\t\t:class:`~collections.abc.Sequence` for the parameters, the 1st\n\t\t\tparameter (e.g., \":1\") will correspond to the 1st element of the\n\t\t\tsequence (i.e., index :data:`0`). When using a :class:`~collections.abc.Mapping`\n\t\t\tfor the parameters, the 1st parameter (e.g., \":1\") will correspond\n\t\t\tto the matching key (i.e., :data:`1` or :data:`\"1\"`).\n\n\t\t\tNumeric styles:\n\n\t\t\t-\t\"numeric\" indicates parameters will use the numeric style::\n\n\t\t\t\t\t... WHERE name = :1\n\n\t\t\t-\t\"numeric_dollar\" indicates parameters will use the numeric\n\t\t\t\tdollar sign style (starts at :data:`1`)::\n\n\t\t\t\t\t... WHERE name = $1\n\n\t\t\t\t.. NOTE:: This is not defined by `PEP 249`_.\n\n\t\t- Ordinal styles:\n\n\t\t\t-\t\"format\" indicates parameters will use the ordinal Python format\n\t\t\t\tstyle::\n\n\t\t\t\t\t... WHERE name = %s\n\n\t\t\t\t.. NOTE:: Strictly speaking, `PEP 249`_ only specifies \"%s\" for\n\t\t\t\t   the \"format\" parameter styles so only that form (without any\n\t\t\t\t   other conversions or flags) is supported.\n\n\t\t\t-\t\"qmark\" indicates parameters will use the ordinal question mark\n\t\t\t\tstyle::\n\n\t\t\t\t\t... WHERE name = ?\n\n\t\t.. _`PEP 249`: http://www.python.org/dev/peps/pep-0249/\n\n\t\t.. _`Python identifiers`: https://docs.python.org/3/reference/lexical_analysis.html#identifiers\n\t\t\"\"\"\n\n\t\tself._converter: _converting._Converter = None\n\t\t\"\"\"\n\t\t*_converter* (:class:`._converting._Converter`) is the parameter\n\t\tconverter to use.\n\t\t\"\"\"\n\n\t\tself._escape_char: Optional[str] = None\n\t\t\"\"\"\n\t\t*_escape_char* (:class:`str` or :data:`None`) is the escape\n\t\tcharacter used to prevent matching a in-style parameter.\n\t\t\"\"\"\n\n\t\tself._expand_tuples: bool = None\n\t\t\"\"\"\n\t\t*_expand_tuples* (:class:`bool`) is whether to convert tuples into a\n\t\tsequence of parameters.\n\t\t\"\"\"\n\n\t\tself._in_obj: _styles._Style = None\n\t\t\"\"\"\n\t\t*_in_obj* (:class:`._styles._Style`) is the in-style parameter object.\n\t\t\"\"\"\n\n\t\tself._in_regex: Pattern = None\n\t\t\"\"\"\n\t\t*_in_regex* (:class:`re.Pattern`) is the regular expression used to\n\t\textract the in-style parameters.\n\t\t\"\"\"\n\n\t\tself._in_style: str = None\n\t\t\"\"\"\n\t\t*_in_style* (:class:`str`) is the parameter style that will be used\n\t\tin an SQL query before being parsed and converted to :attr:`.SQLParams.out_style`.\n\t\t\"\"\"\n\n\t\tself._out_obj: _styles._Style = None\n\t\t\"\"\"\n\t\t*_out_obj* (:class:`._styles._Style`) is the out-style parameter object.\n\t\t\"\"\"\n\n\t\tself._out_style: str = None\n\t\t\"\"\"\n\t\t*_out_style* (:class:`str`) is the parameter style that the SQL query\n\t\twill be converted to.\n\t\t\"\"\"\n\n\t\tif not isinstance(in_style, str):\n\t\t\traise TypeError(\"in_style:{!r} is not a string.\".format(in_style))\n\n\t\tif not isinstance(out_style, str):\n\t\t\traise TypeError(\"out_style:{!r} is not a string.\".format(out_style))\n\n\t\tself._in_style = in_style\n\t\tself._out_style = out_style\n\n\t\tself._in_obj = _styles._STYLES[self._in_style]\n\t\tself._out_obj = _styles._STYLES[self._out_style]\n\n\t\tif escape_char is True:\n\t\t\tuse_char = self._in_obj.escape_char\n\t\telif not escape_char:\n\t\t\tuse_char = None\n\t\telif isinstance(escape_char, str):\n\t\t\tuse_char = escape_char\n\t\telse:\n\t\t\traise TypeError(\"escape_char:{!r} is not a string or bool.\")\n\n\t\tif expand_tuples is None:\n\t\t\texpand_tuples = not isinstance(self._out_obj, _styles._NamedStyle)\n\n\t\tself._escape_char = use_char\n\t\tself._expand_tuples = bool(expand_tuples)\n\n\t\tself._in_regex = self._create_in_regex()\n\t\tself._converter = self._create_converter()\n\n\tdef __repr__(self) -> str:\n\t\t\"\"\"\n\t\tReturns the canonical string representation (:class:`str`) of this\n\t\tinstance.\n\t\t\"\"\"\n\t\treturn \"{}.{}({!r}, {!r})\".format(self.__class__.__module__, self.__class__.__name__, self._in_style, self._out_style)\n\n\tdef _create_converter(self) -> _converting._Converter:\n\t\t\"\"\"\n\t\tCreate the parameter style converter.\n\n\t\tReturns the parameter style converter (:class:`._converting._Converter`).\n\t\t\"\"\"\n\t\tassert self._in_regex is not None, self._in_regex\n\t\tassert self._out_obj is not None, self._out_obj\n\n\t\t# Determine converter class.\n\t\tconverter_class: Type[_converting._Converter]\n\t\tif isinstance(self._in_obj, _styles._NamedStyle):\n\t\t\tif isinstance(self._out_obj, _styles._NamedStyle):\n\t\t\t\tconverter_class = _converting._NamedToNamedConverter\n\t\t\telif isinstance(self._out_obj, _styles._NumericStyle):\n\t\t\t\tconverter_class = _converting._NamedToNumericConverter\n\t\t\telif isinstance(self._out_obj, _styles._OrdinalStyle):\n\t\t\t\tconverter_class = _converting._NamedToOrdinalConverter\n\t\t\telse:\n\t\t\t\traise TypeError(\"out_style:{!r} maps to an unexpected type: {!r}\".format(self._out_style, self._out_obj))\n\n\t\telif isinstance(self._in_obj, _styles._NumericStyle):\n\t\t\tif isinstance(self._out_obj, _styles._NamedStyle):\n\t\t\t\tconverter_class = _converting._NumericToNamedConverter\n\t\t\telif isinstance(self._out_obj, _styles._NumericStyle):\n\t\t\t\tconverter_class = _converting._NumericToNumericConverter\n\t\t\telif isinstance(self._out_obj, _styles._OrdinalStyle):\n\t\t\t\tconverter_class = _converting._NumericToOrdinalConverter\n\t\t\telse:\n\t\t\t\traise TypeError(\"out_style:{!r} maps to an unexpected type: {!r}\".format(self._out_style, self._out_obj))\n\n\t\telif isinstance(self._in_obj, _styles._OrdinalStyle):\n\t\t\tif isinstance(self._out_obj, _styles._NamedStyle):\n\t\t\t\tconverter_class = _converting._OrdinalToNamedConverter\n\t\t\telif isinstance(self._out_obj, _styles._NumericStyle):\n\t\t\t\tconverter_class = _converting._OrdinalToNumericConverter\n\t\t\telif isinstance(self._out_obj, _styles._OrdinalStyle):\n\t\t\t\tconverter_class = _converting._OrdinalToOrdinalConverter\n\t\t\telse:\n\t\t\t\traise TypeError(\"out_style:{!r} maps to an unexpected type: {!r}\".format(self._out_style, self._out_obj))\n\n\t\telse:\n\t\t\traise TypeError(\"in_style:{!r} maps to an unexpected type: {!r}\".format(self._in_style, self._in_obj))\n\n\t\t# Create converter.\n\t\tconverter = converter_class(\n\t\t\tescape_char=self._escape_char,\n\t\t\texpand_tuples=self._expand_tuples,\n\t\t\tin_regex=self._in_regex,\n\t\t\tin_style=self._in_obj,\n\t\t\tout_style=self._out_obj,\n\t\t)\n\t\treturn converter\n\n\tdef _create_in_regex(self) -> Pattern:\n\t\t\"\"\"\n\t\tCreate the in-style parameter regular expression.\n\n\t\tReturns the in-style parameter regular expression (:class:`re.Pattern`).\n\t\t\"\"\"\n\t\tregex_parts = []\n\n\t\tif self._in_obj.escape_char != \"%\" and self._out_obj.escape_char == \"%\":\n\t\t\tregex_parts.append(\"(?P<out_percent>%)\")\n\n\t\tif self._escape_char:\n\t\t\t# Escaping is enabled.\n\t\t\tescape = self._in_obj.escape_regex.format(char=re.escape(self._escape_char))\n\t\t\tregex_parts.append(escape)\n\n\t\tregex_parts.append(self._in_obj.param_regex)\n\n\t\treturn re.compile(\"|\".join(regex_parts))\n\n\t@property\n\tdef escape_char(self) -> Optional[str]:\n\t\t\"\"\"\n\t\t*escape_char* (:class:`str` or :data:`None`) is the escape character\n\t\tused to prevent matching a in-style parameter.\n\t\t\"\"\"\n\t\treturn self._escape_char\n\n\t@property\n\tdef expand_tuples(self) -> bool:\n\t\t\"\"\"\n\t\t*expand_tuples* (:class:`bool`) is whether to convert tuples into a\n\t\tsequence of parameters.\n\t\t\"\"\"\n\t\treturn self._expand_tuples\n", "contexts_below": "\tdef formatmany(\n \t\tself,\n \t\tsql: AnyStr,\n \t\tmany_params: Union[Iterable[Dict[Union[str, int], Any]], Iterable[Sequence[Any]]],\n \t) -> Tuple[AnyStr, Union[List[Dict[Union[str, int], Any]], List[Sequence[Any]]]]:\n \t\t\"\"\"\n \t\tConvert the SQL query to use the out-style parameters instead of the\n \t\tin-style parameters.\n \n \t\t*sql* (:class:`str` or :class:`bytes`) is the SQL query.\n \n \t\t*many_params* (:class:`~collections.abc.Iterable`) contains each set\n \t\tof in-style parameters (*params*).\n \n \t\t-\t*params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\n \t\t\tcontains the set of in-style parameters. It maps each parameter\n \t\t\t(:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\n \t\t\tis a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\n \t\t\tIf :attr:`.SQLParams.in_style` is an ordinal parameter style. then\n \t\t\t*params* must be a :class:`~collections.abc.Sequence`.\n \n \t\tReturns a :class:`tuple` containing:\n \n \t\t-\tThe formatted SQL query (:class:`str` or :class:`bytes`).\n \n \t\t-\tA :class:`list` containing each set of converted out-style\n \t\t\tparameters (:class:`dict` or :class:`list`).\n \t\t\"\"\"\n \t\t# Normalize query encoding to simplify processing.\n \t\tif isinstance(sql, str):\n \t\t\tuse_sql = sql\n \t\t\tstring_type = str\n \t\telif isinstance(sql, bytes):\n \t\t\tuse_sql = sql.decode(_BYTES_ENCODING)\n \t\t\tstring_type = bytes\n \t\telse:\n \t\t\traise TypeError(\"sql:{!r} is not a unicode or byte string.\".format(sql))\n \n \t\tif not _is_iterable(many_params):\n \t\t\traise TypeError(\"many_params:{!r} is not iterable.\".format(many_params))\n \n \t\t# Replace in-style with out-style parameters.\n \t\tuse_sql, many_out_params = self._converter.convert_many(use_sql, many_params)\n \n \t\t# Make sure the query is returned as the proper string type.\n \t\tif string_type is bytes:\n \t\t\tout_sql = use_sql.encode(_BYTES_ENCODING)\n \t\telse:\n \t\t\tout_sql = use_sql\n \n \t\t# Return converted SQL and out-parameters.\n \t\treturn out_sql, many_out_params\n \n \t@property\n \tdef in_style(self) -> str:\n \t\t\"\"\"\n \t\t*in_style* (:class:`str`) is the parameter style to expect in an SQL\n \t\tquery when being parsed.\n \t\t\"\"\"\n \t\treturn self._in_style\n \n \t@property\n \tdef out_style(self) -> str:\n \t\t\"\"\"\n \t\t*out_style* (:class:`str`) is the parameter style that the SQL query\n \t\twill be converted to.\n \t\t\"\"\"\n \t\treturn self._out_style\n ", "input_code": "def format(self, sql: AnyStr, params: Union[Dict[Union[str, int], Any], Sequence[Any]]) -> Tuple[AnyStr, Union[Dict[Union[str, int], Any], Sequence[Any]]]:\n\"\"\"\nConvert the SQL query to use the out-style parameters instead of\nthe in-style parameters.\n\n*sql* (:class:`str` or :class:`bytes`) is the SQL query.\n\n*params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\ncontains the set of in-style parameters. It maps each parameter\n(:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\nis a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\nIf :attr:`.SQLParams.in_style` is an ordinal parameter style, then\n*params* must be a :class:`~collections.abc.Sequence`.\n\nReturns a :class:`tuple` containing:\n\n-       The formatted SQL query (:class:`str` or :class:`bytes`).\n\n-       The set of converted out-style parameters (:class:`dict` or\n        :class:`list`).\n\"\"\"\n", "indent_space": "", "ground_truth": "\tdef format(\n\t\tself,\n\t\tsql: AnyStr,\n\t\tparams: Union[Dict[Union[str, int], Any], Sequence[Any]],\n\t) -> Tuple[AnyStr, Union[Dict[Union[str, int], Any], Sequence[Any]]]:\n\t\t\"\"\"\n\t\tConvert the SQL query to use the out-style parameters instead of\n\t\tthe in-style parameters.\n\n\t\t*sql* (:class:`str` or :class:`bytes`) is the SQL query.\n\n\t\t*params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\n\t\tcontains the set of in-style parameters. It maps each parameter\n\t\t(:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\n\t\tis a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\n\t\tIf :attr:`.SQLParams.in_style` is an ordinal parameter style, then\n\t\t*params* must be a :class:`~collections.abc.Sequence`.\n\n\t\tReturns a :class:`tuple` containing:\n\n\t\t-\tThe formatted SQL query (:class:`str` or :class:`bytes`).\n\n\t\t-\tThe set of converted out-style parameters (:class:`dict` or\n\t\t\t:class:`list`).\n\t\t\"\"\"\n\t\t# Normalize query encoding to simplify processing.\n\t\tif isinstance(sql, str):\n\t\t\tuse_sql = sql\n\t\t\tstring_type = str\n\t\telif isinstance(sql, bytes):\n\t\t\tuse_sql = sql.decode(_BYTES_ENCODING)\n\t\t\tstring_type = bytes\n\t\telse:\n\t\t\traise TypeError(\"sql:{!r} is not a unicode or byte string.\".format(sql))\n\n\t\t# Replace in-style with out-style parameters.\n\t\tuse_sql, out_params = self._converter.convert(use_sql, params)\n\n\t\t# Make sure the query is returned as the proper string type.\n\t\tif string_type is bytes:\n\t\t\tout_sql = use_sql.encode(_BYTES_ENCODING)\n\t\telse:\n\t\t\tout_sql = use_sql\n\n\t\t# Return converted SQL and out-parameters.\n\t\treturn out_sql, out_params", "signature": "def format(self, sql: AnyStr, params: Union[Dict[Union[str, int], Any], Sequence[Any]]) -> Tuple[AnyStr, Union[Dict[Union[str, int], Any], Sequence[Any]]]:", "completion_path": "sqlparams/__init__.py"}
{"ce_id": "62b43428903eeb48555d3eaa", "namespace": "62b43428903eeb48555d3eaa", "namespace_real": "sqlparams.__init__.formatmany", "real_proj_path": "cpburnz---python-sql-parameters/", "type": "class", "class_name": "__init__", "function_name": "formatmany", "contexts_above": "\"\"\"\n:mod:`sqlparams` is a utility package for converting between various SQL\nparameter styles.\n\"\"\"\n\nimport re\nfrom typing import (\n\tAny,\n\tAnyStr,\n\tDict,\n\tIterable,\n\tList,\n\tOptional,\n\tPattern,\n\tSequence,\n\tTuple,\n\tType,\n\tUnion)\n\nfrom . import _converting\nfrom . import _styles\nfrom ._util import _is_iterable\n\nfrom ._meta import (\n\t__author__,\n\t__copyright__,\n\t__credits__,\n\t__license__,\n\t__version__,\n)\n\n_BYTES_ENCODING = 'latin1'\n\"\"\"\nThe encoding to use when parsing a byte query string.\n\"\"\"\n\n_STYLES = {}\n\"\"\"\nMaps parameter style by name.\n\"\"\"\n\n\nclass SQLParams(object):\n\t\"\"\"\n\tThe :class:`.SQLParams` class is used to support named parameters in\n\tSQL queries where they are not otherwise supported (e.g., pyodbc).\n\tThis is done by converting from one parameter style query to another\n\tparameter style query.\n\n\tBy default, when converting to a numeric or ordinal style any\n\t:class:`tuple` parameter will be expanded into \"(?,?,...)\" to support\n\tthe widely used \"IN {tuple}\" SQL expression without leaking any\n\tunescaped values.\n\t\"\"\"\n\n\tdef __init__(\n\t\tself,\n\t\tin_style: str,\n\t\tout_style: str,\n\t\tescape_char: Union[str, bool, None] = None,\n\t\texpand_tuples: Optional[bool] = None,\n\t) -> None:\n\t\t\"\"\"\n\t\tInstantiates the :class:`.SQLParams` instance.\n\n\t\t*in_style* (:class:`str`) is the parameter style that will be used\n\t\tin an SQL query before being parsed and converted to :attr:`.SQLParams.out_style`.\n\n\t\t*out_style* (:class:`str`) is the parameter style that the SQL query\n\t\twill be converted to.\n\n\t\t*escape_char* (:class:`str`, :class:`bool`, or :data:`None`) is the\n\t\tescape character used to prevent matching a in-style parameter. If\n\t\t:data:`True`, use the default escape character (repeat the initial\n\t\tcharacter to escape it; e.g., \"%%\"). If :data:`False`, do not use an\n\t\tescape character. Default is :data:`None` for :data:`False`.\n\n\t\t*expand_tuples* (:class:`bool` or :data:`None`) is whether to\n\t\texpand tuples into a sequence of parameters. Default is :data:`None`\n\t\tto let it be determined by *out_style* (to maintain backward\n\t\tcompatibility). If *out_style* is a numeric or ordinal style, expand\n\t\ttuples by default (:data:`True`). If *out_style* is a named style,\n\t\tdo not expand tuples by default (:data:`False`).\n\n\t\tThe following parameter styles are supported by both *in_style* and\n\t\t*out_style*:\n\n\t\t-\tFor all named styles the parameter keys must be valid `Python identifiers`_.\n\t\t\tThey cannot start with a digit. This is to help prevent\n\t\t\tincorrectly matching common strings such as datetimes.\n\n\t\t\tNamed styles:\n\n\t\t\t-\t\"named\" indicates parameters will use the named style::\n\n\t\t\t\t\t... WHERE name = :name\n\n\t\t\t-\t\"named_dollar\" indicates parameters will use the named dollar\n\t\t\t\tsign style::\n\n\t\t\t\t\t... WHERE name = $name\n\n\t\t\t\t.. NOTE:: This is not defined by `PEP 249`_.\n\n\t\t\t-\t\"pyformat\" indicates parameters will use the named Python\n\t\t\t\textended format style::\n\n\t\t\t\t\t... WHERE name = %(name)s\n\n\t\t\t\t.. NOTE:: Strictly speaking, `PEP 249`_ only specifies\n\t\t\t\t   \"%(name)s\" for the \"pyformat\" parameter style so only that\n\t\t\t\t   form (without any other conversions or flags) is supported.\n\n\t\t-\tAll numeric styles start at :data:`1`. When using a\n\t\t\t:class:`~collections.abc.Sequence` for the parameters, the 1st\n\t\t\tparameter (e.g., \":1\") will correspond to the 1st element of the\n\t\t\tsequence (i.e., index :data:`0`). When using a :class:`~collections.abc.Mapping`\n\t\t\tfor the parameters, the 1st parameter (e.g., \":1\") will correspond\n\t\t\tto the matching key (i.e., :data:`1` or :data:`\"1\"`).\n\n\t\t\tNumeric styles:\n\n\t\t\t-\t\"numeric\" indicates parameters will use the numeric style::\n\n\t\t\t\t\t... WHERE name = :1\n\n\t\t\t-\t\"numeric_dollar\" indicates parameters will use the numeric\n\t\t\t\tdollar sign style (starts at :data:`1`)::\n\n\t\t\t\t\t... WHERE name = $1\n\n\t\t\t\t.. NOTE:: This is not defined by `PEP 249`_.\n\n\t\t- Ordinal styles:\n\n\t\t\t-\t\"format\" indicates parameters will use the ordinal Python format\n\t\t\t\tstyle::\n\n\t\t\t\t\t... WHERE name = %s\n\n\t\t\t\t.. NOTE:: Strictly speaking, `PEP 249`_ only specifies \"%s\" for\n\t\t\t\t   the \"format\" parameter styles so only that form (without any\n\t\t\t\t   other conversions or flags) is supported.\n\n\t\t\t-\t\"qmark\" indicates parameters will use the ordinal question mark\n\t\t\t\tstyle::\n\n\t\t\t\t\t... WHERE name = ?\n\n\t\t.. _`PEP 249`: http://www.python.org/dev/peps/pep-0249/\n\n\t\t.. _`Python identifiers`: https://docs.python.org/3/reference/lexical_analysis.html#identifiers\n\t\t\"\"\"\n\n\t\tself._converter: _converting._Converter = None\n\t\t\"\"\"\n\t\t*_converter* (:class:`._converting._Converter`) is the parameter\n\t\tconverter to use.\n\t\t\"\"\"\n\n\t\tself._escape_char: Optional[str] = None\n\t\t\"\"\"\n\t\t*_escape_char* (:class:`str` or :data:`None`) is the escape\n\t\tcharacter used to prevent matching a in-style parameter.\n\t\t\"\"\"\n\n\t\tself._expand_tuples: bool = None\n\t\t\"\"\"\n\t\t*_expand_tuples* (:class:`bool`) is whether to convert tuples into a\n\t\tsequence of parameters.\n\t\t\"\"\"\n\n\t\tself._in_obj: _styles._Style = None\n\t\t\"\"\"\n\t\t*_in_obj* (:class:`._styles._Style`) is the in-style parameter object.\n\t\t\"\"\"\n\n\t\tself._in_regex: Pattern = None\n\t\t\"\"\"\n\t\t*_in_regex* (:class:`re.Pattern`) is the regular expression used to\n\t\textract the in-style parameters.\n\t\t\"\"\"\n\n\t\tself._in_style: str = None\n\t\t\"\"\"\n\t\t*_in_style* (:class:`str`) is the parameter style that will be used\n\t\tin an SQL query before being parsed and converted to :attr:`.SQLParams.out_style`.\n\t\t\"\"\"\n\n\t\tself._out_obj: _styles._Style = None\n\t\t\"\"\"\n\t\t*_out_obj* (:class:`._styles._Style`) is the out-style parameter object.\n\t\t\"\"\"\n\n\t\tself._out_style: str = None\n\t\t\"\"\"\n\t\t*_out_style* (:class:`str`) is the parameter style that the SQL query\n\t\twill be converted to.\n\t\t\"\"\"\n\n\t\tif not isinstance(in_style, str):\n\t\t\traise TypeError(\"in_style:{!r} is not a string.\".format(in_style))\n\n\t\tif not isinstance(out_style, str):\n\t\t\traise TypeError(\"out_style:{!r} is not a string.\".format(out_style))\n\n\t\tself._in_style = in_style\n\t\tself._out_style = out_style\n\n\t\tself._in_obj = _styles._STYLES[self._in_style]\n\t\tself._out_obj = _styles._STYLES[self._out_style]\n\n\t\tif escape_char is True:\n\t\t\tuse_char = self._in_obj.escape_char\n\t\telif not escape_char:\n\t\t\tuse_char = None\n\t\telif isinstance(escape_char, str):\n\t\t\tuse_char = escape_char\n\t\telse:\n\t\t\traise TypeError(\"escape_char:{!r} is not a string or bool.\")\n\n\t\tif expand_tuples is None:\n\t\t\texpand_tuples = not isinstance(self._out_obj, _styles._NamedStyle)\n\n\t\tself._escape_char = use_char\n\t\tself._expand_tuples = bool(expand_tuples)\n\n\t\tself._in_regex = self._create_in_regex()\n\t\tself._converter = self._create_converter()\n\n\tdef __repr__(self) -> str:\n\t\t\"\"\"\n\t\tReturns the canonical string representation (:class:`str`) of this\n\t\tinstance.\n\t\t\"\"\"\n\t\treturn \"{}.{}({!r}, {!r})\".format(self.__class__.__module__, self.__class__.__name__, self._in_style, self._out_style)\n\n\tdef _create_converter(self) -> _converting._Converter:\n\t\t\"\"\"\n\t\tCreate the parameter style converter.\n\n\t\tReturns the parameter style converter (:class:`._converting._Converter`).\n\t\t\"\"\"\n\t\tassert self._in_regex is not None, self._in_regex\n\t\tassert self._out_obj is not None, self._out_obj\n\n\t\t# Determine converter class.\n\t\tconverter_class: Type[_converting._Converter]\n\t\tif isinstance(self._in_obj, _styles._NamedStyle):\n\t\t\tif isinstance(self._out_obj, _styles._NamedStyle):\n\t\t\t\tconverter_class = _converting._NamedToNamedConverter\n\t\t\telif isinstance(self._out_obj, _styles._NumericStyle):\n\t\t\t\tconverter_class = _converting._NamedToNumericConverter\n\t\t\telif isinstance(self._out_obj, _styles._OrdinalStyle):\n\t\t\t\tconverter_class = _converting._NamedToOrdinalConverter\n\t\t\telse:\n\t\t\t\traise TypeError(\"out_style:{!r} maps to an unexpected type: {!r}\".format(self._out_style, self._out_obj))\n\n\t\telif isinstance(self._in_obj, _styles._NumericStyle):\n\t\t\tif isinstance(self._out_obj, _styles._NamedStyle):\n\t\t\t\tconverter_class = _converting._NumericToNamedConverter\n\t\t\telif isinstance(self._out_obj, _styles._NumericStyle):\n\t\t\t\tconverter_class = _converting._NumericToNumericConverter\n\t\t\telif isinstance(self._out_obj, _styles._OrdinalStyle):\n\t\t\t\tconverter_class = _converting._NumericToOrdinalConverter\n\t\t\telse:\n\t\t\t\traise TypeError(\"out_style:{!r} maps to an unexpected type: {!r}\".format(self._out_style, self._out_obj))\n\n\t\telif isinstance(self._in_obj, _styles._OrdinalStyle):\n\t\t\tif isinstance(self._out_obj, _styles._NamedStyle):\n\t\t\t\tconverter_class = _converting._OrdinalToNamedConverter\n\t\t\telif isinstance(self._out_obj, _styles._NumericStyle):\n\t\t\t\tconverter_class = _converting._OrdinalToNumericConverter\n\t\t\telif isinstance(self._out_obj, _styles._OrdinalStyle):\n\t\t\t\tconverter_class = _converting._OrdinalToOrdinalConverter\n\t\t\telse:\n\t\t\t\traise TypeError(\"out_style:{!r} maps to an unexpected type: {!r}\".format(self._out_style, self._out_obj))\n\n\t\telse:\n\t\t\traise TypeError(\"in_style:{!r} maps to an unexpected type: {!r}\".format(self._in_style, self._in_obj))\n\n\t\t# Create converter.\n\t\tconverter = converter_class(\n\t\t\tescape_char=self._escape_char,\n\t\t\texpand_tuples=self._expand_tuples,\n\t\t\tin_regex=self._in_regex,\n\t\t\tin_style=self._in_obj,\n\t\t\tout_style=self._out_obj,\n\t\t)\n\t\treturn converter\n\n\tdef _create_in_regex(self) -> Pattern:\n\t\t\"\"\"\n\t\tCreate the in-style parameter regular expression.\n\n\t\tReturns the in-style parameter regular expression (:class:`re.Pattern`).\n\t\t\"\"\"\n\t\tregex_parts = []\n\n\t\tif self._in_obj.escape_char != \"%\" and self._out_obj.escape_char == \"%\":\n\t\t\tregex_parts.append(\"(?P<out_percent>%)\")\n\n\t\tif self._escape_char:\n\t\t\t# Escaping is enabled.\n\t\t\tescape = self._in_obj.escape_regex.format(char=re.escape(self._escape_char))\n\t\t\tregex_parts.append(escape)\n\n\t\tregex_parts.append(self._in_obj.param_regex)\n\n\t\treturn re.compile(\"|\".join(regex_parts))\n\n\t@property\n\tdef escape_char(self) -> Optional[str]:\n\t\t\"\"\"\n\t\t*escape_char* (:class:`str` or :data:`None`) is the escape character\n\t\tused to prevent matching a in-style parameter.\n\t\t\"\"\"\n\t\treturn self._escape_char\n\n\t@property\n\tdef expand_tuples(self) -> bool:\n\t\t\"\"\"\n\t\t*expand_tuples* (:class:`bool`) is whether to convert tuples into a\n\t\tsequence of parameters.\n\t\t\"\"\"\n\t\treturn self._expand_tuples\n\n\tdef format(\n\t\tself,\n\t\tsql: AnyStr,\n\t\tparams: Union[Dict[Union[str, int], Any], Sequence[Any]],\n\t) -> Tuple[AnyStr, Union[Dict[Union[str, int], Any], Sequence[Any]]]:\n\t\t\"\"\"\n\t\tConvert the SQL query to use the out-style parameters instead of\n\t\tthe in-style parameters.\n\n\t\t*sql* (:class:`str` or :class:`bytes`) is the SQL query.\n\n\t\t*params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\n\t\tcontains the set of in-style parameters. It maps each parameter\n\t\t(:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\n\t\tis a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\n\t\tIf :attr:`.SQLParams.in_style` is an ordinal parameter style, then\n\t\t*params* must be a :class:`~collections.abc.Sequence`.\n\n\t\tReturns a :class:`tuple` containing:\n\n\t\t-\tThe formatted SQL query (:class:`str` or :class:`bytes`).\n\n\t\t-\tThe set of converted out-style parameters (:class:`dict` or\n\t\t\t:class:`list`).\n\t\t\"\"\"\n\t\t# Normalize query encoding to simplify processing.\n\t\tif isinstance(sql, str):\n\t\t\tuse_sql = sql\n\t\t\tstring_type = str\n\t\telif isinstance(sql, bytes):\n\t\t\tuse_sql = sql.decode(_BYTES_ENCODING)\n\t\t\tstring_type = bytes\n\t\telse:\n\t\t\traise TypeError(\"sql:{!r} is not a unicode or byte string.\".format(sql))\n\n\t\t# Replace in-style with out-style parameters.\n\t\tuse_sql, out_params = self._converter.convert(use_sql, params)\n\n\t\t# Make sure the query is returned as the proper string type.\n\t\tif string_type is bytes:\n\t\t\tout_sql = use_sql.encode(_BYTES_ENCODING)\n\t\telse:\n\t\t\tout_sql = use_sql\n\n\t\t# Return converted SQL and out-parameters.\n\t\treturn out_sql, out_params\n", "contexts_below": "\t@property\n \tdef in_style(self) -> str:\n \t\t\"\"\"\n \t\t*in_style* (:class:`str`) is the parameter style to expect in an SQL\n \t\tquery when being parsed.\n \t\t\"\"\"\n \t\treturn self._in_style\n \n \t@property\n \tdef out_style(self) -> str:\n \t\t\"\"\"\n \t\t*out_style* (:class:`str`) is the parameter style that the SQL query\n \t\twill be converted to.\n \t\t\"\"\"\n \t\treturn self._out_style\n ", "input_code": "def formatmany(self, sql: AnyStr, many_params: Union[Iterable[Dict[Union[str, int], Any]], Iterable[Sequence[Any]]]) -> Tuple[AnyStr, Union[List[Dict[Union[str, int], Any]], List[Sequence[Any]]]]:\n\"\"\"\nConvert the SQL query to use the out-style parameters instead of the\nin-style parameters.\n\n*sql* (:class:`str` or :class:`bytes`) is the SQL query.\n\n*many_params* (:class:`~collections.abc.Iterable`) contains each set\nof in-style parameters (*params*).\n\n-       *params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\n        contains the set of in-style parameters. It maps each parameter\n        (:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\n        is a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\n        If :attr:`.SQLParams.in_style` is an ordinal parameter style. then\n        *params* must be a :class:`~collections.abc.Sequence`.\n\nReturns a :class:`tuple` containing:\n\n-       The formatted SQL query (:class:`str` or :class:`bytes`).\n\n-       A :class:`list` containing each set of converted out-style\n        parameters (:class:`dict` or :class:`list`).\n\"\"\"\n", "indent_space": "", "ground_truth": "\tdef formatmany(\n\t\tself,\n\t\tsql: AnyStr,\n\t\tmany_params: Union[Iterable[Dict[Union[str, int], Any]], Iterable[Sequence[Any]]],\n\t) -> Tuple[AnyStr, Union[List[Dict[Union[str, int], Any]], List[Sequence[Any]]]]:\n\t\t\"\"\"\n\t\tConvert the SQL query to use the out-style parameters instead of the\n\t\tin-style parameters.\n\n\t\t*sql* (:class:`str` or :class:`bytes`) is the SQL query.\n\n\t\t*many_params* (:class:`~collections.abc.Iterable`) contains each set\n\t\tof in-style parameters (*params*).\n\n\t\t-\t*params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\n\t\t\tcontains the set of in-style parameters. It maps each parameter\n\t\t\t(:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\n\t\t\tis a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\n\t\t\tIf :attr:`.SQLParams.in_style` is an ordinal parameter style. then\n\t\t\t*params* must be a :class:`~collections.abc.Sequence`.\n\n\t\tReturns a :class:`tuple` containing:\n\n\t\t-\tThe formatted SQL query (:class:`str` or :class:`bytes`).\n\n\t\t-\tA :class:`list` containing each set of converted out-style\n\t\t\tparameters (:class:`dict` or :class:`list`).\n\t\t\"\"\"\n\t\t# Normalize query encoding to simplify processing.\n\t\tif isinstance(sql, str):\n\t\t\tuse_sql = sql\n\t\t\tstring_type = str\n\t\telif isinstance(sql, bytes):\n\t\t\tuse_sql = sql.decode(_BYTES_ENCODING)\n\t\t\tstring_type = bytes\n\t\telse:\n\t\t\traise TypeError(\"sql:{!r} is not a unicode or byte string.\".format(sql))\n\n\t\tif not _is_iterable(many_params):\n\t\t\traise TypeError(\"many_params:{!r} is not iterable.\".format(many_params))\n\n\t\t# Replace in-style with out-style parameters.\n\t\tuse_sql, many_out_params = self._converter.convert_many(use_sql, many_params)\n\n\t\t# Make sure the query is returned as the proper string type.\n\t\tif string_type is bytes:\n\t\t\tout_sql = use_sql.encode(_BYTES_ENCODING)\n\t\telse:\n\t\t\tout_sql = use_sql\n\n\t\t# Return converted SQL and out-parameters.\n\t\treturn out_sql, many_out_params", "signature": "def formatmany(self, sql: AnyStr, many_params: Union[Iterable[Dict[Union[str, int], Any]], Iterable[Sequence[Any]]]) -> Tuple[AnyStr, Union[List[Dict[Union[str, int], Any]], List[Sequence[Any]]]]:", "completion_path": "sqlparams/__init__.py"}
{"ce_id": "62b45df05108cfac7f2109ce", "namespace": "62b45df05108cfac7f2109ce", "namespace_real": "ocfl.validator.validate", "real_proj_path": "zimeon---ocfl-py/", "type": "class", "class_name": "validator", "function_name": "validate", "contexts_above": "\"\"\"OCFL Validator.\n\nPhilosophy of this code is to keep it separate from the implementations\nof Store, Object and Version used to build and manipulate OCFL data, but\nto leverage lower level functions such as digest creation etc.. Code style\nis plain/verbose with detailed and specific validation errors that might\nhelp someone debug an implementation.\n\nThis code uses PyFilesystem (import fs) exclusively for access to files. This\nshould enable application beyond the operating system filesystem.\n\"\"\"\nimport json\nimport re\nimport fs\n\nfrom .digest import file_digest, normalized_digest\nfrom .inventory_validator import InventoryValidator\nfrom .namaste import find_namastes\nfrom .pyfs import open_fs, ocfl_walk, ocfl_files_identical\nfrom .validation_logger import ValidationLogger\n\n\nclass ValidatorAbortException(Exception):\n    \"\"\"Exception class to bail out of validation.\"\"\"\n\n\nclass Validator():\n    \"\"\"Class for OCFL Validator.\"\"\"\n\n    def __init__(self, log=None, show_warnings=False, show_errors=True, check_digests=True, lax_digests=False, lang='en'):\n        \"\"\"Initialize OCFL validator.\"\"\"\n        self.log = log\n        self.check_digests = check_digests\n        self.lax_digests = lax_digests\n        if self.log is None:\n            self.log = ValidationLogger(show_warnings=show_warnings, show_errors=show_errors, lang=lang)\n        self.registered_extensions = [\n            '0001-digest-algorithms', '0002-flat-direct-storage-layout',\n            '0003-hash-and-id-n-tuple-storage-layout', '0004-hashed-n-tuple-storage-layout',\n            '0005-mutable-head'\n        ]\n        # The following actually initialized in initialize() method\n        self.id = None\n        self.spec_version = None\n        self.digest_algorithm = None\n        self.content_directory = None\n        self.inventory_digest_files = None\n        self.root_inv_validator = None\n        self.obj_fs = None\n        self.initialize()\n\n    def initialize(self):\n        \"\"\"Initialize object state.\n\n        Must be called between attempts to validate objects.\n        \"\"\"\n        self.id = None\n        self.spec_version = '1.0'  # default to latest published version\n        self.digest_algorithm = 'sha512'\n        self.content_directory = 'content'\n        self.inventory_digest_files = {}  # index by version_dir, algorithms may differ\n        self.root_inv_validator = None\n        self.obj_fs = None\n\n    def status_str(self, prefix=''):\n        \"\"\"Return string representation of validation log, with optional prefix.\"\"\"\n        return self.log.status_str(prefix=prefix)\n\n    def __str__(self):\n        \"\"\"Return string representation of validation log.\"\"\"\n        return self.status_str()\n", "contexts_below": "    def validate_inventory(self, inv_file, where='root', extract_spec_version=False):\n         \"\"\"Validate a given inventory file, record errors with self.log.error().\n \n         Returns inventory object for use in later validation\n         of object content. Does not look at anything else in the\n         object itself.\n \n         where - used for reporting messages of where inventory is in object\n \n         extract_spec_version - if set True will attempt to take spec_version from the\n             inventory itself instead of using the spec_version provided\n         \"\"\"\n         try:\n             with self.obj_fs.openbin(inv_file, 'r') as fh:\n                 inventory = json.load(fh)\n         except json.decoder.JSONDecodeError as e:\n             self.log.error('E033', where=where, explanation=str(e))\n             raise ValidatorAbortException\n         inv_validator = InventoryValidator(log=self.log, where=where,\n                                            lax_digests=self.lax_digests,\n                                            spec_version=self.spec_version)\n         inv_validator.validate(inventory, extract_spec_version=extract_spec_version)\n         return inventory, inv_validator\n \n     def validate_inventory_digest(self, inv_file, digest_algorithm, where=\"root\"):\n         \"\"\"Validate the appropriate inventory digest file in path.\"\"\"\n         inv_digest_file = inv_file + '.' + digest_algorithm\n         if not self.obj_fs.exists(inv_digest_file):\n             self.log.error('E058a', where=where, path=inv_digest_file)\n         else:\n             self.validate_inventory_digest_match(inv_file, inv_digest_file)\n \n     def validate_inventory_digest_match(self, inv_file, inv_digest_file):\n         \"\"\"Validate a given inventory digest for a given inventory file.\n \n         On error throws exception with debugging string intended to\n         be presented to a user.\n         \"\"\"\n         if not self.check_digests:\n             return\n         m = re.match(r'''.*\\.(\\w+)$''', inv_digest_file)\n         if m:\n             digest_algorithm = m.group(1)\n             try:\n                 digest_recorded = self.read_inventory_digest(inv_digest_file)\n                 digest_actual = file_digest(inv_file, digest_algorithm, pyfs=self.obj_fs)\n                 if digest_actual != digest_recorded:\n                     self.log.error(\"E060\", inv_file=inv_file, actual=digest_actual, recorded=digest_recorded, inv_digest_file=inv_digest_file)\n             except Exception as e:  # pylint: disable=broad-except\n                 self.log.error(\"E061\", description=str(e))\n         else:\n             self.log.error(\"E058b\", inv_digest_file=inv_digest_file)\n \n     def validate_object_root(self, version_dirs, already_checked):\n         \"\"\"Validate object root.\n \n         All expected_files must be present and no other files.\n         All expected_dirs must be present and no other dirs.\n         \"\"\"\n         expected_files = ['0=ocfl_object_' + self.spec_version, 'inventory.json',\n                           'inventory.json.' + self.digest_algorithm]\n         for entry in self.obj_fs.scandir(''):\n             if entry.is_file:\n                 if entry.name not in expected_files and entry.name not in already_checked:\n                     self.log.error('E001a', file=entry.name)\n             elif entry.is_dir:\n                 if entry.name in version_dirs:\n                     pass\n                 elif entry.name == 'extensions':\n                     self.validate_extensions_dir()\n                 elif re.match(r'''v\\d+$''', entry.name):\n                     # Looks like a version directory so give more specific error\n                     self.log.error('E046b', dir=entry.name)\n                 else:\n                     # Simply an unexpected directory\n                     self.log.error('E001b', dir=entry.name)\n             else:\n                 self.log.error('E001c', entry=entry.name)\n \n     def validate_extensions_dir(self):\n         \"\"\"Validate content of extensions directory inside object root.\n \n         Validate the extensions directory by checking that there aren't any\n         entries in the extensions directory that aren't directories themselves.\n         Where there are extension directories they SHOULD be registered and\n         this code relies up the registered_extensions property to list known\n         extensions.\n         \"\"\"\n         for entry in self.obj_fs.scandir('extensions'):\n             if entry.is_dir:\n                 if entry.name not in self.registered_extensions:\n                     self.log.warning('W013', entry=entry.name)\n             else:\n                 self.log.error('E067', entry=entry.name)\n \n     def validate_version_inventories(self, version_dirs):\n         \"\"\"Each version SHOULD have an inventory up to that point.\n \n         Also keep a record of any content digests different from those in the root inventory\n         so that we can also check them when validating the content.\n \n         version_dirs is an array of version directory names and is assumed to be in\n         version sequence (1, 2, 3...).\n         \"\"\"\n         prior_manifest_digests = {}  # file -> algorithm -> digest -> [versions]\n         prior_fixity_digests = {}  # file -> algorithm -> digest -> [versions]\n         if len(version_dirs) == 0:\n             return prior_manifest_digests, prior_fixity_digests\n         last_version = version_dirs[-1]\n         prev_version_dir = \"NONE\"  # will be set for first directory with inventory\n         prev_spec_version = '1.0'  # lowest version\n         for version_dir in version_dirs:\n             inv_file = fs.path.join(version_dir, 'inventory.json')\n             if not self.obj_fs.exists(inv_file):\n                 self.log.warning('W010', where=version_dir)\n                 continue\n             # There is an inventory file for this version directory, check it\n             if version_dir == last_version:\n                 # Don't validate in this case. Per the spec the inventory in the last version\n                 # MUST be identical to the copy in the object root, just check that\n                 root_inv_file = 'inventory.json'\n                 if not ocfl_files_identical(self.obj_fs, inv_file, root_inv_file):\n                     self.log.error('E064', root_inv_file=root_inv_file, inv_file=inv_file)\n                 else:\n                     # We could also just compare digest files but this gives a more helpful error for\n                     # which file has the incorrect digest if they don't match\n                     self.validate_inventory_digest(inv_file, self.digest_algorithm, where=version_dir)\n                 self.inventory_digest_files[version_dir] = 'inventory.json.' + self.digest_algorithm\n                 this_spec_version = self.spec_version\n             else:\n                 # Note that inventories in prior versions may use different digest algorithms\n                 # from the current invenotory. Also,\n                 # an may accord with the same or earlier versions of the specification\n                 version_inventory, inv_validator = self.validate_inventory(inv_file, where=version_dir, extract_spec_version=True)\n                 this_spec_version = inv_validator.spec_version\n                 digest_algorithm = inv_validator.digest_algorithm\n                 self.validate_inventory_digest(inv_file, digest_algorithm, where=version_dir)\n                 self.inventory_digest_files[version_dir] = 'inventory.json.' + digest_algorithm\n                 if self.id and 'id' in version_inventory:\n                     if version_inventory['id'] != self.id:\n                         self.log.error('E037b', where=version_dir, root_id=self.id, version_id=version_inventory['id'])\n                 if 'manifest' in version_inventory:\n                     # Check that all files listed in prior inventories are in manifest\n                     not_seen = set(prior_manifest_digests.keys())\n                     for digest in version_inventory['manifest']:\n                         for filepath in version_inventory['manifest'][digest]:\n                             # We rely on the validation to check that anything present is OK\n                             if filepath in not_seen:\n                                 not_seen.remove(filepath)\n                     if len(not_seen) > 0:\n                         self.log.error('E023b', where=version_dir, missing_filepaths=', '.join(sorted(not_seen)))\n                     # Record all prior digests\n                     for unnormalized_digest in version_inventory['manifest']:\n                         digest = normalized_digest(unnormalized_digest, digest_type=digest_algorithm)\n                         for filepath in version_inventory['manifest'][unnormalized_digest]:\n                             if filepath not in prior_manifest_digests:\n                                 prior_manifest_digests[filepath] = {}\n                             if digest_algorithm not in prior_manifest_digests[filepath]:\n                                 prior_manifest_digests[filepath][digest_algorithm] = {}\n                             if digest not in prior_manifest_digests[filepath][digest_algorithm]:\n                                 prior_manifest_digests[filepath][digest_algorithm][digest] = []\n                             prior_manifest_digests[filepath][digest_algorithm][digest].append(version_dir)\n                 # Is this inventory an appropriate prior version of the object root inventory?\n                 if self.root_inv_validator is not None:\n                     self.root_inv_validator.validate_as_prior_version(inv_validator)\n                 # Fixity blocks are independent in each version. Record all values and the versions\n                 # they occur in for later checks against content\n                 if 'fixity' in version_inventory:\n                     for digest_algorithm in version_inventory['fixity']:\n                         for unnormalized_digest in version_inventory['fixity'][digest_algorithm]:\n                             digest = normalized_digest(unnormalized_digest, digest_type=digest_algorithm)\n                             for filepath in version_inventory['fixity'][digest_algorithm][unnormalized_digest]:\n                                 if filepath not in prior_fixity_digests:\n                                     prior_fixity_digests[filepath] = {}\n                                 if digest_algorithm not in prior_fixity_digests[filepath]:\n                                     prior_fixity_digests[filepath][digest_algorithm] = {}\n                                 if digest not in prior_fixity_digests[filepath][digest_algorithm]:\n                                     prior_fixity_digests[filepath][digest_algorithm][digest] = []\n                                 prior_fixity_digests[filepath][digest_algorithm][digest].append(version_dir)\n             # We are validating the inventories in sequence and each new version must\n             # follow the same or later spec version to previous inventories\n             if prev_spec_version > this_spec_version:\n                 self.log.error('E103', where=version_dir, this_spec_version=this_spec_version,\n                                prev_version_dir=prev_version_dir, prev_spec_version=prev_spec_version)\n             prev_version_dir = version_dir\n             prev_spec_version = this_spec_version\n         return prior_manifest_digests, prior_fixity_digests\n \n     def validate_content(self, inventory, version_dirs, prior_manifest_digests, prior_fixity_digests):\n         \"\"\"Validate file presence and content against inventory.\n \n         The root inventory in `inventory` is assumed to be valid and safe to use\n         for construction of file paths etc..\n         \"\"\"\n         files_seen = set()\n         # Check files in each version directory\n         for version_dir in version_dirs:\n             try:\n                 # Check contents of version directory except content_directory\n                 for entry in self.obj_fs.listdir(version_dir):\n                     if ((entry == 'inventory.json')\n                             or (version_dir in self.inventory_digest_files and entry == self.inventory_digest_files[version_dir])):\n                         pass\n                     elif entry == self.content_directory:\n                         # Check content_directory\n                         content_path = fs.path.join(version_dir, self.content_directory)\n                         num_content_files_in_version = 0\n                         for dirpath, dirs, files in ocfl_walk(self.obj_fs, content_path):\n                             if dirpath != '/' + content_path and (len(dirs) + len(files)) == 0:\n                                 self.log.error(\"E024\", where=version_dir, path=dirpath)\n                             for file in files:\n                                 files_seen.add(fs.path.join(dirpath, file).lstrip('/'))\n                                 num_content_files_in_version += 1\n                         if num_content_files_in_version == 0:\n                             self.log.warning(\"W003\", where=version_dir)\n                     elif self.obj_fs.isdir(fs.path.join(version_dir, entry)):\n                         self.log.warning(\"W002\", where=version_dir, entry=entry)\n                     else:\n                         self.log.error(\"E015\", where=version_dir, entry=entry)\n             except (fs.errors.ResourceNotFound, fs.errors.DirectoryExpected):\n                 self.log.error('E046a', version_dir=version_dir)\n         # Extract any digests in fixity and organize by filepath\n         fixity_digests = {}\n         if 'fixity' in inventory:\n             for digest_algorithm in inventory['fixity']:\n                 for digest in inventory['fixity'][digest_algorithm]:\n                     for filepath in inventory['fixity'][digest_algorithm][digest]:\n                         if filepath in files_seen:\n                             if filepath not in fixity_digests:\n                                 fixity_digests[filepath] = {}\n                             if digest_algorithm not in fixity_digests[filepath]:\n                                 fixity_digests[filepath][digest_algorithm] = {}\n                             if digest not in fixity_digests[filepath][digest_algorithm]:\n                                 fixity_digests[filepath][digest_algorithm][digest] = ['root']\n                         else:\n                             self.log.error('E093b', where='root', digest_algorithm=digest_algorithm, digest=digest, content_path=filepath)\n         # Check all files in root manifest\n         if 'manifest' in inventory:\n             for digest in inventory['manifest']:\n                 for filepath in inventory['manifest'][digest]:\n                     if filepath not in files_seen:\n                         self.log.error('E092b', where='root', content_path=filepath)\n                     else:\n                         if self.check_digests:\n                             content_digest = file_digest(filepath, digest_type=self.digest_algorithm, pyfs=self.obj_fs)\n                             if content_digest != normalized_digest(digest, digest_type=self.digest_algorithm):\n                                 self.log.error('E092a', where='root', digest_algorithm=self.digest_algorithm, digest=digest, content_path=filepath, content_digest=content_digest)\n                             known_digests = {self.digest_algorithm: content_digest}\n                             # Are there digest values in the fixity block?\n                             self.check_additional_digests(filepath, known_digests, fixity_digests, 'E093a')\n                             # Are there other digests for this same file from other inventories?\n                             self.check_additional_digests(filepath, known_digests, prior_manifest_digests, 'E092a')\n                             self.check_additional_digests(filepath, known_digests, prior_fixity_digests, 'E093a')\n                         files_seen.discard(filepath)\n         # Anything left in files_seen is not mentioned in the inventory\n         if len(files_seen) > 0:\n             self.log.error('E023a', where='root', extra_files=', '.join(sorted(files_seen)))\n \n     def check_additional_digests(self, filepath, known_digests, additional_digests, error_code):\n         \"\"\"Check all the additional digests for filepath.\n \n         This method is intended to be used both for manifest digests in prior versions and\n         for fixity digests. The digests_seen dict is used to store any values calculated\n         so that we don't recalculate digests that might appear multiple times. It is added to\n         with any additional values calculated.\n \n         Parameters:\n             filepath - path of file in object (`v1/content/something` etc.)\n             known_digests - dict of algorithm->digest that we have calculated\n             additional_digests - dict: filepath -> algorithm -> digest -> [versions appears in]\n             error_code - error code to log on mismatch (E092a for manifest, E093a for fixity)\n         \"\"\"\n         if filepath in additional_digests:\n             for digest_algorithm in additional_digests[filepath]:\n                 if digest_algorithm in known_digests:\n                     # Don't recompute anything, just use it if we've seen it before\n                     content_digest = known_digests[digest_algorithm]\n                 else:\n                     content_digest = file_digest(filepath, digest_type=digest_algorithm, pyfs=self.obj_fs)\n                     known_digests[digest_algorithm] = content_digest\n                 for digest in additional_digests[filepath][digest_algorithm]:\n                     if content_digest != normalized_digest(digest, digest_type=digest_algorithm):\n                         where = ','.join(additional_digests[filepath][digest_algorithm][digest])\n                         self.log.error(error_code, where=where, digest_algorithm=digest_algorithm, digest=digest, content_path=filepath, content_digest=content_digest)\n \n     def read_inventory_digest(self, inv_digest_file):\n         \"\"\"Read inventory digest from sidecar file.\n \n         Raise exception if there is an error, else return digest.\n         \"\"\"\n         with self.obj_fs.open(inv_digest_file, 'r') as fh:\n             line = fh.readline()\n             # we ignore any following lines, could raise exception\n         m = re.match(r'''(\\w+)\\s+(\\S+)\\s*$''', line)\n         if not m:\n             raise Exception(\"Bad inventory digest file %s, wrong format\" % (inv_digest_file))\n         if m.group(2) != 'inventory.json':\n             raise Exception(\"Bad inventory name in inventory digest file %s\" % (inv_digest_file))\n         return m.group(1)\n ", "input_code": "def validate(self, path):\n\"\"\"\nValidate OCFL object at path or pyfs root.\n\nReturns True if valid (warnings permitted), False otherwise.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def validate(self, path):\n        \"\"\"Validate OCFL object at path or pyfs root.\n\n        Returns True if valid (warnings permitted), False otherwise.\n        \"\"\"\n        self.initialize()\n        try:\n            if isinstance(path, str):\n                self.obj_fs = open_fs(path)\n            else:\n                self.obj_fs = path\n                path = self.obj_fs.desc('')\n        except fs.errors.CreateFailed:\n            self.log.error('E003e', path=path)\n            return False\n        # Object declaration, set spec version number. If there are multiple declarations,\n        # look for the lastest object version then report any others as errors\n        namastes = find_namastes(0, pyfs=self.obj_fs)\n        if len(namastes) == 0:\n            self.log.error('E003a', assumed_version=self.spec_version)\n        else:\n            spec_version = None\n            for namaste in namastes:\n                # Extract and check spec version number\n                this_file_version = None\n                for version in ('1.1', '1.0'):\n                    if namaste.filename == '0=ocfl_object_' + version:\n                        this_file_version = version\n                        break\n                if this_file_version is None:\n                    self.log.error('E006', filename=namaste.filename)\n                elif spec_version is None or this_file_version > spec_version:\n                    spec_version = this_file_version\n                    if not namaste.content_ok(pyfs=self.obj_fs):\n                        self.log.error('E007', filename=namaste.filename)\n            if spec_version is None:\n                self.log.error('E003c', assumed_version=self.spec_version)\n            else:\n                self.spec_version = spec_version\n                if len(namastes) > 1:\n                    self.log.error('E003b', files=len(namastes), using_version=self.spec_version)\n        # Object root inventory file\n        inv_file = 'inventory.json'\n        if not self.obj_fs.exists(inv_file):\n            self.log.error('E063')\n            return False\n        try:\n            inventory, inv_validator = self.validate_inventory(inv_file)\n            inventory_is_valid = self.log.num_errors == 0\n            self.root_inv_validator = inv_validator\n            all_versions = inv_validator.all_versions\n            self.id = inv_validator.id\n            self.content_directory = inv_validator.content_directory\n            self.digest_algorithm = inv_validator.digest_algorithm\n            self.validate_inventory_digest(inv_file, self.digest_algorithm)\n            # Object root\n            self.validate_object_root(all_versions, already_checked=[namaste.filename for namaste in namastes])\n            # Version inventory files\n            (prior_manifest_digests, prior_fixity_digests) = self.validate_version_inventories(all_versions)\n            if inventory_is_valid:\n                # Object content\n                self.validate_content(inventory, all_versions, prior_manifest_digests, prior_fixity_digests)\n        except ValidatorAbortException:\n            pass\n        return self.log.num_errors == 0", "signature": "def validate(self, path):", "completion_path": "ocfl/validator.py"}
{"ce_id": "62b45df15108cfac7f2109dc", "namespace": "62b45df15108cfac7f2109dc", "namespace_real": "ocfl.validation_logger.status_str", "real_proj_path": "zimeon---ocfl-py/", "type": "class", "class_name": "validation_logger", "function_name": "status_str", "contexts_above": "\"\"\"OCFL Validation Logger.\n\nHandle logging of validation errors and warnings.\n\"\"\"\nimport json\nimport os\nimport os.path\nimport re\n\n\nclass ValidationLogger():\n    \"\"\"Class for OCFL ValidationLogger.\"\"\"\n\n    validation_codes = None\n\n    def __init__(self, show_warnings=False, show_errors=True,\n                 lang='en', validation_codes=None):\n        \"\"\"Initialize OCFL validation logger.\"\"\"\n        self.show_warnings = show_warnings\n        self.show_errors = show_errors\n        self.lang = lang\n        self.codes = {}\n        self.messages = []\n        self.num_errors = 0\n        self.num_warnings = 0\n        self.info = 0\n        self.spec = 'https://ocfl.io/1.0/spec/'\n        if validation_codes is not None:\n            self.validation_codes = validation_codes\n        elif self.validation_codes is None:\n            with open(os.path.join(os.path.dirname(__file__), 'data/validation-errors.json'), 'r', encoding=\"utf-8\") as fh:\n                self.validation_codes = json.load(fh)\n\n    def error_or_warning(self, code, severity='error', **args):\n        \"\"\"Add error or warning to self.codes.\"\"\"\n        if code in self.validation_codes and 'description' in self.validation_codes[code]:\n            desc = self.validation_codes[code]['description']\n            lang_desc = None\n            if self.lang in desc:\n                lang_desc = desc[self.lang]\n            elif 'en' in desc:\n                lang_desc = desc['en']\n            elif len(desc) > 0:\n                # first key alphabetically\n                lang_desc = desc[sorted(list(desc.keys()))[0]]\n            else:\n                lang_desc = \"Unknown \" + severity + \" without a description\"\n            # Add in any parameters\n            if 'params' in self.validation_codes[code]:\n                params = []\n                for param in self.validation_codes[code]['params']:\n                    params.append(str(args[param]) if param in args else '???')\n                try:\n                    lang_desc = lang_desc % tuple(params)\n                except TypeError:\n                    lang_desc += ' ' + str(args)\n            message = '[' + code + '] ' + lang_desc\n        else:\n            message = \"Unknown \" + severity + \": %s - params (%s)\" % (code, str(args))\n        # Add link to spec\n        m = re.match(r'''([EW](\\d\\d\\d))''', code)\n        if m and int(m.group(2)) < 200:\n            message += ' (see ' + self.spec + '#' + m.group(1) + ')'\n        # Store set of codes with last message for that code, and _full_ list of messages\n        self.codes[code] = message\n        if (severity == 'error' and self.show_errors) or (severity != 'error' and self.show_warnings):\n            self.messages.append(message)\n\n    def error(self, code, **args):\n        \"\"\"Add error code to self.codes.\"\"\"\n        self.error_or_warning(code, severity='error', **args)\n        self.num_errors += 1\n\n    def warning(self, code, **args):\n        \"\"\"Add warning code to self.codes.\"\"\"\n        self.error_or_warning(code, severity='warning', **args)\n        self.num_warnings += 1\n", "contexts_below": "    def __str__(self):\n         \"\"\"Return status string.\"\"\"\n         return self.status_str()\n ", "input_code": "def status_str(self, prefix=''):\n\"\"\"\nReturn string of validator status, with optional prefix.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def status_str(self, prefix=''):\n        \"\"\"Return string of validator status, with optional prefix.\"\"\"\n        s = ''\n        for message in sorted(self.messages):\n            s += prefix + message + '\\n'\n        return s[:-1]", "signature": "def status_str(self, prefix=''):", "completion_path": "ocfl/validation_logger.py"}
{"ce_id": "62b45df15108cfac7f2109dd", "namespace": "62b45df15108cfac7f2109dd", "namespace_real": "ocfl.validator.status_str", "real_proj_path": "zimeon---ocfl-py/", "type": "class", "class_name": "validator", "function_name": "status_str", "contexts_above": "\"\"\"OCFL Validator.\n\nPhilosophy of this code is to keep it separate from the implementations\nof Store, Object and Version used to build and manipulate OCFL data, but\nto leverage lower level functions such as digest creation etc.. Code style\nis plain/verbose with detailed and specific validation errors that might\nhelp someone debug an implementation.\n\nThis code uses PyFilesystem (import fs) exclusively for access to files. This\nshould enable application beyond the operating system filesystem.\n\"\"\"\nimport json\nimport re\nimport fs\n\nfrom .digest import file_digest, normalized_digest\nfrom .inventory_validator import InventoryValidator\nfrom .namaste import find_namastes\nfrom .pyfs import open_fs, ocfl_walk, ocfl_files_identical\nfrom .validation_logger import ValidationLogger\n\n\nclass ValidatorAbortException(Exception):\n    \"\"\"Exception class to bail out of validation.\"\"\"\n\n\nclass Validator():\n    \"\"\"Class for OCFL Validator.\"\"\"\n\n    def __init__(self, log=None, show_warnings=False, show_errors=True, check_digests=True, lax_digests=False, lang='en'):\n        \"\"\"Initialize OCFL validator.\"\"\"\n        self.log = log\n        self.check_digests = check_digests\n        self.lax_digests = lax_digests\n        if self.log is None:\n            self.log = ValidationLogger(show_warnings=show_warnings, show_errors=show_errors, lang=lang)\n        self.registered_extensions = [\n            '0001-digest-algorithms', '0002-flat-direct-storage-layout',\n            '0003-hash-and-id-n-tuple-storage-layout', '0004-hashed-n-tuple-storage-layout',\n            '0005-mutable-head'\n        ]\n        # The following actually initialized in initialize() method\n        self.id = None\n        self.spec_version = None\n        self.digest_algorithm = None\n        self.content_directory = None\n        self.inventory_digest_files = None\n        self.root_inv_validator = None\n        self.obj_fs = None\n        self.initialize()\n\n    def initialize(self):\n        \"\"\"Initialize object state.\n\n        Must be called between attempts to validate objects.\n        \"\"\"\n        self.id = None\n        self.spec_version = '1.0'  # default to latest published version\n        self.digest_algorithm = 'sha512'\n        self.content_directory = 'content'\n        self.inventory_digest_files = {}  # index by version_dir, algorithms may differ\n        self.root_inv_validator = None\n        self.obj_fs = None\n", "contexts_below": "    def __str__(self):\n         \"\"\"Return string representation of validation log.\"\"\"\n         return self.status_str()\n \n     def validate(self, path):\n         \"\"\"Validate OCFL object at path or pyfs root.\n \n         Returns True if valid (warnings permitted), False otherwise.\n         \"\"\"\n         self.initialize()\n         try:\n             if isinstance(path, str):\n                 self.obj_fs = open_fs(path)\n             else:\n                 self.obj_fs = path\n                 path = self.obj_fs.desc('')\n         except fs.errors.CreateFailed:\n             self.log.error('E003e', path=path)\n             return False\n         # Object declaration, set spec version number. If there are multiple declarations,\n         # look for the lastest object version then report any others as errors\n         namastes = find_namastes(0, pyfs=self.obj_fs)\n         if len(namastes) == 0:\n             self.log.error('E003a', assumed_version=self.spec_version)\n         else:\n             spec_version = None\n             for namaste in namastes:\n                 # Extract and check spec version number\n                 this_file_version = None\n                 for version in ('1.1', '1.0'):\n                     if namaste.filename == '0=ocfl_object_' + version:\n                         this_file_version = version\n                         break\n                 if this_file_version is None:\n                     self.log.error('E006', filename=namaste.filename)\n                 elif spec_version is None or this_file_version > spec_version:\n                     spec_version = this_file_version\n                     if not namaste.content_ok(pyfs=self.obj_fs):\n                         self.log.error('E007', filename=namaste.filename)\n             if spec_version is None:\n                 self.log.error('E003c', assumed_version=self.spec_version)\n             else:\n                 self.spec_version = spec_version\n                 if len(namastes) > 1:\n                     self.log.error('E003b', files=len(namastes), using_version=self.spec_version)\n         # Object root inventory file\n         inv_file = 'inventory.json'\n         if not self.obj_fs.exists(inv_file):\n             self.log.error('E063')\n             return False\n         try:\n             inventory, inv_validator = self.validate_inventory(inv_file)\n             inventory_is_valid = self.log.num_errors == 0\n             self.root_inv_validator = inv_validator\n             all_versions = inv_validator.all_versions\n             self.id = inv_validator.id\n             self.content_directory = inv_validator.content_directory\n             self.digest_algorithm = inv_validator.digest_algorithm\n             self.validate_inventory_digest(inv_file, self.digest_algorithm)\n             # Object root\n             self.validate_object_root(all_versions, already_checked=[namaste.filename for namaste in namastes])\n             # Version inventory files\n             (prior_manifest_digests, prior_fixity_digests) = self.validate_version_inventories(all_versions)\n             if inventory_is_valid:\n                 # Object content\n                 self.validate_content(inventory, all_versions, prior_manifest_digests, prior_fixity_digests)\n         except ValidatorAbortException:\n             pass\n         return self.log.num_errors == 0\n \n     def validate_inventory(self, inv_file, where='root', extract_spec_version=False):\n         \"\"\"Validate a given inventory file, record errors with self.log.error().\n \n         Returns inventory object for use in later validation\n         of object content. Does not look at anything else in the\n         object itself.\n \n         where - used for reporting messages of where inventory is in object\n \n         extract_spec_version - if set True will attempt to take spec_version from the\n             inventory itself instead of using the spec_version provided\n         \"\"\"\n         try:\n             with self.obj_fs.openbin(inv_file, 'r') as fh:\n                 inventory = json.load(fh)\n         except json.decoder.JSONDecodeError as e:\n             self.log.error('E033', where=where, explanation=str(e))\n             raise ValidatorAbortException\n         inv_validator = InventoryValidator(log=self.log, where=where,\n                                            lax_digests=self.lax_digests,\n                                            spec_version=self.spec_version)\n         inv_validator.validate(inventory, extract_spec_version=extract_spec_version)\n         return inventory, inv_validator\n \n     def validate_inventory_digest(self, inv_file, digest_algorithm, where=\"root\"):\n         \"\"\"Validate the appropriate inventory digest file in path.\"\"\"\n         inv_digest_file = inv_file + '.' + digest_algorithm\n         if not self.obj_fs.exists(inv_digest_file):\n             self.log.error('E058a', where=where, path=inv_digest_file)\n         else:\n             self.validate_inventory_digest_match(inv_file, inv_digest_file)\n \n     def validate_inventory_digest_match(self, inv_file, inv_digest_file):\n         \"\"\"Validate a given inventory digest for a given inventory file.\n \n         On error throws exception with debugging string intended to\n         be presented to a user.\n         \"\"\"\n         if not self.check_digests:\n             return\n         m = re.match(r'''.*\\.(\\w+)$''', inv_digest_file)\n         if m:\n             digest_algorithm = m.group(1)\n             try:\n                 digest_recorded = self.read_inventory_digest(inv_digest_file)\n                 digest_actual = file_digest(inv_file, digest_algorithm, pyfs=self.obj_fs)\n                 if digest_actual != digest_recorded:\n                     self.log.error(\"E060\", inv_file=inv_file, actual=digest_actual, recorded=digest_recorded, inv_digest_file=inv_digest_file)\n             except Exception as e:  # pylint: disable=broad-except\n                 self.log.error(\"E061\", description=str(e))\n         else:\n             self.log.error(\"E058b\", inv_digest_file=inv_digest_file)\n \n     def validate_object_root(self, version_dirs, already_checked):\n         \"\"\"Validate object root.\n \n         All expected_files must be present and no other files.\n         All expected_dirs must be present and no other dirs.\n         \"\"\"\n         expected_files = ['0=ocfl_object_' + self.spec_version, 'inventory.json',\n                           'inventory.json.' + self.digest_algorithm]\n         for entry in self.obj_fs.scandir(''):\n             if entry.is_file:\n                 if entry.name not in expected_files and entry.name not in already_checked:\n                     self.log.error('E001a', file=entry.name)\n             elif entry.is_dir:\n                 if entry.name in version_dirs:\n                     pass\n                 elif entry.name == 'extensions':\n                     self.validate_extensions_dir()\n                 elif re.match(r'''v\\d+$''', entry.name):\n                     # Looks like a version directory so give more specific error\n                     self.log.error('E046b', dir=entry.name)\n                 else:\n                     # Simply an unexpected directory\n                     self.log.error('E001b', dir=entry.name)\n             else:\n                 self.log.error('E001c', entry=entry.name)\n \n     def validate_extensions_dir(self):\n         \"\"\"Validate content of extensions directory inside object root.\n \n         Validate the extensions directory by checking that there aren't any\n         entries in the extensions directory that aren't directories themselves.\n         Where there are extension directories they SHOULD be registered and\n         this code relies up the registered_extensions property to list known\n         extensions.\n         \"\"\"\n         for entry in self.obj_fs.scandir('extensions'):\n             if entry.is_dir:\n                 if entry.name not in self.registered_extensions:\n                     self.log.warning('W013', entry=entry.name)\n             else:\n                 self.log.error('E067', entry=entry.name)\n \n     def validate_version_inventories(self, version_dirs):\n         \"\"\"Each version SHOULD have an inventory up to that point.\n \n         Also keep a record of any content digests different from those in the root inventory\n         so that we can also check them when validating the content.\n \n         version_dirs is an array of version directory names and is assumed to be in\n         version sequence (1, 2, 3...).\n         \"\"\"\n         prior_manifest_digests = {}  # file -> algorithm -> digest -> [versions]\n         prior_fixity_digests = {}  # file -> algorithm -> digest -> [versions]\n         if len(version_dirs) == 0:\n             return prior_manifest_digests, prior_fixity_digests\n         last_version = version_dirs[-1]\n         prev_version_dir = \"NONE\"  # will be set for first directory with inventory\n         prev_spec_version = '1.0'  # lowest version\n         for version_dir in version_dirs:\n             inv_file = fs.path.join(version_dir, 'inventory.json')\n             if not self.obj_fs.exists(inv_file):\n                 self.log.warning('W010', where=version_dir)\n                 continue\n             # There is an inventory file for this version directory, check it\n             if version_dir == last_version:\n                 # Don't validate in this case. Per the spec the inventory in the last version\n                 # MUST be identical to the copy in the object root, just check that\n                 root_inv_file = 'inventory.json'\n                 if not ocfl_files_identical(self.obj_fs, inv_file, root_inv_file):\n                     self.log.error('E064', root_inv_file=root_inv_file, inv_file=inv_file)\n                 else:\n                     # We could also just compare digest files but this gives a more helpful error for\n                     # which file has the incorrect digest if they don't match\n                     self.validate_inventory_digest(inv_file, self.digest_algorithm, where=version_dir)\n                 self.inventory_digest_files[version_dir] = 'inventory.json.' + self.digest_algorithm\n                 this_spec_version = self.spec_version\n             else:\n                 # Note that inventories in prior versions may use different digest algorithms\n                 # from the current invenotory. Also,\n                 # an may accord with the same or earlier versions of the specification\n                 version_inventory, inv_validator = self.validate_inventory(inv_file, where=version_dir, extract_spec_version=True)\n                 this_spec_version = inv_validator.spec_version\n                 digest_algorithm = inv_validator.digest_algorithm\n                 self.validate_inventory_digest(inv_file, digest_algorithm, where=version_dir)\n                 self.inventory_digest_files[version_dir] = 'inventory.json.' + digest_algorithm\n                 if self.id and 'id' in version_inventory:\n                     if version_inventory['id'] != self.id:\n                         self.log.error('E037b', where=version_dir, root_id=self.id, version_id=version_inventory['id'])\n                 if 'manifest' in version_inventory:\n                     # Check that all files listed in prior inventories are in manifest\n                     not_seen = set(prior_manifest_digests.keys())\n                     for digest in version_inventory['manifest']:\n                         for filepath in version_inventory['manifest'][digest]:\n                             # We rely on the validation to check that anything present is OK\n                             if filepath in not_seen:\n                                 not_seen.remove(filepath)\n                     if len(not_seen) > 0:\n                         self.log.error('E023b', where=version_dir, missing_filepaths=', '.join(sorted(not_seen)))\n                     # Record all prior digests\n                     for unnormalized_digest in version_inventory['manifest']:\n                         digest = normalized_digest(unnormalized_digest, digest_type=digest_algorithm)\n                         for filepath in version_inventory['manifest'][unnormalized_digest]:\n                             if filepath not in prior_manifest_digests:\n                                 prior_manifest_digests[filepath] = {}\n                             if digest_algorithm not in prior_manifest_digests[filepath]:\n                                 prior_manifest_digests[filepath][digest_algorithm] = {}\n                             if digest not in prior_manifest_digests[filepath][digest_algorithm]:\n                                 prior_manifest_digests[filepath][digest_algorithm][digest] = []\n                             prior_manifest_digests[filepath][digest_algorithm][digest].append(version_dir)\n                 # Is this inventory an appropriate prior version of the object root inventory?\n                 if self.root_inv_validator is not None:\n                     self.root_inv_validator.validate_as_prior_version(inv_validator)\n                 # Fixity blocks are independent in each version. Record all values and the versions\n                 # they occur in for later checks against content\n                 if 'fixity' in version_inventory:\n                     for digest_algorithm in version_inventory['fixity']:\n                         for unnormalized_digest in version_inventory['fixity'][digest_algorithm]:\n                             digest = normalized_digest(unnormalized_digest, digest_type=digest_algorithm)\n                             for filepath in version_inventory['fixity'][digest_algorithm][unnormalized_digest]:\n                                 if filepath not in prior_fixity_digests:\n                                     prior_fixity_digests[filepath] = {}\n                                 if digest_algorithm not in prior_fixity_digests[filepath]:\n                                     prior_fixity_digests[filepath][digest_algorithm] = {}\n                                 if digest not in prior_fixity_digests[filepath][digest_algorithm]:\n                                     prior_fixity_digests[filepath][digest_algorithm][digest] = []\n                                 prior_fixity_digests[filepath][digest_algorithm][digest].append(version_dir)\n             # We are validating the inventories in sequence and each new version must\n             # follow the same or later spec version to previous inventories\n             if prev_spec_version > this_spec_version:\n                 self.log.error('E103', where=version_dir, this_spec_version=this_spec_version,\n                                prev_version_dir=prev_version_dir, prev_spec_version=prev_spec_version)\n             prev_version_dir = version_dir\n             prev_spec_version = this_spec_version\n         return prior_manifest_digests, prior_fixity_digests\n \n     def validate_content(self, inventory, version_dirs, prior_manifest_digests, prior_fixity_digests):\n         \"\"\"Validate file presence and content against inventory.\n \n         The root inventory in `inventory` is assumed to be valid and safe to use\n         for construction of file paths etc..\n         \"\"\"\n         files_seen = set()\n         # Check files in each version directory\n         for version_dir in version_dirs:\n             try:\n                 # Check contents of version directory except content_directory\n                 for entry in self.obj_fs.listdir(version_dir):\n                     if ((entry == 'inventory.json')\n                             or (version_dir in self.inventory_digest_files and entry == self.inventory_digest_files[version_dir])):\n                         pass\n                     elif entry == self.content_directory:\n                         # Check content_directory\n                         content_path = fs.path.join(version_dir, self.content_directory)\n                         num_content_files_in_version = 0\n                         for dirpath, dirs, files in ocfl_walk(self.obj_fs, content_path):\n                             if dirpath != '/' + content_path and (len(dirs) + len(files)) == 0:\n                                 self.log.error(\"E024\", where=version_dir, path=dirpath)\n                             for file in files:\n                                 files_seen.add(fs.path.join(dirpath, file).lstrip('/'))\n                                 num_content_files_in_version += 1\n                         if num_content_files_in_version == 0:\n                             self.log.warning(\"W003\", where=version_dir)\n                     elif self.obj_fs.isdir(fs.path.join(version_dir, entry)):\n                         self.log.warning(\"W002\", where=version_dir, entry=entry)\n                     else:\n                         self.log.error(\"E015\", where=version_dir, entry=entry)\n             except (fs.errors.ResourceNotFound, fs.errors.DirectoryExpected):\n                 self.log.error('E046a', version_dir=version_dir)\n         # Extract any digests in fixity and organize by filepath\n         fixity_digests = {}\n         if 'fixity' in inventory:\n             for digest_algorithm in inventory['fixity']:\n                 for digest in inventory['fixity'][digest_algorithm]:\n                     for filepath in inventory['fixity'][digest_algorithm][digest]:\n                         if filepath in files_seen:\n                             if filepath not in fixity_digests:\n                                 fixity_digests[filepath] = {}\n                             if digest_algorithm not in fixity_digests[filepath]:\n                                 fixity_digests[filepath][digest_algorithm] = {}\n                             if digest not in fixity_digests[filepath][digest_algorithm]:\n                                 fixity_digests[filepath][digest_algorithm][digest] = ['root']\n                         else:\n                             self.log.error('E093b', where='root', digest_algorithm=digest_algorithm, digest=digest, content_path=filepath)\n         # Check all files in root manifest\n         if 'manifest' in inventory:\n             for digest in inventory['manifest']:\n                 for filepath in inventory['manifest'][digest]:\n                     if filepath not in files_seen:\n                         self.log.error('E092b', where='root', content_path=filepath)\n                     else:\n                         if self.check_digests:\n                             content_digest = file_digest(filepath, digest_type=self.digest_algorithm, pyfs=self.obj_fs)\n                             if content_digest != normalized_digest(digest, digest_type=self.digest_algorithm):\n                                 self.log.error('E092a', where='root', digest_algorithm=self.digest_algorithm, digest=digest, content_path=filepath, content_digest=content_digest)\n                             known_digests = {self.digest_algorithm: content_digest}\n                             # Are there digest values in the fixity block?\n                             self.check_additional_digests(filepath, known_digests, fixity_digests, 'E093a')\n                             # Are there other digests for this same file from other inventories?\n                             self.check_additional_digests(filepath, known_digests, prior_manifest_digests, 'E092a')\n                             self.check_additional_digests(filepath, known_digests, prior_fixity_digests, 'E093a')\n                         files_seen.discard(filepath)\n         # Anything left in files_seen is not mentioned in the inventory\n         if len(files_seen) > 0:\n             self.log.error('E023a', where='root', extra_files=', '.join(sorted(files_seen)))\n \n     def check_additional_digests(self, filepath, known_digests, additional_digests, error_code):\n         \"\"\"Check all the additional digests for filepath.\n \n         This method is intended to be used both for manifest digests in prior versions and\n         for fixity digests. The digests_seen dict is used to store any values calculated\n         so that we don't recalculate digests that might appear multiple times. It is added to\n         with any additional values calculated.\n \n         Parameters:\n             filepath - path of file in object (`v1/content/something` etc.)\n             known_digests - dict of algorithm->digest that we have calculated\n             additional_digests - dict: filepath -> algorithm -> digest -> [versions appears in]\n             error_code - error code to log on mismatch (E092a for manifest, E093a for fixity)\n         \"\"\"\n         if filepath in additional_digests:\n             for digest_algorithm in additional_digests[filepath]:\n                 if digest_algorithm in known_digests:\n                     # Don't recompute anything, just use it if we've seen it before\n                     content_digest = known_digests[digest_algorithm]\n                 else:\n                     content_digest = file_digest(filepath, digest_type=digest_algorithm, pyfs=self.obj_fs)\n                     known_digests[digest_algorithm] = content_digest\n                 for digest in additional_digests[filepath][digest_algorithm]:\n                     if content_digest != normalized_digest(digest, digest_type=digest_algorithm):\n                         where = ','.join(additional_digests[filepath][digest_algorithm][digest])\n                         self.log.error(error_code, where=where, digest_algorithm=digest_algorithm, digest=digest, content_path=filepath, content_digest=content_digest)\n \n     def read_inventory_digest(self, inv_digest_file):\n         \"\"\"Read inventory digest from sidecar file.\n \n         Raise exception if there is an error, else return digest.\n         \"\"\"\n         with self.obj_fs.open(inv_digest_file, 'r') as fh:\n             line = fh.readline()\n             # we ignore any following lines, could raise exception\n         m = re.match(r'''(\\w+)\\s+(\\S+)\\s*$''', line)\n         if not m:\n             raise Exception(\"Bad inventory digest file %s, wrong format\" % (inv_digest_file))\n         if m.group(2) != 'inventory.json':\n             raise Exception(\"Bad inventory name in inventory digest file %s\" % (inv_digest_file))\n         return m.group(1)\n ", "input_code": "def status_str(self, prefix=''):\n\"\"\"\nReturn string representation of validation log, with optional prefix.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def status_str(self, prefix=''):\n        \"\"\"Return string representation of validation log, with optional prefix.\"\"\"\n        return self.log.status_str(prefix=prefix)", "signature": "def status_str(self, prefix=''):", "completion_path": "ocfl/validator.py"}
{"ce_id": "62b45e135108cfac7f2109f4", "namespace": "62b45e135108cfac7f2109f4", "namespace_real": "ocfl.dispositor.is_valid", "real_proj_path": "zimeon---ocfl-py/", "type": "class", "class_name": "dispositor", "function_name": "is_valid", "contexts_above": "\"\"\"Base class for Dispositor objects.\"\"\"\nimport os\nimport os.path\nfrom urllib.parse import quote_plus, unquote_plus\n\n\nclass Dispositor:\n    \"\"\"Base class for disposition handlers -- let's call them Dispositors.\"\"\"\n\n    def strip_root(self, path, root):\n        \"\"\"Remove root from path, throw exception on failure.\"\"\"\n        root = root.rstrip(os.sep)  # ditch any trailing path separator\n        if os.path.commonprefix((path, root)) == root:\n            return os.path.relpath(path, start=root)\n        raise Exception(\"Path %s is not in root %s\" % (path, root))\n", "contexts_below": "    def encode(self, identifier):\n         \"\"\"Encode identifier to get rid of unsafe chars.\"\"\"\n         return quote_plus(identifier)\n \n     def decode(self, identifier):\n         \"\"\"Decode identifier to put back unsafe chars.\"\"\"\n         return unquote_plus(identifier)\n \n     def identifier_to_path(self, identifier):\n         \"\"\"Convert identifier to path relative to some root.\"\"\"\n         raise Exception(\"No yet implemented\")\n \n     def relative_path_to_identifier(self, path):\n         \"\"\"Convert relative path to identifier.\"\"\"\n         raise Exception(\"No yet implemented\")\n \n     def path_to_identifier(self, path, root=None):\n         \"\"\"Convert path relative to root to identifier.\"\"\"\n         if root is not None:\n             path = self.strip_root(path, root)\n         return self.relative_path_to_identifier(path)\n ", "input_code": "def is_valid(self, identifier):\n\"\"\"\nReturn True if identifier is valid, always True in this base implementation.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def is_valid(self, identifier):  # pylint: disable=unused-argument\n        \"\"\"Return True if identifier is valid, always True in this base implementation.\"\"\"\n        return True", "signature": "def is_valid(self, identifier):", "completion_path": "ocfl/dispositor.py"}
{"ce_id": "62b45e145108cfac7f210a07", "namespace": "62b45e145108cfac7f210a07", "namespace_real": "ocfl.inventory_validator.validate", "real_proj_path": "zimeon---ocfl-py/", "type": "class", "class_name": "inventory_validator", "function_name": "validate", "contexts_above": "\"\"\"OCFL Inventory Validator.\n\nCode to validate the Python representation of an OCFL Inventory\nas read with json.load(). Does not examine anything in storage.\n\"\"\"\nimport re\n\nfrom .digest import digest_regex, normalized_digest\nfrom .validation_logger import ValidationLogger\nfrom .w3c_datetime import str_to_datetime\n\n\ndef get_logical_path_map(inventory, version):\n    \"\"\"Get a map of logical paths in state to files on disk for version in inventory.\n\n    Returns a dictionary: logical_path_in_state -> set(content_files)\n\n    The set of content_files may includes references to duplicate files in\n    later versions than the version being described.\n    \"\"\"\n    state = inventory['versions'][version]['state']\n    manifest = inventory['manifest']\n    file_map = {}\n    for digest in state:\n        if digest in manifest:\n            for file in state[digest]:\n                file_map[file] = set(manifest[digest])\n    return file_map\n\n\nclass InventoryValidator():\n    \"\"\"Class for OCFL Inventory Validator.\"\"\"\n\n    def __init__(self, log=None, where='???',\n                 lax_digests=False, spec_version='1.0'):\n        \"\"\"Initialize OCFL Inventory Validator.\"\"\"\n        self.log = ValidationLogger() if log is None else log\n        self.where = where\n        self.spec_version = spec_version\n        # Object state\n        self.inventory = None\n        self.id = None\n        self.digest_algorithm = 'sha512'\n        self.content_directory = 'content'\n        self.all_versions = []\n        self.manifest_files = None\n        self.unnormalized_digests = None\n        self.head = 'UNKNOWN'\n        # Validation control\n        self.lax_digests = lax_digests\n        # Configuration\n        self.spec_versions_supported = ('1.0', '1.1')\n\n    def error(self, code, **args):\n        \"\"\"Error with added context.\"\"\"\n        self.log.error(code, where=self.where, **args)\n\n    def warning(self, code, **args):\n        \"\"\"Warning with added context.\"\"\"\n        self.log.warning(code, where=self.where, **args)\n", "contexts_below": "    def validate_manifest(self, manifest):\n         \"\"\"Validate manifest block in inventory.\n \n         Returns:\n           * manifest_files - a mapping from file to digest for each file in\n               the manifest\n           * manifest_files_correct_format - a simple list of the manifest file\n               path that passed initial checks. They need to be checked for valid\n               version directories later, when we know what version directories\n               are valid\n           * unnormalized_digests - a set of the original digests in unnormalized\n               form that MUST match exactly the values used in state blocks\n         \"\"\"\n         manifest_files = {}\n         manifest_files_correct_format = []\n         unnormalized_digests = set()\n         manifest_digests = set()\n         if not isinstance(manifest, dict):\n             self.error('E041c')\n         else:\n             content_paths = set()\n             content_directories = set()\n             for digest in manifest:\n                 m = re.match(self.digest_regex(), digest)\n                 if not m:\n                     self.error('E025a', digest=digest, algorithm=self.digest_algorithm)  # wrong form of digest\n                 elif not isinstance(manifest[digest], list):\n                     self.error('E092', digest=digest)  # must have path list value\n                 else:\n                     unnormalized_digests.add(digest)\n                     norm_digest = normalized_digest(digest, self.digest_algorithm)\n                     if norm_digest in manifest_digests:\n                         # We have already seen this in different un-normalized form!\n                         self.error(\"E096\", digest=norm_digest)\n                     else:\n                         manifest_digests.add(norm_digest)\n                     for file in manifest[digest]:\n                         manifest_files[file] = norm_digest\n                         if self.check_content_path(file, content_paths, content_directories):\n                             manifest_files_correct_format.append(file)\n             # Check for conflicting content paths\n             for path in content_directories:\n                 if path in content_paths:\n                     self.error(\"E101b\", path=path)\n         return manifest_files, manifest_files_correct_format, unnormalized_digests\n \n     def validate_fixity(self, fixity, manifest_files):\n         \"\"\"Validate fixity block in inventory.\n \n         Check the structure of the fixity block and makes sure that only files\n         listed in the manifest are referenced.\n         \"\"\"\n         if not isinstance(fixity, dict):\n             # The value of fixity must be a JSON object. In v1.0 I catch not an object\n             # as part of E056 but this was clarified as E111 in v1.1. The value may\n             # be an empty object in either case\n             self.error('E056a' if self.spec_version == '1.0' else 'E111')\n         else:\n             for digest_algorithm in fixity:\n                 known_digest = True\n                 try:\n                     regex = digest_regex(digest_algorithm)\n                 except ValueError:\n                     if not self.lax_digests:\n                         self.error('E056b', algorithm=self.digest_algorithm)\n                         continue\n                     # Match anything\n                     regex = r'''^.*$'''\n                     known_digest = False\n                 fixity_algoritm_block = fixity[digest_algorithm]\n                 if not isinstance(fixity_algoritm_block, dict):\n                     self.error('E057a', algorithm=self.digest_algorithm)\n                 else:\n                     digests_seen = set()\n                     for digest in fixity_algoritm_block:\n                         m = re.match(regex, digest)\n                         if not m:\n                             self.error('E057b', digest=digest, algorithm=digest_algorithm)  # wrong form of digest\n                         elif not isinstance(fixity_algoritm_block[digest], list):\n                             self.error('E057c', digest=digest, algorithm=digest_algorithm)  # must have path list value\n                         else:\n                             if known_digest:\n                                 norm_digest = normalized_digest(digest, digest_algorithm)\n                             else:\n                                 norm_digest = digest\n                             if norm_digest in digests_seen:\n                                 # We have already seen this in different un-normalized form!\n                                 self.error(\"E097\", digest=norm_digest, algorithm=digest_algorithm)\n                             else:\n                                 digests_seen.add(norm_digest)\n                             for file in fixity_algoritm_block[digest]:\n                                 if file not in manifest_files:\n                                     self.error(\"E057d\", digest=norm_digest, algorithm=digest_algorithm, path=file)\n \n     def validate_version_sequence(self, versions):\n         \"\"\"Validate sequence of version names in versions block in inventory.\n \n         Returns an array of in-sequence version directories that are part\n         of a valid sequences. May exclude other version directory names that are\n         not part of the valid sequence if an error is thrown.\n         \"\"\"\n         all_versions = []\n         if not isinstance(versions, dict):\n             self.error(\"E044\")\n             return all_versions\n         if len(versions) == 0:\n             self.error(\"E008\")\n             return all_versions\n         # Validate version sequence\n         # https://ocfl.io/draft/spec/#version-directories\n         zero_padded = None\n         max_version_num = 999999  # Excessive limit\n         if 'v1' in versions:\n             fmt = 'v%d'\n             zero_padded = False\n             all_versions.append('v1')\n         else:  # Find padding size\n             for n in range(2, 11):\n                 fmt = 'v%0' + str(n) + 'd'\n                 vkey = fmt % 1\n                 if vkey in versions:\n                     all_versions.append(vkey)\n                     zero_padded = n\n                     max_version_num = (10 ** (n - 1)) - 1\n                     break\n             if not zero_padded:\n                 self.error(\"E009\")\n                 return all_versions\n         if zero_padded:\n             self.warning(\"W001\")\n         # Have v1 and know format, work through to check sequence\n         for n in range(2, max_version_num + 1):\n             v = (fmt % n)\n             if v in versions:\n                 all_versions.append(v)\n             else:\n                 if len(versions) != (n - 1):\n                     self.error(\"E010\")  # Extra version dirs outside sequence\n                 return all_versions\n         # We have now included all possible versions up to the zero padding\n         # size, if there are more versions than this number then we must\n         # have extra that violate the zero-padding rule or are out of\n         # sequence\n         if len(versions) > max_version_num:\n             self.error(\"E011\")\n         return all_versions\n \n     def validate_versions(self, versions, all_versions, unnormalized_digests):\n         \"\"\"Validate versions blocks in inventory.\n \n         Requires as input two things which are assumed to be structurally correct\n         from prior basic validation:\n \n           * versions - which is the JSON object (dict) from the inventory\n           * all_versions - an ordered list of the versions to look at in versions\n                            (all other keys in versions will be ignored)\n \n         Returns a list of digests_used which can then be checked against the\n         manifest.\n         \"\"\"\n         digests_used = []\n         for v in all_versions:\n             version = versions[v]\n             if 'created' not in version:\n                 self.error('E048', version=v)  # No created\n             elif not isinstance(versions[v]['created'], str):\n                 self.error('E049d', version=v)  # Bad created\n             else:\n                 created = versions[v]['created']\n                 try:\n                     str_to_datetime(created)  # catch ValueError if fails\n                     if not re.search(r'''(Z|[+-]\\d\\d:\\d\\d)$''', created):  # FIXME - kludge\n                         self.error('E049a', version=v)\n                     if not re.search(r'''T\\d\\d:\\d\\d:\\d\\d''', created):  # FIXME - kludge\n                         self.error('E049b', version=v)\n                 except ValueError as e:\n                     self.error('E049c', version=v, description=str(e))\n             if 'state' in version:\n                 digests_used += self.validate_state_block(version['state'], version=v, unnormalized_digests=unnormalized_digests)\n             else:\n                 self.error('E048c', version=v)\n             if 'message' not in version:\n                 self.warning('W007a', version=v)\n             elif not isinstance(version['message'], str):\n                 self.error('E094', version=v)\n             if 'user' not in version:\n                 self.warning('W007b', version=v)\n             else:\n                 user = version['user']\n                 if not isinstance(user, dict):\n                     self.error('E054a', version=v)\n                 else:\n                     if 'name' not in user or not isinstance(user['name'], str):\n                         self.error('E054b', version=v)\n                     if 'address' not in user:\n                         self.warning('W008', version=v)\n                     elif not isinstance(user['address'], str):\n                         self.error('E054c', version=v)\n                     elif not re.match(r'''\\w{3,6}:''', user['address']):\n                         self.warning('W009', version=v)\n         return digests_used\n \n     def validate_state_block(self, state, version, unnormalized_digests):\n         \"\"\"Validate state block in a version in an inventory.\n \n         The version is used only for error reporting.\n \n         Returns a list of content digests referenced in the state block.\n         \"\"\"\n         digests = []\n         logical_paths = set()\n         logical_directories = set()\n         if not isinstance(state, dict):\n             self.error('E050c', version=version)\n         else:\n             digest_re = re.compile(self.digest_regex())\n             for digest in state:\n                 if not digest_re.match(digest):\n                     self.error('E050d', version=version, digest=digest)\n                 elif not isinstance(state[digest], list):\n                     self.error('E050e', version=version, digest=digest)\n                 else:\n                     for path in state[digest]:\n                         if path in logical_paths:\n                             self.error(\"E095a\", version=version, path=path)\n                         else:\n                             self.check_logical_path(path, version, logical_paths, logical_directories)\n                     if digest not in unnormalized_digests:\n                         # Exact string value must match, not just normalized\n                         self.error(\"E050f\", version=version, digest=digest)\n                     norm_digest = normalized_digest(digest, self.digest_algorithm)\n                     digests.append(norm_digest)\n             # Check for conflicting logical paths\n             for path in logical_directories:\n                 if path in logical_paths:\n                     self.error(\"E095b\", version=version, path=path)\n         return digests\n \n     def check_content_paths_map_to_versions(self, manifest_files, all_versions):\n         \"\"\"Check that every content path starts with a valid version.\n \n         The content directory component has already been checked in\n         check_content_path(). We have already tested all paths enough\n         to know that they can be split into at least 2 components.\n         \"\"\"\n         for path in manifest_files:\n             version_dir, dummy_rest = path.split('/', 1)\n             if version_dir not in all_versions:\n                 self.error('E042b', path=path)\n \n     def check_digests_present_and_used(self, manifest_files, digests_used):\n         \"\"\"Check all digests in manifest that are needed are present and used.\"\"\"\n         in_manifest = set(manifest_files.values())\n         in_state = set(digests_used)\n         not_in_manifest = in_state.difference(in_manifest)\n         if len(not_in_manifest) > 0:\n             self.error(\"E050a\", digests=\", \".join(sorted(not_in_manifest)))\n         not_in_state = in_manifest.difference(in_state)\n         if len(not_in_state) > 0:\n             self.error(\"E107\", digests=\", \".join(sorted(not_in_state)))\n \n     def digest_regex(self):\n         \"\"\"Return regex for validating un-normalized digest format.\"\"\"\n         try:\n             return digest_regex(self.digest_algorithm)\n         except ValueError:\n             if not self.lax_digests:\n                 self.error('E026a', digest=self.digest_algorithm)\n         # Match anything\n         return r'''^.*$'''\n \n     def check_logical_path(self, path, version, logical_paths, logical_directories):\n         \"\"\"Check logical path and accumulate paths/directories for E095b check.\n \n         logical_paths and logical_directories are expected to be sets.\n \n         Only adds good paths to the accumulated paths/directories.\n         \"\"\"\n         if path.startswith('/') or path.endswith('/'):\n             self.error(\"E053\", version=version, path=path)\n         else:\n             elements = path.split('/')\n             for element in elements:\n                 if element in ['.', '..', '']:\n                     self.error(\"E052\", version=version, path=path)\n                     return\n             # Accumulate paths and directories\n             logical_paths.add(path)\n             logical_directories.add('/'.join(elements[0:-1]))\n \n     def check_content_path(self, path, content_paths, content_directories):\n         \"\"\"Check logical path and accumulate paths/directories for E101 check.\n \n         Returns True if valid, else False. Only adds good paths to the\n         accumulated paths/directories. We don't yet know the set of valid\n         version directories so the check here is just for 'v' + digits.\n         \"\"\"\n         if path.startswith('/') or path.endswith('/'):\n             self.error(\"E100\", path=path)\n             return False\n         m = re.match(r'''^(v\\d+/''' + self.content_directory + r''')/(.+)''', path)\n         if not m:\n             self.error(\"E042a\", path=path)\n             return False\n         elements = m.group(2).split('/')\n         for element in elements:\n             if element in ('', '.', '..'):\n                 self.error(\"E099\", path=path)\n                 return False\n         # Accumulate paths and directories if not seen before\n         if path in content_paths:\n             self.error(\"E101a\", path=path)\n             return False\n         content_paths.add(path)\n         content_directories.add('/'.join([m.group(1)] + elements[0:-1]))\n         return True\n \n     def validate_as_prior_version(self, prior):\n         \"\"\"Check that prior is a valid prior version of the current inventory object.\n \n         The input variable prior is also expected to be an InventoryValidator object\n         and both self and prior inventories are assumed to have been checked for\n         internal consistency.\n         \"\"\"\n         # Must have a subset of versions which also checks zero padding format etc.\n         if not set(prior.all_versions) < set(self.all_versions):\n             self.error('E066a', prior_head=prior.head)\n         else:\n             # Check references to files but realize that there might be different\n             # digest algorithms between versions\n             version = 'no-version'\n             for version in prior.all_versions:\n                 # If the digest algorithm is the same then we can make a\n                 # direct check on whether the state blocks match\n                 if prior.digest_algorithm == self.digest_algorithm:\n                     self.compare_states_for_version(prior, version)\n                 # Now check the mappings from state to logical path, which must\n                 # be consistent even if the digestAlgorithm is different between\n                 # versions. Get maps from logical paths to files on disk:\n                 prior_map = get_logical_path_map(prior.inventory, version)\n                 self_map = get_logical_path_map(self.inventory, version)\n                 # Look first for differences in logical paths listed\n                 only_in_prior = prior_map.keys() - self_map.keys()\n                 only_in_self = self_map.keys() - prior_map.keys()\n                 if only_in_prior or only_in_self:\n                     if only_in_prior:\n                         self.error('E066b', version=version, prior_head=prior.head, only_in=prior.head, logical_paths=','.join(only_in_prior))\n                     if only_in_self:\n                         self.error('E066b', version=version, prior_head=prior.head, only_in=self.where, logical_paths=','.join(only_in_self))\n                 else:\n                     # Check them all in details - digests must match\n                     for logical_path, this_map in prior_map.items():\n                         if not this_map.issubset(self_map[logical_path]):\n                             self.error('E066c', version=version, prior_head=prior.head,\n                                        logical_path=logical_path, prior_content=','.join(this_map),\n                                        current_content=','.join(self_map[logical_path]))\n                 # Check metadata\n                 prior_version = prior.inventory['versions'][version]\n                 self_version = self.inventory['versions'][version]\n                 for key in ('created', 'message', 'user'):\n                     if prior_version.get(key) != self_version.get(key):\n                         self.warning('W011', version=version, prior_head=prior.head, key=key)\n \n     def compare_states_for_version(self, prior, version):\n         \"\"\"Compare state blocks for version between self and prior.\n \n         Assumes the same digest algorithm in both, do not call otherwise!\n \n         Looks only for digests that appear in one but not in the other, the code\n         in validate_as_prior_version(..) does a check for whether the same sets\n         of logical files appear and we don't want to duplicate an error message\n         about that.\n \n         While the mapping checks in validate_as_prior_version(..) do all that is\n         necessary to detect an error, the additional errors that may be generated\n         here provide more detailed diagnostics in the case that the digest\n         algorithm is the same across versions being compared.\n         \"\"\"\n         self_state = self.inventory['versions'][version]['state']\n         prior_state = prior.inventory['versions'][version]['state']\n         for digest in set(self_state.keys()).union(prior_state.keys()):\n             if digest not in prior_state:\n                 self.error('E066d', version=version, prior_head=prior.head,\n                            digest=digest, logical_files=', '.join(self_state[digest]))\n             elif digest not in self_state:\n                 self.error('E066e', version=version, prior_head=prior.head,\n                            digest=digest, logical_files=', '.join(prior_state[digest]))\n ", "input_code": "def validate(self, inventory, extract_spec_version=False):\n\"\"\"\nValidate a given inventory.\n\nIf extract_spec_version is True then will look at the type value to determine\nthe specification version. In the case that there is no type value or it isn't\nvalid, then other tests will be based on the version given in self.spec_version.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def validate(self, inventory, extract_spec_version=False):\n        \"\"\"Validate a given inventory.\n\n        If extract_spec_version is True then will look at the type value to determine\n        the specification version. In the case that there is no type value or it isn't\n        valid, then other tests will be based on the version given in self.spec_version.\n        \"\"\"\n        # Basic structure\n        self.inventory = inventory\n        if 'id' in inventory:\n            iid = inventory['id']\n            if not isinstance(iid, str) or iid == '':\n                self.error(\"E037a\")\n            else:\n                # URI syntax https://www.rfc-editor.org/rfc/rfc3986.html#section-3.1 :\n                # scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n                if not re.match(r'''[a-z][a-z\\d\\+\\-\\.]*:.+''', iid, re.IGNORECASE):\n                    self.warning(\"W005\", id=iid)\n                self.id = iid\n        else:\n            self.error(\"E036a\")\n        if 'type' not in inventory:\n            self.error(\"E036b\")\n        elif not isinstance(inventory['type'], str):\n            self.error(\"E999\")\n        elif extract_spec_version:\n            m = re.match(r'''https://ocfl.io/(\\d+.\\d)/spec/#inventory''', inventory['type'])\n            if not m:\n                self.error('E038b', got=inventory['type'], assumed_spec_version=self.spec_version)\n            elif m.group(1) in self.spec_versions_supported:\n                self.spec_version = m.group(1)\n            else:\n                self.error(\"E038c\", got=m.group(1), assumed_spec_version=self.spec_version)\n        elif inventory['type'] != 'https://ocfl.io/' + self.spec_version + '/spec/#inventory':\n            self.error(\"E038a\", expected='https://ocfl.io/' + self.spec_version + '/spec/#inventory', got=inventory['type'])\n        if 'digestAlgorithm' not in inventory:\n            self.error(\"E036c\")\n        elif inventory['digestAlgorithm'] == 'sha512':\n            pass\n        elif self.lax_digests:\n            self.digest_algorithm = inventory['digestAlgorithm']\n        elif inventory['digestAlgorithm'] == 'sha256':\n            self.warning(\"W004\")\n            self.digest_algorithm = inventory['digestAlgorithm']\n        else:\n            self.error(\"E039\", digest_algorithm=inventory['digestAlgorithm'])\n        if 'contentDirectory' in inventory:\n            # Careful only to set self.content_directory if value is safe\n            cd = inventory['contentDirectory']\n            if not isinstance(cd, str) or '/' in cd:\n                self.error(\"E017\")\n            elif cd in ('.', '..'):\n                self.error(\"E018\")\n            else:\n                self.content_directory = cd\n        manifest_files_correct_format = None\n        if 'manifest' not in inventory:\n            self.error(\"E041a\")\n        else:\n            (self.manifest_files, manifest_files_correct_format, self.unnormalized_digests) = self.validate_manifest(inventory['manifest'])\n        digests_used = []\n        if 'versions' not in inventory:\n            self.error(\"E041b\")\n        else:\n            self.all_versions = self.validate_version_sequence(inventory['versions'])\n            digests_used = self.validate_versions(inventory['versions'], self.all_versions, self.unnormalized_digests)\n        if 'head' not in inventory:\n            self.error(\"E036d\")\n        elif len(self.all_versions) > 0:\n            self.head = self.all_versions[-1]\n            if inventory['head'] != self.head:\n                self.error(\"E040\", got=inventory['head'], expected=self.head)\n        if len(self.all_versions) == 0:\n            # Abort tests is we don't have a valid version sequence, otherwise\n            # there will likely be spurious subsequent error reports\n            return\n        if len(self.all_versions) > 0:\n            if manifest_files_correct_format is not None:\n                self.check_content_paths_map_to_versions(manifest_files_correct_format, self.all_versions)\n            if self.manifest_files is not None:\n                self.check_digests_present_and_used(self.manifest_files, digests_used)\n        if 'fixity' in inventory:\n            self.validate_fixity(inventory['fixity'], self.manifest_files)", "signature": "def validate(self, inventory, extract_spec_version=False):", "completion_path": "ocfl/inventory_validator.py"}
{"ce_id": "62b45e145108cfac7f210a09", "namespace": "62b45e145108cfac7f210a09", "namespace_real": "ocfl.inventory_validator.check_digests_present_and_used", "real_proj_path": "zimeon---ocfl-py/", "type": "class", "class_name": "inventory_validator", "function_name": "check_digests_present_and_used", "contexts_above": "\"\"\"OCFL Inventory Validator.\n\nCode to validate the Python representation of an OCFL Inventory\nas read with json.load(). Does not examine anything in storage.\n\"\"\"\nimport re\n\nfrom .digest import digest_regex, normalized_digest\nfrom .validation_logger import ValidationLogger\nfrom .w3c_datetime import str_to_datetime\n\n\ndef get_logical_path_map(inventory, version):\n    \"\"\"Get a map of logical paths in state to files on disk for version in inventory.\n\n    Returns a dictionary: logical_path_in_state -> set(content_files)\n\n    The set of content_files may includes references to duplicate files in\n    later versions than the version being described.\n    \"\"\"\n    state = inventory['versions'][version]['state']\n    manifest = inventory['manifest']\n    file_map = {}\n    for digest in state:\n        if digest in manifest:\n            for file in state[digest]:\n                file_map[file] = set(manifest[digest])\n    return file_map\n\n\nclass InventoryValidator():\n    \"\"\"Class for OCFL Inventory Validator.\"\"\"\n\n    def __init__(self, log=None, where='???',\n                 lax_digests=False, spec_version='1.0'):\n        \"\"\"Initialize OCFL Inventory Validator.\"\"\"\n        self.log = ValidationLogger() if log is None else log\n        self.where = where\n        self.spec_version = spec_version\n        # Object state\n        self.inventory = None\n        self.id = None\n        self.digest_algorithm = 'sha512'\n        self.content_directory = 'content'\n        self.all_versions = []\n        self.manifest_files = None\n        self.unnormalized_digests = None\n        self.head = 'UNKNOWN'\n        # Validation control\n        self.lax_digests = lax_digests\n        # Configuration\n        self.spec_versions_supported = ('1.0', '1.1')\n\n    def error(self, code, **args):\n        \"\"\"Error with added context.\"\"\"\n        self.log.error(code, where=self.where, **args)\n\n    def warning(self, code, **args):\n        \"\"\"Warning with added context.\"\"\"\n        self.log.warning(code, where=self.where, **args)\n\n    def validate(self, inventory, extract_spec_version=False):\n        \"\"\"Validate a given inventory.\n\n        If extract_spec_version is True then will look at the type value to determine\n        the specification version. In the case that there is no type value or it isn't\n        valid, then other tests will be based on the version given in self.spec_version.\n        \"\"\"\n        # Basic structure\n        self.inventory = inventory\n        if 'id' in inventory:\n            iid = inventory['id']\n            if not isinstance(iid, str) or iid == '':\n                self.error(\"E037a\")\n            else:\n                # URI syntax https://www.rfc-editor.org/rfc/rfc3986.html#section-3.1 :\n                # scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n                if not re.match(r'''[a-z][a-z\\d\\+\\-\\.]*:.+''', iid, re.IGNORECASE):\n                    self.warning(\"W005\", id=iid)\n                self.id = iid\n        else:\n            self.error(\"E036a\")\n        if 'type' not in inventory:\n            self.error(\"E036b\")\n        elif not isinstance(inventory['type'], str):\n            self.error(\"E999\")\n        elif extract_spec_version:\n            m = re.match(r'''https://ocfl.io/(\\d+.\\d)/spec/#inventory''', inventory['type'])\n            if not m:\n                self.error('E038b', got=inventory['type'], assumed_spec_version=self.spec_version)\n            elif m.group(1) in self.spec_versions_supported:\n                self.spec_version = m.group(1)\n            else:\n                self.error(\"E038c\", got=m.group(1), assumed_spec_version=self.spec_version)\n        elif inventory['type'] != 'https://ocfl.io/' + self.spec_version + '/spec/#inventory':\n            self.error(\"E038a\", expected='https://ocfl.io/' + self.spec_version + '/spec/#inventory', got=inventory['type'])\n        if 'digestAlgorithm' not in inventory:\n            self.error(\"E036c\")\n        elif inventory['digestAlgorithm'] == 'sha512':\n            pass\n        elif self.lax_digests:\n            self.digest_algorithm = inventory['digestAlgorithm']\n        elif inventory['digestAlgorithm'] == 'sha256':\n            self.warning(\"W004\")\n            self.digest_algorithm = inventory['digestAlgorithm']\n        else:\n            self.error(\"E039\", digest_algorithm=inventory['digestAlgorithm'])\n        if 'contentDirectory' in inventory:\n            # Careful only to set self.content_directory if value is safe\n            cd = inventory['contentDirectory']\n            if not isinstance(cd, str) or '/' in cd:\n                self.error(\"E017\")\n            elif cd in ('.', '..'):\n                self.error(\"E018\")\n            else:\n                self.content_directory = cd\n        manifest_files_correct_format = None\n        if 'manifest' not in inventory:\n            self.error(\"E041a\")\n        else:\n            (self.manifest_files, manifest_files_correct_format, self.unnormalized_digests) = self.validate_manifest(inventory['manifest'])\n        digests_used = []\n        if 'versions' not in inventory:\n            self.error(\"E041b\")\n        else:\n            self.all_versions = self.validate_version_sequence(inventory['versions'])\n            digests_used = self.validate_versions(inventory['versions'], self.all_versions, self.unnormalized_digests)\n        if 'head' not in inventory:\n            self.error(\"E036d\")\n        elif len(self.all_versions) > 0:\n            self.head = self.all_versions[-1]\n            if inventory['head'] != self.head:\n                self.error(\"E040\", got=inventory['head'], expected=self.head)\n        if len(self.all_versions) == 0:\n            # Abort tests is we don't have a valid version sequence, otherwise\n            # there will likely be spurious subsequent error reports\n            return\n        if len(self.all_versions) > 0:\n            if manifest_files_correct_format is not None:\n                self.check_content_paths_map_to_versions(manifest_files_correct_format, self.all_versions)\n            if self.manifest_files is not None:\n                self.check_digests_present_and_used(self.manifest_files, digests_used)\n        if 'fixity' in inventory:\n            self.validate_fixity(inventory['fixity'], self.manifest_files)\n\n    def validate_manifest(self, manifest):\n        \"\"\"Validate manifest block in inventory.\n\n        Returns:\n          * manifest_files - a mapping from file to digest for each file in\n              the manifest\n          * manifest_files_correct_format - a simple list of the manifest file\n              path that passed initial checks. They need to be checked for valid\n              version directories later, when we know what version directories\n              are valid\n          * unnormalized_digests - a set of the original digests in unnormalized\n              form that MUST match exactly the values used in state blocks\n        \"\"\"\n        manifest_files = {}\n        manifest_files_correct_format = []\n        unnormalized_digests = set()\n        manifest_digests = set()\n        if not isinstance(manifest, dict):\n            self.error('E041c')\n        else:\n            content_paths = set()\n            content_directories = set()\n            for digest in manifest:\n                m = re.match(self.digest_regex(), digest)\n                if not m:\n                    self.error('E025a', digest=digest, algorithm=self.digest_algorithm)  # wrong form of digest\n                elif not isinstance(manifest[digest], list):\n                    self.error('E092', digest=digest)  # must have path list value\n                else:\n                    unnormalized_digests.add(digest)\n                    norm_digest = normalized_digest(digest, self.digest_algorithm)\n                    if norm_digest in manifest_digests:\n                        # We have already seen this in different un-normalized form!\n                        self.error(\"E096\", digest=norm_digest)\n                    else:\n                        manifest_digests.add(norm_digest)\n                    for file in manifest[digest]:\n                        manifest_files[file] = norm_digest\n                        if self.check_content_path(file, content_paths, content_directories):\n                            manifest_files_correct_format.append(file)\n            # Check for conflicting content paths\n            for path in content_directories:\n                if path in content_paths:\n                    self.error(\"E101b\", path=path)\n        return manifest_files, manifest_files_correct_format, unnormalized_digests\n\n    def validate_fixity(self, fixity, manifest_files):\n        \"\"\"Validate fixity block in inventory.\n\n        Check the structure of the fixity block and makes sure that only files\n        listed in the manifest are referenced.\n        \"\"\"\n        if not isinstance(fixity, dict):\n            # The value of fixity must be a JSON object. In v1.0 I catch not an object\n            # as part of E056 but this was clarified as E111 in v1.1. The value may\n            # be an empty object in either case\n            self.error('E056a' if self.spec_version == '1.0' else 'E111')\n        else:\n            for digest_algorithm in fixity:\n                known_digest = True\n                try:\n                    regex = digest_regex(digest_algorithm)\n                except ValueError:\n                    if not self.lax_digests:\n                        self.error('E056b', algorithm=self.digest_algorithm)\n                        continue\n                    # Match anything\n                    regex = r'''^.*$'''\n                    known_digest = False\n                fixity_algoritm_block = fixity[digest_algorithm]\n                if not isinstance(fixity_algoritm_block, dict):\n                    self.error('E057a', algorithm=self.digest_algorithm)\n                else:\n                    digests_seen = set()\n                    for digest in fixity_algoritm_block:\n                        m = re.match(regex, digest)\n                        if not m:\n                            self.error('E057b', digest=digest, algorithm=digest_algorithm)  # wrong form of digest\n                        elif not isinstance(fixity_algoritm_block[digest], list):\n                            self.error('E057c', digest=digest, algorithm=digest_algorithm)  # must have path list value\n                        else:\n                            if known_digest:\n                                norm_digest = normalized_digest(digest, digest_algorithm)\n                            else:\n                                norm_digest = digest\n                            if norm_digest in digests_seen:\n                                # We have already seen this in different un-normalized form!\n                                self.error(\"E097\", digest=norm_digest, algorithm=digest_algorithm)\n                            else:\n                                digests_seen.add(norm_digest)\n                            for file in fixity_algoritm_block[digest]:\n                                if file not in manifest_files:\n                                    self.error(\"E057d\", digest=norm_digest, algorithm=digest_algorithm, path=file)\n\n    def validate_version_sequence(self, versions):\n        \"\"\"Validate sequence of version names in versions block in inventory.\n\n        Returns an array of in-sequence version directories that are part\n        of a valid sequences. May exclude other version directory names that are\n        not part of the valid sequence if an error is thrown.\n        \"\"\"\n        all_versions = []\n        if not isinstance(versions, dict):\n            self.error(\"E044\")\n            return all_versions\n        if len(versions) == 0:\n            self.error(\"E008\")\n            return all_versions\n        # Validate version sequence\n        # https://ocfl.io/draft/spec/#version-directories\n        zero_padded = None\n        max_version_num = 999999  # Excessive limit\n        if 'v1' in versions:\n            fmt = 'v%d'\n            zero_padded = False\n            all_versions.append('v1')\n        else:  # Find padding size\n            for n in range(2, 11):\n                fmt = 'v%0' + str(n) + 'd'\n                vkey = fmt % 1\n                if vkey in versions:\n                    all_versions.append(vkey)\n                    zero_padded = n\n                    max_version_num = (10 ** (n - 1)) - 1\n                    break\n            if not zero_padded:\n                self.error(\"E009\")\n                return all_versions\n        if zero_padded:\n            self.warning(\"W001\")\n        # Have v1 and know format, work through to check sequence\n        for n in range(2, max_version_num + 1):\n            v = (fmt % n)\n            if v in versions:\n                all_versions.append(v)\n            else:\n                if len(versions) != (n - 1):\n                    self.error(\"E010\")  # Extra version dirs outside sequence\n                return all_versions\n        # We have now included all possible versions up to the zero padding\n        # size, if there are more versions than this number then we must\n        # have extra that violate the zero-padding rule or are out of\n        # sequence\n        if len(versions) > max_version_num:\n            self.error(\"E011\")\n        return all_versions\n\n    def validate_versions(self, versions, all_versions, unnormalized_digests):\n        \"\"\"Validate versions blocks in inventory.\n\n        Requires as input two things which are assumed to be structurally correct\n        from prior basic validation:\n\n          * versions - which is the JSON object (dict) from the inventory\n          * all_versions - an ordered list of the versions to look at in versions\n                           (all other keys in versions will be ignored)\n\n        Returns a list of digests_used which can then be checked against the\n        manifest.\n        \"\"\"\n        digests_used = []\n        for v in all_versions:\n            version = versions[v]\n            if 'created' not in version:\n                self.error('E048', version=v)  # No created\n            elif not isinstance(versions[v]['created'], str):\n                self.error('E049d', version=v)  # Bad created\n            else:\n                created = versions[v]['created']\n                try:\n                    str_to_datetime(created)  # catch ValueError if fails\n                    if not re.search(r'''(Z|[+-]\\d\\d:\\d\\d)$''', created):  # FIXME - kludge\n                        self.error('E049a', version=v)\n                    if not re.search(r'''T\\d\\d:\\d\\d:\\d\\d''', created):  # FIXME - kludge\n                        self.error('E049b', version=v)\n                except ValueError as e:\n                    self.error('E049c', version=v, description=str(e))\n            if 'state' in version:\n                digests_used += self.validate_state_block(version['state'], version=v, unnormalized_digests=unnormalized_digests)\n            else:\n                self.error('E048c', version=v)\n            if 'message' not in version:\n                self.warning('W007a', version=v)\n            elif not isinstance(version['message'], str):\n                self.error('E094', version=v)\n            if 'user' not in version:\n                self.warning('W007b', version=v)\n            else:\n                user = version['user']\n                if not isinstance(user, dict):\n                    self.error('E054a', version=v)\n                else:\n                    if 'name' not in user or not isinstance(user['name'], str):\n                        self.error('E054b', version=v)\n                    if 'address' not in user:\n                        self.warning('W008', version=v)\n                    elif not isinstance(user['address'], str):\n                        self.error('E054c', version=v)\n                    elif not re.match(r'''\\w{3,6}:''', user['address']):\n                        self.warning('W009', version=v)\n        return digests_used\n\n    def validate_state_block(self, state, version, unnormalized_digests):\n        \"\"\"Validate state block in a version in an inventory.\n\n        The version is used only for error reporting.\n\n        Returns a list of content digests referenced in the state block.\n        \"\"\"\n        digests = []\n        logical_paths = set()\n        logical_directories = set()\n        if not isinstance(state, dict):\n            self.error('E050c', version=version)\n        else:\n            digest_re = re.compile(self.digest_regex())\n            for digest in state:\n                if not digest_re.match(digest):\n                    self.error('E050d', version=version, digest=digest)\n                elif not isinstance(state[digest], list):\n                    self.error('E050e', version=version, digest=digest)\n                else:\n                    for path in state[digest]:\n                        if path in logical_paths:\n                            self.error(\"E095a\", version=version, path=path)\n                        else:\n                            self.check_logical_path(path, version, logical_paths, logical_directories)\n                    if digest not in unnormalized_digests:\n                        # Exact string value must match, not just normalized\n                        self.error(\"E050f\", version=version, digest=digest)\n                    norm_digest = normalized_digest(digest, self.digest_algorithm)\n                    digests.append(norm_digest)\n            # Check for conflicting logical paths\n            for path in logical_directories:\n                if path in logical_paths:\n                    self.error(\"E095b\", version=version, path=path)\n        return digests\n\n    def check_content_paths_map_to_versions(self, manifest_files, all_versions):\n        \"\"\"Check that every content path starts with a valid version.\n\n        The content directory component has already been checked in\n        check_content_path(). We have already tested all paths enough\n        to know that they can be split into at least 2 components.\n        \"\"\"\n        for path in manifest_files:\n            version_dir, dummy_rest = path.split('/', 1)\n            if version_dir not in all_versions:\n                self.error('E042b', path=path)\n", "contexts_below": "    def digest_regex(self):\n         \"\"\"Return regex for validating un-normalized digest format.\"\"\"\n         try:\n             return digest_regex(self.digest_algorithm)\n         except ValueError:\n             if not self.lax_digests:\n                 self.error('E026a', digest=self.digest_algorithm)\n         # Match anything\n         return r'''^.*$'''\n \n     def check_logical_path(self, path, version, logical_paths, logical_directories):\n         \"\"\"Check logical path and accumulate paths/directories for E095b check.\n \n         logical_paths and logical_directories are expected to be sets.\n \n         Only adds good paths to the accumulated paths/directories.\n         \"\"\"\n         if path.startswith('/') or path.endswith('/'):\n             self.error(\"E053\", version=version, path=path)\n         else:\n             elements = path.split('/')\n             for element in elements:\n                 if element in ['.', '..', '']:\n                     self.error(\"E052\", version=version, path=path)\n                     return\n             # Accumulate paths and directories\n             logical_paths.add(path)\n             logical_directories.add('/'.join(elements[0:-1]))\n \n     def check_content_path(self, path, content_paths, content_directories):\n         \"\"\"Check logical path and accumulate paths/directories for E101 check.\n \n         Returns True if valid, else False. Only adds good paths to the\n         accumulated paths/directories. We don't yet know the set of valid\n         version directories so the check here is just for 'v' + digits.\n         \"\"\"\n         if path.startswith('/') or path.endswith('/'):\n             self.error(\"E100\", path=path)\n             return False\n         m = re.match(r'''^(v\\d+/''' + self.content_directory + r''')/(.+)''', path)\n         if not m:\n             self.error(\"E042a\", path=path)\n             return False\n         elements = m.group(2).split('/')\n         for element in elements:\n             if element in ('', '.', '..'):\n                 self.error(\"E099\", path=path)\n                 return False\n         # Accumulate paths and directories if not seen before\n         if path in content_paths:\n             self.error(\"E101a\", path=path)\n             return False\n         content_paths.add(path)\n         content_directories.add('/'.join([m.group(1)] + elements[0:-1]))\n         return True\n \n     def validate_as_prior_version(self, prior):\n         \"\"\"Check that prior is a valid prior version of the current inventory object.\n \n         The input variable prior is also expected to be an InventoryValidator object\n         and both self and prior inventories are assumed to have been checked for\n         internal consistency.\n         \"\"\"\n         # Must have a subset of versions which also checks zero padding format etc.\n         if not set(prior.all_versions) < set(self.all_versions):\n             self.error('E066a', prior_head=prior.head)\n         else:\n             # Check references to files but realize that there might be different\n             # digest algorithms between versions\n             version = 'no-version'\n             for version in prior.all_versions:\n                 # If the digest algorithm is the same then we can make a\n                 # direct check on whether the state blocks match\n                 if prior.digest_algorithm == self.digest_algorithm:\n                     self.compare_states_for_version(prior, version)\n                 # Now check the mappings from state to logical path, which must\n                 # be consistent even if the digestAlgorithm is different between\n                 # versions. Get maps from logical paths to files on disk:\n                 prior_map = get_logical_path_map(prior.inventory, version)\n                 self_map = get_logical_path_map(self.inventory, version)\n                 # Look first for differences in logical paths listed\n                 only_in_prior = prior_map.keys() - self_map.keys()\n                 only_in_self = self_map.keys() - prior_map.keys()\n                 if only_in_prior or only_in_self:\n                     if only_in_prior:\n                         self.error('E066b', version=version, prior_head=prior.head, only_in=prior.head, logical_paths=','.join(only_in_prior))\n                     if only_in_self:\n                         self.error('E066b', version=version, prior_head=prior.head, only_in=self.where, logical_paths=','.join(only_in_self))\n                 else:\n                     # Check them all in details - digests must match\n                     for logical_path, this_map in prior_map.items():\n                         if not this_map.issubset(self_map[logical_path]):\n                             self.error('E066c', version=version, prior_head=prior.head,\n                                        logical_path=logical_path, prior_content=','.join(this_map),\n                                        current_content=','.join(self_map[logical_path]))\n                 # Check metadata\n                 prior_version = prior.inventory['versions'][version]\n                 self_version = self.inventory['versions'][version]\n                 for key in ('created', 'message', 'user'):\n                     if prior_version.get(key) != self_version.get(key):\n                         self.warning('W011', version=version, prior_head=prior.head, key=key)\n \n     def compare_states_for_version(self, prior, version):\n         \"\"\"Compare state blocks for version between self and prior.\n \n         Assumes the same digest algorithm in both, do not call otherwise!\n \n         Looks only for digests that appear in one but not in the other, the code\n         in validate_as_prior_version(..) does a check for whether the same sets\n         of logical files appear and we don't want to duplicate an error message\n         about that.\n \n         While the mapping checks in validate_as_prior_version(..) do all that is\n         necessary to detect an error, the additional errors that may be generated\n         here provide more detailed diagnostics in the case that the digest\n         algorithm is the same across versions being compared.\n         \"\"\"\n         self_state = self.inventory['versions'][version]['state']\n         prior_state = prior.inventory['versions'][version]['state']\n         for digest in set(self_state.keys()).union(prior_state.keys()):\n             if digest not in prior_state:\n                 self.error('E066d', version=version, prior_head=prior.head,\n                            digest=digest, logical_files=', '.join(self_state[digest]))\n             elif digest not in self_state:\n                 self.error('E066e', version=version, prior_head=prior.head,\n                            digest=digest, logical_files=', '.join(prior_state[digest]))\n ", "input_code": "def check_digests_present_and_used(self, manifest_files, digests_used):\n\"\"\"\nCheck all digests in manifest that are needed are present and used.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def check_digests_present_and_used(self, manifest_files, digests_used):\n        \"\"\"Check all digests in manifest that are needed are present and used.\"\"\"\n        in_manifest = set(manifest_files.values())\n        in_state = set(digests_used)\n        not_in_manifest = in_state.difference(in_manifest)\n        if len(not_in_manifest) > 0:\n            self.error(\"E050a\", digests=\", \".join(sorted(not_in_manifest)))\n        not_in_state = in_manifest.difference(in_state)\n        if len(not_in_state) > 0:\n            self.error(\"E107\", digests=\", \".join(sorted(not_in_state)))", "signature": "def check_digests_present_and_used(self, manifest_files, digests_used):", "completion_path": "ocfl/inventory_validator.py"}
{"ce_id": "62b45e165108cfac7f210a16", "namespace": "62b45e165108cfac7f210a16", "namespace_real": "ocfl.inventory_validator.validate_as_prior_version", "real_proj_path": "zimeon---ocfl-py/", "type": "class", "class_name": "inventory_validator", "function_name": "validate_as_prior_version", "contexts_above": "\"\"\"OCFL Inventory Validator.\n\nCode to validate the Python representation of an OCFL Inventory\nas read with json.load(). Does not examine anything in storage.\n\"\"\"\nimport re\n\nfrom .digest import digest_regex, normalized_digest\nfrom .validation_logger import ValidationLogger\nfrom .w3c_datetime import str_to_datetime\n\n\ndef get_logical_path_map(inventory, version):\n    \"\"\"Get a map of logical paths in state to files on disk for version in inventory.\n\n    Returns a dictionary: logical_path_in_state -> set(content_files)\n\n    The set of content_files may includes references to duplicate files in\n    later versions than the version being described.\n    \"\"\"\n    state = inventory['versions'][version]['state']\n    manifest = inventory['manifest']\n    file_map = {}\n    for digest in state:\n        if digest in manifest:\n            for file in state[digest]:\n                file_map[file] = set(manifest[digest])\n    return file_map\n\n\nclass InventoryValidator():\n    \"\"\"Class for OCFL Inventory Validator.\"\"\"\n\n    def __init__(self, log=None, where='???',\n                 lax_digests=False, spec_version='1.0'):\n        \"\"\"Initialize OCFL Inventory Validator.\"\"\"\n        self.log = ValidationLogger() if log is None else log\n        self.where = where\n        self.spec_version = spec_version\n        # Object state\n        self.inventory = None\n        self.id = None\n        self.digest_algorithm = 'sha512'\n        self.content_directory = 'content'\n        self.all_versions = []\n        self.manifest_files = None\n        self.unnormalized_digests = None\n        self.head = 'UNKNOWN'\n        # Validation control\n        self.lax_digests = lax_digests\n        # Configuration\n        self.spec_versions_supported = ('1.0', '1.1')\n\n    def error(self, code, **args):\n        \"\"\"Error with added context.\"\"\"\n        self.log.error(code, where=self.where, **args)\n\n    def warning(self, code, **args):\n        \"\"\"Warning with added context.\"\"\"\n        self.log.warning(code, where=self.where, **args)\n\n    def validate(self, inventory, extract_spec_version=False):\n        \"\"\"Validate a given inventory.\n\n        If extract_spec_version is True then will look at the type value to determine\n        the specification version. In the case that there is no type value or it isn't\n        valid, then other tests will be based on the version given in self.spec_version.\n        \"\"\"\n        # Basic structure\n        self.inventory = inventory\n        if 'id' in inventory:\n            iid = inventory['id']\n            if not isinstance(iid, str) or iid == '':\n                self.error(\"E037a\")\n            else:\n                # URI syntax https://www.rfc-editor.org/rfc/rfc3986.html#section-3.1 :\n                # scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n                if not re.match(r'''[a-z][a-z\\d\\+\\-\\.]*:.+''', iid, re.IGNORECASE):\n                    self.warning(\"W005\", id=iid)\n                self.id = iid\n        else:\n            self.error(\"E036a\")\n        if 'type' not in inventory:\n            self.error(\"E036b\")\n        elif not isinstance(inventory['type'], str):\n            self.error(\"E999\")\n        elif extract_spec_version:\n            m = re.match(r'''https://ocfl.io/(\\d+.\\d)/spec/#inventory''', inventory['type'])\n            if not m:\n                self.error('E038b', got=inventory['type'], assumed_spec_version=self.spec_version)\n            elif m.group(1) in self.spec_versions_supported:\n                self.spec_version = m.group(1)\n            else:\n                self.error(\"E038c\", got=m.group(1), assumed_spec_version=self.spec_version)\n        elif inventory['type'] != 'https://ocfl.io/' + self.spec_version + '/spec/#inventory':\n            self.error(\"E038a\", expected='https://ocfl.io/' + self.spec_version + '/spec/#inventory', got=inventory['type'])\n        if 'digestAlgorithm' not in inventory:\n            self.error(\"E036c\")\n        elif inventory['digestAlgorithm'] == 'sha512':\n            pass\n        elif self.lax_digests:\n            self.digest_algorithm = inventory['digestAlgorithm']\n        elif inventory['digestAlgorithm'] == 'sha256':\n            self.warning(\"W004\")\n            self.digest_algorithm = inventory['digestAlgorithm']\n        else:\n            self.error(\"E039\", digest_algorithm=inventory['digestAlgorithm'])\n        if 'contentDirectory' in inventory:\n            # Careful only to set self.content_directory if value is safe\n            cd = inventory['contentDirectory']\n            if not isinstance(cd, str) or '/' in cd:\n                self.error(\"E017\")\n            elif cd in ('.', '..'):\n                self.error(\"E018\")\n            else:\n                self.content_directory = cd\n        manifest_files_correct_format = None\n        if 'manifest' not in inventory:\n            self.error(\"E041a\")\n        else:\n            (self.manifest_files, manifest_files_correct_format, self.unnormalized_digests) = self.validate_manifest(inventory['manifest'])\n        digests_used = []\n        if 'versions' not in inventory:\n            self.error(\"E041b\")\n        else:\n            self.all_versions = self.validate_version_sequence(inventory['versions'])\n            digests_used = self.validate_versions(inventory['versions'], self.all_versions, self.unnormalized_digests)\n        if 'head' not in inventory:\n            self.error(\"E036d\")\n        elif len(self.all_versions) > 0:\n            self.head = self.all_versions[-1]\n            if inventory['head'] != self.head:\n                self.error(\"E040\", got=inventory['head'], expected=self.head)\n        if len(self.all_versions) == 0:\n            # Abort tests is we don't have a valid version sequence, otherwise\n            # there will likely be spurious subsequent error reports\n            return\n        if len(self.all_versions) > 0:\n            if manifest_files_correct_format is not None:\n                self.check_content_paths_map_to_versions(manifest_files_correct_format, self.all_versions)\n            if self.manifest_files is not None:\n                self.check_digests_present_and_used(self.manifest_files, digests_used)\n        if 'fixity' in inventory:\n            self.validate_fixity(inventory['fixity'], self.manifest_files)\n\n    def validate_manifest(self, manifest):\n        \"\"\"Validate manifest block in inventory.\n\n        Returns:\n          * manifest_files - a mapping from file to digest for each file in\n              the manifest\n          * manifest_files_correct_format - a simple list of the manifest file\n              path that passed initial checks. They need to be checked for valid\n              version directories later, when we know what version directories\n              are valid\n          * unnormalized_digests - a set of the original digests in unnormalized\n              form that MUST match exactly the values used in state blocks\n        \"\"\"\n        manifest_files = {}\n        manifest_files_correct_format = []\n        unnormalized_digests = set()\n        manifest_digests = set()\n        if not isinstance(manifest, dict):\n            self.error('E041c')\n        else:\n            content_paths = set()\n            content_directories = set()\n            for digest in manifest:\n                m = re.match(self.digest_regex(), digest)\n                if not m:\n                    self.error('E025a', digest=digest, algorithm=self.digest_algorithm)  # wrong form of digest\n                elif not isinstance(manifest[digest], list):\n                    self.error('E092', digest=digest)  # must have path list value\n                else:\n                    unnormalized_digests.add(digest)\n                    norm_digest = normalized_digest(digest, self.digest_algorithm)\n                    if norm_digest in manifest_digests:\n                        # We have already seen this in different un-normalized form!\n                        self.error(\"E096\", digest=norm_digest)\n                    else:\n                        manifest_digests.add(norm_digest)\n                    for file in manifest[digest]:\n                        manifest_files[file] = norm_digest\n                        if self.check_content_path(file, content_paths, content_directories):\n                            manifest_files_correct_format.append(file)\n            # Check for conflicting content paths\n            for path in content_directories:\n                if path in content_paths:\n                    self.error(\"E101b\", path=path)\n        return manifest_files, manifest_files_correct_format, unnormalized_digests\n\n    def validate_fixity(self, fixity, manifest_files):\n        \"\"\"Validate fixity block in inventory.\n\n        Check the structure of the fixity block and makes sure that only files\n        listed in the manifest are referenced.\n        \"\"\"\n        if not isinstance(fixity, dict):\n            # The value of fixity must be a JSON object. In v1.0 I catch not an object\n            # as part of E056 but this was clarified as E111 in v1.1. The value may\n            # be an empty object in either case\n            self.error('E056a' if self.spec_version == '1.0' else 'E111')\n        else:\n            for digest_algorithm in fixity:\n                known_digest = True\n                try:\n                    regex = digest_regex(digest_algorithm)\n                except ValueError:\n                    if not self.lax_digests:\n                        self.error('E056b', algorithm=self.digest_algorithm)\n                        continue\n                    # Match anything\n                    regex = r'''^.*$'''\n                    known_digest = False\n                fixity_algoritm_block = fixity[digest_algorithm]\n                if not isinstance(fixity_algoritm_block, dict):\n                    self.error('E057a', algorithm=self.digest_algorithm)\n                else:\n                    digests_seen = set()\n                    for digest in fixity_algoritm_block:\n                        m = re.match(regex, digest)\n                        if not m:\n                            self.error('E057b', digest=digest, algorithm=digest_algorithm)  # wrong form of digest\n                        elif not isinstance(fixity_algoritm_block[digest], list):\n                            self.error('E057c', digest=digest, algorithm=digest_algorithm)  # must have path list value\n                        else:\n                            if known_digest:\n                                norm_digest = normalized_digest(digest, digest_algorithm)\n                            else:\n                                norm_digest = digest\n                            if norm_digest in digests_seen:\n                                # We have already seen this in different un-normalized form!\n                                self.error(\"E097\", digest=norm_digest, algorithm=digest_algorithm)\n                            else:\n                                digests_seen.add(norm_digest)\n                            for file in fixity_algoritm_block[digest]:\n                                if file not in manifest_files:\n                                    self.error(\"E057d\", digest=norm_digest, algorithm=digest_algorithm, path=file)\n\n    def validate_version_sequence(self, versions):\n        \"\"\"Validate sequence of version names in versions block in inventory.\n\n        Returns an array of in-sequence version directories that are part\n        of a valid sequences. May exclude other version directory names that are\n        not part of the valid sequence if an error is thrown.\n        \"\"\"\n        all_versions = []\n        if not isinstance(versions, dict):\n            self.error(\"E044\")\n            return all_versions\n        if len(versions) == 0:\n            self.error(\"E008\")\n            return all_versions\n        # Validate version sequence\n        # https://ocfl.io/draft/spec/#version-directories\n        zero_padded = None\n        max_version_num = 999999  # Excessive limit\n        if 'v1' in versions:\n            fmt = 'v%d'\n            zero_padded = False\n            all_versions.append('v1')\n        else:  # Find padding size\n            for n in range(2, 11):\n                fmt = 'v%0' + str(n) + 'd'\n                vkey = fmt % 1\n                if vkey in versions:\n                    all_versions.append(vkey)\n                    zero_padded = n\n                    max_version_num = (10 ** (n - 1)) - 1\n                    break\n            if not zero_padded:\n                self.error(\"E009\")\n                return all_versions\n        if zero_padded:\n            self.warning(\"W001\")\n        # Have v1 and know format, work through to check sequence\n        for n in range(2, max_version_num + 1):\n            v = (fmt % n)\n            if v in versions:\n                all_versions.append(v)\n            else:\n                if len(versions) != (n - 1):\n                    self.error(\"E010\")  # Extra version dirs outside sequence\n                return all_versions\n        # We have now included all possible versions up to the zero padding\n        # size, if there are more versions than this number then we must\n        # have extra that violate the zero-padding rule or are out of\n        # sequence\n        if len(versions) > max_version_num:\n            self.error(\"E011\")\n        return all_versions\n\n    def validate_versions(self, versions, all_versions, unnormalized_digests):\n        \"\"\"Validate versions blocks in inventory.\n\n        Requires as input two things which are assumed to be structurally correct\n        from prior basic validation:\n\n          * versions - which is the JSON object (dict) from the inventory\n          * all_versions - an ordered list of the versions to look at in versions\n                           (all other keys in versions will be ignored)\n\n        Returns a list of digests_used which can then be checked against the\n        manifest.\n        \"\"\"\n        digests_used = []\n        for v in all_versions:\n            version = versions[v]\n            if 'created' not in version:\n                self.error('E048', version=v)  # No created\n            elif not isinstance(versions[v]['created'], str):\n                self.error('E049d', version=v)  # Bad created\n            else:\n                created = versions[v]['created']\n                try:\n                    str_to_datetime(created)  # catch ValueError if fails\n                    if not re.search(r'''(Z|[+-]\\d\\d:\\d\\d)$''', created):  # FIXME - kludge\n                        self.error('E049a', version=v)\n                    if not re.search(r'''T\\d\\d:\\d\\d:\\d\\d''', created):  # FIXME - kludge\n                        self.error('E049b', version=v)\n                except ValueError as e:\n                    self.error('E049c', version=v, description=str(e))\n            if 'state' in version:\n                digests_used += self.validate_state_block(version['state'], version=v, unnormalized_digests=unnormalized_digests)\n            else:\n                self.error('E048c', version=v)\n            if 'message' not in version:\n                self.warning('W007a', version=v)\n            elif not isinstance(version['message'], str):\n                self.error('E094', version=v)\n            if 'user' not in version:\n                self.warning('W007b', version=v)\n            else:\n                user = version['user']\n                if not isinstance(user, dict):\n                    self.error('E054a', version=v)\n                else:\n                    if 'name' not in user or not isinstance(user['name'], str):\n                        self.error('E054b', version=v)\n                    if 'address' not in user:\n                        self.warning('W008', version=v)\n                    elif not isinstance(user['address'], str):\n                        self.error('E054c', version=v)\n                    elif not re.match(r'''\\w{3,6}:''', user['address']):\n                        self.warning('W009', version=v)\n        return digests_used\n\n    def validate_state_block(self, state, version, unnormalized_digests):\n        \"\"\"Validate state block in a version in an inventory.\n\n        The version is used only for error reporting.\n\n        Returns a list of content digests referenced in the state block.\n        \"\"\"\n        digests = []\n        logical_paths = set()\n        logical_directories = set()\n        if not isinstance(state, dict):\n            self.error('E050c', version=version)\n        else:\n            digest_re = re.compile(self.digest_regex())\n            for digest in state:\n                if not digest_re.match(digest):\n                    self.error('E050d', version=version, digest=digest)\n                elif not isinstance(state[digest], list):\n                    self.error('E050e', version=version, digest=digest)\n                else:\n                    for path in state[digest]:\n                        if path in logical_paths:\n                            self.error(\"E095a\", version=version, path=path)\n                        else:\n                            self.check_logical_path(path, version, logical_paths, logical_directories)\n                    if digest not in unnormalized_digests:\n                        # Exact string value must match, not just normalized\n                        self.error(\"E050f\", version=version, digest=digest)\n                    norm_digest = normalized_digest(digest, self.digest_algorithm)\n                    digests.append(norm_digest)\n            # Check for conflicting logical paths\n            for path in logical_directories:\n                if path in logical_paths:\n                    self.error(\"E095b\", version=version, path=path)\n        return digests\n\n    def check_content_paths_map_to_versions(self, manifest_files, all_versions):\n        \"\"\"Check that every content path starts with a valid version.\n\n        The content directory component has already been checked in\n        check_content_path(). We have already tested all paths enough\n        to know that they can be split into at least 2 components.\n        \"\"\"\n        for path in manifest_files:\n            version_dir, dummy_rest = path.split('/', 1)\n            if version_dir not in all_versions:\n                self.error('E042b', path=path)\n\n    def check_digests_present_and_used(self, manifest_files, digests_used):\n        \"\"\"Check all digests in manifest that are needed are present and used.\"\"\"\n        in_manifest = set(manifest_files.values())\n        in_state = set(digests_used)\n        not_in_manifest = in_state.difference(in_manifest)\n        if len(not_in_manifest) > 0:\n            self.error(\"E050a\", digests=\", \".join(sorted(not_in_manifest)))\n        not_in_state = in_manifest.difference(in_state)\n        if len(not_in_state) > 0:\n            self.error(\"E107\", digests=\", \".join(sorted(not_in_state)))\n\n    def digest_regex(self):\n        \"\"\"Return regex for validating un-normalized digest format.\"\"\"\n        try:\n            return digest_regex(self.digest_algorithm)\n        except ValueError:\n            if not self.lax_digests:\n                self.error('E026a', digest=self.digest_algorithm)\n        # Match anything\n        return r'''^.*$'''\n\n    def check_logical_path(self, path, version, logical_paths, logical_directories):\n        \"\"\"Check logical path and accumulate paths/directories for E095b check.\n\n        logical_paths and logical_directories are expected to be sets.\n\n        Only adds good paths to the accumulated paths/directories.\n        \"\"\"\n        if path.startswith('/') or path.endswith('/'):\n            self.error(\"E053\", version=version, path=path)\n        else:\n            elements = path.split('/')\n            for element in elements:\n                if element in ['.', '..', '']:\n                    self.error(\"E052\", version=version, path=path)\n                    return\n            # Accumulate paths and directories\n            logical_paths.add(path)\n            logical_directories.add('/'.join(elements[0:-1]))\n\n    def check_content_path(self, path, content_paths, content_directories):\n        \"\"\"Check logical path and accumulate paths/directories for E101 check.\n\n        Returns True if valid, else False. Only adds good paths to the\n        accumulated paths/directories. We don't yet know the set of valid\n        version directories so the check here is just for 'v' + digits.\n        \"\"\"\n        if path.startswith('/') or path.endswith('/'):\n            self.error(\"E100\", path=path)\n            return False\n        m = re.match(r'''^(v\\d+/''' + self.content_directory + r''')/(.+)''', path)\n        if not m:\n            self.error(\"E042a\", path=path)\n            return False\n        elements = m.group(2).split('/')\n        for element in elements:\n            if element in ('', '.', '..'):\n                self.error(\"E099\", path=path)\n                return False\n        # Accumulate paths and directories if not seen before\n        if path in content_paths:\n            self.error(\"E101a\", path=path)\n            return False\n        content_paths.add(path)\n        content_directories.add('/'.join([m.group(1)] + elements[0:-1]))\n        return True\n", "contexts_below": "    def compare_states_for_version(self, prior, version):\n         \"\"\"Compare state blocks for version between self and prior.\n \n         Assumes the same digest algorithm in both, do not call otherwise!\n \n         Looks only for digests that appear in one but not in the other, the code\n         in validate_as_prior_version(..) does a check for whether the same sets\n         of logical files appear and we don't want to duplicate an error message\n         about that.\n \n         While the mapping checks in validate_as_prior_version(..) do all that is\n         necessary to detect an error, the additional errors that may be generated\n         here provide more detailed diagnostics in the case that the digest\n         algorithm is the same across versions being compared.\n         \"\"\"\n         self_state = self.inventory['versions'][version]['state']\n         prior_state = prior.inventory['versions'][version]['state']\n         for digest in set(self_state.keys()).union(prior_state.keys()):\n             if digest not in prior_state:\n                 self.error('E066d', version=version, prior_head=prior.head,\n                            digest=digest, logical_files=', '.join(self_state[digest]))\n             elif digest not in self_state:\n                 self.error('E066e', version=version, prior_head=prior.head,\n                            digest=digest, logical_files=', '.join(prior_state[digest]))\n ", "input_code": "def validate_as_prior_version(self, prior):\n\"\"\"\nCheck that prior is a valid prior version of the current inventory object.\n\nThe input variable prior is also expected to be an InventoryValidator object\nand both self and prior inventories are assumed to have been checked for\ninternal consistency.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def validate_as_prior_version(self, prior):\n        \"\"\"Check that prior is a valid prior version of the current inventory object.\n\n        The input variable prior is also expected to be an InventoryValidator object\n        and both self and prior inventories are assumed to have been checked for\n        internal consistency.\n        \"\"\"\n        # Must have a subset of versions which also checks zero padding format etc.\n        if not set(prior.all_versions) < set(self.all_versions):\n            self.error('E066a', prior_head=prior.head)\n        else:\n            # Check references to files but realize that there might be different\n            # digest algorithms between versions\n            version = 'no-version'\n            for version in prior.all_versions:\n                # If the digest algorithm is the same then we can make a\n                # direct check on whether the state blocks match\n                if prior.digest_algorithm == self.digest_algorithm:\n                    self.compare_states_for_version(prior, version)\n                # Now check the mappings from state to logical path, which must\n                # be consistent even if the digestAlgorithm is different between\n                # versions. Get maps from logical paths to files on disk:\n                prior_map = get_logical_path_map(prior.inventory, version)\n                self_map = get_logical_path_map(self.inventory, version)\n                # Look first for differences in logical paths listed\n                only_in_prior = prior_map.keys() - self_map.keys()\n                only_in_self = self_map.keys() - prior_map.keys()\n                if only_in_prior or only_in_self:\n                    if only_in_prior:\n                        self.error('E066b', version=version, prior_head=prior.head, only_in=prior.head, logical_paths=','.join(only_in_prior))\n                    if only_in_self:\n                        self.error('E066b', version=version, prior_head=prior.head, only_in=self.where, logical_paths=','.join(only_in_self))\n                else:\n                    # Check them all in details - digests must match\n                    for logical_path, this_map in prior_map.items():\n                        if not this_map.issubset(self_map[logical_path]):\n                            self.error('E066c', version=version, prior_head=prior.head,\n                                       logical_path=logical_path, prior_content=','.join(this_map),\n                                       current_content=','.join(self_map[logical_path]))\n                # Check metadata\n                prior_version = prior.inventory['versions'][version]\n                self_version = self.inventory['versions'][version]\n                for key in ('created', 'message', 'user'):\n                    if prior_version.get(key) != self_version.get(key):\n                        self.warning('W011', version=version, prior_head=prior.head, key=key)", "signature": "def validate_as_prior_version(self, prior):", "completion_path": "ocfl/inventory_validator.py"}
{"ce_id": "62b45e165108cfac7f210a17", "namespace": "62b45e165108cfac7f210a17", "namespace_real": "ocfl.inventory_validator.get_logical_path_map", "real_proj_path": "zimeon---ocfl-py/", "type": "function", "class_name": null, "function_name": "get_logical_path_map", "contexts_above": "\"\"\"OCFL Inventory Validator.\n\nCode to validate the Python representation of an OCFL Inventory\nas read with json.load(). Does not examine anything in storage.\n\"\"\"\nimport re\n\nfrom .digest import digest_regex, normalized_digest\nfrom .validation_logger import ValidationLogger\nfrom .w3c_datetime import str_to_datetime\n\n", "contexts_below": "\n class InventoryValidator():\n     \"\"\"Class for OCFL Inventory Validator.\"\"\"\n \n     def __init__(self, log=None, where='???',\n                  lax_digests=False, spec_version='1.0'):\n         \"\"\"Initialize OCFL Inventory Validator.\"\"\"\n         self.log = ValidationLogger() if log is None else log\n         self.where = where\n         self.spec_version = spec_version\n         # Object state\n         self.inventory = None\n         self.id = None\n         self.digest_algorithm = 'sha512'\n         self.content_directory = 'content'\n         self.all_versions = []\n         self.manifest_files = None\n         self.unnormalized_digests = None\n         self.head = 'UNKNOWN'\n         # Validation control\n         self.lax_digests = lax_digests\n         # Configuration\n         self.spec_versions_supported = ('1.0', '1.1')\n \n     def error(self, code, **args):\n         \"\"\"Error with added context.\"\"\"\n         self.log.error(code, where=self.where, **args)\n \n     def warning(self, code, **args):\n         \"\"\"Warning with added context.\"\"\"\n         self.log.warning(code, where=self.where, **args)\n \n     def validate(self, inventory, extract_spec_version=False):\n         \"\"\"Validate a given inventory.\n \n         If extract_spec_version is True then will look at the type value to determine\n         the specification version. In the case that there is no type value or it isn't\n         valid, then other tests will be based on the version given in self.spec_version.\n         \"\"\"\n         # Basic structure\n         self.inventory = inventory\n         if 'id' in inventory:\n             iid = inventory['id']\n             if not isinstance(iid, str) or iid == '':\n                 self.error(\"E037a\")\n             else:\n                 # URI syntax https://www.rfc-editor.org/rfc/rfc3986.html#section-3.1 :\n                 # scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n                 if not re.match(r'''[a-z][a-z\\d\\+\\-\\.]*:.+''', iid, re.IGNORECASE):\n                     self.warning(\"W005\", id=iid)\n                 self.id = iid\n         else:\n             self.error(\"E036a\")\n         if 'type' not in inventory:\n             self.error(\"E036b\")\n         elif not isinstance(inventory['type'], str):\n             self.error(\"E999\")\n         elif extract_spec_version:\n             m = re.match(r'''https://ocfl.io/(\\d+.\\d)/spec/#inventory''', inventory['type'])\n             if not m:\n                 self.error('E038b', got=inventory['type'], assumed_spec_version=self.spec_version)\n             elif m.group(1) in self.spec_versions_supported:\n                 self.spec_version = m.group(1)\n             else:\n                 self.error(\"E038c\", got=m.group(1), assumed_spec_version=self.spec_version)\n         elif inventory['type'] != 'https://ocfl.io/' + self.spec_version + '/spec/#inventory':\n             self.error(\"E038a\", expected='https://ocfl.io/' + self.spec_version + '/spec/#inventory', got=inventory['type'])\n         if 'digestAlgorithm' not in inventory:\n             self.error(\"E036c\")\n         elif inventory['digestAlgorithm'] == 'sha512':\n             pass\n         elif self.lax_digests:\n             self.digest_algorithm = inventory['digestAlgorithm']\n         elif inventory['digestAlgorithm'] == 'sha256':\n             self.warning(\"W004\")\n             self.digest_algorithm = inventory['digestAlgorithm']\n         else:\n             self.error(\"E039\", digest_algorithm=inventory['digestAlgorithm'])\n         if 'contentDirectory' in inventory:\n             # Careful only to set self.content_directory if value is safe\n             cd = inventory['contentDirectory']\n             if not isinstance(cd, str) or '/' in cd:\n                 self.error(\"E017\")\n             elif cd in ('.', '..'):\n                 self.error(\"E018\")\n             else:\n                 self.content_directory = cd\n         manifest_files_correct_format = None\n         if 'manifest' not in inventory:\n             self.error(\"E041a\")\n         else:\n             (self.manifest_files, manifest_files_correct_format, self.unnormalized_digests) = self.validate_manifest(inventory['manifest'])\n         digests_used = []\n         if 'versions' not in inventory:\n             self.error(\"E041b\")\n         else:\n             self.all_versions = self.validate_version_sequence(inventory['versions'])\n             digests_used = self.validate_versions(inventory['versions'], self.all_versions, self.unnormalized_digests)\n         if 'head' not in inventory:\n             self.error(\"E036d\")\n         elif len(self.all_versions) > 0:\n             self.head = self.all_versions[-1]\n             if inventory['head'] != self.head:\n                 self.error(\"E040\", got=inventory['head'], expected=self.head)\n         if len(self.all_versions) == 0:\n             # Abort tests is we don't have a valid version sequence, otherwise\n             # there will likely be spurious subsequent error reports\n             return\n         if len(self.all_versions) > 0:\n             if manifest_files_correct_format is not None:\n                 self.check_content_paths_map_to_versions(manifest_files_correct_format, self.all_versions)\n             if self.manifest_files is not None:\n                 self.check_digests_present_and_used(self.manifest_files, digests_used)\n         if 'fixity' in inventory:\n             self.validate_fixity(inventory['fixity'], self.manifest_files)\n \n     def validate_manifest(self, manifest):\n         \"\"\"Validate manifest block in inventory.\n \n         Returns:\n           * manifest_files - a mapping from file to digest for each file in\n               the manifest\n           * manifest_files_correct_format - a simple list of the manifest file\n               path that passed initial checks. They need to be checked for valid\n               version directories later, when we know what version directories\n               are valid\n           * unnormalized_digests - a set of the original digests in unnormalized\n               form that MUST match exactly the values used in state blocks\n         \"\"\"\n         manifest_files = {}\n         manifest_files_correct_format = []\n         unnormalized_digests = set()\n         manifest_digests = set()\n         if not isinstance(manifest, dict):\n             self.error('E041c')\n         else:\n             content_paths = set()\n             content_directories = set()\n             for digest in manifest:\n                 m = re.match(self.digest_regex(), digest)\n                 if not m:\n                     self.error('E025a', digest=digest, algorithm=self.digest_algorithm)  # wrong form of digest\n                 elif not isinstance(manifest[digest], list):\n                     self.error('E092', digest=digest)  # must have path list value\n                 else:\n                     unnormalized_digests.add(digest)\n                     norm_digest = normalized_digest(digest, self.digest_algorithm)\n                     if norm_digest in manifest_digests:\n                         # We have already seen this in different un-normalized form!\n                         self.error(\"E096\", digest=norm_digest)\n                     else:\n                         manifest_digests.add(norm_digest)\n                     for file in manifest[digest]:\n                         manifest_files[file] = norm_digest\n                         if self.check_content_path(file, content_paths, content_directories):\n                             manifest_files_correct_format.append(file)\n             # Check for conflicting content paths\n             for path in content_directories:\n                 if path in content_paths:\n                     self.error(\"E101b\", path=path)\n         return manifest_files, manifest_files_correct_format, unnormalized_digests\n \n     def validate_fixity(self, fixity, manifest_files):\n         \"\"\"Validate fixity block in inventory.\n \n         Check the structure of the fixity block and makes sure that only files\n         listed in the manifest are referenced.\n         \"\"\"\n         if not isinstance(fixity, dict):\n             # The value of fixity must be a JSON object. In v1.0 I catch not an object\n             # as part of E056 but this was clarified as E111 in v1.1. The value may\n             # be an empty object in either case\n             self.error('E056a' if self.spec_version == '1.0' else 'E111')\n         else:\n             for digest_algorithm in fixity:\n                 known_digest = True\n                 try:\n                     regex = digest_regex(digest_algorithm)\n                 except ValueError:\n                     if not self.lax_digests:\n                         self.error('E056b', algorithm=self.digest_algorithm)\n                         continue\n                     # Match anything\n                     regex = r'''^.*$'''\n                     known_digest = False\n                 fixity_algoritm_block = fixity[digest_algorithm]\n                 if not isinstance(fixity_algoritm_block, dict):\n                     self.error('E057a', algorithm=self.digest_algorithm)\n                 else:\n                     digests_seen = set()\n                     for digest in fixity_algoritm_block:\n                         m = re.match(regex, digest)\n                         if not m:\n                             self.error('E057b', digest=digest, algorithm=digest_algorithm)  # wrong form of digest\n                         elif not isinstance(fixity_algoritm_block[digest], list):\n                             self.error('E057c', digest=digest, algorithm=digest_algorithm)  # must have path list value\n                         else:\n                             if known_digest:\n                                 norm_digest = normalized_digest(digest, digest_algorithm)\n                             else:\n                                 norm_digest = digest\n                             if norm_digest in digests_seen:\n                                 # We have already seen this in different un-normalized form!\n                                 self.error(\"E097\", digest=norm_digest, algorithm=digest_algorithm)\n                             else:\n                                 digests_seen.add(norm_digest)\n                             for file in fixity_algoritm_block[digest]:\n                                 if file not in manifest_files:\n                                     self.error(\"E057d\", digest=norm_digest, algorithm=digest_algorithm, path=file)\n \n     def validate_version_sequence(self, versions):\n         \"\"\"Validate sequence of version names in versions block in inventory.\n \n         Returns an array of in-sequence version directories that are part\n         of a valid sequences. May exclude other version directory names that are\n         not part of the valid sequence if an error is thrown.\n         \"\"\"\n         all_versions = []\n         if not isinstance(versions, dict):\n             self.error(\"E044\")\n             return all_versions\n         if len(versions) == 0:\n             self.error(\"E008\")\n             return all_versions\n         # Validate version sequence\n         # https://ocfl.io/draft/spec/#version-directories\n         zero_padded = None\n         max_version_num = 999999  # Excessive limit\n         if 'v1' in versions:\n             fmt = 'v%d'\n             zero_padded = False\n             all_versions.append('v1')\n         else:  # Find padding size\n             for n in range(2, 11):\n                 fmt = 'v%0' + str(n) + 'd'\n                 vkey = fmt % 1\n                 if vkey in versions:\n                     all_versions.append(vkey)\n                     zero_padded = n\n                     max_version_num = (10 ** (n - 1)) - 1\n                     break\n             if not zero_padded:\n                 self.error(\"E009\")\n                 return all_versions\n         if zero_padded:\n             self.warning(\"W001\")\n         # Have v1 and know format, work through to check sequence\n         for n in range(2, max_version_num + 1):\n             v = (fmt % n)\n             if v in versions:\n                 all_versions.append(v)\n             else:\n                 if len(versions) != (n - 1):\n                     self.error(\"E010\")  # Extra version dirs outside sequence\n                 return all_versions\n         # We have now included all possible versions up to the zero padding\n         # size, if there are more versions than this number then we must\n         # have extra that violate the zero-padding rule or are out of\n         # sequence\n         if len(versions) > max_version_num:\n             self.error(\"E011\")\n         return all_versions\n \n     def validate_versions(self, versions, all_versions, unnormalized_digests):\n         \"\"\"Validate versions blocks in inventory.\n \n         Requires as input two things which are assumed to be structurally correct\n         from prior basic validation:\n \n           * versions - which is the JSON object (dict) from the inventory\n           * all_versions - an ordered list of the versions to look at in versions\n                            (all other keys in versions will be ignored)\n \n         Returns a list of digests_used which can then be checked against the\n         manifest.\n         \"\"\"\n         digests_used = []\n         for v in all_versions:\n             version = versions[v]\n             if 'created' not in version:\n                 self.error('E048', version=v)  # No created\n             elif not isinstance(versions[v]['created'], str):\n                 self.error('E049d', version=v)  # Bad created\n             else:\n                 created = versions[v]['created']\n                 try:\n                     str_to_datetime(created)  # catch ValueError if fails\n                     if not re.search(r'''(Z|[+-]\\d\\d:\\d\\d)$''', created):  # FIXME - kludge\n                         self.error('E049a', version=v)\n                     if not re.search(r'''T\\d\\d:\\d\\d:\\d\\d''', created):  # FIXME - kludge\n                         self.error('E049b', version=v)\n                 except ValueError as e:\n                     self.error('E049c', version=v, description=str(e))\n             if 'state' in version:\n                 digests_used += self.validate_state_block(version['state'], version=v, unnormalized_digests=unnormalized_digests)\n             else:\n                 self.error('E048c', version=v)\n             if 'message' not in version:\n                 self.warning('W007a', version=v)\n             elif not isinstance(version['message'], str):\n                 self.error('E094', version=v)\n             if 'user' not in version:\n                 self.warning('W007b', version=v)\n             else:\n                 user = version['user']\n                 if not isinstance(user, dict):\n                     self.error('E054a', version=v)\n                 else:\n                     if 'name' not in user or not isinstance(user['name'], str):\n                         self.error('E054b', version=v)\n                     if 'address' not in user:\n                         self.warning('W008', version=v)\n                     elif not isinstance(user['address'], str):\n                         self.error('E054c', version=v)\n                     elif not re.match(r'''\\w{3,6}:''', user['address']):\n                         self.warning('W009', version=v)\n         return digests_used\n \n     def validate_state_block(self, state, version, unnormalized_digests):\n         \"\"\"Validate state block in a version in an inventory.\n \n         The version is used only for error reporting.\n \n         Returns a list of content digests referenced in the state block.\n         \"\"\"\n         digests = []\n         logical_paths = set()\n         logical_directories = set()\n         if not isinstance(state, dict):\n             self.error('E050c', version=version)\n         else:\n             digest_re = re.compile(self.digest_regex())\n             for digest in state:\n                 if not digest_re.match(digest):\n                     self.error('E050d', version=version, digest=digest)\n                 elif not isinstance(state[digest], list):\n                     self.error('E050e', version=version, digest=digest)\n                 else:\n                     for path in state[digest]:\n                         if path in logical_paths:\n                             self.error(\"E095a\", version=version, path=path)\n                         else:\n                             self.check_logical_path(path, version, logical_paths, logical_directories)\n                     if digest not in unnormalized_digests:\n                         # Exact string value must match, not just normalized\n                         self.error(\"E050f\", version=version, digest=digest)\n                     norm_digest = normalized_digest(digest, self.digest_algorithm)\n                     digests.append(norm_digest)\n             # Check for conflicting logical paths\n             for path in logical_directories:\n                 if path in logical_paths:\n                     self.error(\"E095b\", version=version, path=path)\n         return digests\n \n     def check_content_paths_map_to_versions(self, manifest_files, all_versions):\n         \"\"\"Check that every content path starts with a valid version.\n \n         The content directory component has already been checked in\n         check_content_path(). We have already tested all paths enough\n         to know that they can be split into at least 2 components.\n         \"\"\"\n         for path in manifest_files:\n             version_dir, dummy_rest = path.split('/', 1)\n             if version_dir not in all_versions:\n                 self.error('E042b', path=path)\n \n     def check_digests_present_and_used(self, manifest_files, digests_used):\n         \"\"\"Check all digests in manifest that are needed are present and used.\"\"\"\n         in_manifest = set(manifest_files.values())\n         in_state = set(digests_used)\n         not_in_manifest = in_state.difference(in_manifest)\n         if len(not_in_manifest) > 0:\n             self.error(\"E050a\", digests=\", \".join(sorted(not_in_manifest)))\n         not_in_state = in_manifest.difference(in_state)\n         if len(not_in_state) > 0:\n             self.error(\"E107\", digests=\", \".join(sorted(not_in_state)))\n \n     def digest_regex(self):\n         \"\"\"Return regex for validating un-normalized digest format.\"\"\"\n         try:\n             return digest_regex(self.digest_algorithm)\n         except ValueError:\n             if not self.lax_digests:\n                 self.error('E026a', digest=self.digest_algorithm)\n         # Match anything\n         return r'''^.*$'''\n \n     def check_logical_path(self, path, version, logical_paths, logical_directories):\n         \"\"\"Check logical path and accumulate paths/directories for E095b check.\n \n         logical_paths and logical_directories are expected to be sets.\n \n         Only adds good paths to the accumulated paths/directories.\n         \"\"\"\n         if path.startswith('/') or path.endswith('/'):\n             self.error(\"E053\", version=version, path=path)\n         else:\n             elements = path.split('/')\n             for element in elements:\n                 if element in ['.', '..', '']:\n                     self.error(\"E052\", version=version, path=path)\n                     return\n             # Accumulate paths and directories\n             logical_paths.add(path)\n             logical_directories.add('/'.join(elements[0:-1]))\n \n     def check_content_path(self, path, content_paths, content_directories):\n         \"\"\"Check logical path and accumulate paths/directories for E101 check.\n \n         Returns True if valid, else False. Only adds good paths to the\n         accumulated paths/directories. We don't yet know the set of valid\n         version directories so the check here is just for 'v' + digits.\n         \"\"\"\n         if path.startswith('/') or path.endswith('/'):\n             self.error(\"E100\", path=path)\n             return False\n         m = re.match(r'''^(v\\d+/''' + self.content_directory + r''')/(.+)''', path)\n         if not m:\n             self.error(\"E042a\", path=path)\n             return False\n         elements = m.group(2).split('/')\n         for element in elements:\n             if element in ('', '.', '..'):\n                 self.error(\"E099\", path=path)\n                 return False\n         # Accumulate paths and directories if not seen before\n         if path in content_paths:\n             self.error(\"E101a\", path=path)\n             return False\n         content_paths.add(path)\n         content_directories.add('/'.join([m.group(1)] + elements[0:-1]))\n         return True\n \n     def validate_as_prior_version(self, prior):\n         \"\"\"Check that prior is a valid prior version of the current inventory object.\n \n         The input variable prior is also expected to be an InventoryValidator object\n         and both self and prior inventories are assumed to have been checked for\n         internal consistency.\n         \"\"\"\n         # Must have a subset of versions which also checks zero padding format etc.\n         if not set(prior.all_versions) < set(self.all_versions):\n             self.error('E066a', prior_head=prior.head)\n         else:\n             # Check references to files but realize that there might be different\n             # digest algorithms between versions\n             version = 'no-version'\n             for version in prior.all_versions:\n                 # If the digest algorithm is the same then we can make a\n                 # direct check on whether the state blocks match\n                 if prior.digest_algorithm == self.digest_algorithm:\n                     self.compare_states_for_version(prior, version)\n                 # Now check the mappings from state to logical path, which must\n                 # be consistent even if the digestAlgorithm is different between\n                 # versions. Get maps from logical paths to files on disk:\n                 prior_map = get_logical_path_map(prior.inventory, version)\n                 self_map = get_logical_path_map(self.inventory, version)\n                 # Look first for differences in logical paths listed\n                 only_in_prior = prior_map.keys() - self_map.keys()\n                 only_in_self = self_map.keys() - prior_map.keys()\n                 if only_in_prior or only_in_self:\n                     if only_in_prior:\n                         self.error('E066b', version=version, prior_head=prior.head, only_in=prior.head, logical_paths=','.join(only_in_prior))\n                     if only_in_self:\n                         self.error('E066b', version=version, prior_head=prior.head, only_in=self.where, logical_paths=','.join(only_in_self))\n                 else:\n                     # Check them all in details - digests must match\n                     for logical_path, this_map in prior_map.items():\n                         if not this_map.issubset(self_map[logical_path]):\n                             self.error('E066c', version=version, prior_head=prior.head,\n                                        logical_path=logical_path, prior_content=','.join(this_map),\n                                        current_content=','.join(self_map[logical_path]))\n                 # Check metadata\n                 prior_version = prior.inventory['versions'][version]\n                 self_version = self.inventory['versions'][version]\n                 for key in ('created', 'message', 'user'):\n                     if prior_version.get(key) != self_version.get(key):\n                         self.warning('W011', version=version, prior_head=prior.head, key=key)\n \n     def compare_states_for_version(self, prior, version):\n         \"\"\"Compare state blocks for version between self and prior.\n \n         Assumes the same digest algorithm in both, do not call otherwise!\n \n         Looks only for digests that appear in one but not in the other, the code\n         in validate_as_prior_version(..) does a check for whether the same sets\n         of logical files appear and we don't want to duplicate an error message\n         about that.\n \n         While the mapping checks in validate_as_prior_version(..) do all that is\n         necessary to detect an error, the additional errors that may be generated\n         here provide more detailed diagnostics in the case that the digest\n         algorithm is the same across versions being compared.\n         \"\"\"\n         self_state = self.inventory['versions'][version]['state']\n         prior_state = prior.inventory['versions'][version]['state']\n         for digest in set(self_state.keys()).union(prior_state.keys()):\n             if digest not in prior_state:\n                 self.error('E066d', version=version, prior_head=prior.head,\n                            digest=digest, logical_files=', '.join(self_state[digest]))\n             elif digest not in self_state:\n                 self.error('E066e', version=version, prior_head=prior.head,\n                            digest=digest, logical_files=', '.join(prior_state[digest]))\n ", "input_code": "def get_logical_path_map(inventory, version):\n\"\"\"\nGet a map of logical paths in state to files on disk for version in inventory.\n\nReturns a dictionary: logical_path_in_state -> set(content_files)\n\nThe set of content_files may includes references to duplicate files in\nlater versions than the version being described.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def get_logical_path_map(inventory, version):\n    \"\"\"Get a map of logical paths in state to files on disk for version in inventory.\n\n    Returns a dictionary: logical_path_in_state -> set(content_files)\n\n    The set of content_files may includes references to duplicate files in\n    later versions than the version being described.\n    \"\"\"\n    state = inventory['versions'][version]['state']\n    manifest = inventory['manifest']\n    file_map = {}\n    for digest in state:\n        if digest in manifest:\n            for file in state[digest]:\n                file_map[file] = set(manifest[digest])\n    return file_map", "signature": "def get_logical_path_map(inventory, version):", "completion_path": "ocfl/inventory_validator.py"}
{"ce_id": "62b45e175108cfac7f210a19", "namespace": "62b45e175108cfac7f210a19", "namespace_real": "ocfl.inventory_validator.validate_fixity", "real_proj_path": "zimeon---ocfl-py/", "type": "class", "class_name": "inventory_validator", "function_name": "validate_fixity", "contexts_above": "\"\"\"OCFL Inventory Validator.\n\nCode to validate the Python representation of an OCFL Inventory\nas read with json.load(). Does not examine anything in storage.\n\"\"\"\nimport re\n\nfrom .digest import digest_regex, normalized_digest\nfrom .validation_logger import ValidationLogger\nfrom .w3c_datetime import str_to_datetime\n\n\ndef get_logical_path_map(inventory, version):\n    \"\"\"Get a map of logical paths in state to files on disk for version in inventory.\n\n    Returns a dictionary: logical_path_in_state -> set(content_files)\n\n    The set of content_files may includes references to duplicate files in\n    later versions than the version being described.\n    \"\"\"\n    state = inventory['versions'][version]['state']\n    manifest = inventory['manifest']\n    file_map = {}\n    for digest in state:\n        if digest in manifest:\n            for file in state[digest]:\n                file_map[file] = set(manifest[digest])\n    return file_map\n\n\nclass InventoryValidator():\n    \"\"\"Class for OCFL Inventory Validator.\"\"\"\n\n    def __init__(self, log=None, where='???',\n                 lax_digests=False, spec_version='1.0'):\n        \"\"\"Initialize OCFL Inventory Validator.\"\"\"\n        self.log = ValidationLogger() if log is None else log\n        self.where = where\n        self.spec_version = spec_version\n        # Object state\n        self.inventory = None\n        self.id = None\n        self.digest_algorithm = 'sha512'\n        self.content_directory = 'content'\n        self.all_versions = []\n        self.manifest_files = None\n        self.unnormalized_digests = None\n        self.head = 'UNKNOWN'\n        # Validation control\n        self.lax_digests = lax_digests\n        # Configuration\n        self.spec_versions_supported = ('1.0', '1.1')\n\n    def error(self, code, **args):\n        \"\"\"Error with added context.\"\"\"\n        self.log.error(code, where=self.where, **args)\n\n    def warning(self, code, **args):\n        \"\"\"Warning with added context.\"\"\"\n        self.log.warning(code, where=self.where, **args)\n\n    def validate(self, inventory, extract_spec_version=False):\n        \"\"\"Validate a given inventory.\n\n        If extract_spec_version is True then will look at the type value to determine\n        the specification version. In the case that there is no type value or it isn't\n        valid, then other tests will be based on the version given in self.spec_version.\n        \"\"\"\n        # Basic structure\n        self.inventory = inventory\n        if 'id' in inventory:\n            iid = inventory['id']\n            if not isinstance(iid, str) or iid == '':\n                self.error(\"E037a\")\n            else:\n                # URI syntax https://www.rfc-editor.org/rfc/rfc3986.html#section-3.1 :\n                # scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n                if not re.match(r'''[a-z][a-z\\d\\+\\-\\.]*:.+''', iid, re.IGNORECASE):\n                    self.warning(\"W005\", id=iid)\n                self.id = iid\n        else:\n            self.error(\"E036a\")\n        if 'type' not in inventory:\n            self.error(\"E036b\")\n        elif not isinstance(inventory['type'], str):\n            self.error(\"E999\")\n        elif extract_spec_version:\n            m = re.match(r'''https://ocfl.io/(\\d+.\\d)/spec/#inventory''', inventory['type'])\n            if not m:\n                self.error('E038b', got=inventory['type'], assumed_spec_version=self.spec_version)\n            elif m.group(1) in self.spec_versions_supported:\n                self.spec_version = m.group(1)\n            else:\n                self.error(\"E038c\", got=m.group(1), assumed_spec_version=self.spec_version)\n        elif inventory['type'] != 'https://ocfl.io/' + self.spec_version + '/spec/#inventory':\n            self.error(\"E038a\", expected='https://ocfl.io/' + self.spec_version + '/spec/#inventory', got=inventory['type'])\n        if 'digestAlgorithm' not in inventory:\n            self.error(\"E036c\")\n        elif inventory['digestAlgorithm'] == 'sha512':\n            pass\n        elif self.lax_digests:\n            self.digest_algorithm = inventory['digestAlgorithm']\n        elif inventory['digestAlgorithm'] == 'sha256':\n            self.warning(\"W004\")\n            self.digest_algorithm = inventory['digestAlgorithm']\n        else:\n            self.error(\"E039\", digest_algorithm=inventory['digestAlgorithm'])\n        if 'contentDirectory' in inventory:\n            # Careful only to set self.content_directory if value is safe\n            cd = inventory['contentDirectory']\n            if not isinstance(cd, str) or '/' in cd:\n                self.error(\"E017\")\n            elif cd in ('.', '..'):\n                self.error(\"E018\")\n            else:\n                self.content_directory = cd\n        manifest_files_correct_format = None\n        if 'manifest' not in inventory:\n            self.error(\"E041a\")\n        else:\n            (self.manifest_files, manifest_files_correct_format, self.unnormalized_digests) = self.validate_manifest(inventory['manifest'])\n        digests_used = []\n        if 'versions' not in inventory:\n            self.error(\"E041b\")\n        else:\n            self.all_versions = self.validate_version_sequence(inventory['versions'])\n            digests_used = self.validate_versions(inventory['versions'], self.all_versions, self.unnormalized_digests)\n        if 'head' not in inventory:\n            self.error(\"E036d\")\n        elif len(self.all_versions) > 0:\n            self.head = self.all_versions[-1]\n            if inventory['head'] != self.head:\n                self.error(\"E040\", got=inventory['head'], expected=self.head)\n        if len(self.all_versions) == 0:\n            # Abort tests is we don't have a valid version sequence, otherwise\n            # there will likely be spurious subsequent error reports\n            return\n        if len(self.all_versions) > 0:\n            if manifest_files_correct_format is not None:\n                self.check_content_paths_map_to_versions(manifest_files_correct_format, self.all_versions)\n            if self.manifest_files is not None:\n                self.check_digests_present_and_used(self.manifest_files, digests_used)\n        if 'fixity' in inventory:\n            self.validate_fixity(inventory['fixity'], self.manifest_files)\n\n    def validate_manifest(self, manifest):\n        \"\"\"Validate manifest block in inventory.\n\n        Returns:\n          * manifest_files - a mapping from file to digest for each file in\n              the manifest\n          * manifest_files_correct_format - a simple list of the manifest file\n              path that passed initial checks. They need to be checked for valid\n              version directories later, when we know what version directories\n              are valid\n          * unnormalized_digests - a set of the original digests in unnormalized\n              form that MUST match exactly the values used in state blocks\n        \"\"\"\n        manifest_files = {}\n        manifest_files_correct_format = []\n        unnormalized_digests = set()\n        manifest_digests = set()\n        if not isinstance(manifest, dict):\n            self.error('E041c')\n        else:\n            content_paths = set()\n            content_directories = set()\n            for digest in manifest:\n                m = re.match(self.digest_regex(), digest)\n                if not m:\n                    self.error('E025a', digest=digest, algorithm=self.digest_algorithm)  # wrong form of digest\n                elif not isinstance(manifest[digest], list):\n                    self.error('E092', digest=digest)  # must have path list value\n                else:\n                    unnormalized_digests.add(digest)\n                    norm_digest = normalized_digest(digest, self.digest_algorithm)\n                    if norm_digest in manifest_digests:\n                        # We have already seen this in different un-normalized form!\n                        self.error(\"E096\", digest=norm_digest)\n                    else:\n                        manifest_digests.add(norm_digest)\n                    for file in manifest[digest]:\n                        manifest_files[file] = norm_digest\n                        if self.check_content_path(file, content_paths, content_directories):\n                            manifest_files_correct_format.append(file)\n            # Check for conflicting content paths\n            for path in content_directories:\n                if path in content_paths:\n                    self.error(\"E101b\", path=path)\n        return manifest_files, manifest_files_correct_format, unnormalized_digests\n", "contexts_below": "    def validate_version_sequence(self, versions):\n         \"\"\"Validate sequence of version names in versions block in inventory.\n \n         Returns an array of in-sequence version directories that are part\n         of a valid sequences. May exclude other version directory names that are\n         not part of the valid sequence if an error is thrown.\n         \"\"\"\n         all_versions = []\n         if not isinstance(versions, dict):\n             self.error(\"E044\")\n             return all_versions\n         if len(versions) == 0:\n             self.error(\"E008\")\n             return all_versions\n         # Validate version sequence\n         # https://ocfl.io/draft/spec/#version-directories\n         zero_padded = None\n         max_version_num = 999999  # Excessive limit\n         if 'v1' in versions:\n             fmt = 'v%d'\n             zero_padded = False\n             all_versions.append('v1')\n         else:  # Find padding size\n             for n in range(2, 11):\n                 fmt = 'v%0' + str(n) + 'd'\n                 vkey = fmt % 1\n                 if vkey in versions:\n                     all_versions.append(vkey)\n                     zero_padded = n\n                     max_version_num = (10 ** (n - 1)) - 1\n                     break\n             if not zero_padded:\n                 self.error(\"E009\")\n                 return all_versions\n         if zero_padded:\n             self.warning(\"W001\")\n         # Have v1 and know format, work through to check sequence\n         for n in range(2, max_version_num + 1):\n             v = (fmt % n)\n             if v in versions:\n                 all_versions.append(v)\n             else:\n                 if len(versions) != (n - 1):\n                     self.error(\"E010\")  # Extra version dirs outside sequence\n                 return all_versions\n         # We have now included all possible versions up to the zero padding\n         # size, if there are more versions than this number then we must\n         # have extra that violate the zero-padding rule or are out of\n         # sequence\n         if len(versions) > max_version_num:\n             self.error(\"E011\")\n         return all_versions\n \n     def validate_versions(self, versions, all_versions, unnormalized_digests):\n         \"\"\"Validate versions blocks in inventory.\n \n         Requires as input two things which are assumed to be structurally correct\n         from prior basic validation:\n \n           * versions - which is the JSON object (dict) from the inventory\n           * all_versions - an ordered list of the versions to look at in versions\n                            (all other keys in versions will be ignored)\n \n         Returns a list of digests_used which can then be checked against the\n         manifest.\n         \"\"\"\n         digests_used = []\n         for v in all_versions:\n             version = versions[v]\n             if 'created' not in version:\n                 self.error('E048', version=v)  # No created\n             elif not isinstance(versions[v]['created'], str):\n                 self.error('E049d', version=v)  # Bad created\n             else:\n                 created = versions[v]['created']\n                 try:\n                     str_to_datetime(created)  # catch ValueError if fails\n                     if not re.search(r'''(Z|[+-]\\d\\d:\\d\\d)$''', created):  # FIXME - kludge\n                         self.error('E049a', version=v)\n                     if not re.search(r'''T\\d\\d:\\d\\d:\\d\\d''', created):  # FIXME - kludge\n                         self.error('E049b', version=v)\n                 except ValueError as e:\n                     self.error('E049c', version=v, description=str(e))\n             if 'state' in version:\n                 digests_used += self.validate_state_block(version['state'], version=v, unnormalized_digests=unnormalized_digests)\n             else:\n                 self.error('E048c', version=v)\n             if 'message' not in version:\n                 self.warning('W007a', version=v)\n             elif not isinstance(version['message'], str):\n                 self.error('E094', version=v)\n             if 'user' not in version:\n                 self.warning('W007b', version=v)\n             else:\n                 user = version['user']\n                 if not isinstance(user, dict):\n                     self.error('E054a', version=v)\n                 else:\n                     if 'name' not in user or not isinstance(user['name'], str):\n                         self.error('E054b', version=v)\n                     if 'address' not in user:\n                         self.warning('W008', version=v)\n                     elif not isinstance(user['address'], str):\n                         self.error('E054c', version=v)\n                     elif not re.match(r'''\\w{3,6}:''', user['address']):\n                         self.warning('W009', version=v)\n         return digests_used\n \n     def validate_state_block(self, state, version, unnormalized_digests):\n         \"\"\"Validate state block in a version in an inventory.\n \n         The version is used only for error reporting.\n \n         Returns a list of content digests referenced in the state block.\n         \"\"\"\n         digests = []\n         logical_paths = set()\n         logical_directories = set()\n         if not isinstance(state, dict):\n             self.error('E050c', version=version)\n         else:\n             digest_re = re.compile(self.digest_regex())\n             for digest in state:\n                 if not digest_re.match(digest):\n                     self.error('E050d', version=version, digest=digest)\n                 elif not isinstance(state[digest], list):\n                     self.error('E050e', version=version, digest=digest)\n                 else:\n                     for path in state[digest]:\n                         if path in logical_paths:\n                             self.error(\"E095a\", version=version, path=path)\n                         else:\n                             self.check_logical_path(path, version, logical_paths, logical_directories)\n                     if digest not in unnormalized_digests:\n                         # Exact string value must match, not just normalized\n                         self.error(\"E050f\", version=version, digest=digest)\n                     norm_digest = normalized_digest(digest, self.digest_algorithm)\n                     digests.append(norm_digest)\n             # Check for conflicting logical paths\n             for path in logical_directories:\n                 if path in logical_paths:\n                     self.error(\"E095b\", version=version, path=path)\n         return digests\n \n     def check_content_paths_map_to_versions(self, manifest_files, all_versions):\n         \"\"\"Check that every content path starts with a valid version.\n \n         The content directory component has already been checked in\n         check_content_path(). We have already tested all paths enough\n         to know that they can be split into at least 2 components.\n         \"\"\"\n         for path in manifest_files:\n             version_dir, dummy_rest = path.split('/', 1)\n             if version_dir not in all_versions:\n                 self.error('E042b', path=path)\n \n     def check_digests_present_and_used(self, manifest_files, digests_used):\n         \"\"\"Check all digests in manifest that are needed are present and used.\"\"\"\n         in_manifest = set(manifest_files.values())\n         in_state = set(digests_used)\n         not_in_manifest = in_state.difference(in_manifest)\n         if len(not_in_manifest) > 0:\n             self.error(\"E050a\", digests=\", \".join(sorted(not_in_manifest)))\n         not_in_state = in_manifest.difference(in_state)\n         if len(not_in_state) > 0:\n             self.error(\"E107\", digests=\", \".join(sorted(not_in_state)))\n \n     def digest_regex(self):\n         \"\"\"Return regex for validating un-normalized digest format.\"\"\"\n         try:\n             return digest_regex(self.digest_algorithm)\n         except ValueError:\n             if not self.lax_digests:\n                 self.error('E026a', digest=self.digest_algorithm)\n         # Match anything\n         return r'''^.*$'''\n \n     def check_logical_path(self, path, version, logical_paths, logical_directories):\n         \"\"\"Check logical path and accumulate paths/directories for E095b check.\n \n         logical_paths and logical_directories are expected to be sets.\n \n         Only adds good paths to the accumulated paths/directories.\n         \"\"\"\n         if path.startswith('/') or path.endswith('/'):\n             self.error(\"E053\", version=version, path=path)\n         else:\n             elements = path.split('/')\n             for element in elements:\n                 if element in ['.', '..', '']:\n                     self.error(\"E052\", version=version, path=path)\n                     return\n             # Accumulate paths and directories\n             logical_paths.add(path)\n             logical_directories.add('/'.join(elements[0:-1]))\n \n     def check_content_path(self, path, content_paths, content_directories):\n         \"\"\"Check logical path and accumulate paths/directories for E101 check.\n \n         Returns True if valid, else False. Only adds good paths to the\n         accumulated paths/directories. We don't yet know the set of valid\n         version directories so the check here is just for 'v' + digits.\n         \"\"\"\n         if path.startswith('/') or path.endswith('/'):\n             self.error(\"E100\", path=path)\n             return False\n         m = re.match(r'''^(v\\d+/''' + self.content_directory + r''')/(.+)''', path)\n         if not m:\n             self.error(\"E042a\", path=path)\n             return False\n         elements = m.group(2).split('/')\n         for element in elements:\n             if element in ('', '.', '..'):\n                 self.error(\"E099\", path=path)\n                 return False\n         # Accumulate paths and directories if not seen before\n         if path in content_paths:\n             self.error(\"E101a\", path=path)\n             return False\n         content_paths.add(path)\n         content_directories.add('/'.join([m.group(1)] + elements[0:-1]))\n         return True\n \n     def validate_as_prior_version(self, prior):\n         \"\"\"Check that prior is a valid prior version of the current inventory object.\n \n         The input variable prior is also expected to be an InventoryValidator object\n         and both self and prior inventories are assumed to have been checked for\n         internal consistency.\n         \"\"\"\n         # Must have a subset of versions which also checks zero padding format etc.\n         if not set(prior.all_versions) < set(self.all_versions):\n             self.error('E066a', prior_head=prior.head)\n         else:\n             # Check references to files but realize that there might be different\n             # digest algorithms between versions\n             version = 'no-version'\n             for version in prior.all_versions:\n                 # If the digest algorithm is the same then we can make a\n                 # direct check on whether the state blocks match\n                 if prior.digest_algorithm == self.digest_algorithm:\n                     self.compare_states_for_version(prior, version)\n                 # Now check the mappings from state to logical path, which must\n                 # be consistent even if the digestAlgorithm is different between\n                 # versions. Get maps from logical paths to files on disk:\n                 prior_map = get_logical_path_map(prior.inventory, version)\n                 self_map = get_logical_path_map(self.inventory, version)\n                 # Look first for differences in logical paths listed\n                 only_in_prior = prior_map.keys() - self_map.keys()\n                 only_in_self = self_map.keys() - prior_map.keys()\n                 if only_in_prior or only_in_self:\n                     if only_in_prior:\n                         self.error('E066b', version=version, prior_head=prior.head, only_in=prior.head, logical_paths=','.join(only_in_prior))\n                     if only_in_self:\n                         self.error('E066b', version=version, prior_head=prior.head, only_in=self.where, logical_paths=','.join(only_in_self))\n                 else:\n                     # Check them all in details - digests must match\n                     for logical_path, this_map in prior_map.items():\n                         if not this_map.issubset(self_map[logical_path]):\n                             self.error('E066c', version=version, prior_head=prior.head,\n                                        logical_path=logical_path, prior_content=','.join(this_map),\n                                        current_content=','.join(self_map[logical_path]))\n                 # Check metadata\n                 prior_version = prior.inventory['versions'][version]\n                 self_version = self.inventory['versions'][version]\n                 for key in ('created', 'message', 'user'):\n                     if prior_version.get(key) != self_version.get(key):\n                         self.warning('W011', version=version, prior_head=prior.head, key=key)\n \n     def compare_states_for_version(self, prior, version):\n         \"\"\"Compare state blocks for version between self and prior.\n \n         Assumes the same digest algorithm in both, do not call otherwise!\n \n         Looks only for digests that appear in one but not in the other, the code\n         in validate_as_prior_version(..) does a check for whether the same sets\n         of logical files appear and we don't want to duplicate an error message\n         about that.\n \n         While the mapping checks in validate_as_prior_version(..) do all that is\n         necessary to detect an error, the additional errors that may be generated\n         here provide more detailed diagnostics in the case that the digest\n         algorithm is the same across versions being compared.\n         \"\"\"\n         self_state = self.inventory['versions'][version]['state']\n         prior_state = prior.inventory['versions'][version]['state']\n         for digest in set(self_state.keys()).union(prior_state.keys()):\n             if digest not in prior_state:\n                 self.error('E066d', version=version, prior_head=prior.head,\n                            digest=digest, logical_files=', '.join(self_state[digest]))\n             elif digest not in self_state:\n                 self.error('E066e', version=version, prior_head=prior.head,\n                            digest=digest, logical_files=', '.join(prior_state[digest]))\n ", "input_code": "def validate_fixity(self, fixity, manifest_files):\n\"\"\"\nValidate fixity block in inventory.\n\nCheck the structure of the fixity block and makes sure that only files\nlisted in the manifest are referenced.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def validate_fixity(self, fixity, manifest_files):\n        \"\"\"Validate fixity block in inventory.\n\n        Check the structure of the fixity block and makes sure that only files\n        listed in the manifest are referenced.\n        \"\"\"\n        if not isinstance(fixity, dict):\n            # The value of fixity must be a JSON object. In v1.0 I catch not an object\n            # as part of E056 but this was clarified as E111 in v1.1. The value may\n            # be an empty object in either case\n            self.error('E056a' if self.spec_version == '1.0' else 'E111')\n        else:\n            for digest_algorithm in fixity:\n                known_digest = True\n                try:\n                    regex = digest_regex(digest_algorithm)\n                except ValueError:\n                    if not self.lax_digests:\n                        self.error('E056b', algorithm=self.digest_algorithm)\n                        continue\n                    # Match anything\n                    regex = r'''^.*$'''\n                    known_digest = False\n                fixity_algoritm_block = fixity[digest_algorithm]\n                if not isinstance(fixity_algoritm_block, dict):\n                    self.error('E057a', algorithm=self.digest_algorithm)\n                else:\n                    digests_seen = set()\n                    for digest in fixity_algoritm_block:\n                        m = re.match(regex, digest)\n                        if not m:\n                            self.error('E057b', digest=digest, algorithm=digest_algorithm)  # wrong form of digest\n                        elif not isinstance(fixity_algoritm_block[digest], list):\n                            self.error('E057c', digest=digest, algorithm=digest_algorithm)  # must have path list value\n                        else:\n                            if known_digest:\n                                norm_digest = normalized_digest(digest, digest_algorithm)\n                            else:\n                                norm_digest = digest\n                            if norm_digest in digests_seen:\n                                # We have already seen this in different un-normalized form!\n                                self.error(\"E097\", digest=norm_digest, algorithm=digest_algorithm)\n                            else:\n                                digests_seen.add(norm_digest)\n                            for file in fixity_algoritm_block[digest]:\n                                if file not in manifest_files:\n                                    self.error(\"E057d\", digest=norm_digest, algorithm=digest_algorithm, path=file)", "signature": "def validate_fixity(self, fixity, manifest_files):", "completion_path": "ocfl/inventory_validator.py"}
{"ce_id": "62b463153879012d19481498", "namespace": "62b463153879012d19481498", "namespace_real": "packtools.file_utils.files_list", "real_proj_path": "scieloorg---packtools/", "type": "function", "class_name": null, "function_name": "files_list", "contexts_above": "import os\nimport logging\nimport re\nimport shutil\nimport tempfile\n\nfrom zipfile import ZipFile, ZIP_DEFLATED\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef is_folder(source):\n    return os.path.isdir(source)\n\n\ndef is_zipfile(source):\n    return os.path.isfile(source) and source.endswith(\".zip\")\n\n\ndef xml_files_list(path):\n    \"\"\"\n    Return the XML files found in `path`\n    \"\"\"\n    return (f for f in os.listdir(path) if f.endswith(\".xml\"))\n\n", "contexts_below": "\n def read_file(path, encoding=\"utf-8\", mode=\"r\"):\n     with open(path, mode=mode, encoding=encoding) as f:\n         text = f.read()\n     return text\n \n \n def read_from_zipfile(zip_path, filename):\n     with ZipFile(zip_path) as zf:\n         return zf.read(filename)\n \n \n def xml_files_list_from_zipfile(zip_path):\n     with ZipFile(zip_path) as zf:\n         xmls_filenames = [\n             xml_filename\n             for xml_filename in zf.namelist()\n             if os.path.splitext(xml_filename)[-1] == \".xml\"\n         ]\n     return xmls_filenames\n \n \n def files_list_from_zipfile(zip_path):\n     \"\"\"\n     Return the files in `zip_path`\n \n     Example:\n \n     ```\n     [\n         '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200069.pdf',\n         '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200069.xml',\n         '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071.pdf',\n         '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071.xml',\n         '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf01.tif',\n         '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf02.tif',\n         '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf03.tif',\n         '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf04.tif',\n     ]\n     ```\n     \"\"\"\n     with ZipFile(zip_path) as zf:\n         return zf.namelist()\n \n \n def write_file(path, source, mode=\"w\"):\n     dirname = os.path.dirname(path)\n     if not os.path.isdir(dirname):\n         os.makedirs(dirname)\n     logger.debug(\"Gravando arquivo: %s\", path)\n     if \"b\" in mode:\n         with open(path, mode) as f:\n             f.write(source)\n         return\n \n     with open(path, mode, encoding=\"utf-8\") as f:\n         f.write(source)\n \n \n def create_zip_file(files, zip_name, zip_folder=None):\n     zip_folder = zip_folder or tempfile.mkdtemp()\n \n     zip_path = os.path.join(zip_folder, zip_name)\n     with ZipFile(zip_path, 'w', ZIP_DEFLATED) as myzip:\n         for f in files:\n             myzip.write(f, os.path.basename(f))\n     return zip_path\n \n \n def delete_folder(path):\n     try:\n         shutil.rmtree(path)\n     except:\n         pass\n \n \n def create_temp_file(filename, content=None, mode='w'):\n     file_path = tempfile.mkdtemp()\n     file_path = os.path.join(file_path, filename)\n     write_file(file_path, content or '', mode)\n     return file_path\n \n \n def copy_file(source, target):\n     tmpdir = tempfile.mkdtemp()\n     fullpath_target = os.path.join(tmpdir, target)\n \n     logger.info(f'Copying file {source} to {fullpath_target}')\n     return shutil.copyfile(source, fullpath_target)\n \n \n def size(file_path):\n     return os.path.getsize(file_path)\n \n \n def get_prefix_by_xml_filename(xml_filename):\n     \"\"\"\n     Obt\u00e9m o prefixo associado a um arquivo xml\n \n     Parameters\n     ----------\n     xml_filename : str\n         Nome de arquivo xml\n \n     Returns\n     -------\n     str\n         Prefixo associado ao arquivo xml\n     \"\"\"\n     file, ext = os.path.splitext(xml_filename)\n     return file\n \n \n def get_file_role(file_path, prefix, pdf_langs):\n     \"\"\"\n     Obt\u00e9m o papel/fun\u00e7\u00e3o de um arquivo (xml, renditions ou assets) no contexto de um documento\n \n     Parameters\n     ----------\n     file_path : str\n         Nome de um arquivo\n     prefix: str\n         Prefixo associado ao arquivo\n     pdf_langs: list\n         Idiomas dos PDFs do documento\n \n     Returns\n     -------\n     str\n         Papel/fun\u00e7\u00e3o de arquivo (xml, rendition ou assets) no contexto de um documento\n     \"\"\"\n     file, ext = os.path.splitext(file_path)\n \n     if ext == '.xml':\n         return 'xml'\n     elif ext == '.pdf':\n         if file == prefix:\n             return 'renditions'\n \n         for lang in pdf_langs:\n             if file == f'{prefix}-{lang}':\n                 return 'renditions'\n     return 'assets'\n \n \n def extract_issn_from_zip_uri(zip_uri):\n     \"\"\"\n     Extrai c\u00f3digo ISSN a partir do endere\u00e7o de um arquivo zip\n \n     Parameters\n     ----------\n     zip_uri : str\n         Endere\u00e7o de um arquivo zip\n \n     Returns\n     -------\n     str\n         ISSN\n     \"\"\"\n     match = re.search(r'.*/ingress/packages/(\\d{4}-\\d{4})/.*.zip', zip_uri)\n     if match:\n         return match.group(1)\n \n \n def get_filename(file_path):\n     return os.path.basename(file_path)\n ", "input_code": "def files_list(path):\n\"\"\"\nReturn the files in `path`\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def files_list(path):\n    \"\"\"\n    Return the files in `path`\n    \"\"\"\n    return os.listdir(path)", "signature": "def files_list(path):", "completion_path": "packtools/file_utils.py"}
{"ce_id": "62b463153879012d1948149a", "namespace": "62b463153879012d1948149a", "namespace_real": "packtools.sps.models.packages._group_files_by_xml_filename", "real_proj_path": "scieloorg---packtools/", "type": "function", "class_name": null, "function_name": "_group_files_by_xml_filename", "contexts_above": "import logging\nimport os\n\nfrom packtools import file_utils\nfrom zipfile import ZipFile\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Package:\n    def __init__(self, source, name):\n        self._source = source\n        self._xml = None\n        self._assets = {}\n        self._renditions = {}\n        self._name = name\n        self.zip_file_path = file_utils.is_zipfile(source) and source\n\n    @property\n    def assets(self):\n        return self._assets\n\n    @property\n    def name(self):\n        return self._name\n\n    def file_path(self, file_path):\n        if file_utils.is_folder(self._source):\n            return os.path.join(self._source, file_path)\n        return file_path\n\n    def add_asset(self, basename, file_path):\n        \"\"\"\n        \"{\n            \"artigo02-gf03.tiff\": \"/path/artigo02-gf03.tiff\",\n            \"artigo02-gf03.jpg\": \"/path/artigo02-gf03.jpg\",\n            \"artigo02-gf03.png\": \"/path/artigo02-gf03.png\",\n        }\n        \"\"\"\n        self._assets[basename] = self.file_path(file_path)\n\n    def get_asset(self, basename):\n        try:\n            return self._assets[basename]\n        except KeyError:\n            return\n\n    def add_rendition(self, lang, file_path):\n        \"\"\"\n        {\n            \"original\": \"artigo02.pdf\",\n            \"en\": \"artigo02-en.pdf\",\n        }\n        \"\"\"\n        self._renditions[lang] = self.file_path(file_path)\n\n    def get_rendition(self, lang):\n        try:\n            return self._renditions[lang]\n        except KeyError:\n            return\n\n    @property\n    def source(self):\n        return self._source\n\n    @property\n    def xml(self):\n        return self.file_path(self._xml)\n\n    @xml.setter\n    def xml(self, value):\n        self._xml = value\n\n    @property\n    def renditions(self):\n        return self._renditions\n\n    @property\n    def xml_content(self):\n        if file_utils.is_folder(self._source):\n            with open(self.xml, \"rb\") as fp:\n                return fp.read()\n        with ZipFile(self._source) as zf:\n            return zf.read(self.xml)\n\n\ndef select_filenames_by_prefix(prefix, files):\n    \"\"\"\n    Get files which belongs to a document package.\n\n    Retorna os arquivos da lista `files` cujos nomes iniciam com `prefix`\n\n    Parameters\n    ----------\n    prefix : str\n        Filename prefix\n    files : str list\n        Files paths\n    Returns\n    -------\n    list\n        files paths which basename files matches to prefix\n    \"\"\"\n    return [\n        item\n        for item in files\n        if match_file_by_prefix(prefix, item)\n    ]\n\n\ndef match_file_by_prefix(prefix, file_path):\n    \"\"\"\n    Identify if a `file_path` belongs to a document package by a given `prefix`\n\n    Retorna `True` para documentos pertencentes a um pacote.\n\n    Parameters\n    ----------\n    prefix : str\n        Filename prefix\n    file_path : str\n        File path\n    Returns\n    -------\n    bool\n        True - file belongs to the package\n    \"\"\"\n    basename = os.path.basename(file_path)\n    if basename.startswith(prefix + \"-\"):\n        return True\n    if basename.startswith(prefix + \".\"):\n        return True\n    return False\n\n\ndef explore_source(source):\n    packages = _explore_zipfile(source)\n    if not packages:\n        packages = _explore_folder(source)\n    if not packages:\n        raise ValueError(\"%s: Invalid value for `source`\" % source)\n    return packages\n\n\ndef _explore_folder(folder):\n    \"\"\"\n    Get packages' data from folder\n\n    Groups files by their XML basename and returns data in dict format.\n\n    Parameters\n    ----------\n    folder : str\n        Folder of the package\n    Returns\n    -------\n    dict\n    \"\"\"\n    if file_utils.is_folder(folder):\n        data = _group_files_by_xml_filename(\n            folder,\n            file_utils.xml_files_list(folder),\n            file_utils.files_list(folder),\n        )\n        return data\n\n\ndef _explore_zipfile(zip_path):\n    \"\"\"\n    Get packages' data from zip_path\n\n    Groups files by their XML basename and returns data in dict format.\n\n    Parameters\n    ----------\n    zip_path : str\n        zip file path\n    Returns\n    -------\n    dict\n    \"\"\"\n    if file_utils.is_zipfile(zip_path):\n        with ZipFile(zip_path, 'r'):\n            data = _group_files_by_xml_filename(\n                zip_path,\n                file_utils.xml_files_list_from_zipfile(zip_path),\n                file_utils.files_list_from_zipfile(zip_path),\n            )\n            return data\n\n", "contexts_below": "\n def _eval_file(prefix, file_path):\n     \"\"\"\n     Identifica o tipo de arquivo do pacote: `asset` ou `rendition`.\n \n     Identifica o tipo de arquivo do pacote e atualiza `packages` com o tipo e\n     o endere\u00e7o do arquivo em an\u00e1lise.\n \n     Parameters\n     ----------\n     prefix : str\n         nome do arquivo XML sem extens\u00e3o\n     filename : str\n         filename\n     file_folder : str\n         file folder\n \n     Returns\n     -------\n     dict\n     \"\"\"\n     if not match_file_by_prefix(prefix, file_path):\n         # ignore files which name does not match\n         return\n     if file_path.endswith(\".xml\"):\n         # ignore XML files\n         return\n \n     # it matches\n     filename = os.path.basename(file_path)\n     fname, ext = os.path.splitext(filename)\n \n     lang = None\n     if ext == \".pdf\":\n         suffix = fname.replace(prefix, \"\")\n         if fname == prefix:\n             lang = \"original\"\n         elif len(suffix) == 3 and suffix[0] == \"-\":\n             # it is a rendition\n             lang = suffix[1:]\n \n     if lang:\n         return dict(\n             component_id=lang,\n             file_path=file_path,\n         )\n     else:\n         return dict(\n             component_id=filename,\n             component_name=fname,\n             ftype=ext[1:],\n             file_path=file_path,\n         )\n \n ", "input_code": "def _group_files_by_xml_filename(source, xmls, files):\n\"\"\"\nGroup files by their XML basename\n\nGroups files by their XML basename and returns data in dict format.\n\nParameters\n----------\nxml_filename : str\n    XML filenames\nfiles : list\n    list of files in the folder or zipfile\n\nReturns\n-------\ndict\n    key: name of the XML files\n    value: Package\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _group_files_by_xml_filename(source, xmls, files):\n    \"\"\"\n    Group files by their XML basename\n\n    Groups files by their XML basename and returns data in dict format.\n\n    Parameters\n    ----------\n    xml_filename : str\n        XML filenames\n    files : list\n        list of files in the folder or zipfile\n\n    Returns\n    -------\n    dict\n        key: name of the XML files\n        value: Package\n    \"\"\"\n    docs = {}\n    for xml in xmls:\n        basename = os.path.basename(xml)\n        prefix, ext = os.path.splitext(basename)\n\n        docs.setdefault(prefix, Package(source, prefix))\n\n        # XML\n        docs[prefix].xml = xml\n\n        for file in select_filenames_by_prefix(prefix, files):\n            # avalia arquivo do pacote, se \u00e9 asset ou rendition\n            component = _eval_file(prefix, file)\n            if not component:\n                continue\n\n            # resultado do avalia\u00e7\u00e3o do pacote\n            ftype = component.get(\"ftype\")\n            file_path = component[\"file_path\"]\n            comp_id = component[\"component_id\"]\n\n            if ftype:\n                docs[prefix].add_asset(comp_id, file_path)\n            else:\n                docs[prefix].add_rendition(comp_id, file_path)\n            files.remove(file)\n    return docs", "signature": "def _group_files_by_xml_filename(source, xmls, files):", "completion_path": "packtools/sps/models/packages.py"}
{"ce_id": "62b463153879012d1948149b", "namespace": "62b463153879012d1948149b", "namespace_real": "packtools.sps.models.packages.match_file_by_prefix", "real_proj_path": "scieloorg---packtools/", "type": "function", "class_name": null, "function_name": "match_file_by_prefix", "contexts_above": "import logging\nimport os\n\nfrom packtools import file_utils\nfrom zipfile import ZipFile\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Package:\n    def __init__(self, source, name):\n        self._source = source\n        self._xml = None\n        self._assets = {}\n        self._renditions = {}\n        self._name = name\n        self.zip_file_path = file_utils.is_zipfile(source) and source\n\n    @property\n    def assets(self):\n        return self._assets\n\n    @property\n    def name(self):\n        return self._name\n\n    def file_path(self, file_path):\n        if file_utils.is_folder(self._source):\n            return os.path.join(self._source, file_path)\n        return file_path\n\n    def add_asset(self, basename, file_path):\n        \"\"\"\n        \"{\n            \"artigo02-gf03.tiff\": \"/path/artigo02-gf03.tiff\",\n            \"artigo02-gf03.jpg\": \"/path/artigo02-gf03.jpg\",\n            \"artigo02-gf03.png\": \"/path/artigo02-gf03.png\",\n        }\n        \"\"\"\n        self._assets[basename] = self.file_path(file_path)\n\n    def get_asset(self, basename):\n        try:\n            return self._assets[basename]\n        except KeyError:\n            return\n\n    def add_rendition(self, lang, file_path):\n        \"\"\"\n        {\n            \"original\": \"artigo02.pdf\",\n            \"en\": \"artigo02-en.pdf\",\n        }\n        \"\"\"\n        self._renditions[lang] = self.file_path(file_path)\n\n    def get_rendition(self, lang):\n        try:\n            return self._renditions[lang]\n        except KeyError:\n            return\n\n    @property\n    def source(self):\n        return self._source\n\n    @property\n    def xml(self):\n        return self.file_path(self._xml)\n\n    @xml.setter\n    def xml(self, value):\n        self._xml = value\n\n    @property\n    def renditions(self):\n        return self._renditions\n\n    @property\n    def xml_content(self):\n        if file_utils.is_folder(self._source):\n            with open(self.xml, \"rb\") as fp:\n                return fp.read()\n        with ZipFile(self._source) as zf:\n            return zf.read(self.xml)\n\n\ndef select_filenames_by_prefix(prefix, files):\n    \"\"\"\n    Get files which belongs to a document package.\n\n    Retorna os arquivos da lista `files` cujos nomes iniciam com `prefix`\n\n    Parameters\n    ----------\n    prefix : str\n        Filename prefix\n    files : str list\n        Files paths\n    Returns\n    -------\n    list\n        files paths which basename files matches to prefix\n    \"\"\"\n    return [\n        item\n        for item in files\n        if match_file_by_prefix(prefix, item)\n    ]\n\n", "contexts_below": "\n def explore_source(source):\n     packages = _explore_zipfile(source)\n     if not packages:\n         packages = _explore_folder(source)\n     if not packages:\n         raise ValueError(\"%s: Invalid value for `source`\" % source)\n     return packages\n \n \n def _explore_folder(folder):\n     \"\"\"\n     Get packages' data from folder\n \n     Groups files by their XML basename and returns data in dict format.\n \n     Parameters\n     ----------\n     folder : str\n         Folder of the package\n     Returns\n     -------\n     dict\n     \"\"\"\n     if file_utils.is_folder(folder):\n         data = _group_files_by_xml_filename(\n             folder,\n             file_utils.xml_files_list(folder),\n             file_utils.files_list(folder),\n         )\n         return data\n \n \n def _explore_zipfile(zip_path):\n     \"\"\"\n     Get packages' data from zip_path\n \n     Groups files by their XML basename and returns data in dict format.\n \n     Parameters\n     ----------\n     zip_path : str\n         zip file path\n     Returns\n     -------\n     dict\n     \"\"\"\n     if file_utils.is_zipfile(zip_path):\n         with ZipFile(zip_path, 'r'):\n             data = _group_files_by_xml_filename(\n                 zip_path,\n                 file_utils.xml_files_list_from_zipfile(zip_path),\n                 file_utils.files_list_from_zipfile(zip_path),\n             )\n             return data\n \n \n def _group_files_by_xml_filename(source, xmls, files):\n     \"\"\"\n     Group files by their XML basename\n \n     Groups files by their XML basename and returns data in dict format.\n \n     Parameters\n     ----------\n     xml_filename : str\n         XML filenames\n     files : list\n         list of files in the folder or zipfile\n \n     Returns\n     -------\n     dict\n         key: name of the XML files\n         value: Package\n     \"\"\"\n     docs = {}\n     for xml in xmls:\n         basename = os.path.basename(xml)\n         prefix, ext = os.path.splitext(basename)\n \n         docs.setdefault(prefix, Package(source, prefix))\n \n         # XML\n         docs[prefix].xml = xml\n \n         for file in select_filenames_by_prefix(prefix, files):\n             # avalia arquivo do pacote, se \u00e9 asset ou rendition\n             component = _eval_file(prefix, file)\n             if not component:\n                 continue\n \n             # resultado do avalia\u00e7\u00e3o do pacote\n             ftype = component.get(\"ftype\")\n             file_path = component[\"file_path\"]\n             comp_id = component[\"component_id\"]\n \n             if ftype:\n                 docs[prefix].add_asset(comp_id, file_path)\n             else:\n                 docs[prefix].add_rendition(comp_id, file_path)\n             files.remove(file)\n     return docs\n \n \n def _eval_file(prefix, file_path):\n     \"\"\"\n     Identifica o tipo de arquivo do pacote: `asset` ou `rendition`.\n \n     Identifica o tipo de arquivo do pacote e atualiza `packages` com o tipo e\n     o endere\u00e7o do arquivo em an\u00e1lise.\n \n     Parameters\n     ----------\n     prefix : str\n         nome do arquivo XML sem extens\u00e3o\n     filename : str\n         filename\n     file_folder : str\n         file folder\n \n     Returns\n     -------\n     dict\n     \"\"\"\n     if not match_file_by_prefix(prefix, file_path):\n         # ignore files which name does not match\n         return\n     if file_path.endswith(\".xml\"):\n         # ignore XML files\n         return\n \n     # it matches\n     filename = os.path.basename(file_path)\n     fname, ext = os.path.splitext(filename)\n \n     lang = None\n     if ext == \".pdf\":\n         suffix = fname.replace(prefix, \"\")\n         if fname == prefix:\n             lang = \"original\"\n         elif len(suffix) == 3 and suffix[0] == \"-\":\n             # it is a rendition\n             lang = suffix[1:]\n \n     if lang:\n         return dict(\n             component_id=lang,\n             file_path=file_path,\n         )\n     else:\n         return dict(\n             component_id=filename,\n             component_name=fname,\n             ftype=ext[1:],\n             file_path=file_path,\n         )\n \n ", "input_code": "def match_file_by_prefix(prefix, file_path):\n\"\"\"\nIdentify if a `file_path` belongs to a document package by a given `prefix`\n\nRetorna `True` para documentos pertencentes a um pacote.\n\nParameters\n----------\nprefix : str\n    Filename prefix\nfile_path : str\n    File path\nReturns\n-------\nbool\n    True - file belongs to the package\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def match_file_by_prefix(prefix, file_path):\n    \"\"\"\n    Identify if a `file_path` belongs to a document package by a given `prefix`\n\n    Retorna `True` para documentos pertencentes a um pacote.\n\n    Parameters\n    ----------\n    prefix : str\n        Filename prefix\n    file_path : str\n        File path\n    Returns\n    -------\n    bool\n        True - file belongs to the package\n    \"\"\"\n    basename = os.path.basename(file_path)\n    if basename.startswith(prefix + \"-\"):\n        return True\n    if basename.startswith(prefix + \".\"):\n        return True\n    return False", "signature": "def match_file_by_prefix(prefix, file_path):", "completion_path": "packtools/sps/models/packages.py"}
{"ce_id": "62b463153879012d1948149c", "namespace": "62b463153879012d1948149c", "namespace_real": "packtools.sps.models.packages.select_filenames_by_prefix", "real_proj_path": "scieloorg---packtools/", "type": "function", "class_name": null, "function_name": "select_filenames_by_prefix", "contexts_above": "import logging\nimport os\n\nfrom packtools import file_utils\nfrom zipfile import ZipFile\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Package:\n    def __init__(self, source, name):\n        self._source = source\n        self._xml = None\n        self._assets = {}\n        self._renditions = {}\n        self._name = name\n        self.zip_file_path = file_utils.is_zipfile(source) and source\n\n    @property\n    def assets(self):\n        return self._assets\n\n    @property\n    def name(self):\n        return self._name\n\n    def file_path(self, file_path):\n        if file_utils.is_folder(self._source):\n            return os.path.join(self._source, file_path)\n        return file_path\n\n    def add_asset(self, basename, file_path):\n        \"\"\"\n        \"{\n            \"artigo02-gf03.tiff\": \"/path/artigo02-gf03.tiff\",\n            \"artigo02-gf03.jpg\": \"/path/artigo02-gf03.jpg\",\n            \"artigo02-gf03.png\": \"/path/artigo02-gf03.png\",\n        }\n        \"\"\"\n        self._assets[basename] = self.file_path(file_path)\n\n    def get_asset(self, basename):\n        try:\n            return self._assets[basename]\n        except KeyError:\n            return\n\n    def add_rendition(self, lang, file_path):\n        \"\"\"\n        {\n            \"original\": \"artigo02.pdf\",\n            \"en\": \"artigo02-en.pdf\",\n        }\n        \"\"\"\n        self._renditions[lang] = self.file_path(file_path)\n\n    def get_rendition(self, lang):\n        try:\n            return self._renditions[lang]\n        except KeyError:\n            return\n\n    @property\n    def source(self):\n        return self._source\n\n    @property\n    def xml(self):\n        return self.file_path(self._xml)\n\n    @xml.setter\n    def xml(self, value):\n        self._xml = value\n\n    @property\n    def renditions(self):\n        return self._renditions\n\n    @property\n    def xml_content(self):\n        if file_utils.is_folder(self._source):\n            with open(self.xml, \"rb\") as fp:\n                return fp.read()\n        with ZipFile(self._source) as zf:\n            return zf.read(self.xml)\n\n", "contexts_below": "\n def match_file_by_prefix(prefix, file_path):\n     \"\"\"\n     Identify if a `file_path` belongs to a document package by a given `prefix`\n \n     Retorna `True` para documentos pertencentes a um pacote.\n \n     Parameters\n     ----------\n     prefix : str\n         Filename prefix\n     file_path : str\n         File path\n     Returns\n     -------\n     bool\n         True - file belongs to the package\n     \"\"\"\n     basename = os.path.basename(file_path)\n     if basename.startswith(prefix + \"-\"):\n         return True\n     if basename.startswith(prefix + \".\"):\n         return True\n     return False\n \n \n def explore_source(source):\n     packages = _explore_zipfile(source)\n     if not packages:\n         packages = _explore_folder(source)\n     if not packages:\n         raise ValueError(\"%s: Invalid value for `source`\" % source)\n     return packages\n \n \n def _explore_folder(folder):\n     \"\"\"\n     Get packages' data from folder\n \n     Groups files by their XML basename and returns data in dict format.\n \n     Parameters\n     ----------\n     folder : str\n         Folder of the package\n     Returns\n     -------\n     dict\n     \"\"\"\n     if file_utils.is_folder(folder):\n         data = _group_files_by_xml_filename(\n             folder,\n             file_utils.xml_files_list(folder),\n             file_utils.files_list(folder),\n         )\n         return data\n \n \n def _explore_zipfile(zip_path):\n     \"\"\"\n     Get packages' data from zip_path\n \n     Groups files by their XML basename and returns data in dict format.\n \n     Parameters\n     ----------\n     zip_path : str\n         zip file path\n     Returns\n     -------\n     dict\n     \"\"\"\n     if file_utils.is_zipfile(zip_path):\n         with ZipFile(zip_path, 'r'):\n             data = _group_files_by_xml_filename(\n                 zip_path,\n                 file_utils.xml_files_list_from_zipfile(zip_path),\n                 file_utils.files_list_from_zipfile(zip_path),\n             )\n             return data\n \n \n def _group_files_by_xml_filename(source, xmls, files):\n     \"\"\"\n     Group files by their XML basename\n \n     Groups files by their XML basename and returns data in dict format.\n \n     Parameters\n     ----------\n     xml_filename : str\n         XML filenames\n     files : list\n         list of files in the folder or zipfile\n \n     Returns\n     -------\n     dict\n         key: name of the XML files\n         value: Package\n     \"\"\"\n     docs = {}\n     for xml in xmls:\n         basename = os.path.basename(xml)\n         prefix, ext = os.path.splitext(basename)\n \n         docs.setdefault(prefix, Package(source, prefix))\n \n         # XML\n         docs[prefix].xml = xml\n \n         for file in select_filenames_by_prefix(prefix, files):\n             # avalia arquivo do pacote, se \u00e9 asset ou rendition\n             component = _eval_file(prefix, file)\n             if not component:\n                 continue\n \n             # resultado do avalia\u00e7\u00e3o do pacote\n             ftype = component.get(\"ftype\")\n             file_path = component[\"file_path\"]\n             comp_id = component[\"component_id\"]\n \n             if ftype:\n                 docs[prefix].add_asset(comp_id, file_path)\n             else:\n                 docs[prefix].add_rendition(comp_id, file_path)\n             files.remove(file)\n     return docs\n \n \n def _eval_file(prefix, file_path):\n     \"\"\"\n     Identifica o tipo de arquivo do pacote: `asset` ou `rendition`.\n \n     Identifica o tipo de arquivo do pacote e atualiza `packages` com o tipo e\n     o endere\u00e7o do arquivo em an\u00e1lise.\n \n     Parameters\n     ----------\n     prefix : str\n         nome do arquivo XML sem extens\u00e3o\n     filename : str\n         filename\n     file_folder : str\n         file folder\n \n     Returns\n     -------\n     dict\n     \"\"\"\n     if not match_file_by_prefix(prefix, file_path):\n         # ignore files which name does not match\n         return\n     if file_path.endswith(\".xml\"):\n         # ignore XML files\n         return\n \n     # it matches\n     filename = os.path.basename(file_path)\n     fname, ext = os.path.splitext(filename)\n \n     lang = None\n     if ext == \".pdf\":\n         suffix = fname.replace(prefix, \"\")\n         if fname == prefix:\n             lang = \"original\"\n         elif len(suffix) == 3 and suffix[0] == \"-\":\n             # it is a rendition\n             lang = suffix[1:]\n \n     if lang:\n         return dict(\n             component_id=lang,\n             file_path=file_path,\n         )\n     else:\n         return dict(\n             component_id=filename,\n             component_name=fname,\n             ftype=ext[1:],\n             file_path=file_path,\n         )\n \n ", "input_code": "def select_filenames_by_prefix(prefix, files):\n\"\"\"\nGet files which belongs to a document package.\n\nRetorna os arquivos da lista `files` cujos nomes iniciam com `prefix`\n\nParameters\n----------\nprefix : str\n    Filename prefix\nfiles : str list\n    Files paths\nReturns\n-------\nlist\n    files paths which basename files matches to prefix\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def select_filenames_by_prefix(prefix, files):\n    \"\"\"\n    Get files which belongs to a document package.\n\n    Retorna os arquivos da lista `files` cujos nomes iniciam com `prefix`\n\n    Parameters\n    ----------\n    prefix : str\n        Filename prefix\n    files : str list\n        Files paths\n    Returns\n    -------\n    list\n        files paths which basename files matches to prefix\n    \"\"\"\n    return [\n        item\n        for item in files\n        if match_file_by_prefix(prefix, item)\n    ]", "signature": "def select_filenames_by_prefix(prefix, files):", "completion_path": "packtools/sps/models/packages.py"}
{"ce_id": "62b463153879012d1948149d", "namespace": "62b463153879012d1948149d", "namespace_real": "packtools.sps.models.packages._explore_folder", "real_proj_path": "scieloorg---packtools/", "type": "function", "class_name": null, "function_name": "_explore_folder", "contexts_above": "import logging\nimport os\n\nfrom packtools import file_utils\nfrom zipfile import ZipFile\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Package:\n    def __init__(self, source, name):\n        self._source = source\n        self._xml = None\n        self._assets = {}\n        self._renditions = {}\n        self._name = name\n        self.zip_file_path = file_utils.is_zipfile(source) and source\n\n    @property\n    def assets(self):\n        return self._assets\n\n    @property\n    def name(self):\n        return self._name\n\n    def file_path(self, file_path):\n        if file_utils.is_folder(self._source):\n            return os.path.join(self._source, file_path)\n        return file_path\n\n    def add_asset(self, basename, file_path):\n        \"\"\"\n        \"{\n            \"artigo02-gf03.tiff\": \"/path/artigo02-gf03.tiff\",\n            \"artigo02-gf03.jpg\": \"/path/artigo02-gf03.jpg\",\n            \"artigo02-gf03.png\": \"/path/artigo02-gf03.png\",\n        }\n        \"\"\"\n        self._assets[basename] = self.file_path(file_path)\n\n    def get_asset(self, basename):\n        try:\n            return self._assets[basename]\n        except KeyError:\n            return\n\n    def add_rendition(self, lang, file_path):\n        \"\"\"\n        {\n            \"original\": \"artigo02.pdf\",\n            \"en\": \"artigo02-en.pdf\",\n        }\n        \"\"\"\n        self._renditions[lang] = self.file_path(file_path)\n\n    def get_rendition(self, lang):\n        try:\n            return self._renditions[lang]\n        except KeyError:\n            return\n\n    @property\n    def source(self):\n        return self._source\n\n    @property\n    def xml(self):\n        return self.file_path(self._xml)\n\n    @xml.setter\n    def xml(self, value):\n        self._xml = value\n\n    @property\n    def renditions(self):\n        return self._renditions\n\n    @property\n    def xml_content(self):\n        if file_utils.is_folder(self._source):\n            with open(self.xml, \"rb\") as fp:\n                return fp.read()\n        with ZipFile(self._source) as zf:\n            return zf.read(self.xml)\n\n\ndef select_filenames_by_prefix(prefix, files):\n    \"\"\"\n    Get files which belongs to a document package.\n\n    Retorna os arquivos da lista `files` cujos nomes iniciam com `prefix`\n\n    Parameters\n    ----------\n    prefix : str\n        Filename prefix\n    files : str list\n        Files paths\n    Returns\n    -------\n    list\n        files paths which basename files matches to prefix\n    \"\"\"\n    return [\n        item\n        for item in files\n        if match_file_by_prefix(prefix, item)\n    ]\n\n\ndef match_file_by_prefix(prefix, file_path):\n    \"\"\"\n    Identify if a `file_path` belongs to a document package by a given `prefix`\n\n    Retorna `True` para documentos pertencentes a um pacote.\n\n    Parameters\n    ----------\n    prefix : str\n        Filename prefix\n    file_path : str\n        File path\n    Returns\n    -------\n    bool\n        True - file belongs to the package\n    \"\"\"\n    basename = os.path.basename(file_path)\n    if basename.startswith(prefix + \"-\"):\n        return True\n    if basename.startswith(prefix + \".\"):\n        return True\n    return False\n\n\ndef explore_source(source):\n    packages = _explore_zipfile(source)\n    if not packages:\n        packages = _explore_folder(source)\n    if not packages:\n        raise ValueError(\"%s: Invalid value for `source`\" % source)\n    return packages\n\n", "contexts_below": "\n def _explore_zipfile(zip_path):\n     \"\"\"\n     Get packages' data from zip_path\n \n     Groups files by their XML basename and returns data in dict format.\n \n     Parameters\n     ----------\n     zip_path : str\n         zip file path\n     Returns\n     -------\n     dict\n     \"\"\"\n     if file_utils.is_zipfile(zip_path):\n         with ZipFile(zip_path, 'r'):\n             data = _group_files_by_xml_filename(\n                 zip_path,\n                 file_utils.xml_files_list_from_zipfile(zip_path),\n                 file_utils.files_list_from_zipfile(zip_path),\n             )\n             return data\n \n \n def _group_files_by_xml_filename(source, xmls, files):\n     \"\"\"\n     Group files by their XML basename\n \n     Groups files by their XML basename and returns data in dict format.\n \n     Parameters\n     ----------\n     xml_filename : str\n         XML filenames\n     files : list\n         list of files in the folder or zipfile\n \n     Returns\n     -------\n     dict\n         key: name of the XML files\n         value: Package\n     \"\"\"\n     docs = {}\n     for xml in xmls:\n         basename = os.path.basename(xml)\n         prefix, ext = os.path.splitext(basename)\n \n         docs.setdefault(prefix, Package(source, prefix))\n \n         # XML\n         docs[prefix].xml = xml\n \n         for file in select_filenames_by_prefix(prefix, files):\n             # avalia arquivo do pacote, se \u00e9 asset ou rendition\n             component = _eval_file(prefix, file)\n             if not component:\n                 continue\n \n             # resultado do avalia\u00e7\u00e3o do pacote\n             ftype = component.get(\"ftype\")\n             file_path = component[\"file_path\"]\n             comp_id = component[\"component_id\"]\n \n             if ftype:\n                 docs[prefix].add_asset(comp_id, file_path)\n             else:\n                 docs[prefix].add_rendition(comp_id, file_path)\n             files.remove(file)\n     return docs\n \n \n def _eval_file(prefix, file_path):\n     \"\"\"\n     Identifica o tipo de arquivo do pacote: `asset` ou `rendition`.\n \n     Identifica o tipo de arquivo do pacote e atualiza `packages` com o tipo e\n     o endere\u00e7o do arquivo em an\u00e1lise.\n \n     Parameters\n     ----------\n     prefix : str\n         nome do arquivo XML sem extens\u00e3o\n     filename : str\n         filename\n     file_folder : str\n         file folder\n \n     Returns\n     -------\n     dict\n     \"\"\"\n     if not match_file_by_prefix(prefix, file_path):\n         # ignore files which name does not match\n         return\n     if file_path.endswith(\".xml\"):\n         # ignore XML files\n         return\n \n     # it matches\n     filename = os.path.basename(file_path)\n     fname, ext = os.path.splitext(filename)\n \n     lang = None\n     if ext == \".pdf\":\n         suffix = fname.replace(prefix, \"\")\n         if fname == prefix:\n             lang = \"original\"\n         elif len(suffix) == 3 and suffix[0] == \"-\":\n             # it is a rendition\n             lang = suffix[1:]\n \n     if lang:\n         return dict(\n             component_id=lang,\n             file_path=file_path,\n         )\n     else:\n         return dict(\n             component_id=filename,\n             component_name=fname,\n             ftype=ext[1:],\n             file_path=file_path,\n         )\n \n ", "input_code": "def _explore_folder(folder):\n\"\"\"\nGet packages' data from folder\n\nGroups files by their XML basename and returns data in dict format.\n\nParameters\n----------\nfolder : str\n    Folder of the package\nReturns\n-------\ndict\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _explore_folder(folder):\n    \"\"\"\n    Get packages' data from folder\n\n    Groups files by their XML basename and returns data in dict format.\n\n    Parameters\n    ----------\n    folder : str\n        Folder of the package\n    Returns\n    -------\n    dict\n    \"\"\"\n    if file_utils.is_folder(folder):\n        data = _group_files_by_xml_filename(\n            folder,\n            file_utils.xml_files_list(folder),\n            file_utils.files_list(folder),\n        )\n        return data", "signature": "def _explore_folder(folder):", "completion_path": "packtools/sps/models/packages.py"}
{"ce_id": "62b463153879012d1948149f", "namespace": "62b463153879012d1948149f", "namespace_real": "packtools.sps.models.packages._eval_file", "real_proj_path": "scieloorg---packtools/", "type": "function", "class_name": null, "function_name": "_eval_file", "contexts_above": "import logging\nimport os\n\nfrom packtools import file_utils\nfrom zipfile import ZipFile\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Package:\n    def __init__(self, source, name):\n        self._source = source\n        self._xml = None\n        self._assets = {}\n        self._renditions = {}\n        self._name = name\n        self.zip_file_path = file_utils.is_zipfile(source) and source\n\n    @property\n    def assets(self):\n        return self._assets\n\n    @property\n    def name(self):\n        return self._name\n\n    def file_path(self, file_path):\n        if file_utils.is_folder(self._source):\n            return os.path.join(self._source, file_path)\n        return file_path\n\n    def add_asset(self, basename, file_path):\n        \"\"\"\n        \"{\n            \"artigo02-gf03.tiff\": \"/path/artigo02-gf03.tiff\",\n            \"artigo02-gf03.jpg\": \"/path/artigo02-gf03.jpg\",\n            \"artigo02-gf03.png\": \"/path/artigo02-gf03.png\",\n        }\n        \"\"\"\n        self._assets[basename] = self.file_path(file_path)\n\n    def get_asset(self, basename):\n        try:\n            return self._assets[basename]\n        except KeyError:\n            return\n\n    def add_rendition(self, lang, file_path):\n        \"\"\"\n        {\n            \"original\": \"artigo02.pdf\",\n            \"en\": \"artigo02-en.pdf\",\n        }\n        \"\"\"\n        self._renditions[lang] = self.file_path(file_path)\n\n    def get_rendition(self, lang):\n        try:\n            return self._renditions[lang]\n        except KeyError:\n            return\n\n    @property\n    def source(self):\n        return self._source\n\n    @property\n    def xml(self):\n        return self.file_path(self._xml)\n\n    @xml.setter\n    def xml(self, value):\n        self._xml = value\n\n    @property\n    def renditions(self):\n        return self._renditions\n\n    @property\n    def xml_content(self):\n        if file_utils.is_folder(self._source):\n            with open(self.xml, \"rb\") as fp:\n                return fp.read()\n        with ZipFile(self._source) as zf:\n            return zf.read(self.xml)\n\n\ndef select_filenames_by_prefix(prefix, files):\n    \"\"\"\n    Get files which belongs to a document package.\n\n    Retorna os arquivos da lista `files` cujos nomes iniciam com `prefix`\n\n    Parameters\n    ----------\n    prefix : str\n        Filename prefix\n    files : str list\n        Files paths\n    Returns\n    -------\n    list\n        files paths which basename files matches to prefix\n    \"\"\"\n    return [\n        item\n        for item in files\n        if match_file_by_prefix(prefix, item)\n    ]\n\n\ndef match_file_by_prefix(prefix, file_path):\n    \"\"\"\n    Identify if a `file_path` belongs to a document package by a given `prefix`\n\n    Retorna `True` para documentos pertencentes a um pacote.\n\n    Parameters\n    ----------\n    prefix : str\n        Filename prefix\n    file_path : str\n        File path\n    Returns\n    -------\n    bool\n        True - file belongs to the package\n    \"\"\"\n    basename = os.path.basename(file_path)\n    if basename.startswith(prefix + \"-\"):\n        return True\n    if basename.startswith(prefix + \".\"):\n        return True\n    return False\n\n\ndef explore_source(source):\n    packages = _explore_zipfile(source)\n    if not packages:\n        packages = _explore_folder(source)\n    if not packages:\n        raise ValueError(\"%s: Invalid value for `source`\" % source)\n    return packages\n\n\ndef _explore_folder(folder):\n    \"\"\"\n    Get packages' data from folder\n\n    Groups files by their XML basename and returns data in dict format.\n\n    Parameters\n    ----------\n    folder : str\n        Folder of the package\n    Returns\n    -------\n    dict\n    \"\"\"\n    if file_utils.is_folder(folder):\n        data = _group_files_by_xml_filename(\n            folder,\n            file_utils.xml_files_list(folder),\n            file_utils.files_list(folder),\n        )\n        return data\n\n\ndef _explore_zipfile(zip_path):\n    \"\"\"\n    Get packages' data from zip_path\n\n    Groups files by their XML basename and returns data in dict format.\n\n    Parameters\n    ----------\n    zip_path : str\n        zip file path\n    Returns\n    -------\n    dict\n    \"\"\"\n    if file_utils.is_zipfile(zip_path):\n        with ZipFile(zip_path, 'r'):\n            data = _group_files_by_xml_filename(\n                zip_path,\n                file_utils.xml_files_list_from_zipfile(zip_path),\n                file_utils.files_list_from_zipfile(zip_path),\n            )\n            return data\n\n\ndef _group_files_by_xml_filename(source, xmls, files):\n    \"\"\"\n    Group files by their XML basename\n\n    Groups files by their XML basename and returns data in dict format.\n\n    Parameters\n    ----------\n    xml_filename : str\n        XML filenames\n    files : list\n        list of files in the folder or zipfile\n\n    Returns\n    -------\n    dict\n        key: name of the XML files\n        value: Package\n    \"\"\"\n    docs = {}\n    for xml in xmls:\n        basename = os.path.basename(xml)\n        prefix, ext = os.path.splitext(basename)\n\n        docs.setdefault(prefix, Package(source, prefix))\n\n        # XML\n        docs[prefix].xml = xml\n\n        for file in select_filenames_by_prefix(prefix, files):\n            # avalia arquivo do pacote, se \u00e9 asset ou rendition\n            component = _eval_file(prefix, file)\n            if not component:\n                continue\n\n            # resultado do avalia\u00e7\u00e3o do pacote\n            ftype = component.get(\"ftype\")\n            file_path = component[\"file_path\"]\n            comp_id = component[\"component_id\"]\n\n            if ftype:\n                docs[prefix].add_asset(comp_id, file_path)\n            else:\n                docs[prefix].add_rendition(comp_id, file_path)\n            files.remove(file)\n    return docs\n\n", "contexts_below": "", "input_code": "def _eval_file(prefix, file_path):\n\"\"\"\nIdentifica o tipo de arquivo do pacote: `asset` ou `rendition`.\n\nIdentifica o tipo de arquivo do pacote e atualiza `packages` com o tipo e\no endere\u00e7o do arquivo em an\u00e1lise.\n\nParameters\n----------\nprefix : str\n    nome do arquivo XML sem extens\u00e3o\nfilename : str\n    filename\nfile_folder : str\n    file folder\n\nReturns\n-------\ndict\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _eval_file(prefix, file_path):\n    \"\"\"\n    Identifica o tipo de arquivo do pacote: `asset` ou `rendition`.\n\n    Identifica o tipo de arquivo do pacote e atualiza `packages` com o tipo e\n    o endere\u00e7o do arquivo em an\u00e1lise.\n\n    Parameters\n    ----------\n    prefix : str\n        nome do arquivo XML sem extens\u00e3o\n    filename : str\n        filename\n    file_folder : str\n        file folder\n\n    Returns\n    -------\n    dict\n    \"\"\"\n    if not match_file_by_prefix(prefix, file_path):\n        # ignore files which name does not match\n        return\n    if file_path.endswith(\".xml\"):\n        # ignore XML files\n        return\n\n    # it matches\n    filename = os.path.basename(file_path)\n    fname, ext = os.path.splitext(filename)\n\n    lang = None\n    if ext == \".pdf\":\n        suffix = fname.replace(prefix, \"\")\n        if fname == prefix:\n            lang = \"original\"\n        elif len(suffix) == 3 and suffix[0] == \"-\":\n            # it is a rendition\n            lang = suffix[1:]\n\n    if lang:\n        return dict(\n            component_id=lang,\n            file_path=file_path,\n        )\n    else:\n        return dict(\n            component_id=filename,\n            component_name=fname,\n            ftype=ext[1:],\n            file_path=file_path,\n        )", "signature": "def _eval_file(prefix, file_path):", "completion_path": "packtools/sps/models/packages.py"}
{"ce_id": "62b463153879012d194814a1", "namespace": "62b463153879012d194814a1", "namespace_real": "packtools.sps.models.packages.add_rendition", "real_proj_path": "scieloorg---packtools/", "type": "class", "class_name": "packages", "function_name": "add_rendition", "contexts_above": "import logging\nimport os\n\nfrom packtools import file_utils\nfrom zipfile import ZipFile\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Package:\n    def __init__(self, source, name):\n        self._source = source\n        self._xml = None\n        self._assets = {}\n        self._renditions = {}\n        self._name = name\n        self.zip_file_path = file_utils.is_zipfile(source) and source\n\n    @property\n    def assets(self):\n        return self._assets\n\n    @property\n    def name(self):\n        return self._name\n\n    def file_path(self, file_path):\n        if file_utils.is_folder(self._source):\n            return os.path.join(self._source, file_path)\n        return file_path\n\n    def add_asset(self, basename, file_path):\n        \"\"\"\n        \"{\n            \"artigo02-gf03.tiff\": \"/path/artigo02-gf03.tiff\",\n            \"artigo02-gf03.jpg\": \"/path/artigo02-gf03.jpg\",\n            \"artigo02-gf03.png\": \"/path/artigo02-gf03.png\",\n        }\n        \"\"\"\n        self._assets[basename] = self.file_path(file_path)\n\n    def get_asset(self, basename):\n        try:\n            return self._assets[basename]\n        except KeyError:\n            return\n", "contexts_below": "    def get_rendition(self, lang):\n         try:\n             return self._renditions[lang]\n         except KeyError:\n             return\n \n     @property\n     def source(self):\n         return self._source\n \n     @property\n     def xml(self):\n         return self.file_path(self._xml)\n \n     @xml.setter\n     def xml(self, value):\n         self._xml = value\n \n     @property\n     def renditions(self):\n         return self._renditions\n \n     @property\n     def xml_content(self):\n         if file_utils.is_folder(self._source):\n             with open(self.xml, \"rb\") as fp:\n                 return fp.read()\n         with ZipFile(self._source) as zf:\n             return zf.read(self.xml)\n \n \n def select_filenames_by_prefix(prefix, files):\n     \"\"\"\n     Get files which belongs to a document package.\n \n     Retorna os arquivos da lista `files` cujos nomes iniciam com `prefix`\n \n     Parameters\n     ----------\n     prefix : str\n         Filename prefix\n     files : str list\n         Files paths\n     Returns\n     -------\n     list\n         files paths which basename files matches to prefix\n     \"\"\"\n     return [\n         item\n         for item in files\n         if match_file_by_prefix(prefix, item)\n     ]\n \n \n def match_file_by_prefix(prefix, file_path):\n     \"\"\"\n     Identify if a `file_path` belongs to a document package by a given `prefix`\n \n     Retorna `True` para documentos pertencentes a um pacote.\n \n     Parameters\n     ----------\n     prefix : str\n         Filename prefix\n     file_path : str\n         File path\n     Returns\n     -------\n     bool\n         True - file belongs to the package\n     \"\"\"\n     basename = os.path.basename(file_path)\n     if basename.startswith(prefix + \"-\"):\n         return True\n     if basename.startswith(prefix + \".\"):\n         return True\n     return False\n \n \n def explore_source(source):\n     packages = _explore_zipfile(source)\n     if not packages:\n         packages = _explore_folder(source)\n     if not packages:\n         raise ValueError(\"%s: Invalid value for `source`\" % source)\n     return packages\n \n \n def _explore_folder(folder):\n     \"\"\"\n     Get packages' data from folder\n \n     Groups files by their XML basename and returns data in dict format.\n \n     Parameters\n     ----------\n     folder : str\n         Folder of the package\n     Returns\n     -------\n     dict\n     \"\"\"\n     if file_utils.is_folder(folder):\n         data = _group_files_by_xml_filename(\n             folder,\n             file_utils.xml_files_list(folder),\n             file_utils.files_list(folder),\n         )\n         return data\n \n \n def _explore_zipfile(zip_path):\n     \"\"\"\n     Get packages' data from zip_path\n \n     Groups files by their XML basename and returns data in dict format.\n \n     Parameters\n     ----------\n     zip_path : str\n         zip file path\n     Returns\n     -------\n     dict\n     \"\"\"\n     if file_utils.is_zipfile(zip_path):\n         with ZipFile(zip_path, 'r'):\n             data = _group_files_by_xml_filename(\n                 zip_path,\n                 file_utils.xml_files_list_from_zipfile(zip_path),\n                 file_utils.files_list_from_zipfile(zip_path),\n             )\n             return data\n \n \n def _group_files_by_xml_filename(source, xmls, files):\n     \"\"\"\n     Group files by their XML basename\n \n     Groups files by their XML basename and returns data in dict format.\n \n     Parameters\n     ----------\n     xml_filename : str\n         XML filenames\n     files : list\n         list of files in the folder or zipfile\n \n     Returns\n     -------\n     dict\n         key: name of the XML files\n         value: Package\n     \"\"\"\n     docs = {}\n     for xml in xmls:\n         basename = os.path.basename(xml)\n         prefix, ext = os.path.splitext(basename)\n \n         docs.setdefault(prefix, Package(source, prefix))\n \n         # XML\n         docs[prefix].xml = xml\n \n         for file in select_filenames_by_prefix(prefix, files):\n             # avalia arquivo do pacote, se \u00e9 asset ou rendition\n             component = _eval_file(prefix, file)\n             if not component:\n                 continue\n \n             # resultado do avalia\u00e7\u00e3o do pacote\n             ftype = component.get(\"ftype\")\n             file_path = component[\"file_path\"]\n             comp_id = component[\"component_id\"]\n \n             if ftype:\n                 docs[prefix].add_asset(comp_id, file_path)\n             else:\n                 docs[prefix].add_rendition(comp_id, file_path)\n             files.remove(file)\n     return docs\n \n \n def _eval_file(prefix, file_path):\n     \"\"\"\n     Identifica o tipo de arquivo do pacote: `asset` ou `rendition`.\n \n     Identifica o tipo de arquivo do pacote e atualiza `packages` com o tipo e\n     o endere\u00e7o do arquivo em an\u00e1lise.\n \n     Parameters\n     ----------\n     prefix : str\n         nome do arquivo XML sem extens\u00e3o\n     filename : str\n         filename\n     file_folder : str\n         file folder\n \n     Returns\n     -------\n     dict\n     \"\"\"\n     if not match_file_by_prefix(prefix, file_path):\n         # ignore files which name does not match\n         return\n     if file_path.endswith(\".xml\"):\n         # ignore XML files\n         return\n \n     # it matches\n     filename = os.path.basename(file_path)\n     fname, ext = os.path.splitext(filename)\n \n     lang = None\n     if ext == \".pdf\":\n         suffix = fname.replace(prefix, \"\")\n         if fname == prefix:\n             lang = \"original\"\n         elif len(suffix) == 3 and suffix[0] == \"-\":\n             # it is a rendition\n             lang = suffix[1:]\n \n     if lang:\n         return dict(\n             component_id=lang,\n             file_path=file_path,\n         )\n     else:\n         return dict(\n             component_id=filename,\n             component_name=fname,\n             ftype=ext[1:],\n             file_path=file_path,\n         )\n \n ", "input_code": "def add_rendition(self, lang, file_path):\n\"\"\"\n{\n    \"original\": \"artigo02.pdf\",\n    \"en\": \"artigo02-en.pdf\",\n}\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def add_rendition(self, lang, file_path):\n        \"\"\"\n        {\n            \"original\": \"artigo02.pdf\",\n            \"en\": \"artigo02-en.pdf\",\n        }\n        \"\"\"\n        self._renditions[lang] = self.file_path(file_path)", "signature": "def add_rendition(self, lang, file_path):", "completion_path": "packtools/sps/models/packages.py"}
{"ce_id": "62b463163879012d194814a2", "namespace": "62b463163879012d194814a2", "namespace_real": "packtools.sps.models.packages.add_asset", "real_proj_path": "scieloorg---packtools/", "type": "class", "class_name": "packages", "function_name": "add_asset", "contexts_above": "import logging\nimport os\n\nfrom packtools import file_utils\nfrom zipfile import ZipFile\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Package:\n    def __init__(self, source, name):\n        self._source = source\n        self._xml = None\n        self._assets = {}\n        self._renditions = {}\n        self._name = name\n        self.zip_file_path = file_utils.is_zipfile(source) and source\n\n    @property\n    def assets(self):\n        return self._assets\n\n    @property\n    def name(self):\n        return self._name\n\n    def file_path(self, file_path):\n        if file_utils.is_folder(self._source):\n            return os.path.join(self._source, file_path)\n        return file_path\n", "contexts_below": "    def get_asset(self, basename):\n         try:\n             return self._assets[basename]\n         except KeyError:\n             return\n \n     def add_rendition(self, lang, file_path):\n         \"\"\"\n         {\n             \"original\": \"artigo02.pdf\",\n             \"en\": \"artigo02-en.pdf\",\n         }\n         \"\"\"\n         self._renditions[lang] = self.file_path(file_path)\n \n     def get_rendition(self, lang):\n         try:\n             return self._renditions[lang]\n         except KeyError:\n             return\n \n     @property\n     def source(self):\n         return self._source\n \n     @property\n     def xml(self):\n         return self.file_path(self._xml)\n \n     @xml.setter\n     def xml(self, value):\n         self._xml = value\n \n     @property\n     def renditions(self):\n         return self._renditions\n \n     @property\n     def xml_content(self):\n         if file_utils.is_folder(self._source):\n             with open(self.xml, \"rb\") as fp:\n                 return fp.read()\n         with ZipFile(self._source) as zf:\n             return zf.read(self.xml)\n \n \n def select_filenames_by_prefix(prefix, files):\n     \"\"\"\n     Get files which belongs to a document package.\n \n     Retorna os arquivos da lista `files` cujos nomes iniciam com `prefix`\n \n     Parameters\n     ----------\n     prefix : str\n         Filename prefix\n     files : str list\n         Files paths\n     Returns\n     -------\n     list\n         files paths which basename files matches to prefix\n     \"\"\"\n     return [\n         item\n         for item in files\n         if match_file_by_prefix(prefix, item)\n     ]\n \n \n def match_file_by_prefix(prefix, file_path):\n     \"\"\"\n     Identify if a `file_path` belongs to a document package by a given `prefix`\n \n     Retorna `True` para documentos pertencentes a um pacote.\n \n     Parameters\n     ----------\n     prefix : str\n         Filename prefix\n     file_path : str\n         File path\n     Returns\n     -------\n     bool\n         True - file belongs to the package\n     \"\"\"\n     basename = os.path.basename(file_path)\n     if basename.startswith(prefix + \"-\"):\n         return True\n     if basename.startswith(prefix + \".\"):\n         return True\n     return False\n \n \n def explore_source(source):\n     packages = _explore_zipfile(source)\n     if not packages:\n         packages = _explore_folder(source)\n     if not packages:\n         raise ValueError(\"%s: Invalid value for `source`\" % source)\n     return packages\n \n \n def _explore_folder(folder):\n     \"\"\"\n     Get packages' data from folder\n \n     Groups files by their XML basename and returns data in dict format.\n \n     Parameters\n     ----------\n     folder : str\n         Folder of the package\n     Returns\n     -------\n     dict\n     \"\"\"\n     if file_utils.is_folder(folder):\n         data = _group_files_by_xml_filename(\n             folder,\n             file_utils.xml_files_list(folder),\n             file_utils.files_list(folder),\n         )\n         return data\n \n \n def _explore_zipfile(zip_path):\n     \"\"\"\n     Get packages' data from zip_path\n \n     Groups files by their XML basename and returns data in dict format.\n \n     Parameters\n     ----------\n     zip_path : str\n         zip file path\n     Returns\n     -------\n     dict\n     \"\"\"\n     if file_utils.is_zipfile(zip_path):\n         with ZipFile(zip_path, 'r'):\n             data = _group_files_by_xml_filename(\n                 zip_path,\n                 file_utils.xml_files_list_from_zipfile(zip_path),\n                 file_utils.files_list_from_zipfile(zip_path),\n             )\n             return data\n \n \n def _group_files_by_xml_filename(source, xmls, files):\n     \"\"\"\n     Group files by their XML basename\n \n     Groups files by their XML basename and returns data in dict format.\n \n     Parameters\n     ----------\n     xml_filename : str\n         XML filenames\n     files : list\n         list of files in the folder or zipfile\n \n     Returns\n     -------\n     dict\n         key: name of the XML files\n         value: Package\n     \"\"\"\n     docs = {}\n     for xml in xmls:\n         basename = os.path.basename(xml)\n         prefix, ext = os.path.splitext(basename)\n \n         docs.setdefault(prefix, Package(source, prefix))\n \n         # XML\n         docs[prefix].xml = xml\n \n         for file in select_filenames_by_prefix(prefix, files):\n             # avalia arquivo do pacote, se \u00e9 asset ou rendition\n             component = _eval_file(prefix, file)\n             if not component:\n                 continue\n \n             # resultado do avalia\u00e7\u00e3o do pacote\n             ftype = component.get(\"ftype\")\n             file_path = component[\"file_path\"]\n             comp_id = component[\"component_id\"]\n \n             if ftype:\n                 docs[prefix].add_asset(comp_id, file_path)\n             else:\n                 docs[prefix].add_rendition(comp_id, file_path)\n             files.remove(file)\n     return docs\n \n \n def _eval_file(prefix, file_path):\n     \"\"\"\n     Identifica o tipo de arquivo do pacote: `asset` ou `rendition`.\n \n     Identifica o tipo de arquivo do pacote e atualiza `packages` com o tipo e\n     o endere\u00e7o do arquivo em an\u00e1lise.\n \n     Parameters\n     ----------\n     prefix : str\n         nome do arquivo XML sem extens\u00e3o\n     filename : str\n         filename\n     file_folder : str\n         file folder\n \n     Returns\n     -------\n     dict\n     \"\"\"\n     if not match_file_by_prefix(prefix, file_path):\n         # ignore files which name does not match\n         return\n     if file_path.endswith(\".xml\"):\n         # ignore XML files\n         return\n \n     # it matches\n     filename = os.path.basename(file_path)\n     fname, ext = os.path.splitext(filename)\n \n     lang = None\n     if ext == \".pdf\":\n         suffix = fname.replace(prefix, \"\")\n         if fname == prefix:\n             lang = \"original\"\n         elif len(suffix) == 3 and suffix[0] == \"-\":\n             # it is a rendition\n             lang = suffix[1:]\n \n     if lang:\n         return dict(\n             component_id=lang,\n             file_path=file_path,\n         )\n     else:\n         return dict(\n             component_id=filename,\n             component_name=fname,\n             ftype=ext[1:],\n             file_path=file_path,\n         )\n \n ", "input_code": "def add_asset(self, basename, file_path):\n\"\"\"\n\"{\n    \"artigo02-gf03.tiff\": \"/path/artigo02-gf03.tiff\",\n    \"artigo02-gf03.jpg\": \"/path/artigo02-gf03.jpg\",\n    \"artigo02-gf03.png\": \"/path/artigo02-gf03.png\",\n}\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def add_asset(self, basename, file_path):\n        \"\"\"\n        \"{\n            \"artigo02-gf03.tiff\": \"/path/artigo02-gf03.tiff\",\n            \"artigo02-gf03.jpg\": \"/path/artigo02-gf03.jpg\",\n            \"artigo02-gf03.png\": \"/path/artigo02-gf03.png\",\n        }\n        \"\"\"\n        self._assets[basename] = self.file_path(file_path)", "signature": "def add_asset(self, basename, file_path):", "completion_path": "packtools/sps/models/packages.py"}
{"ce_id": "62b463163879012d194814a4", "namespace": "62b463163879012d194814a4", "namespace_real": "packtools.sps.models.packages._explore_zipfile", "real_proj_path": "scieloorg---packtools/", "type": "function", "class_name": null, "function_name": "_explore_zipfile", "contexts_above": "import logging\nimport os\n\nfrom packtools import file_utils\nfrom zipfile import ZipFile\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Package:\n    def __init__(self, source, name):\n        self._source = source\n        self._xml = None\n        self._assets = {}\n        self._renditions = {}\n        self._name = name\n        self.zip_file_path = file_utils.is_zipfile(source) and source\n\n    @property\n    def assets(self):\n        return self._assets\n\n    @property\n    def name(self):\n        return self._name\n\n    def file_path(self, file_path):\n        if file_utils.is_folder(self._source):\n            return os.path.join(self._source, file_path)\n        return file_path\n\n    def add_asset(self, basename, file_path):\n        \"\"\"\n        \"{\n            \"artigo02-gf03.tiff\": \"/path/artigo02-gf03.tiff\",\n            \"artigo02-gf03.jpg\": \"/path/artigo02-gf03.jpg\",\n            \"artigo02-gf03.png\": \"/path/artigo02-gf03.png\",\n        }\n        \"\"\"\n        self._assets[basename] = self.file_path(file_path)\n\n    def get_asset(self, basename):\n        try:\n            return self._assets[basename]\n        except KeyError:\n            return\n\n    def add_rendition(self, lang, file_path):\n        \"\"\"\n        {\n            \"original\": \"artigo02.pdf\",\n            \"en\": \"artigo02-en.pdf\",\n        }\n        \"\"\"\n        self._renditions[lang] = self.file_path(file_path)\n\n    def get_rendition(self, lang):\n        try:\n            return self._renditions[lang]\n        except KeyError:\n            return\n\n    @property\n    def source(self):\n        return self._source\n\n    @property\n    def xml(self):\n        return self.file_path(self._xml)\n\n    @xml.setter\n    def xml(self, value):\n        self._xml = value\n\n    @property\n    def renditions(self):\n        return self._renditions\n\n    @property\n    def xml_content(self):\n        if file_utils.is_folder(self._source):\n            with open(self.xml, \"rb\") as fp:\n                return fp.read()\n        with ZipFile(self._source) as zf:\n            return zf.read(self.xml)\n\n\ndef select_filenames_by_prefix(prefix, files):\n    \"\"\"\n    Get files which belongs to a document package.\n\n    Retorna os arquivos da lista `files` cujos nomes iniciam com `prefix`\n\n    Parameters\n    ----------\n    prefix : str\n        Filename prefix\n    files : str list\n        Files paths\n    Returns\n    -------\n    list\n        files paths which basename files matches to prefix\n    \"\"\"\n    return [\n        item\n        for item in files\n        if match_file_by_prefix(prefix, item)\n    ]\n\n\ndef match_file_by_prefix(prefix, file_path):\n    \"\"\"\n    Identify if a `file_path` belongs to a document package by a given `prefix`\n\n    Retorna `True` para documentos pertencentes a um pacote.\n\n    Parameters\n    ----------\n    prefix : str\n        Filename prefix\n    file_path : str\n        File path\n    Returns\n    -------\n    bool\n        True - file belongs to the package\n    \"\"\"\n    basename = os.path.basename(file_path)\n    if basename.startswith(prefix + \"-\"):\n        return True\n    if basename.startswith(prefix + \".\"):\n        return True\n    return False\n\n\ndef explore_source(source):\n    packages = _explore_zipfile(source)\n    if not packages:\n        packages = _explore_folder(source)\n    if not packages:\n        raise ValueError(\"%s: Invalid value for `source`\" % source)\n    return packages\n\n\ndef _explore_folder(folder):\n    \"\"\"\n    Get packages' data from folder\n\n    Groups files by their XML basename and returns data in dict format.\n\n    Parameters\n    ----------\n    folder : str\n        Folder of the package\n    Returns\n    -------\n    dict\n    \"\"\"\n    if file_utils.is_folder(folder):\n        data = _group_files_by_xml_filename(\n            folder,\n            file_utils.xml_files_list(folder),\n            file_utils.files_list(folder),\n        )\n        return data\n\n", "contexts_below": "\n def _group_files_by_xml_filename(source, xmls, files):\n     \"\"\"\n     Group files by their XML basename\n \n     Groups files by their XML basename and returns data in dict format.\n \n     Parameters\n     ----------\n     xml_filename : str\n         XML filenames\n     files : list\n         list of files in the folder or zipfile\n \n     Returns\n     -------\n     dict\n         key: name of the XML files\n         value: Package\n     \"\"\"\n     docs = {}\n     for xml in xmls:\n         basename = os.path.basename(xml)\n         prefix, ext = os.path.splitext(basename)\n \n         docs.setdefault(prefix, Package(source, prefix))\n \n         # XML\n         docs[prefix].xml = xml\n \n         for file in select_filenames_by_prefix(prefix, files):\n             # avalia arquivo do pacote, se \u00e9 asset ou rendition\n             component = _eval_file(prefix, file)\n             if not component:\n                 continue\n \n             # resultado do avalia\u00e7\u00e3o do pacote\n             ftype = component.get(\"ftype\")\n             file_path = component[\"file_path\"]\n             comp_id = component[\"component_id\"]\n \n             if ftype:\n                 docs[prefix].add_asset(comp_id, file_path)\n             else:\n                 docs[prefix].add_rendition(comp_id, file_path)\n             files.remove(file)\n     return docs\n \n \n def _eval_file(prefix, file_path):\n     \"\"\"\n     Identifica o tipo de arquivo do pacote: `asset` ou `rendition`.\n \n     Identifica o tipo de arquivo do pacote e atualiza `packages` com o tipo e\n     o endere\u00e7o do arquivo em an\u00e1lise.\n \n     Parameters\n     ----------\n     prefix : str\n         nome do arquivo XML sem extens\u00e3o\n     filename : str\n         filename\n     file_folder : str\n         file folder\n \n     Returns\n     -------\n     dict\n     \"\"\"\n     if not match_file_by_prefix(prefix, file_path):\n         # ignore files which name does not match\n         return\n     if file_path.endswith(\".xml\"):\n         # ignore XML files\n         return\n \n     # it matches\n     filename = os.path.basename(file_path)\n     fname, ext = os.path.splitext(filename)\n \n     lang = None\n     if ext == \".pdf\":\n         suffix = fname.replace(prefix, \"\")\n         if fname == prefix:\n             lang = \"original\"\n         elif len(suffix) == 3 and suffix[0] == \"-\":\n             # it is a rendition\n             lang = suffix[1:]\n \n     if lang:\n         return dict(\n             component_id=lang,\n             file_path=file_path,\n         )\n     else:\n         return dict(\n             component_id=filename,\n             component_name=fname,\n             ftype=ext[1:],\n             file_path=file_path,\n         )\n \n ", "input_code": "def _explore_zipfile(zip_path):\n\"\"\"\nGet packages' data from zip_path\n\nGroups files by their XML basename and returns data in dict format.\n\nParameters\n----------\nzip_path : str\n    zip file path\nReturns\n-------\ndict\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _explore_zipfile(zip_path):\n    \"\"\"\n    Get packages' data from zip_path\n\n    Groups files by their XML basename and returns data in dict format.\n\n    Parameters\n    ----------\n    zip_path : str\n        zip file path\n    Returns\n    -------\n    dict\n    \"\"\"\n    if file_utils.is_zipfile(zip_path):\n        with ZipFile(zip_path, 'r'):\n            data = _group_files_by_xml_filename(\n                zip_path,\n                file_utils.xml_files_list_from_zipfile(zip_path),\n                file_utils.files_list_from_zipfile(zip_path),\n            )\n            return data", "signature": "def _explore_zipfile(zip_path):", "completion_path": "packtools/sps/models/packages.py"}
{"ce_id": "62b463163879012d194814a6", "namespace": "62b463163879012d194814a6", "namespace_real": "packtools.file_utils.files_list_from_zipfile", "real_proj_path": "scieloorg---packtools/", "type": "function", "class_name": null, "function_name": "files_list_from_zipfile", "contexts_above": "import os\nimport logging\nimport re\nimport shutil\nimport tempfile\n\nfrom zipfile import ZipFile, ZIP_DEFLATED\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef is_folder(source):\n    return os.path.isdir(source)\n\n\ndef is_zipfile(source):\n    return os.path.isfile(source) and source.endswith(\".zip\")\n\n\ndef xml_files_list(path):\n    \"\"\"\n    Return the XML files found in `path`\n    \"\"\"\n    return (f for f in os.listdir(path) if f.endswith(\".xml\"))\n\n\ndef files_list(path):\n    \"\"\"\n    Return the files in `path`\n    \"\"\"\n    return os.listdir(path)\n\n\ndef read_file(path, encoding=\"utf-8\", mode=\"r\"):\n    with open(path, mode=mode, encoding=encoding) as f:\n        text = f.read()\n    return text\n\n\ndef read_from_zipfile(zip_path, filename):\n    with ZipFile(zip_path) as zf:\n        return zf.read(filename)\n\n\ndef xml_files_list_from_zipfile(zip_path):\n    with ZipFile(zip_path) as zf:\n        xmls_filenames = [\n            xml_filename\n            for xml_filename in zf.namelist()\n            if os.path.splitext(xml_filename)[-1] == \".xml\"\n        ]\n    return xmls_filenames\n\n", "contexts_below": "\n def write_file(path, source, mode=\"w\"):\n     dirname = os.path.dirname(path)\n     if not os.path.isdir(dirname):\n         os.makedirs(dirname)\n     logger.debug(\"Gravando arquivo: %s\", path)\n     if \"b\" in mode:\n         with open(path, mode) as f:\n             f.write(source)\n         return\n \n     with open(path, mode, encoding=\"utf-8\") as f:\n         f.write(source)\n \n \n def create_zip_file(files, zip_name, zip_folder=None):\n     zip_folder = zip_folder or tempfile.mkdtemp()\n \n     zip_path = os.path.join(zip_folder, zip_name)\n     with ZipFile(zip_path, 'w', ZIP_DEFLATED) as myzip:\n         for f in files:\n             myzip.write(f, os.path.basename(f))\n     return zip_path\n \n \n def delete_folder(path):\n     try:\n         shutil.rmtree(path)\n     except:\n         pass\n \n \n def create_temp_file(filename, content=None, mode='w'):\n     file_path = tempfile.mkdtemp()\n     file_path = os.path.join(file_path, filename)\n     write_file(file_path, content or '', mode)\n     return file_path\n \n \n def copy_file(source, target):\n     tmpdir = tempfile.mkdtemp()\n     fullpath_target = os.path.join(tmpdir, target)\n \n     logger.info(f'Copying file {source} to {fullpath_target}')\n     return shutil.copyfile(source, fullpath_target)\n \n \n def size(file_path):\n     return os.path.getsize(file_path)\n \n \n def get_prefix_by_xml_filename(xml_filename):\n     \"\"\"\n     Obt\u00e9m o prefixo associado a um arquivo xml\n \n     Parameters\n     ----------\n     xml_filename : str\n         Nome de arquivo xml\n \n     Returns\n     -------\n     str\n         Prefixo associado ao arquivo xml\n     \"\"\"\n     file, ext = os.path.splitext(xml_filename)\n     return file\n \n \n def get_file_role(file_path, prefix, pdf_langs):\n     \"\"\"\n     Obt\u00e9m o papel/fun\u00e7\u00e3o de um arquivo (xml, renditions ou assets) no contexto de um documento\n \n     Parameters\n     ----------\n     file_path : str\n         Nome de um arquivo\n     prefix: str\n         Prefixo associado ao arquivo\n     pdf_langs: list\n         Idiomas dos PDFs do documento\n \n     Returns\n     -------\n     str\n         Papel/fun\u00e7\u00e3o de arquivo (xml, rendition ou assets) no contexto de um documento\n     \"\"\"\n     file, ext = os.path.splitext(file_path)\n \n     if ext == '.xml':\n         return 'xml'\n     elif ext == '.pdf':\n         if file == prefix:\n             return 'renditions'\n \n         for lang in pdf_langs:\n             if file == f'{prefix}-{lang}':\n                 return 'renditions'\n     return 'assets'\n \n \n def extract_issn_from_zip_uri(zip_uri):\n     \"\"\"\n     Extrai c\u00f3digo ISSN a partir do endere\u00e7o de um arquivo zip\n \n     Parameters\n     ----------\n     zip_uri : str\n         Endere\u00e7o de um arquivo zip\n \n     Returns\n     -------\n     str\n         ISSN\n     \"\"\"\n     match = re.search(r'.*/ingress/packages/(\\d{4}-\\d{4})/.*.zip', zip_uri)\n     if match:\n         return match.group(1)\n \n \n def get_filename(file_path):\n     return os.path.basename(file_path)\n ", "input_code": "def files_list_from_zipfile(zip_path):\n\"\"\"\nReturn the files in `zip_path`\n\nExample:\n\n```\n[\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200069.pdf',\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200069.xml',\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071.pdf',\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071.xml',\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf01.tif',\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf02.tif',\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf03.tif',\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf04.tif',\n]\n```\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def files_list_from_zipfile(zip_path):\n    \"\"\"\n    Return the files in `zip_path`\n\n    Example:\n\n    ```\n    [\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200069.pdf',\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200069.xml',\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071.pdf',\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071.xml',\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf01.tif',\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf02.tif',\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf03.tif',\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf04.tif',\n    ]\n    ```\n    \"\"\"\n    with ZipFile(zip_path) as zf:\n        return zf.namelist()", "signature": "def files_list_from_zipfile(zip_path):", "completion_path": "packtools/file_utils.py"}
{"ce_id": "62b4631b3879012d194814dd", "namespace": "62b4631b3879012d194814dd", "namespace_real": "packtools.sps.utils.xml_utils.fix_namespace_prefix_w", "real_proj_path": "scieloorg---packtools/", "type": "function", "class_name": null, "function_name": "fix_namespace_prefix_w", "contexts_above": "import logging\nimport re\n\nfrom copy import deepcopy\nfrom lxml import etree\nfrom packtools import validations\nfrom packtools.sps import exceptions\nfrom packtools import file_utils\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef get_nodes_with_lang(xmltree, lang_xpath, node_xpath=None):\n    _items = []\n    for node in xmltree.xpath(lang_xpath):\n        _item = {}\n        if node_xpath:\n            _item[\"node\"] = node.find(node_xpath)\n        else:\n            _item[\"node\"] = node\n        _item[\"lang\"] = node.get('{http://www.w3.org/XML/1998/namespace}lang')\n        _items.append(_item)\n    return _items\n\n\ndef node_text_without_xref(node):\n    \"\"\"\n    Retorna text com subtags, exceto `xref`\n    \"\"\"\n    if node is None:\n        return\n\n    node = deepcopy(node)\n\n    for xref in node.findall(\".//xref\"):\n        if xref.tail:\n            _next = xref.getnext()\n            if _next is None or _next.tag != \"xref\":\n                e = etree.Element(\"EMPTYTAGTOKEEPXREFTAIL\")\n                xref.addnext(e)\n    for xref in node.findall(\".//xref\"):\n        parent = xref.getparent()\n        parent.remove(xref)\n    etree.strip_tags(node, \"EMPTYTAGTOKEEPXREFTAIL\")\n    return node_text(node)\n\n\ndef formatted_text(title_node):\n    # FIXME substituir `formatted_text` por `node_text_without_xref`\n    # por ser mais expl\u00edcito\n    return node_text_without_xref(title_node)\n\n\ndef fix_xml(xml_str):\n    return fix_namespace_prefix_w(xml_str)\n\n", "contexts_below": "\n def _get_xml_content(xml):\n     if isinstance(xml, str):\n         try:\n             content = file_utils.read_file(xml)\n         except (FileNotFoundError, OSError):\n             content = xml\n         content = fix_xml(content)\n         return content.encode(\"utf-8\")\n     return xml\n \n \n def get_xml_tree(content):\n     parser = etree.XMLParser(remove_blank_text=True, no_network=True)\n     try:\n         content = _get_xml_content(content)\n         xml_tree = etree.XML(content, parser)\n     except etree.XMLSyntaxError as exc:\n         raise exceptions.SPSLoadToXMLError(str(exc)) from None\n     else:\n         return xml_tree\n \n \n def tostring(node, doctype=None, pretty_print=False):\n     return etree.tostring(\n         node,\n         doctype=doctype,\n         xml_declaration=True,\n         method=\"xml\",\n         encoding=\"utf-8\",\n         pretty_print=pretty_print,\n     ).decode(\"utf-8\")\n \n \n def node_text(node):\n     \"\"\"\n     Retorna todos os node.text, incluindo a subtags\n     Para <title>Text <bold>text</bold> Text</title>, retorna\n     Text <bold>text</bold> Text\n     \"\"\"\n     items = [node.text or \"\"]\n     for child in node.getchildren():\n         items.append(\n             etree.tostring(child, encoding=\"utf-8\").decode(\"utf-8\")\n         )\n     return \"\".join(items)\n \n \n def get_year_month_day(node):\n     \"\"\"\n     Retorna os valores respectivos dos elementos \"year\", \"month\", \"day\".\n \n     Parameters\n     ----------\n     node : lxml.etree.Element\n         Elemento do tipo _date_, que tem os elementos \"year\", \"month\", \"day\".\n \n     Returns\n     -------\n     tuple of strings\n         (\"YYYY\", \"MM\", \"DD\")\n     None se node is None\n \n     \"\"\"\n     if node is not None:\n         return tuple(\n             [(node.findtext(item) or \"\").zfill(2)\n              for item in [\"year\", \"month\", \"day\"]]\n         )\n \n \n def create_alternatives(node, assets_data):\n     \"\"\"\n     ```xml\n     <alternatives>\n         <graphic\n             xlink:href=\"https://minio.scielo.br/documentstore/1678-2674/\n             rQRTPbt6jkrncZTsPdCyXsn/\n             6d6b2cfaa2dc5bd1fb84644218506cbfbc4dfb1e.tif\"/>\n         <graphic\n             xlink:href=\"https://minio.scielo.br/documentstore/1678-2674/\n             rQRTPbt6jkrncZTsPdCyXsn/\n             b810735a45beb5f829d4eb07e4cf68842f57313f.png\"\n             specific-use=\"scielo-web\"/>\n         <graphic\n             xlink:href=\"https://minio.scielo.br/documentstore/1678-2674/\n             rQRTPbt6jkrncZTsPdCyXsn/\n             e9d0cd6430c85a125e7490629ce43f227d00ef5e.jpg\"\n             specific-use=\"scielo-web\"\n             content-type=\"scielo-267x140\"/>\n     </alternatives>\n     ```\n     \"\"\"\n     if node is None or not assets_data:\n         return\n     parent = node.getparent()\n     if parent is None:\n         return\n     if len(assets_data) == 1:\n         for extension, uri in assets_data.items():\n             node.set(\"{http://www.w3.org/1999/xlink}href\", uri)\n             if extension in [\".tif\", \".tiff\"]:\n                 pass\n             elif extension in [\".png\"]:\n                 node.set(\"specific-use\", \"scielo-web\")\n             else:\n                 node.set(\"specific-use\", \"scielo-web\")\n                 node.set(\"content-type\", \"scielo-267x140\")\n     else:\n         alternative_node = etree.Element(\"alternatives\")\n         for extension, uri in assets_data.items():\n             _node = etree.Element(\"graphic\")\n             _node.set(\"{http://www.w3.org/1999/xlink}href\", uri)\n             alternative_node.append(_node)\n             if extension in [\".tif\", \".tiff\"]:\n                 pass\n             elif extension in [\".png\"]:\n                 _node.set(\"specific-use\", \"scielo-web\")\n             else:\n                 _node.set(\"specific-use\", \"scielo-web\")\n                 _node.set(\"content-type\", \"scielo-267x140\")\n         parent.replace(node, alternative_node)\n \n \n def parse_value(value):\n     value = value.lower()\n     if value.isdigit():\n         return value.zfill(2)\n     if \"spe\" in value:\n         return \"spe\"\n     if \"sup\" in value:\n         return \"s\"\n     return value\n \n \n def parse_issue(issue):\n     issue = \" \".join([item for item in issue.split()])\n     parts = issue.split()\n     parts = [parse_value(item) for item in parts]\n     s = \"-\".join(parts)\n     s = s.replace(\"spe-\", \"spe\")\n     s = s.replace(\"s-\", \"s\")\n     if s.endswith(\"s\"):\n         s += \"0\"\n     return s\n \n \n def is_allowed_to_update(xml_sps, attr_name, attr_new_value):\n     \"\"\"\n     Se h\u00e1 uma fun\u00e7\u00e3o de valida\u00e7\u00e3o associada com o atributo,\n     verificar se \u00e9 permitido atualizar o atributo, dados seus valores\n     atual e/ou novo\n     \"\"\"\n     validate_function = validations.VALIDATE_FUNCTIONS.get(attr_name)\n     if validate_function is None:\n         # n\u00e3o h\u00e1 nenhuma valida\u00e7\u00e3o, ent\u00e3o \u00e9 permitido fazer a atualiza\u00e7\u00e3o\n         return True\n \n     curr_value = getattr(xml_sps, attr_name)\n \n     if attr_new_value == curr_value:\n         # desnecessario atualizar\n         return False\n \n     try:\n         # valida o valor atual do atributo\n         validate_function(curr_value)\n \n     except (ValueError, exceptions.InvalidValueForOrderError):\n         # o valor atual do atributo \u00e9 inv\u00e1lido,\n         # ent\u00e3o continuar para verificar o valor \"novo\"\n         pass\n \n     else:\n         # o valor atual do atributo \u00e9 v\u00e1lido,\n         # ent\u00e3o n\u00e3o permitir atualiza\u00e7\u00e3o\n         raise exceptions.NotAllowedtoChangeAttributeValueError(\n             \"Not allowed to update %s (%s) with %s, \"\n             \"because current is valid\" %\n             (attr_name, curr_value, attr_new_value))\n \n     try:\n         # valida o valor novo para o atributo\n         validate_function(attr_new_value)\n \n     except (ValueError, exceptions.InvalidValueForOrderError):\n         # o valor novo \u00e9 inv\u00e1lido, ent\u00e3o n\u00e3o permitir atualiza\u00e7\u00e3o\n         raise exceptions.InvalidAttributeValueError(\n             \"Not allowed to update %s (%s) with %s, \"\n             \"because new value is invalid\" %\n             (attr_name, curr_value, attr_new_value))\n \n     else:\n         # o valor novo \u00e9 v\u00e1lido, ent\u00e3o n\u00e3o permitir atualiza\u00e7\u00e3o\n         return True\n \n \n def match_pubdate(node, pubdate_xpaths):\n     \"\"\"\n     Retorna o primeiro match da lista de pubdate_xpaths\n     \"\"\"\n     for xpath in pubdate_xpaths:\n         pubdate = node.find(xpath)\n         if pubdate is not None:\n             return pubdate\n ", "input_code": "def fix_namespace_prefix_w(content):\n\"\"\"\nConvert text that defaults to 'w:st=\"' to 'w-st=\"'\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def fix_namespace_prefix_w(content):\n    \"\"\"\n    Convert os textos cujo padr\u00e3o \u00e9 `w:st=\"` em `w-st=\"`\n    \"\"\"\n    pattern = r\"\\bw:[a-z]{1,}=\\\"\"\n    found_items = re.findall(pattern, content)\n    logger.debug(\"Found %i namespace prefix w\", len(found_items))\n    for item in set(found_items):\n        new_namespace = item.replace(\":\", \"-\")\n        logger.debug(\"%s -> %s\" % (item, new_namespace))\n        content = content.replace(item, new_namespace)\n    return content", "signature": "def fix_namespace_prefix_w(content):", "completion_path": "packtools/sps/utils/xml_utils.py"}
{"ce_id": "62b463283879012d1948153d", "namespace": "62b463283879012d1948153d", "namespace_real": "packtools.sps.utils.xml_utils.match_pubdate", "real_proj_path": "scieloorg---packtools/", "type": "function", "class_name": null, "function_name": "match_pubdate", "contexts_above": "import logging\nimport re\n\nfrom copy import deepcopy\nfrom lxml import etree\nfrom packtools import validations\nfrom packtools.sps import exceptions\nfrom packtools import file_utils\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef get_nodes_with_lang(xmltree, lang_xpath, node_xpath=None):\n    _items = []\n    for node in xmltree.xpath(lang_xpath):\n        _item = {}\n        if node_xpath:\n            _item[\"node\"] = node.find(node_xpath)\n        else:\n            _item[\"node\"] = node\n        _item[\"lang\"] = node.get('{http://www.w3.org/XML/1998/namespace}lang')\n        _items.append(_item)\n    return _items\n\n\ndef node_text_without_xref(node):\n    \"\"\"\n    Retorna text com subtags, exceto `xref`\n    \"\"\"\n    if node is None:\n        return\n\n    node = deepcopy(node)\n\n    for xref in node.findall(\".//xref\"):\n        if xref.tail:\n            _next = xref.getnext()\n            if _next is None or _next.tag != \"xref\":\n                e = etree.Element(\"EMPTYTAGTOKEEPXREFTAIL\")\n                xref.addnext(e)\n    for xref in node.findall(\".//xref\"):\n        parent = xref.getparent()\n        parent.remove(xref)\n    etree.strip_tags(node, \"EMPTYTAGTOKEEPXREFTAIL\")\n    return node_text(node)\n\n\ndef formatted_text(title_node):\n    # FIXME substituir `formatted_text` por `node_text_without_xref`\n    # por ser mais expl\u00edcito\n    return node_text_without_xref(title_node)\n\n\ndef fix_xml(xml_str):\n    return fix_namespace_prefix_w(xml_str)\n\n\ndef fix_namespace_prefix_w(content):\n    \"\"\"\n    Convert os textos cujo padr\u00e3o \u00e9 `w:st=\"` em `w-st=\"`\n    \"\"\"\n    pattern = r\"\\bw:[a-z]{1,}=\\\"\"\n    found_items = re.findall(pattern, content)\n    logger.debug(\"Found %i namespace prefix w\", len(found_items))\n    for item in set(found_items):\n        new_namespace = item.replace(\":\", \"-\")\n        logger.debug(\"%s -> %s\" % (item, new_namespace))\n        content = content.replace(item, new_namespace)\n    return content\n\n\ndef _get_xml_content(xml):\n    if isinstance(xml, str):\n        try:\n            content = file_utils.read_file(xml)\n        except (FileNotFoundError, OSError):\n            content = xml\n        content = fix_xml(content)\n        return content.encode(\"utf-8\")\n    return xml\n\n\ndef get_xml_tree(content):\n    parser = etree.XMLParser(remove_blank_text=True, no_network=True)\n    try:\n        content = _get_xml_content(content)\n        xml_tree = etree.XML(content, parser)\n    except etree.XMLSyntaxError as exc:\n        raise exceptions.SPSLoadToXMLError(str(exc)) from None\n    else:\n        return xml_tree\n\n\ndef tostring(node, doctype=None, pretty_print=False):\n    return etree.tostring(\n        node,\n        doctype=doctype,\n        xml_declaration=True,\n        method=\"xml\",\n        encoding=\"utf-8\",\n        pretty_print=pretty_print,\n    ).decode(\"utf-8\")\n\n\ndef node_text(node):\n    \"\"\"\n    Retorna todos os node.text, incluindo a subtags\n    Para <title>Text <bold>text</bold> Text</title>, retorna\n    Text <bold>text</bold> Text\n    \"\"\"\n    items = [node.text or \"\"]\n    for child in node.getchildren():\n        items.append(\n            etree.tostring(child, encoding=\"utf-8\").decode(\"utf-8\")\n        )\n    return \"\".join(items)\n\n\ndef get_year_month_day(node):\n    \"\"\"\n    Retorna os valores respectivos dos elementos \"year\", \"month\", \"day\".\n\n    Parameters\n    ----------\n    node : lxml.etree.Element\n        Elemento do tipo _date_, que tem os elementos \"year\", \"month\", \"day\".\n\n    Returns\n    -------\n    tuple of strings\n        (\"YYYY\", \"MM\", \"DD\")\n    None se node is None\n\n    \"\"\"\n    if node is not None:\n        return tuple(\n            [(node.findtext(item) or \"\").zfill(2)\n             for item in [\"year\", \"month\", \"day\"]]\n        )\n\n\ndef create_alternatives(node, assets_data):\n    \"\"\"\n    ```xml\n    <alternatives>\n        <graphic\n            xlink:href=\"https://minio.scielo.br/documentstore/1678-2674/\n            rQRTPbt6jkrncZTsPdCyXsn/\n            6d6b2cfaa2dc5bd1fb84644218506cbfbc4dfb1e.tif\"/>\n        <graphic\n            xlink:href=\"https://minio.scielo.br/documentstore/1678-2674/\n            rQRTPbt6jkrncZTsPdCyXsn/\n            b810735a45beb5f829d4eb07e4cf68842f57313f.png\"\n            specific-use=\"scielo-web\"/>\n        <graphic\n            xlink:href=\"https://minio.scielo.br/documentstore/1678-2674/\n            rQRTPbt6jkrncZTsPdCyXsn/\n            e9d0cd6430c85a125e7490629ce43f227d00ef5e.jpg\"\n            specific-use=\"scielo-web\"\n            content-type=\"scielo-267x140\"/>\n    </alternatives>\n    ```\n    \"\"\"\n    if node is None or not assets_data:\n        return\n    parent = node.getparent()\n    if parent is None:\n        return\n    if len(assets_data) == 1:\n        for extension, uri in assets_data.items():\n            node.set(\"{http://www.w3.org/1999/xlink}href\", uri)\n            if extension in [\".tif\", \".tiff\"]:\n                pass\n            elif extension in [\".png\"]:\n                node.set(\"specific-use\", \"scielo-web\")\n            else:\n                node.set(\"specific-use\", \"scielo-web\")\n                node.set(\"content-type\", \"scielo-267x140\")\n    else:\n        alternative_node = etree.Element(\"alternatives\")\n        for extension, uri in assets_data.items():\n            _node = etree.Element(\"graphic\")\n            _node.set(\"{http://www.w3.org/1999/xlink}href\", uri)\n            alternative_node.append(_node)\n            if extension in [\".tif\", \".tiff\"]:\n                pass\n            elif extension in [\".png\"]:\n                _node.set(\"specific-use\", \"scielo-web\")\n            else:\n                _node.set(\"specific-use\", \"scielo-web\")\n                _node.set(\"content-type\", \"scielo-267x140\")\n        parent.replace(node, alternative_node)\n\n\ndef parse_value(value):\n    value = value.lower()\n    if value.isdigit():\n        return value.zfill(2)\n    if \"spe\" in value:\n        return \"spe\"\n    if \"sup\" in value:\n        return \"s\"\n    return value\n\n\ndef parse_issue(issue):\n    issue = \" \".join([item for item in issue.split()])\n    parts = issue.split()\n    parts = [parse_value(item) for item in parts]\n    s = \"-\".join(parts)\n    s = s.replace(\"spe-\", \"spe\")\n    s = s.replace(\"s-\", \"s\")\n    if s.endswith(\"s\"):\n        s += \"0\"\n    return s\n\n\ndef is_allowed_to_update(xml_sps, attr_name, attr_new_value):\n    \"\"\"\n    Se h\u00e1 uma fun\u00e7\u00e3o de valida\u00e7\u00e3o associada com o atributo,\n    verificar se \u00e9 permitido atualizar o atributo, dados seus valores\n    atual e/ou novo\n    \"\"\"\n    validate_function = validations.VALIDATE_FUNCTIONS.get(attr_name)\n    if validate_function is None:\n        # n\u00e3o h\u00e1 nenhuma valida\u00e7\u00e3o, ent\u00e3o \u00e9 permitido fazer a atualiza\u00e7\u00e3o\n        return True\n\n    curr_value = getattr(xml_sps, attr_name)\n\n    if attr_new_value == curr_value:\n        # desnecessario atualizar\n        return False\n\n    try:\n        # valida o valor atual do atributo\n        validate_function(curr_value)\n\n    except (ValueError, exceptions.InvalidValueForOrderError):\n        # o valor atual do atributo \u00e9 inv\u00e1lido,\n        # ent\u00e3o continuar para verificar o valor \"novo\"\n        pass\n\n    else:\n        # o valor atual do atributo \u00e9 v\u00e1lido,\n        # ent\u00e3o n\u00e3o permitir atualiza\u00e7\u00e3o\n        raise exceptions.NotAllowedtoChangeAttributeValueError(\n            \"Not allowed to update %s (%s) with %s, \"\n            \"because current is valid\" %\n            (attr_name, curr_value, attr_new_value))\n\n    try:\n        # valida o valor novo para o atributo\n        validate_function(attr_new_value)\n\n    except (ValueError, exceptions.InvalidValueForOrderError):\n        # o valor novo \u00e9 inv\u00e1lido, ent\u00e3o n\u00e3o permitir atualiza\u00e7\u00e3o\n        raise exceptions.InvalidAttributeValueError(\n            \"Not allowed to update %s (%s) with %s, \"\n            \"because new value is invalid\" %\n            (attr_name, curr_value, attr_new_value))\n\n    else:\n        # o valor novo \u00e9 v\u00e1lido, ent\u00e3o n\u00e3o permitir atualiza\u00e7\u00e3o\n        return True\n\n", "contexts_below": "", "input_code": "def match_pubdate(node, pubdate_xpaths):\n\"\"\"\nReturns the first match in the pubdate_xpaths list\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def match_pubdate(node, pubdate_xpaths):\n    \"\"\"\n    Retorna o primeiro match da lista de pubdate_xpaths\n    \"\"\"\n    for xpath in pubdate_xpaths:\n        pubdate = node.find(xpath)\n        if pubdate is not None:\n            return pubdate", "signature": "def match_pubdate(node, pubdate_xpaths):", "completion_path": "packtools/sps/utils/xml_utils.py"}
{"ce_id": "62b463303879012d19481579", "namespace": "62b463303879012d19481579", "namespace_real": "packtools.sps.models.front_articlemeta_issue._extract_number_and_supplment_from_issue_element", "real_proj_path": "scieloorg---packtools/", "type": "function", "class_name": null, "function_name": "_extract_number_and_supplment_from_issue_element", "contexts_above": "\"\"\"<article>\n<front>\n    <article-meta>\n      <pub-date publication-format=\"electronic\" date-type=\"collection\">\n        <year>2003</year>\n      </pub-date>\n      <volume>4</volume>\n      <issue>1</issue>\n      <fpage>108</fpage>\n      <lpage>123</lpage>\n    </article-meta>\n  </front>\n</article>\n\"\"\"\nfrom packtools.sps.models.dates import ArticleDates\n\n", "contexts_below": "\n class ArticleMetaIssue:\n \n     def __init__(self, xmltree):\n         self.xmltree = xmltree\n \n     @property\n     def data(self):\n         attr_names = (\n             \"volume\", \"number\", \"suppl\",\n             \"fpage\", \"fpage_seq\", \"lpage\",\n             \"elocation_id\",\n         )\n         _data = {}\n         for k in attr_names:\n             try:\n                 value = getattr(self, k)\n             except AttributeError:\n                 continue\n             else:\n                 if value:\n                     _data[k] = value\n         try:\n             _data[\"pub_year\"] = self.collection_date[\"year\"]\n         except (KeyError, TypeError):\n             pass\n         return _data\n \n     @property\n     def collection_date(self):\n         _date = ArticleDates(self.xmltree)\n         return _date.collection_date\n \n     @property\n     def volume(self):\n         return self.xmltree.findtext(\".//front/article-meta/volume\")\n \n     @property\n     def issue(self):\n         return self.xmltree.findtext(\".//front/article-meta/issue\")\n \n     @property\n     def number(self):\n         _issue = self.issue\n         if _issue:\n             n, s = _extract_number_and_supplment_from_issue_element(_issue)\n             return n\n \n     @property\n     def suppl(self):\n         _suppl = self.xmltree.findtext(\".//front/article-meta/supplement\")\n         if _suppl:\n             return _suppl\n         _issue = self.issue\n         if _issue:\n             n, s = _extract_number_and_supplment_from_issue_element(_issue)\n             return s\n \n     @property\n     def elocation_id(self):\n         return self.xmltree.findtext(\".//front/article-meta/elocation-id\")\n \n     @property\n     def fpage(self):\n         return self.xmltree.findtext(\".//front/article-meta/fpage\")\n \n     @property\n     def fpage_seq(self):\n         try:\n             return self.xmltree.xpath(\".//front/article-meta/fpage\")[0].get(\"seq\")\n         except IndexError:\n             return None\n \n     @property\n     def lpage(self):\n         return self.xmltree.findtext(\".//front/article-meta/lpage\")\n ", "input_code": "def _extract_number_and_supplment_from_issue_element(issue):\n\"\"\"\nExtract the possible values of number and suppl from the contents of issue.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _extract_number_and_supplment_from_issue_element(issue):\n    \"\"\"\n    Extrai do conte\u00fado de <issue>xxxx</issue>, os valores number e suppl.\n    Valores poss\u00edveis\n    5 (suppl), 5 Suppl, 5 Suppl 1, 5 spe, 5 suppl, 5 suppl 1, 5 suppl. 1,\n    25 Suppl 1, 2-5 suppl 1, 2spe, Spe, Supl. 1, Suppl, Suppl 12,\n    s2, spe, spe 1, spe pr, spe2, spe.2, spepr, supp 1, supp5 1, suppl,\n    suppl 1, suppl 5 pr, suppl 12, suppl 1-2, suppl. 1\n    \"\"\"\n    if not issue:\n        return None, None\n    issue = issue.strip().replace(\".\", \"\")\n    splitted = [s for s in issue.split() if s]\n\n    splitted = [\"spe\"\n                if \"spe\" in s.lower() and s.isalpha() else s\n                for s in splitted\n                ]\n    if len(splitted) == 1:\n        issue = splitted[0]\n        if issue.isdigit():\n            return issue, None\n        if \"sup\" in issue.lower():\n            # match como sup*\n            return None, \"0\"\n        if issue.startswith(\"s\"):\n            if issue[1:].isdigit():\n                return None, issue[1:]\n        # match com spe, 2-5, 3B\n        return issue, None\n\n    if len(splitted) == 2:\n        if \"sup\" in splitted[0].lower():\n            return None, splitted[1]\n        if \"sup\" in splitted[1].lower():\n            return splitted[0], \"0\"\n        # match spe 4 -> spe4\n        return \"\".join(splitted), None\n\n    if len(splitted) == 3:\n        if \"sup\" in splitted[1].lower():\n            return splitted[0], splitted[2]\n    # match ????\n    return \"\".join(splitted), None", "signature": "def _extract_number_and_supplment_from_issue_element(issue):", "completion_path": "packtools/sps/models/front_articlemeta_issue.py"}
{"ce_id": "62b46740d2f69a53b466171a", "namespace": "62b46740d2f69a53b466171a", "namespace_real": "boolean.boolean.pretty", "real_proj_path": "bastikr---boolean/", "type": "class", "class_name": "boolean", "function_name": "pretty", "contexts_above": "\"\"\"\nBoolean expressions algebra.\n\nThis module defines a Boolean algebra over the set {TRUE, FALSE} with boolean\nvariables called Symbols and the boolean functions AND, OR, NOT.\n\nSome basic logic comparison is supported: two expressions can be\ncompared for equivalence or containment. Furthermore you can simplify\nan expression and obtain its normal form.\n\nYou can create expressions in Python using familiar boolean operators\nor parse expressions from strings. The parsing can be extended with\nyour own tokenizer.  You can also customize how expressions behave and\nhow they are presented.\n\nFor extensive documentation look either into the docs directory or view it\nonline, at https://booleanpy.readthedocs.org/en/latest/.\n\nCopyright (c) Sebastian Kraemer, basti.kr@gmail.com and others\n\nSPDX-License-Identifier: BSD-2-Clause\n\"\"\"\n\nimport inspect\nimport itertools\nfrom functools import reduce  # NOQA\nfrom operator import and_ as and_operator\nfrom operator import or_ as or_operator\n\n# Set to True to enable tracing for parsing\nTRACE_PARSE = False\n\n# Token types for standard operators and parens\nTOKEN_AND = 1\nTOKEN_OR = 2\nTOKEN_NOT = 3\nTOKEN_LPAR = 4\nTOKEN_RPAR = 5\nTOKEN_TRUE = 6\nTOKEN_FALSE = 7\nTOKEN_SYMBOL = 8\n\nTOKEN_TYPES = {\n    TOKEN_AND: \"AND\",\n    TOKEN_OR: \"OR\",\n    TOKEN_NOT: \"NOT\",\n    TOKEN_LPAR: \"(\",\n    TOKEN_RPAR: \")\",\n    TOKEN_TRUE: \"TRUE\",\n    TOKEN_FALSE: \"FALSE\",\n    TOKEN_SYMBOL: \"SYMBOL\",\n}\n\n# parsing error code and messages\nPARSE_UNKNOWN_TOKEN = 1\nPARSE_UNBALANCED_CLOSING_PARENS = 2\nPARSE_INVALID_EXPRESSION = 3\nPARSE_INVALID_NESTING = 4\nPARSE_INVALID_SYMBOL_SEQUENCE = 5\nPARSE_INVALID_OPERATOR_SEQUENCE = 6\n\nPARSE_ERRORS = {\n    PARSE_UNKNOWN_TOKEN: \"Unknown token\",\n    PARSE_UNBALANCED_CLOSING_PARENS: \"Unbalanced parenthesis\",\n    PARSE_INVALID_EXPRESSION: \"Invalid expression\",\n    PARSE_INVALID_NESTING: \"Invalid expression nesting such as (AND xx)\",\n    PARSE_INVALID_SYMBOL_SEQUENCE: \"Invalid symbols sequence such as (A B)\",\n    PARSE_INVALID_OPERATOR_SEQUENCE: \"Invalid operator sequence without symbols such as AND OR or OR OR\",\n}\n\n\nclass ParseError(Exception):\n    \"\"\"\n    Raised when the parser or tokenizer encounters a syntax error. Instances of\n    this class have attributes token_type, token_string, position, error_code to\n    access the details of the error. str() of the exception instance returns a\n    formatted message.\n    \"\"\"\n\n    def __init__(self, token_type=None, token_string=\"\", position=-1, error_code=0):\n        self.token_type = token_type\n        self.token_string = token_string\n        self.position = position\n        self.error_code = error_code\n\n    def __str__(self, *args, **kwargs):\n        emsg = PARSE_ERRORS.get(self.error_code, \"Unknown parsing error\")\n\n        tstr = \"\"\n        if self.token_string:\n            tstr = f' for token: \"{self.token_string}\"'\n\n        pos = \"\"\n        if self.position > 0:\n            pos = f\" at position: {self.position}\"\n\n        return f\"{emsg}{tstr}{pos}\"\n\n\nclass BooleanAlgebra(object):\n    \"\"\"\n    An algebra is defined by:\n\n    - the types of its operations and Symbol.\n    - the tokenizer used when parsing expressions from strings.\n\n    This class also serves as a base class for all boolean expressions,\n    including base elements, functions and variable symbols.\n    \"\"\"\n\n    def __init__(\n        self,\n        TRUE_class=None,\n        FALSE_class=None,\n        Symbol_class=None,\n        NOT_class=None,\n        AND_class=None,\n        OR_class=None,\n        allowed_in_token=(\".\", \":\", \"_\"),\n    ):\n        \"\"\"\n        The types for TRUE, FALSE, NOT, AND, OR and Symbol define the boolean\n        algebra elements, operations and Symbol variable. They default to the\n        standard classes if not provided.\n\n        You can customize an algebra by providing alternative subclasses of the\n        standard types.\n        \"\"\"\n        # TRUE and FALSE base elements are algebra-level \"singleton\" instances\n        self.TRUE = TRUE_class or _TRUE\n        self.TRUE = self.TRUE()\n\n        self.FALSE = FALSE_class or _FALSE\n        self.FALSE = self.FALSE()\n\n        # they cross-reference each other\n        self.TRUE.dual = self.FALSE\n        self.FALSE.dual = self.TRUE\n\n        # boolean operation types, defaulting to the standard types\n        self.NOT = NOT_class or NOT\n        self.AND = AND_class or AND\n        self.OR = OR_class or OR\n\n        # class used for Symbols\n        self.Symbol = Symbol_class or Symbol\n\n        tf_nao = {\n            \"TRUE\": self.TRUE,\n            \"FALSE\": self.FALSE,\n            \"NOT\": self.NOT,\n            \"AND\": self.AND,\n            \"OR\": self.OR,\n            \"Symbol\": self.Symbol,\n        }\n\n        # setup cross references such that all algebra types and\n        # objects hold a named attribute for every other types and\n        # objects, including themselves.\n        for obj in tf_nao.values():\n            for name, value in tf_nao.items():\n                setattr(obj, name, value)\n\n        # Set the set of characters allowed in tokens\n        self.allowed_in_token = allowed_in_token\n\n    def definition(self):\n        \"\"\"\n        Return a tuple of this algebra defined elements and types as:\n        (TRUE, FALSE, NOT, AND, OR, Symbol)\n        \"\"\"\n        return self.TRUE, self.FALSE, self.NOT, self.AND, self.OR, self.Symbol\n\n    def symbols(self, *args):\n        \"\"\"\n        Return a tuple of symbols building a new Symbol from each argument.\n        \"\"\"\n        return tuple(map(self.Symbol, args))\n\n    def parse(self, expr, simplify=False):\n        \"\"\"\n        Return a boolean expression parsed from `expr` either a unicode string\n        or tokens iterable.\n\n        Optionally simplify the expression if `simplify` is True.\n\n        Raise ParseError on errors.\n\n        If `expr` is a string, the standard `tokenizer` is used for tokenization\n        and the algebra configured Symbol type is used to create Symbol\n        instances from Symbol tokens.\n\n        If `expr` is an iterable, it should contain 3-tuples of: (token_type,\n        token_string, token_position). In this case, the `token_type` can be\n        a Symbol instance or one of the TOKEN_* constant types.\n        See the `tokenize()` method for detailed specification.\n        \"\"\"\n\n        precedence = {self.NOT: 5, self.AND: 10, self.OR: 15, TOKEN_LPAR: 20}\n\n        if isinstance(expr, str):\n            tokenized = self.tokenize(expr)\n        else:\n            tokenized = iter(expr)\n\n        if TRACE_PARSE:\n            tokenized = list(tokenized)\n            print(\"tokens:\")\n            for t in tokenized:\n                print(t)\n            tokenized = iter(tokenized)\n\n        # the abstract syntax tree for this expression that will be build as we\n        # process tokens\n        # the first two items are None\n        # symbol items are appended to this structure\n        ast = [None, None]\n\n        def is_sym(_t):\n            return isinstance(_t, Symbol) or _t in (TOKEN_TRUE, TOKEN_FALSE, TOKEN_SYMBOL)\n\n        def is_operator(_t):\n            return _t in (TOKEN_AND, TOKEN_OR)\n\n        prev_token = None\n        for token_type, token_string, token_position in tokenized:\n            if TRACE_PARSE:\n                print(\n                    \"\\nprocessing token_type:\",\n                    repr(token_type),\n                    \"token_string:\",\n                    repr(token_string),\n                    \"token_position:\",\n                    repr(token_position),\n                )\n\n            if prev_token:\n                prev_token_type, _prev_token_string, _prev_token_position = prev_token\n                if TRACE_PARSE:\n                    print(\"  prev_token:\", repr(prev_token))\n\n                if is_sym(prev_token_type) and (\n                    is_sym(token_type)\n                ):  # or token_type == TOKEN_LPAR) :\n                    raise ParseError(\n                        token_type, token_string, token_position, PARSE_INVALID_SYMBOL_SEQUENCE\n                    )\n\n                if is_operator(prev_token_type) and (\n                    is_operator(token_type) or token_type == TOKEN_RPAR\n                ):\n                    raise ParseError(\n                        token_type, token_string, token_position, PARSE_INVALID_OPERATOR_SEQUENCE\n                    )\n\n            else:\n                if is_operator(token_type):\n                    raise ParseError(\n                        token_type, token_string, token_position, PARSE_INVALID_OPERATOR_SEQUENCE\n                    )\n\n            if token_type == TOKEN_SYMBOL:\n                ast.append(self.Symbol(token_string))\n                if TRACE_PARSE:\n                    print(\" ast: token_type is TOKEN_SYMBOL: append new symbol\", repr(ast))\n\n            elif isinstance(token_type, Symbol):\n                ast.append(token_type)\n                if TRACE_PARSE:\n                    print(\" ast: token_type is Symbol): append existing symbol\", repr(ast))\n\n            elif token_type == TOKEN_TRUE:\n                ast.append(self.TRUE)\n                if TRACE_PARSE:\n                    print(\" ast: token_type is TOKEN_TRUE:\", repr(ast))\n\n            elif token_type == TOKEN_FALSE:\n                ast.append(self.FALSE)\n                if TRACE_PARSE:\n                    print(\" ast: token_type is TOKEN_FALSE:\", repr(ast))\n\n            elif token_type == TOKEN_NOT:\n                ast = [ast, self.NOT]\n                if TRACE_PARSE:\n                    print(\" ast: token_type is TOKEN_NOT:\", repr(ast))\n\n            elif token_type == TOKEN_AND:\n                ast = self._start_operation(ast, self.AND, precedence)\n                if TRACE_PARSE:\n                    print(\"  ast:token_type is TOKEN_AND: start_operation\", ast)\n\n            elif token_type == TOKEN_OR:\n                ast = self._start_operation(ast, self.OR, precedence)\n                if TRACE_PARSE:\n                    print(\"  ast:token_type is TOKEN_OR: start_operation\", ast)\n\n            elif token_type == TOKEN_LPAR:\n                if prev_token:\n                    # Check that an opening parens is preceded by a function\n                    # or an opening parens\n                    if prev_token_type not in (TOKEN_NOT, TOKEN_AND, TOKEN_OR, TOKEN_LPAR):\n                        raise ParseError(\n                            token_type, token_string, token_position, PARSE_INVALID_NESTING\n                        )\n                ast = [ast, TOKEN_LPAR]\n\n            elif token_type == TOKEN_RPAR:\n                while True:\n                    if ast[0] is None:\n                        raise ParseError(\n                            token_type,\n                            token_string,\n                            token_position,\n                            PARSE_UNBALANCED_CLOSING_PARENS,\n                        )\n\n                    if ast[1] is TOKEN_LPAR:\n                        ast[0].append(ast[2])\n                        if TRACE_PARSE:\n                            print(\"ast9:\", repr(ast))\n                        ast = ast[0]\n                        if TRACE_PARSE:\n                            print(\"ast10:\", repr(ast))\n                        break\n\n                    if isinstance(ast[1], int):\n                        raise ParseError(\n                            token_type,\n                            token_string,\n                            token_position,\n                            PARSE_UNBALANCED_CLOSING_PARENS,\n                        )\n\n                    # the parens are properly nested\n                    # the top ast node should be a function subclass\n                    if not (inspect.isclass(ast[1]) and issubclass(ast[1], Function)):\n                        raise ParseError(\n                            token_type, token_string, token_position, PARSE_INVALID_NESTING\n                        )\n\n                    subex = ast[1](*ast[2:])\n                    ast[0].append(subex)\n                    if TRACE_PARSE:\n                        print(\"ast11:\", repr(ast))\n                    ast = ast[0]\n                    if TRACE_PARSE:\n                        print(\"ast12:\", repr(ast))\n            else:\n                raise ParseError(token_type, token_string, token_position, PARSE_UNKNOWN_TOKEN)\n\n            prev_token = (token_type, token_string, token_position)\n\n        try:\n            while True:\n                if ast[0] is None:\n                    if TRACE_PARSE:\n                        print(\"ast[0] is None:\", repr(ast))\n                    if ast[1] is None:\n                        if TRACE_PARSE:\n                            print(\"  ast[1] is None:\", repr(ast))\n                        if len(ast) != 3:\n                            raise ParseError(error_code=PARSE_INVALID_EXPRESSION)\n                        parsed = ast[2]\n                        if TRACE_PARSE:\n                            print(\"    parsed = ast[2]:\", repr(parsed))\n\n                    else:\n                        # call the function in ast[1] with the rest of the ast as args\n                        parsed = ast[1](*ast[2:])\n                        if TRACE_PARSE:\n                            print(\"  parsed = ast[1](*ast[2:]):\", repr(parsed))\n                    break\n                else:\n                    if TRACE_PARSE:\n                        print(\"subex = ast[1](*ast[2:]):\", repr(ast))\n                    subex = ast[1](*ast[2:])\n                    ast[0].append(subex)\n                    if TRACE_PARSE:\n                        print(\"  ast[0].append(subex):\", repr(ast))\n                    ast = ast[0]\n                    if TRACE_PARSE:\n                        print(\"    ast = ast[0]:\", repr(ast))\n        except TypeError:\n            raise ParseError(error_code=PARSE_INVALID_EXPRESSION)\n\n        if simplify:\n            return parsed.simplify()\n\n        if TRACE_PARSE:\n            print(\"final parsed:\", repr(parsed))\n        return parsed\n\n    def _start_operation(self, ast, operation, precedence):\n        \"\"\"\n        Return an AST where all operations of lower precedence are finalized.\n        \"\"\"\n        if TRACE_PARSE:\n            print(\"   start_operation:\", repr(operation), \"AST:\", ast)\n\n        op_prec = precedence[operation]\n        while True:\n            if ast[1] is None:\n                # [None, None, x]\n                if TRACE_PARSE:\n                    print(\"     start_op: ast[1] is None:\", repr(ast))\n                ast[1] = operation\n                if TRACE_PARSE:\n                    print(\"     --> start_op: ast[1] is None:\", repr(ast))\n                return ast\n\n            prec = precedence[ast[1]]\n            if prec > op_prec:  # op=&, [ast, |, x, y] -> [[ast, |, x], &, y]\n                if TRACE_PARSE:\n                    print(\"     start_op: prec > op_prec:\", repr(ast))\n                ast = [ast, operation, ast.pop(-1)]\n                if TRACE_PARSE:\n                    print(\"     --> start_op: prec > op_prec:\", repr(ast))\n                return ast\n\n            if prec == op_prec:  # op=&, [ast, &, x] -> [ast, &, x]\n                if TRACE_PARSE:\n                    print(\"     start_op: prec == op_prec:\", repr(ast))\n                return ast\n\n            if not (inspect.isclass(ast[1]) and issubclass(ast[1], Function)):\n                # the top ast node should be a function subclass at this stage\n                raise ParseError(error_code=PARSE_INVALID_NESTING)\n\n            if ast[0] is None:  # op=|, [None, &, x, y] -> [None, |, x&y]\n                if TRACE_PARSE:\n                    print(\"     start_op: ast[0] is None:\", repr(ast))\n                subexp = ast[1](*ast[2:])\n                new_ast = [ast[0], operation, subexp]\n                if TRACE_PARSE:\n                    print(\"     --> start_op: ast[0] is None:\", repr(new_ast))\n                return new_ast\n\n            else:  # op=|, [[ast, &, x], ~, y] -> [ast, &, x, ~y]\n                if TRACE_PARSE:\n                    print(\"     start_op: else:\", repr(ast))\n                ast[0].append(ast[1](*ast[2:]))\n                ast = ast[0]\n                if TRACE_PARSE:\n                    print(\"     --> start_op: else:\", repr(ast))\n\n    def tokenize(self, expr):\n        \"\"\"\n        Return an iterable of 3-tuple describing each token given an expression\n        unicode string.\n\n        This 3-tuple contains (token, token string, position):\n\n        - token: either a Symbol instance or one of TOKEN_* token types.\n        - token string: the original token unicode string.\n        - position: some simple object describing the starting position of the\n          original token string in the `expr` string. It can be an int for a\n          character offset, or a tuple of starting (row/line, column).\n\n        The token position is used only for error reporting and can be None or\n        empty.\n\n        Raise ParseError on errors. The ParseError.args is a tuple of:\n        (token_string, position, error message)\n\n        You can use this tokenizer as a base to create specialized tokenizers\n        for your custom algebra by subclassing BooleanAlgebra. See also the\n        tests for other examples of alternative tokenizers.\n\n        This tokenizer has these characteristics:\n\n        - The `expr` string can span multiple lines,\n        - Whitespace is not significant.\n        - The returned position is the starting character offset of a token.\n        - A TOKEN_SYMBOL is returned for valid identifiers which is a string\n          without spaces.\n\n            - These are valid identifiers:\n                - Python identifiers.\n                - a string even if starting with digits\n                - digits (except for 0 and 1).\n                - dotted names : foo.bar consist of one token.\n                - names with colons: foo:bar consist of one token.\n            \n            - These are not identifiers:\n                - quoted strings.\n                - any punctuation which is not an operation\n\n        - Recognized operators are (in any upper/lower case combinations):\n\n            - for and:  '*', '&', 'and'\n            - for or: '+', '|', 'or'\n            - for not: '~', '!', 'not'\n\n        - Recognized special symbols are (in any upper/lower case combinations):\n\n            - True symbols: 1 and True\n            - False symbols: 0, False and None\n        \"\"\"\n        if not isinstance(expr, str):\n            raise TypeError(f\"expr must be string but it is {type(expr)}.\")\n\n        # mapping of lowercase token strings to a token type id for the standard\n        # operators, parens and common true or false symbols, as used in the\n        # default tokenizer implementation.\n        TOKENS = {\n            \"*\": TOKEN_AND,\n            \"&\": TOKEN_AND,\n            \"and\": TOKEN_AND,\n            \"+\": TOKEN_OR,\n            \"|\": TOKEN_OR,\n            \"or\": TOKEN_OR,\n            \"~\": TOKEN_NOT,\n            \"!\": TOKEN_NOT,\n            \"not\": TOKEN_NOT,\n            \"(\": TOKEN_LPAR,\n            \")\": TOKEN_RPAR,\n            \"[\": TOKEN_LPAR,\n            \"]\": TOKEN_RPAR,\n            \"true\": TOKEN_TRUE,\n            \"1\": TOKEN_TRUE,\n            \"false\": TOKEN_FALSE,\n            \"0\": TOKEN_FALSE,\n            \"none\": TOKEN_FALSE,\n        }\n\n        position = 0\n        length = len(expr)\n\n        while position < length:\n            tok = expr[position]\n\n            sym = tok.isalnum() or tok == \"_\"\n            if sym:\n                position += 1\n                while position < length:\n                    char = expr[position]\n                    if char.isalnum() or char in self.allowed_in_token:\n                        position += 1\n                        tok += char\n                    else:\n                        break\n                position -= 1\n\n            try:\n                yield TOKENS[tok.lower()], tok, position\n            except KeyError:\n                if sym:\n                    yield TOKEN_SYMBOL, tok, position\n                elif tok not in (\" \", \"\\t\", \"\\r\", \"\\n\"):\n                    raise ParseError(\n                        token_string=tok, position=position, error_code=PARSE_UNKNOWN_TOKEN\n                    )\n\n            position += 1\n\n    def _recurse_distributive(self, expr, operation_inst):\n        \"\"\"\n        Recursively flatten, simplify and apply the distributive laws to the\n        `expr` expression. Distributivity is considered for the AND or OR\n        `operation_inst` instance.\n        \"\"\"\n        if expr.isliteral:\n            return expr\n\n        args = (self._recurse_distributive(arg, operation_inst) for arg in expr.args)\n        args = tuple(arg.simplify() for arg in args)\n        if len(args) == 1:\n            return args[0]\n\n        flattened_expr = expr.__class__(*args)\n\n        dualoperation = operation_inst.dual\n        if isinstance(flattened_expr, dualoperation):\n            flattened_expr = flattened_expr.distributive()\n        return flattened_expr\n\n    def normalize(self, expr, operation):\n        \"\"\"\n        Return a normalized expression transformed to its normal form in the\n        given AND or OR operation.\n\n        The new expression arguments will satisfy these conditions:\n    \n        - ``operation(*args) == expr`` (here mathematical equality is meant)\n        - the operation does not occur in any of its arg.\n        - NOT is only appearing in literals (aka. Negation normal form).\n\n        The operation must be an AND or OR operation or a subclass.\n        \"\"\"\n        # Ensure that the operation is not NOT\n        assert operation in (\n            self.AND,\n            self.OR,\n        )\n        # Move NOT inwards.\n        expr = expr.literalize()\n        # Simplify first otherwise _recurse_distributive() may take forever.\n        expr = expr.simplify()\n        operation_example = operation(self.TRUE, self.FALSE)\n\n        # For large dual operations build up from normalized subexpressions,\n        # otherwise we can get exponential blowup midway through\n        expr.args = tuple(self.normalize(a, operation) for a in expr.args)\n        if len(expr.args) > 1 and (\n            (operation == self.AND and isinstance(expr, self.OR))\n            or (operation == self.OR and isinstance(expr, self.AND))\n        ):\n            args = expr.args\n            expr_class = expr.__class__\n            expr = args[0]\n            for arg in args[1:]:\n                expr = expr_class(expr, arg)\n                expr = self._recurse_distributive(expr, operation_example)\n                # Canonicalize\n                expr = expr.simplify()\n\n        else:\n            expr = self._recurse_distributive(expr, operation_example)\n            # Canonicalize\n            expr = expr.simplify()\n\n        return expr\n\n    def cnf(self, expr):\n        \"\"\"\n        Return a conjunctive normal form of the `expr` expression.\n        \"\"\"\n        return self.normalize(expr, self.AND)\n\n    conjunctive_normal_form = cnf\n\n    def dnf(self, expr):\n        \"\"\"\n        Return a disjunctive normal form of the `expr` expression.\n        \"\"\"\n        return self.normalize(expr, self.OR)\n\n    disjunctive_normal_form = dnf\n\n\nclass Expression(object):\n    \"\"\"\n    Abstract base class for all boolean expressions, including functions and\n    variable symbols.\n    \"\"\"\n\n    # these class attributes are configured when a new BooleanAlgebra is created\n    TRUE = None\n    FALSE = None\n    NOT = None\n    AND = None\n    OR = None\n    Symbol = None\n\n    def __init__(self):\n        # Defines sort and comparison order between expressions arguments\n        self.sort_order = None\n\n        # Store arguments aka. subterms of this expressions.\n        # subterms are either literals or expressions.\n        self.args = tuple()\n\n        # True is this is a literal expression such as a Symbol, TRUE or FALSE\n        self.isliteral = False\n\n        # True if this expression has been simplified to in canonical form.\n        self.iscanonical = False\n\n    @property\n    def objects(self):\n        \"\"\"\n        Return a set of all associated objects with this expression symbols.\n        Include recursively subexpressions objects.\n        \"\"\"\n        return set(s.obj for s in self.symbols)\n\n    def get_literals(self):\n        \"\"\"\n        Return a list of all the literals contained in this expression.\n        Include recursively subexpressions symbols.\n        This includes duplicates.\n        \"\"\"\n        if self.isliteral:\n            return [self]\n        if not self.args:\n            return []\n        return list(itertools.chain.from_iterable(arg.get_literals() for arg in self.args))\n\n    @property\n    def literals(self):\n        \"\"\"\n        Return a set of all literals contained in this expression.\n        Include recursively subexpressions literals.\n        \"\"\"\n        return set(self.get_literals())\n\n    def literalize(self):\n        \"\"\"\n        Return an expression where NOTs are only occurring as literals.\n        Applied recursively to subexpressions.\n        \"\"\"\n        if self.isliteral:\n            return self\n        args = tuple(arg.literalize() for arg in self.args)\n        if all(arg is self.args[i] for i, arg in enumerate(args)):\n            return self\n\n        return self.__class__(*args)\n\n    def get_symbols(self):\n        \"\"\"\n        Return a list of all the symbols contained in this expression.\n        Include subexpressions symbols recursively.\n        This includes duplicates.\n        \"\"\"\n        return [s if isinstance(s, Symbol) else s.args[0] for s in self.get_literals()]\n\n    @property\n    def symbols(\n        self,\n    ):\n        \"\"\"\n        Return a list of all the symbols contained in this expression.\n        Include subexpressions symbols recursively.\n        This includes duplicates.\n        \"\"\"\n        return set(self.get_symbols())\n\n    def subs(self, substitutions, default=None, simplify=False):\n        \"\"\"\n        Return an expression where all subterms of this expression are\n        by the new expression using a `substitutions` mapping of:\n        {expr: replacement}\n\n        Return the provided `default` value if this expression has no elements,\n        e.g. is empty.\n\n        Simplify the results if `simplify` is True.\n\n        Return this expression unmodified if nothing could be substituted. Note\n        that a possible usage of this function is to check for expression\n        containment as the expression will be returned unmodified if if does not\n        contain any of the provided substitutions.\n        \"\"\"\n        # shortcut: check if we have our whole expression as a possible\n        # subsitution source\n        for expr, substitution in substitutions.items():\n            if expr == self:\n                return substitution\n\n        # otherwise, do a proper substitution of subexpressions\n        expr = self._subs(substitutions, default, simplify)\n        return self if expr is None else expr\n\n    def _subs(self, substitutions, default, simplify):\n        \"\"\"\n        Return an expression where all subterms are substituted by the new\n        expression using a `substitutions` mapping of: {expr: replacement}\n        \"\"\"\n        # track the new list of unchanged args or replaced args through\n        # a substitution\n        new_arguments = []\n        changed_something = False\n\n        # shortcut for basic logic True or False\n        if self is self.TRUE or self is self.FALSE:\n            return self\n\n        # if the expression has no elements, e.g. is empty, do not apply\n        # substitutions\n        if not self.args:\n            return default\n\n        # iterate the subexpressions: either plain symbols or a subexpressions\n        for arg in self.args:\n            # collect substitutions for exact matches\n            # break as soon as we have a match\n            for expr, substitution in substitutions.items():\n                if arg == expr:\n                    new_arguments.append(substitution)\n                    changed_something = True\n                    break\n\n            # this will execute only if we did not break out of the\n            # loop, e.g. if we did not change anything and did not\n            # collect any substitutions\n            else:\n                # recursively call _subs on each arg to see if we get a\n                # substituted arg\n                new_arg = arg._subs(substitutions, default, simplify)\n                if new_arg is None:\n                    # if we did not collect a substitution for this arg,\n                    # keep the arg as-is, it is not replaced by anything\n                    new_arguments.append(arg)\n                else:\n                    # otherwise, we add the substitution for this arg instead\n                    new_arguments.append(new_arg)\n                    changed_something = True\n\n        if not changed_something:\n            return\n\n        # here we did some substitution: we return a new expression\n        # built from the new_arguments\n        newexpr = self.__class__(*new_arguments)\n        return newexpr.simplify() if simplify else newexpr\n\n    def simplify(self):\n        \"\"\"\n        Return a new simplified expression in canonical form built from this\n        expression. The simplified expression may be exactly the same as this\n        expression.\n\n        Subclasses override this method to compute actual simplification.\n        \"\"\"\n        return self\n\n    def __hash__(self):\n        \"\"\"\n        Expressions are immutable and hashable. The hash of Functions is\n        computed by respecting the structure of the whole expression by mixing\n        the class name hash and the recursive hash of a frozenset of arguments.\n        Hash of elements is based on their boolean equivalent. Hash of symbols\n        is based on their object.\n        \"\"\"\n        if not self.args:\n            arghash = id(self)\n        else:\n            arghash = hash(frozenset(map(hash, self.args)))\n        return hash(self.__class__.__name__) ^ arghash\n\n    def __eq__(self, other):\n        \"\"\"\n        Test if other element is structurally the same as itself.\n\n        This method does not make any simplification or transformation, so it\n        will return False although the expression terms may be mathematically\n        equal. Use simplify() before testing equality to check the mathematical\n        equality.\n\n        For literals, plain equality is used.\n\n        For functions, equality uses the facts that operations are:\n\n        - commutative: order does not matter and different orders are equal.\n        - idempotent: so args can appear more often in one term than in the other.\n        \"\"\"\n        if self is other:\n            return True\n\n        if isinstance(other, self.__class__):\n            return frozenset(self.args) == frozenset(other.args)\n\n        return NotImplemented\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __lt__(self, other):\n        if self.sort_order is not None and other.sort_order is not None:\n            if self.sort_order == other.sort_order:\n                return NotImplemented\n            return self.sort_order < other.sort_order\n        return NotImplemented\n\n    def __gt__(self, other):\n        lt = other.__lt__(self)\n        if lt is NotImplemented:\n            return not self.__lt__(other)\n        return lt\n\n    def __and__(self, other):\n        return self.AND(self, other)\n\n    __mul__ = __and__\n\n    def __invert__(self):\n        return self.NOT(self)\n\n    def __or__(self, other):\n        return self.OR(self, other)\n\n    __add__ = __or__\n\n    def __bool__(self):\n        raise TypeError(\"Cannot evaluate expression as a Python Boolean.\")\n\n    __nonzero__ = __bool__\n\n\nclass BaseElement(Expression):\n    \"\"\"\n    Abstract base class for the base elements TRUE and FALSE of the boolean\n    algebra.\n    \"\"\"\n\n    def __init__(self):\n        super(BaseElement, self).__init__()\n        self.sort_order = 0\n        self.iscanonical = True\n        # The dual Base Element class for this element: TRUE.dual returns\n        # _FALSE() and FALSE.dual returns _TRUE(). This is a cyclic reference\n        # and therefore only assigned after creation of the singletons,\n        self.dual = None\n\n    def __lt__(self, other):\n        if isinstance(other, BaseElement):\n            return self == self.FALSE\n        return NotImplemented\n\n    __nonzero__ = __bool__ = lambda s: None\n\n    def pretty(self, indent=0, debug=False):\n        \"\"\"\n        Return a pretty formatted representation of self.\n        \"\"\"\n        return (\" \" * indent) + repr(self)\n\n\nclass _TRUE(BaseElement):\n    \"\"\"\n    Boolean base element TRUE.\n    Not meant to be subclassed nor instantiated directly.\n    \"\"\"\n\n    def __init__(self):\n        super(_TRUE, self).__init__()\n        # assigned at singleton creation: self.dual = FALSE\n\n    def __hash__(self):\n        return hash(True)\n\n    def __eq__(self, other):\n        return self is other or other is True or isinstance(other, _TRUE)\n\n    def __str__(self):\n        return \"1\"\n\n    def __repr__(self):\n        return \"TRUE\"\n\n    def __call__(self):\n        return self\n\n    __nonzero__ = __bool__ = lambda s: True\n\n\nclass _FALSE(BaseElement):\n    \"\"\"\n    Boolean base element FALSE.\n    Not meant to be subclassed nor instantiated directly.\n    \"\"\"\n\n    def __init__(self):\n        super(_FALSE, self).__init__()\n        # assigned at singleton creation: self.dual = TRUE\n\n    def __hash__(self):\n        return hash(False)\n\n    def __eq__(self, other):\n        return self is other or other is False or isinstance(other, _FALSE)\n\n    def __str__(self):\n        return \"0\"\n\n    def __repr__(self):\n        return \"FALSE\"\n\n    def __call__(self):\n        return self\n\n    __nonzero__ = __bool__ = lambda s: False\n\n\nclass Symbol(Expression):\n    \"\"\"\n    Boolean variable.\n\n    A Symbol can hold an object used to determine equality between symbols.\n    \"\"\"\n\n    def __init__(self, obj):\n        super(Symbol, self).__init__()\n        self.sort_order = 5\n        # Store an associated object. This object determines equality\n        self.obj = obj\n        self.iscanonical = True\n        self.isliteral = True\n\n    def __call__(self, **kwargs):\n        \"\"\"\n        Return the evaluated value for this symbol from kwargs\n        \"\"\"\n        return kwargs[self.obj]\n\n    def __hash__(self):\n        if self.obj is None:  # Anonymous Symbol.\n            return id(self)\n        return hash(self.obj)\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n        if isinstance(other, self.__class__):\n            return self.obj == other.obj\n        return NotImplemented\n\n    def __lt__(self, other):\n        comparator = Expression.__lt__(self, other)\n        if comparator is not NotImplemented:\n            return comparator\n        if isinstance(other, Symbol):\n            return self.obj < other.obj\n        return NotImplemented\n\n    def __str__(self):\n        return str(self.obj)\n\n    def __repr__(self):\n        obj = f\"'{self.obj}'\" if isinstance(self.obj, str) else repr(self.obj)\n        return f\"{self.__class__.__name__}({obj})\"\n", "contexts_below": "\n class Function(Expression):\n     \"\"\"\n     Boolean function.\n \n     A boolean function takes n (one or more) boolean expressions as arguments\n     where n is called the order of the function and maps them to one of the base\n     elements TRUE or FALSE. Implemented functions are AND, OR and NOT.\n     \"\"\"\n \n     def __init__(self, *args):\n         super(Function, self).__init__()\n \n         # Specifies an infix notation of an operator for printing such as | or &.\n         self.operator = None\n \n         assert all(\n             isinstance(arg, Expression) for arg in args\n         ), f\"Bad arguments: all arguments must be an Expression: {args!r}\"\n         self.args = tuple(args)\n \n     def __str__(self):\n         args = self.args\n         if len(args) == 1:\n             if self.isliteral:\n                 return f\"{self.operator}{args[0]}\"\n             return f\"{self.operator}({args[0]})\"\n \n         args_str = []\n         for arg in args:\n             if arg.isliteral:\n                 args_str.append(str(arg))\n             else:\n                 args_str.append(f\"({arg})\")\n \n         return self.operator.join(args_str)\n \n     def __repr__(self):\n         args = \", \".join(map(repr, self.args))\n         return f\"{self.__class__.__name__}({args})\"\n \n     def pretty(self, indent=0, debug=False):\n         \"\"\"\n         Return a pretty formatted representation of self as an indented tree.\n \n         If debug is True, also prints debug information for each expression arg.\n \n         For example:\n \n         >>> print(BooleanAlgebra().parse(\n         ...    u'not a and not b and not (a and ba and c) and c or c').pretty())\n         OR(\n           AND(\n             NOT(Symbol('a')),\n             NOT(Symbol('b')),\n             NOT(\n               AND(\n                 Symbol('a'),\n                 Symbol('ba'),\n                 Symbol('c')\n               )\n             ),\n             Symbol('c')\n           ),\n           Symbol('c')\n         )\n         \"\"\"\n         debug_details = \"\"\n         if debug:\n             debug_details += f\"<isliteral={self.isliteral!r}, iscanonical={self.iscanonical!r}\"\n             identity = getattr(self, \"identity\", None)\n             if identity is not None:\n                 debug_details += f\", identity={identity!r}\"\n \n             annihilator = getattr(self, \"annihilator\", None)\n             if annihilator is not None:\n                 debug_details += f\", annihilator={annihilator!r}\"\n \n             dual = getattr(self, \"dual\", None)\n             if dual is not None:\n                 debug_details += f\", dual={dual!r}\"\n             debug_details += \">\"\n         cls = self.__class__.__name__\n         args = [a.pretty(indent=indent + 2, debug=debug) for a in self.args]\n         pfargs = \",\\n\".join(args)\n         cur_indent = \" \" * indent\n         new_line = \"\" if self.isliteral else \"\\n\"\n         return f\"{cur_indent}{cls}({debug_details}{new_line}{pfargs}\\n{cur_indent})\"\n \n \n class NOT(Function):\n     \"\"\"\n     Boolean NOT operation.\n \n     The NOT operation takes exactly one argument. If this argument is a Symbol\n     the resulting expression is also called a literal.\n \n     The operator \"~\" can be used as abbreviation for NOT, e.g. instead of NOT(x)\n     one can write ~x (where x is some boolean expression). Also for printing \"~\"\n     is used for better readability.\n \n     You can subclass to define alternative string representation.\n \n     For example:\n \n     >>> class NOT2(NOT):\n     ...     def __init__(self, *args):\n     ...         super(NOT2, self).__init__(*args)\n     ...         self.operator = '!'\n     \"\"\"\n \n     def __init__(self, arg1):\n         super(NOT, self).__init__(arg1)\n         self.isliteral = isinstance(self.args[0], Symbol)\n         self.operator = \"~\"\n \n     def literalize(self):\n         \"\"\"\n         Return an expression where NOTs are only occurring as literals.\n         \"\"\"\n         expr = self.demorgan()\n         if isinstance(expr, self.__class__):\n             return expr\n         return expr.literalize()\n \n     def simplify(self):\n         \"\"\"\n         Return a simplified expr in canonical form.\n \n         This means double negations are canceled out and all contained boolean\n         objects are in their canonical form.\n         \"\"\"\n         if self.iscanonical:\n             return self\n \n         expr = self.cancel()\n         if not isinstance(expr, self.__class__):\n             return expr.simplify()\n \n         if expr.args[0] in (\n             self.TRUE,\n             self.FALSE,\n         ):\n             return expr.args[0].dual\n \n         expr = self.__class__(expr.args[0].simplify())\n         expr.iscanonical = True\n         return expr\n \n     def cancel(self):\n         \"\"\"\n         Cancel itself and following NOTs as far as possible.\n         Returns the simplified expression.\n         \"\"\"\n         expr = self\n         while True:\n             arg = expr.args[0]\n             if not isinstance(arg, self.__class__):\n                 return expr\n             expr = arg.args[0]\n             if not isinstance(expr, self.__class__):\n                 return expr\n \n     def demorgan(self):\n         \"\"\"\n         Return a expr where the NOT function is moved inward.\n         This is achieved by canceling double NOTs and using De Morgan laws.\n         \"\"\"\n         expr = self.cancel()\n         if expr.isliteral or not isinstance(expr, self.NOT):\n             return expr\n         op = expr.args[0]\n         return op.dual(*(self.__class__(arg).cancel() for arg in op.args))\n \n     def __call__(self, **kwargs):\n         \"\"\"\n         Return the evaluated (negated) value for this function.\n         \"\"\"\n         return not self.args[0](**kwargs)\n \n     def __lt__(self, other):\n         return self.args[0] < other\n \n     def pretty(self, indent=1, debug=False):\n         \"\"\"\n         Return a pretty formatted representation of self.\n         Include additional debug details if `debug` is True.\n         \"\"\"\n         debug_details = \"\"\n         if debug:\n             debug_details += f\"<isliteral={self.isliteral!r}, iscanonical={self.iscanonical!r}>\"\n         if self.isliteral:\n             pretty_literal = self.args[0].pretty(indent=0, debug=debug)\n             return (\" \" * indent) + f\"{self.__class__.__name__}({debug_details}{pretty_literal})\"\n         else:\n             return super(NOT, self).pretty(indent=indent, debug=debug)\n \n \n class DualBase(Function):\n     \"\"\"\n     Base class for AND and OR function.\n \n     This class uses the duality principle to combine similar methods of AND\n     and OR. Both operations take two or more arguments and can be created using\n     \"|\" for OR and \"&\" for AND.\n     \"\"\"\n \n     _pyoperator = None\n \n     def __init__(self, arg1, arg2, *args):\n         super(DualBase, self).__init__(arg1, arg2, *args)\n \n         # identity element for the specific operation.\n         # This will be TRUE for the AND operation and FALSE for the OR operation.\n         self.identity = None\n \n         # annihilator element for this function.\n         # This will be FALSE for the AND operation and TRUE for the OR operation.\n         self.annihilator = None\n \n         # dual class of this function.\n         # This means OR.dual returns AND and AND.dual returns OR.\n         self.dual = None\n \n     def __contains__(self, expr):\n         \"\"\"\n         Test if expr is a subterm of this expression.\n         \"\"\"\n         if expr in self.args:\n             return True\n \n         if isinstance(expr, self.__class__):\n             return all(arg in self.args for arg in expr.args)\n \n     def simplify(self, sort=True):\n         \"\"\"\n         Return a new simplified expression in canonical form from this\n         expression.\n \n         For simplification of AND and OR fthe ollowing rules are used\n         recursively bottom up:\n \n         - Associativity (output does not contain same operations nested)::\n \n             (A & B) & C = A & (B & C) = A & B & C\n             (A | B) | C = A | (B | C) = A | B | C\n          \n          \n         - Annihilation::\n \n             A & 0 = 0, A | 1 = 1\n \n         - Idempotence (e.g. removing duplicates)::\n \n             A & A = A, A | A = A\n \n         - Identity::\n \n             A & 1 = A, A | 0 = A\n \n         - Complementation::\n \n             A & ~A = 0, A | ~A = 1\n \n         - Elimination::\n \n             (A & B) | (A & ~B) = A, (A | B) & (A | ~B) = A\n \n         - Absorption::\n \n             A & (A | B) = A, A | (A & B) = A\n \n         - Negative absorption::\n \n             A & (~A | B) = A & B, A | (~A & B) = A | B\n \n         - Commutativity (output is always sorted)::\n \n             A & B = B & A, A | B = B | A\n \n         Other boolean objects are also in their canonical form.\n         \"\"\"\n         # TODO: Refactor DualBase.simplify into different \"sub-evals\".\n \n         # If self is already canonical do nothing.\n         if self.iscanonical:\n             return self\n \n         # Otherwise bring arguments into canonical form.\n         args = [arg.simplify() for arg in self.args]\n \n         # Create new instance of own class with canonical args.\n         # TODO: Only create new class if some args changed.\n         expr = self.__class__(*args)\n \n         # Literalize before doing anything, this also applies De Morgan's Law\n         expr = expr.literalize()\n \n         # Associativity:\n         #     (A & B) & C = A & (B & C) = A & B & C\n         #     (A | B) | C = A | (B | C) = A | B | C\n         expr = expr.flatten()\n \n         # Annihilation: A & 0 = 0, A | 1 = 1\n         if self.annihilator in expr.args:\n             return self.annihilator\n \n         # Idempotence: A & A = A, A | A = A\n         # this boils down to removing duplicates\n         args = []\n         for arg in expr.args:\n             if arg not in args:\n                 args.append(arg)\n         if len(args) == 1:\n             return args[0]\n \n         # Identity: A & 1 = A, A | 0 = A\n         if self.identity in args:\n             args.remove(self.identity)\n             if len(args) == 1:\n                 return args[0]\n \n         # Complementation: A & ~A = 0, A | ~A = 1\n         for arg in args:\n             if self.NOT(arg) in args:\n                 return self.annihilator\n \n         # Elimination: (A & B) | (A & ~B) = A, (A | B) & (A | ~B) = A\n         i = 0\n         while i < len(args) - 1:\n             j = i + 1\n             ai = args[i]\n             if not isinstance(ai, self.dual):\n                 i += 1\n                 continue\n             while j < len(args):\n                 aj = args[j]\n                 if not isinstance(aj, self.dual) or len(ai.args) != len(aj.args):\n                     j += 1\n                     continue\n \n                 # Find terms where only one arg is different.\n                 negated = None\n                 for arg in ai.args:\n                     # FIXME: what does this pass Do?\n                     if arg in aj.args:\n                         pass\n                     elif self.NOT(arg).cancel() in aj.args:\n                         if negated is None:\n                             negated = arg\n                         else:\n                             negated = None\n                             break\n                     else:\n                         negated = None\n                         break\n \n                 # If the different arg is a negation simplify the expr.\n                 if negated is not None:\n                     # Cancel out one of the two terms.\n                     del args[j]\n                     aiargs = list(ai.args)\n                     aiargs.remove(negated)\n                     if len(aiargs) == 1:\n                         args[i] = aiargs[0]\n                     else:\n                         args[i] = self.dual(*aiargs)\n \n                     if len(args) == 1:\n                         return args[0]\n                     else:\n                         # Now the other simplifications have to be redone.\n                         return self.__class__(*args).simplify()\n                 j += 1\n             i += 1\n \n         # Absorption: A & (A | B) = A, A | (A & B) = A\n         # Negative absorption: A & (~A | B) = A & B, A | (~A & B) = A | B\n         args = self.absorb(args)\n         if len(args) == 1:\n             return args[0]\n \n         # Commutativity: A & B = B & A, A | B = B | A\n         if sort:\n             args.sort()\n \n         # Create new (now canonical) expression.\n         expr = self.__class__(*args)\n         expr.iscanonical = True\n         return expr\n \n     def flatten(self):\n         \"\"\"\n         Return a new expression where nested terms of this expression are\n         flattened as far as possible.\n \n         E.g.::\n \n             A & (B & C) becomes A & B & C.\n         \"\"\"\n         args = list(self.args)\n         i = 0\n         for arg in self.args:\n             if isinstance(arg, self.__class__):\n                 args[i : i + 1] = arg.args\n                 i += len(arg.args)\n             else:\n                 i += 1\n \n         return self.__class__(*args)\n \n     def absorb(self, args):\n         \"\"\"\n         Given an `args` sequence of expressions, return a new list of expression\n         applying absorption and negative absorption.\n \n         See https://en.wikipedia.org/wiki/Absorption_law\n \n         Absorption::\n \n             A & (A | B) = A, A | (A & B) = A\n \n         Negative absorption::\n \n             A & (~A | B) = A & B, A | (~A & B) = A | B\n         \"\"\"\n         args = list(args)\n         if not args:\n             args = list(self.args)\n         i = 0\n         while i < len(args):\n             absorber = args[i]\n             j = 0\n             while j < len(args):\n                 if j == i:\n                     j += 1\n                     continue\n                 target = args[j]\n                 if not isinstance(target, self.dual):\n                     j += 1\n                     continue\n \n                 # Absorption\n                 if absorber in target:\n                     del args[j]\n                     if j < i:\n                         i -= 1\n                     continue\n \n                 # Negative absorption\n                 neg_absorber = self.NOT(absorber).cancel()\n                 if neg_absorber in target:\n                     b = target.subtract(neg_absorber, simplify=False)\n                     if b is None:\n                         del args[j]\n                         if j < i:\n                             i -= 1\n                         continue\n                     else:\n                         args[j] = b\n                         j += 1\n                         continue\n \n                 if isinstance(absorber, self.dual):\n                     remove = None\n                     for arg in absorber.args:\n                         narg = self.NOT(arg).cancel()\n                         if arg in target.args:\n                             pass\n                         elif narg in target.args:\n                             if remove is None:\n                                 remove = narg\n                             else:\n                                 remove = None\n                                 break\n                         else:\n                             remove = None\n                             break\n                     if remove is not None:\n                         args[j] = target.subtract(remove, simplify=True)\n                 j += 1\n             i += 1\n \n         return args\n \n     def subtract(self, expr, simplify):\n         \"\"\"\n         Return a new expression where the `expr` expression has been removed\n         from this expression if it exists.\n         \"\"\"\n         args = self.args\n         if expr in self.args:\n             args = list(self.args)\n             args.remove(expr)\n         elif isinstance(expr, self.__class__):\n             if all(arg in self.args for arg in expr.args):\n                 args = tuple(arg for arg in self.args if arg not in expr)\n         if len(args) == 0:\n             return None\n         if len(args) == 1:\n             return args[0]\n \n         newexpr = self.__class__(*args)\n         if simplify:\n             newexpr = newexpr.simplify()\n         return newexpr\n \n     def distributive(self):\n         \"\"\"\n         Return a term where the leading AND or OR terms are switched.\n \n         This is done by applying the distributive laws::\n \n             A & (B|C) = (A&B) | (A&C)\n             A | (B&C) = (A|B) & (A|C)\n         \"\"\"\n         dual = self.dual\n         args = list(self.args)\n         for i, arg in enumerate(args):\n             if isinstance(arg, dual):\n                 args[i] = arg.args\n             else:\n                 args[i] = (arg,)\n \n         prod = itertools.product(*args)\n         args = tuple(self.__class__(*arg).simplify() for arg in prod)\n \n         if len(args) == 1:\n             return args[0]\n         else:\n             return dual(*args)\n \n     def __lt__(self, other):\n         comparator = Expression.__lt__(self, other)\n         if comparator is not NotImplemented:\n             return comparator\n \n         if isinstance(other, self.__class__):\n             lenself = len(self.args)\n             lenother = len(other.args)\n             for i in range(min(lenself, lenother)):\n                 if self.args[i] == other.args[i]:\n                     continue\n \n                 comparator = self.args[i] < other.args[i]\n                 if comparator is not NotImplemented:\n                     return comparator\n \n             if lenself != lenother:\n                 return lenself < lenother\n         return NotImplemented\n \n     def __call__(self, **kwargs):\n         \"\"\"\n         Return the evaluation of this expression by calling each of its arg as\n         arg(**kwargs) and applying its corresponding Python operator (and or or)\n         to the results.\n \n         Reduce is used as in e.g. AND(a, b, c, d) == AND(a, AND(b, AND(c, d)))\n         ore.g. OR(a, b, c, d) == OR(a, OR(b, OR(c, d)))\n         \"\"\"\n         return reduce(self._pyoperator, (a(**kwargs) for a in self.args))\n \n \n class AND(DualBase):\n     \"\"\"\n     Boolean AND operation, taking two or more arguments.\n \n     It can also be created by using \"&\" between two boolean expressions.\n \n     You can subclass to define alternative string representation by overriding\n     self.operator.\n     \n     For example:\n \n     >>> class AND2(AND):\n     ...     def __init__(self, *args):\n     ...         super(AND2, self).__init__(*args)\n     ...         self.operator = 'AND'\n     \"\"\"\n \n     _pyoperator = and_operator\n \n     def __init__(self, arg1, arg2, *args):\n         super(AND, self).__init__(arg1, arg2, *args)\n         self.sort_order = 10\n         self.identity = self.TRUE\n         self.annihilator = self.FALSE\n         self.dual = self.OR\n         self.operator = \"&\"\n \n \n class OR(DualBase):\n     \"\"\"\n     Boolean OR operation, taking two or more arguments\n \n     It can also be created by using \"|\" between two boolean expressions.\n \n     You can subclass to define alternative string representation by overriding\n     self.operator.\n \n     For example:\n \n     >>> class OR2(OR):\n     ...     def __init__(self, *args):\n     ...         super(OR2, self).__init__(*args)\n     ...         self.operator = 'OR'\n     \"\"\"\n \n     _pyoperator = or_operator\n \n     def __init__(self, arg1, arg2, *args):\n         super(OR, self).__init__(arg1, arg2, *args)\n         self.sort_order = 25\n         self.identity = self.FALSE\n         self.annihilator = self.TRUE\n         self.dual = self.AND\n         self.operator = \"|\"\n ", "input_code": "def pretty(self, indent=0, debug=False):\n\"\"\"\nReturn a pretty formatted representation of self.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def pretty(self, indent=0, debug=False):\n        \"\"\"\n        Return a pretty formatted representation of self.\n        \"\"\"\n        debug_details = \"\"\n        if debug:\n            debug_details += f\"<isliteral={self.isliteral!r}, iscanonical={self.iscanonical!r}>\"\n\n        obj = f\"'{self.obj}'\" if isinstance(self.obj, str) else repr(self.obj)\n        return (\" \" * indent) + f\"{self.__class__.__name__}({debug_details}{obj})\"", "signature": "def pretty(self, indent=0, debug=False):", "completion_path": "boolean/boolean.py"}
{"ce_id": "62b46746d2f69a53b4661722", "namespace": "62b46746d2f69a53b4661722", "namespace_real": "boolean.boolean.absorb", "real_proj_path": "bastikr---boolean/", "type": "class", "class_name": "boolean", "function_name": "absorb", "contexts_above": "\"\"\"\nBoolean expressions algebra.\n\nThis module defines a Boolean algebra over the set {TRUE, FALSE} with boolean\nvariables called Symbols and the boolean functions AND, OR, NOT.\n\nSome basic logic comparison is supported: two expressions can be\ncompared for equivalence or containment. Furthermore you can simplify\nan expression and obtain its normal form.\n\nYou can create expressions in Python using familiar boolean operators\nor parse expressions from strings. The parsing can be extended with\nyour own tokenizer.  You can also customize how expressions behave and\nhow they are presented.\n\nFor extensive documentation look either into the docs directory or view it\nonline, at https://booleanpy.readthedocs.org/en/latest/.\n\nCopyright (c) Sebastian Kraemer, basti.kr@gmail.com and others\n\nSPDX-License-Identifier: BSD-2-Clause\n\"\"\"\n\nimport inspect\nimport itertools\nfrom functools import reduce  # NOQA\nfrom operator import and_ as and_operator\nfrom operator import or_ as or_operator\n\n# Set to True to enable tracing for parsing\nTRACE_PARSE = False\n\n# Token types for standard operators and parens\nTOKEN_AND = 1\nTOKEN_OR = 2\nTOKEN_NOT = 3\nTOKEN_LPAR = 4\nTOKEN_RPAR = 5\nTOKEN_TRUE = 6\nTOKEN_FALSE = 7\nTOKEN_SYMBOL = 8\n\nTOKEN_TYPES = {\n    TOKEN_AND: \"AND\",\n    TOKEN_OR: \"OR\",\n    TOKEN_NOT: \"NOT\",\n    TOKEN_LPAR: \"(\",\n    TOKEN_RPAR: \")\",\n    TOKEN_TRUE: \"TRUE\",\n    TOKEN_FALSE: \"FALSE\",\n    TOKEN_SYMBOL: \"SYMBOL\",\n}\n\n# parsing error code and messages\nPARSE_UNKNOWN_TOKEN = 1\nPARSE_UNBALANCED_CLOSING_PARENS = 2\nPARSE_INVALID_EXPRESSION = 3\nPARSE_INVALID_NESTING = 4\nPARSE_INVALID_SYMBOL_SEQUENCE = 5\nPARSE_INVALID_OPERATOR_SEQUENCE = 6\n\nPARSE_ERRORS = {\n    PARSE_UNKNOWN_TOKEN: \"Unknown token\",\n    PARSE_UNBALANCED_CLOSING_PARENS: \"Unbalanced parenthesis\",\n    PARSE_INVALID_EXPRESSION: \"Invalid expression\",\n    PARSE_INVALID_NESTING: \"Invalid expression nesting such as (AND xx)\",\n    PARSE_INVALID_SYMBOL_SEQUENCE: \"Invalid symbols sequence such as (A B)\",\n    PARSE_INVALID_OPERATOR_SEQUENCE: \"Invalid operator sequence without symbols such as AND OR or OR OR\",\n}\n\n\nclass ParseError(Exception):\n    \"\"\"\n    Raised when the parser or tokenizer encounters a syntax error. Instances of\n    this class have attributes token_type, token_string, position, error_code to\n    access the details of the error. str() of the exception instance returns a\n    formatted message.\n    \"\"\"\n\n    def __init__(self, token_type=None, token_string=\"\", position=-1, error_code=0):\n        self.token_type = token_type\n        self.token_string = token_string\n        self.position = position\n        self.error_code = error_code\n\n    def __str__(self, *args, **kwargs):\n        emsg = PARSE_ERRORS.get(self.error_code, \"Unknown parsing error\")\n\n        tstr = \"\"\n        if self.token_string:\n            tstr = f' for token: \"{self.token_string}\"'\n\n        pos = \"\"\n        if self.position > 0:\n            pos = f\" at position: {self.position}\"\n\n        return f\"{emsg}{tstr}{pos}\"\n\n\nclass BooleanAlgebra(object):\n    \"\"\"\n    An algebra is defined by:\n\n    - the types of its operations and Symbol.\n    - the tokenizer used when parsing expressions from strings.\n\n    This class also serves as a base class for all boolean expressions,\n    including base elements, functions and variable symbols.\n    \"\"\"\n\n    def __init__(\n        self,\n        TRUE_class=None,\n        FALSE_class=None,\n        Symbol_class=None,\n        NOT_class=None,\n        AND_class=None,\n        OR_class=None,\n        allowed_in_token=(\".\", \":\", \"_\"),\n    ):\n        \"\"\"\n        The types for TRUE, FALSE, NOT, AND, OR and Symbol define the boolean\n        algebra elements, operations and Symbol variable. They default to the\n        standard classes if not provided.\n\n        You can customize an algebra by providing alternative subclasses of the\n        standard types.\n        \"\"\"\n        # TRUE and FALSE base elements are algebra-level \"singleton\" instances\n        self.TRUE = TRUE_class or _TRUE\n        self.TRUE = self.TRUE()\n\n        self.FALSE = FALSE_class or _FALSE\n        self.FALSE = self.FALSE()\n\n        # they cross-reference each other\n        self.TRUE.dual = self.FALSE\n        self.FALSE.dual = self.TRUE\n\n        # boolean operation types, defaulting to the standard types\n        self.NOT = NOT_class or NOT\n        self.AND = AND_class or AND\n        self.OR = OR_class or OR\n\n        # class used for Symbols\n        self.Symbol = Symbol_class or Symbol\n\n        tf_nao = {\n            \"TRUE\": self.TRUE,\n            \"FALSE\": self.FALSE,\n            \"NOT\": self.NOT,\n            \"AND\": self.AND,\n            \"OR\": self.OR,\n            \"Symbol\": self.Symbol,\n        }\n\n        # setup cross references such that all algebra types and\n        # objects hold a named attribute for every other types and\n        # objects, including themselves.\n        for obj in tf_nao.values():\n            for name, value in tf_nao.items():\n                setattr(obj, name, value)\n\n        # Set the set of characters allowed in tokens\n        self.allowed_in_token = allowed_in_token\n\n    def definition(self):\n        \"\"\"\n        Return a tuple of this algebra defined elements and types as:\n        (TRUE, FALSE, NOT, AND, OR, Symbol)\n        \"\"\"\n        return self.TRUE, self.FALSE, self.NOT, self.AND, self.OR, self.Symbol\n\n    def symbols(self, *args):\n        \"\"\"\n        Return a tuple of symbols building a new Symbol from each argument.\n        \"\"\"\n        return tuple(map(self.Symbol, args))\n\n    def parse(self, expr, simplify=False):\n        \"\"\"\n        Return a boolean expression parsed from `expr` either a unicode string\n        or tokens iterable.\n\n        Optionally simplify the expression if `simplify` is True.\n\n        Raise ParseError on errors.\n\n        If `expr` is a string, the standard `tokenizer` is used for tokenization\n        and the algebra configured Symbol type is used to create Symbol\n        instances from Symbol tokens.\n\n        If `expr` is an iterable, it should contain 3-tuples of: (token_type,\n        token_string, token_position). In this case, the `token_type` can be\n        a Symbol instance or one of the TOKEN_* constant types.\n        See the `tokenize()` method for detailed specification.\n        \"\"\"\n\n        precedence = {self.NOT: 5, self.AND: 10, self.OR: 15, TOKEN_LPAR: 20}\n\n        if isinstance(expr, str):\n            tokenized = self.tokenize(expr)\n        else:\n            tokenized = iter(expr)\n\n        if TRACE_PARSE:\n            tokenized = list(tokenized)\n            print(\"tokens:\")\n            for t in tokenized:\n                print(t)\n            tokenized = iter(tokenized)\n\n        # the abstract syntax tree for this expression that will be build as we\n        # process tokens\n        # the first two items are None\n        # symbol items are appended to this structure\n        ast = [None, None]\n\n        def is_sym(_t):\n            return isinstance(_t, Symbol) or _t in (TOKEN_TRUE, TOKEN_FALSE, TOKEN_SYMBOL)\n\n        def is_operator(_t):\n            return _t in (TOKEN_AND, TOKEN_OR)\n\n        prev_token = None\n        for token_type, token_string, token_position in tokenized:\n            if TRACE_PARSE:\n                print(\n                    \"\\nprocessing token_type:\",\n                    repr(token_type),\n                    \"token_string:\",\n                    repr(token_string),\n                    \"token_position:\",\n                    repr(token_position),\n                )\n\n            if prev_token:\n                prev_token_type, _prev_token_string, _prev_token_position = prev_token\n                if TRACE_PARSE:\n                    print(\"  prev_token:\", repr(prev_token))\n\n                if is_sym(prev_token_type) and (\n                    is_sym(token_type)\n                ):  # or token_type == TOKEN_LPAR) :\n                    raise ParseError(\n                        token_type, token_string, token_position, PARSE_INVALID_SYMBOL_SEQUENCE\n                    )\n\n                if is_operator(prev_token_type) and (\n                    is_operator(token_type) or token_type == TOKEN_RPAR\n                ):\n                    raise ParseError(\n                        token_type, token_string, token_position, PARSE_INVALID_OPERATOR_SEQUENCE\n                    )\n\n            else:\n                if is_operator(token_type):\n                    raise ParseError(\n                        token_type, token_string, token_position, PARSE_INVALID_OPERATOR_SEQUENCE\n                    )\n\n            if token_type == TOKEN_SYMBOL:\n                ast.append(self.Symbol(token_string))\n                if TRACE_PARSE:\n                    print(\" ast: token_type is TOKEN_SYMBOL: append new symbol\", repr(ast))\n\n            elif isinstance(token_type, Symbol):\n                ast.append(token_type)\n                if TRACE_PARSE:\n                    print(\" ast: token_type is Symbol): append existing symbol\", repr(ast))\n\n            elif token_type == TOKEN_TRUE:\n                ast.append(self.TRUE)\n                if TRACE_PARSE:\n                    print(\" ast: token_type is TOKEN_TRUE:\", repr(ast))\n\n            elif token_type == TOKEN_FALSE:\n                ast.append(self.FALSE)\n                if TRACE_PARSE:\n                    print(\" ast: token_type is TOKEN_FALSE:\", repr(ast))\n\n            elif token_type == TOKEN_NOT:\n                ast = [ast, self.NOT]\n                if TRACE_PARSE:\n                    print(\" ast: token_type is TOKEN_NOT:\", repr(ast))\n\n            elif token_type == TOKEN_AND:\n                ast = self._start_operation(ast, self.AND, precedence)\n                if TRACE_PARSE:\n                    print(\"  ast:token_type is TOKEN_AND: start_operation\", ast)\n\n            elif token_type == TOKEN_OR:\n                ast = self._start_operation(ast, self.OR, precedence)\n                if TRACE_PARSE:\n                    print(\"  ast:token_type is TOKEN_OR: start_operation\", ast)\n\n            elif token_type == TOKEN_LPAR:\n                if prev_token:\n                    # Check that an opening parens is preceded by a function\n                    # or an opening parens\n                    if prev_token_type not in (TOKEN_NOT, TOKEN_AND, TOKEN_OR, TOKEN_LPAR):\n                        raise ParseError(\n                            token_type, token_string, token_position, PARSE_INVALID_NESTING\n                        )\n                ast = [ast, TOKEN_LPAR]\n\n            elif token_type == TOKEN_RPAR:\n                while True:\n                    if ast[0] is None:\n                        raise ParseError(\n                            token_type,\n                            token_string,\n                            token_position,\n                            PARSE_UNBALANCED_CLOSING_PARENS,\n                        )\n\n                    if ast[1] is TOKEN_LPAR:\n                        ast[0].append(ast[2])\n                        if TRACE_PARSE:\n                            print(\"ast9:\", repr(ast))\n                        ast = ast[0]\n                        if TRACE_PARSE:\n                            print(\"ast10:\", repr(ast))\n                        break\n\n                    if isinstance(ast[1], int):\n                        raise ParseError(\n                            token_type,\n                            token_string,\n                            token_position,\n                            PARSE_UNBALANCED_CLOSING_PARENS,\n                        )\n\n                    # the parens are properly nested\n                    # the top ast node should be a function subclass\n                    if not (inspect.isclass(ast[1]) and issubclass(ast[1], Function)):\n                        raise ParseError(\n                            token_type, token_string, token_position, PARSE_INVALID_NESTING\n                        )\n\n                    subex = ast[1](*ast[2:])\n                    ast[0].append(subex)\n                    if TRACE_PARSE:\n                        print(\"ast11:\", repr(ast))\n                    ast = ast[0]\n                    if TRACE_PARSE:\n                        print(\"ast12:\", repr(ast))\n            else:\n                raise ParseError(token_type, token_string, token_position, PARSE_UNKNOWN_TOKEN)\n\n            prev_token = (token_type, token_string, token_position)\n\n        try:\n            while True:\n                if ast[0] is None:\n                    if TRACE_PARSE:\n                        print(\"ast[0] is None:\", repr(ast))\n                    if ast[1] is None:\n                        if TRACE_PARSE:\n                            print(\"  ast[1] is None:\", repr(ast))\n                        if len(ast) != 3:\n                            raise ParseError(error_code=PARSE_INVALID_EXPRESSION)\n                        parsed = ast[2]\n                        if TRACE_PARSE:\n                            print(\"    parsed = ast[2]:\", repr(parsed))\n\n                    else:\n                        # call the function in ast[1] with the rest of the ast as args\n                        parsed = ast[1](*ast[2:])\n                        if TRACE_PARSE:\n                            print(\"  parsed = ast[1](*ast[2:]):\", repr(parsed))\n                    break\n                else:\n                    if TRACE_PARSE:\n                        print(\"subex = ast[1](*ast[2:]):\", repr(ast))\n                    subex = ast[1](*ast[2:])\n                    ast[0].append(subex)\n                    if TRACE_PARSE:\n                        print(\"  ast[0].append(subex):\", repr(ast))\n                    ast = ast[0]\n                    if TRACE_PARSE:\n                        print(\"    ast = ast[0]:\", repr(ast))\n        except TypeError:\n            raise ParseError(error_code=PARSE_INVALID_EXPRESSION)\n\n        if simplify:\n            return parsed.simplify()\n\n        if TRACE_PARSE:\n            print(\"final parsed:\", repr(parsed))\n        return parsed\n\n    def _start_operation(self, ast, operation, precedence):\n        \"\"\"\n        Return an AST where all operations of lower precedence are finalized.\n        \"\"\"\n        if TRACE_PARSE:\n            print(\"   start_operation:\", repr(operation), \"AST:\", ast)\n\n        op_prec = precedence[operation]\n        while True:\n            if ast[1] is None:\n                # [None, None, x]\n                if TRACE_PARSE:\n                    print(\"     start_op: ast[1] is None:\", repr(ast))\n                ast[1] = operation\n                if TRACE_PARSE:\n                    print(\"     --> start_op: ast[1] is None:\", repr(ast))\n                return ast\n\n            prec = precedence[ast[1]]\n            if prec > op_prec:  # op=&, [ast, |, x, y] -> [[ast, |, x], &, y]\n                if TRACE_PARSE:\n                    print(\"     start_op: prec > op_prec:\", repr(ast))\n                ast = [ast, operation, ast.pop(-1)]\n                if TRACE_PARSE:\n                    print(\"     --> start_op: prec > op_prec:\", repr(ast))\n                return ast\n\n            if prec == op_prec:  # op=&, [ast, &, x] -> [ast, &, x]\n                if TRACE_PARSE:\n                    print(\"     start_op: prec == op_prec:\", repr(ast))\n                return ast\n\n            if not (inspect.isclass(ast[1]) and issubclass(ast[1], Function)):\n                # the top ast node should be a function subclass at this stage\n                raise ParseError(error_code=PARSE_INVALID_NESTING)\n\n            if ast[0] is None:  # op=|, [None, &, x, y] -> [None, |, x&y]\n                if TRACE_PARSE:\n                    print(\"     start_op: ast[0] is None:\", repr(ast))\n                subexp = ast[1](*ast[2:])\n                new_ast = [ast[0], operation, subexp]\n                if TRACE_PARSE:\n                    print(\"     --> start_op: ast[0] is None:\", repr(new_ast))\n                return new_ast\n\n            else:  # op=|, [[ast, &, x], ~, y] -> [ast, &, x, ~y]\n                if TRACE_PARSE:\n                    print(\"     start_op: else:\", repr(ast))\n                ast[0].append(ast[1](*ast[2:]))\n                ast = ast[0]\n                if TRACE_PARSE:\n                    print(\"     --> start_op: else:\", repr(ast))\n\n    def tokenize(self, expr):\n        \"\"\"\n        Return an iterable of 3-tuple describing each token given an expression\n        unicode string.\n\n        This 3-tuple contains (token, token string, position):\n\n        - token: either a Symbol instance or one of TOKEN_* token types.\n        - token string: the original token unicode string.\n        - position: some simple object describing the starting position of the\n          original token string in the `expr` string. It can be an int for a\n          character offset, or a tuple of starting (row/line, column).\n\n        The token position is used only for error reporting and can be None or\n        empty.\n\n        Raise ParseError on errors. The ParseError.args is a tuple of:\n        (token_string, position, error message)\n\n        You can use this tokenizer as a base to create specialized tokenizers\n        for your custom algebra by subclassing BooleanAlgebra. See also the\n        tests for other examples of alternative tokenizers.\n\n        This tokenizer has these characteristics:\n\n        - The `expr` string can span multiple lines,\n        - Whitespace is not significant.\n        - The returned position is the starting character offset of a token.\n        - A TOKEN_SYMBOL is returned for valid identifiers which is a string\n          without spaces.\n\n            - These are valid identifiers:\n                - Python identifiers.\n                - a string even if starting with digits\n                - digits (except for 0 and 1).\n                - dotted names : foo.bar consist of one token.\n                - names with colons: foo:bar consist of one token.\n            \n            - These are not identifiers:\n                - quoted strings.\n                - any punctuation which is not an operation\n\n        - Recognized operators are (in any upper/lower case combinations):\n\n            - for and:  '*', '&', 'and'\n            - for or: '+', '|', 'or'\n            - for not: '~', '!', 'not'\n\n        - Recognized special symbols are (in any upper/lower case combinations):\n\n            - True symbols: 1 and True\n            - False symbols: 0, False and None\n        \"\"\"\n        if not isinstance(expr, str):\n            raise TypeError(f\"expr must be string but it is {type(expr)}.\")\n\n        # mapping of lowercase token strings to a token type id for the standard\n        # operators, parens and common true or false symbols, as used in the\n        # default tokenizer implementation.\n        TOKENS = {\n            \"*\": TOKEN_AND,\n            \"&\": TOKEN_AND,\n            \"and\": TOKEN_AND,\n            \"+\": TOKEN_OR,\n            \"|\": TOKEN_OR,\n            \"or\": TOKEN_OR,\n            \"~\": TOKEN_NOT,\n            \"!\": TOKEN_NOT,\n            \"not\": TOKEN_NOT,\n            \"(\": TOKEN_LPAR,\n            \")\": TOKEN_RPAR,\n            \"[\": TOKEN_LPAR,\n            \"]\": TOKEN_RPAR,\n            \"true\": TOKEN_TRUE,\n            \"1\": TOKEN_TRUE,\n            \"false\": TOKEN_FALSE,\n            \"0\": TOKEN_FALSE,\n            \"none\": TOKEN_FALSE,\n        }\n\n        position = 0\n        length = len(expr)\n\n        while position < length:\n            tok = expr[position]\n\n            sym = tok.isalnum() or tok == \"_\"\n            if sym:\n                position += 1\n                while position < length:\n                    char = expr[position]\n                    if char.isalnum() or char in self.allowed_in_token:\n                        position += 1\n                        tok += char\n                    else:\n                        break\n                position -= 1\n\n            try:\n                yield TOKENS[tok.lower()], tok, position\n            except KeyError:\n                if sym:\n                    yield TOKEN_SYMBOL, tok, position\n                elif tok not in (\" \", \"\\t\", \"\\r\", \"\\n\"):\n                    raise ParseError(\n                        token_string=tok, position=position, error_code=PARSE_UNKNOWN_TOKEN\n                    )\n\n            position += 1\n\n    def _recurse_distributive(self, expr, operation_inst):\n        \"\"\"\n        Recursively flatten, simplify and apply the distributive laws to the\n        `expr` expression. Distributivity is considered for the AND or OR\n        `operation_inst` instance.\n        \"\"\"\n        if expr.isliteral:\n            return expr\n\n        args = (self._recurse_distributive(arg, operation_inst) for arg in expr.args)\n        args = tuple(arg.simplify() for arg in args)\n        if len(args) == 1:\n            return args[0]\n\n        flattened_expr = expr.__class__(*args)\n\n        dualoperation = operation_inst.dual\n        if isinstance(flattened_expr, dualoperation):\n            flattened_expr = flattened_expr.distributive()\n        return flattened_expr\n\n    def normalize(self, expr, operation):\n        \"\"\"\n        Return a normalized expression transformed to its normal form in the\n        given AND or OR operation.\n\n        The new expression arguments will satisfy these conditions:\n    \n        - ``operation(*args) == expr`` (here mathematical equality is meant)\n        - the operation does not occur in any of its arg.\n        - NOT is only appearing in literals (aka. Negation normal form).\n\n        The operation must be an AND or OR operation or a subclass.\n        \"\"\"\n        # Ensure that the operation is not NOT\n        assert operation in (\n            self.AND,\n            self.OR,\n        )\n        # Move NOT inwards.\n        expr = expr.literalize()\n        # Simplify first otherwise _recurse_distributive() may take forever.\n        expr = expr.simplify()\n        operation_example = operation(self.TRUE, self.FALSE)\n\n        # For large dual operations build up from normalized subexpressions,\n        # otherwise we can get exponential blowup midway through\n        expr.args = tuple(self.normalize(a, operation) for a in expr.args)\n        if len(expr.args) > 1 and (\n            (operation == self.AND and isinstance(expr, self.OR))\n            or (operation == self.OR and isinstance(expr, self.AND))\n        ):\n            args = expr.args\n            expr_class = expr.__class__\n            expr = args[0]\n            for arg in args[1:]:\n                expr = expr_class(expr, arg)\n                expr = self._recurse_distributive(expr, operation_example)\n                # Canonicalize\n                expr = expr.simplify()\n\n        else:\n            expr = self._recurse_distributive(expr, operation_example)\n            # Canonicalize\n            expr = expr.simplify()\n\n        return expr\n\n    def cnf(self, expr):\n        \"\"\"\n        Return a conjunctive normal form of the `expr` expression.\n        \"\"\"\n        return self.normalize(expr, self.AND)\n\n    conjunctive_normal_form = cnf\n\n    def dnf(self, expr):\n        \"\"\"\n        Return a disjunctive normal form of the `expr` expression.\n        \"\"\"\n        return self.normalize(expr, self.OR)\n\n    disjunctive_normal_form = dnf\n\n\nclass Expression(object):\n    \"\"\"\n    Abstract base class for all boolean expressions, including functions and\n    variable symbols.\n    \"\"\"\n\n    # these class attributes are configured when a new BooleanAlgebra is created\n    TRUE = None\n    FALSE = None\n    NOT = None\n    AND = None\n    OR = None\n    Symbol = None\n\n    def __init__(self):\n        # Defines sort and comparison order between expressions arguments\n        self.sort_order = None\n\n        # Store arguments aka. subterms of this expressions.\n        # subterms are either literals or expressions.\n        self.args = tuple()\n\n        # True is this is a literal expression such as a Symbol, TRUE or FALSE\n        self.isliteral = False\n\n        # True if this expression has been simplified to in canonical form.\n        self.iscanonical = False\n\n    @property\n    def objects(self):\n        \"\"\"\n        Return a set of all associated objects with this expression symbols.\n        Include recursively subexpressions objects.\n        \"\"\"\n        return set(s.obj for s in self.symbols)\n\n    def get_literals(self):\n        \"\"\"\n        Return a list of all the literals contained in this expression.\n        Include recursively subexpressions symbols.\n        This includes duplicates.\n        \"\"\"\n        if self.isliteral:\n            return [self]\n        if not self.args:\n            return []\n        return list(itertools.chain.from_iterable(arg.get_literals() for arg in self.args))\n\n    @property\n    def literals(self):\n        \"\"\"\n        Return a set of all literals contained in this expression.\n        Include recursively subexpressions literals.\n        \"\"\"\n        return set(self.get_literals())\n\n    def literalize(self):\n        \"\"\"\n        Return an expression where NOTs are only occurring as literals.\n        Applied recursively to subexpressions.\n        \"\"\"\n        if self.isliteral:\n            return self\n        args = tuple(arg.literalize() for arg in self.args)\n        if all(arg is self.args[i] for i, arg in enumerate(args)):\n            return self\n\n        return self.__class__(*args)\n\n    def get_symbols(self):\n        \"\"\"\n        Return a list of all the symbols contained in this expression.\n        Include subexpressions symbols recursively.\n        This includes duplicates.\n        \"\"\"\n        return [s if isinstance(s, Symbol) else s.args[0] for s in self.get_literals()]\n\n    @property\n    def symbols(\n        self,\n    ):\n        \"\"\"\n        Return a list of all the symbols contained in this expression.\n        Include subexpressions symbols recursively.\n        This includes duplicates.\n        \"\"\"\n        return set(self.get_symbols())\n\n    def subs(self, substitutions, default=None, simplify=False):\n        \"\"\"\n        Return an expression where all subterms of this expression are\n        by the new expression using a `substitutions` mapping of:\n        {expr: replacement}\n\n        Return the provided `default` value if this expression has no elements,\n        e.g. is empty.\n\n        Simplify the results if `simplify` is True.\n\n        Return this expression unmodified if nothing could be substituted. Note\n        that a possible usage of this function is to check for expression\n        containment as the expression will be returned unmodified if if does not\n        contain any of the provided substitutions.\n        \"\"\"\n        # shortcut: check if we have our whole expression as a possible\n        # subsitution source\n        for expr, substitution in substitutions.items():\n            if expr == self:\n                return substitution\n\n        # otherwise, do a proper substitution of subexpressions\n        expr = self._subs(substitutions, default, simplify)\n        return self if expr is None else expr\n\n    def _subs(self, substitutions, default, simplify):\n        \"\"\"\n        Return an expression where all subterms are substituted by the new\n        expression using a `substitutions` mapping of: {expr: replacement}\n        \"\"\"\n        # track the new list of unchanged args or replaced args through\n        # a substitution\n        new_arguments = []\n        changed_something = False\n\n        # shortcut for basic logic True or False\n        if self is self.TRUE or self is self.FALSE:\n            return self\n\n        # if the expression has no elements, e.g. is empty, do not apply\n        # substitutions\n        if not self.args:\n            return default\n\n        # iterate the subexpressions: either plain symbols or a subexpressions\n        for arg in self.args:\n            # collect substitutions for exact matches\n            # break as soon as we have a match\n            for expr, substitution in substitutions.items():\n                if arg == expr:\n                    new_arguments.append(substitution)\n                    changed_something = True\n                    break\n\n            # this will execute only if we did not break out of the\n            # loop, e.g. if we did not change anything and did not\n            # collect any substitutions\n            else:\n                # recursively call _subs on each arg to see if we get a\n                # substituted arg\n                new_arg = arg._subs(substitutions, default, simplify)\n                if new_arg is None:\n                    # if we did not collect a substitution for this arg,\n                    # keep the arg as-is, it is not replaced by anything\n                    new_arguments.append(arg)\n                else:\n                    # otherwise, we add the substitution for this arg instead\n                    new_arguments.append(new_arg)\n                    changed_something = True\n\n        if not changed_something:\n            return\n\n        # here we did some substitution: we return a new expression\n        # built from the new_arguments\n        newexpr = self.__class__(*new_arguments)\n        return newexpr.simplify() if simplify else newexpr\n\n    def simplify(self):\n        \"\"\"\n        Return a new simplified expression in canonical form built from this\n        expression. The simplified expression may be exactly the same as this\n        expression.\n\n        Subclasses override this method to compute actual simplification.\n        \"\"\"\n        return self\n\n    def __hash__(self):\n        \"\"\"\n        Expressions are immutable and hashable. The hash of Functions is\n        computed by respecting the structure of the whole expression by mixing\n        the class name hash and the recursive hash of a frozenset of arguments.\n        Hash of elements is based on their boolean equivalent. Hash of symbols\n        is based on their object.\n        \"\"\"\n        if not self.args:\n            arghash = id(self)\n        else:\n            arghash = hash(frozenset(map(hash, self.args)))\n        return hash(self.__class__.__name__) ^ arghash\n\n    def __eq__(self, other):\n        \"\"\"\n        Test if other element is structurally the same as itself.\n\n        This method does not make any simplification or transformation, so it\n        will return False although the expression terms may be mathematically\n        equal. Use simplify() before testing equality to check the mathematical\n        equality.\n\n        For literals, plain equality is used.\n\n        For functions, equality uses the facts that operations are:\n\n        - commutative: order does not matter and different orders are equal.\n        - idempotent: so args can appear more often in one term than in the other.\n        \"\"\"\n        if self is other:\n            return True\n\n        if isinstance(other, self.__class__):\n            return frozenset(self.args) == frozenset(other.args)\n\n        return NotImplemented\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __lt__(self, other):\n        if self.sort_order is not None and other.sort_order is not None:\n            if self.sort_order == other.sort_order:\n                return NotImplemented\n            return self.sort_order < other.sort_order\n        return NotImplemented\n\n    def __gt__(self, other):\n        lt = other.__lt__(self)\n        if lt is NotImplemented:\n            return not self.__lt__(other)\n        return lt\n\n    def __and__(self, other):\n        return self.AND(self, other)\n\n    __mul__ = __and__\n\n    def __invert__(self):\n        return self.NOT(self)\n\n    def __or__(self, other):\n        return self.OR(self, other)\n\n    __add__ = __or__\n\n    def __bool__(self):\n        raise TypeError(\"Cannot evaluate expression as a Python Boolean.\")\n\n    __nonzero__ = __bool__\n\n\nclass BaseElement(Expression):\n    \"\"\"\n    Abstract base class for the base elements TRUE and FALSE of the boolean\n    algebra.\n    \"\"\"\n\n    def __init__(self):\n        super(BaseElement, self).__init__()\n        self.sort_order = 0\n        self.iscanonical = True\n        # The dual Base Element class for this element: TRUE.dual returns\n        # _FALSE() and FALSE.dual returns _TRUE(). This is a cyclic reference\n        # and therefore only assigned after creation of the singletons,\n        self.dual = None\n\n    def __lt__(self, other):\n        if isinstance(other, BaseElement):\n            return self == self.FALSE\n        return NotImplemented\n\n    __nonzero__ = __bool__ = lambda s: None\n\n    def pretty(self, indent=0, debug=False):\n        \"\"\"\n        Return a pretty formatted representation of self.\n        \"\"\"\n        return (\" \" * indent) + repr(self)\n\n\nclass _TRUE(BaseElement):\n    \"\"\"\n    Boolean base element TRUE.\n    Not meant to be subclassed nor instantiated directly.\n    \"\"\"\n\n    def __init__(self):\n        super(_TRUE, self).__init__()\n        # assigned at singleton creation: self.dual = FALSE\n\n    def __hash__(self):\n        return hash(True)\n\n    def __eq__(self, other):\n        return self is other or other is True or isinstance(other, _TRUE)\n\n    def __str__(self):\n        return \"1\"\n\n    def __repr__(self):\n        return \"TRUE\"\n\n    def __call__(self):\n        return self\n\n    __nonzero__ = __bool__ = lambda s: True\n\n\nclass _FALSE(BaseElement):\n    \"\"\"\n    Boolean base element FALSE.\n    Not meant to be subclassed nor instantiated directly.\n    \"\"\"\n\n    def __init__(self):\n        super(_FALSE, self).__init__()\n        # assigned at singleton creation: self.dual = TRUE\n\n    def __hash__(self):\n        return hash(False)\n\n    def __eq__(self, other):\n        return self is other or other is False or isinstance(other, _FALSE)\n\n    def __str__(self):\n        return \"0\"\n\n    def __repr__(self):\n        return \"FALSE\"\n\n    def __call__(self):\n        return self\n\n    __nonzero__ = __bool__ = lambda s: False\n\n\nclass Symbol(Expression):\n    \"\"\"\n    Boolean variable.\n\n    A Symbol can hold an object used to determine equality between symbols.\n    \"\"\"\n\n    def __init__(self, obj):\n        super(Symbol, self).__init__()\n        self.sort_order = 5\n        # Store an associated object. This object determines equality\n        self.obj = obj\n        self.iscanonical = True\n        self.isliteral = True\n\n    def __call__(self, **kwargs):\n        \"\"\"\n        Return the evaluated value for this symbol from kwargs\n        \"\"\"\n        return kwargs[self.obj]\n\n    def __hash__(self):\n        if self.obj is None:  # Anonymous Symbol.\n            return id(self)\n        return hash(self.obj)\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n        if isinstance(other, self.__class__):\n            return self.obj == other.obj\n        return NotImplemented\n\n    def __lt__(self, other):\n        comparator = Expression.__lt__(self, other)\n        if comparator is not NotImplemented:\n            return comparator\n        if isinstance(other, Symbol):\n            return self.obj < other.obj\n        return NotImplemented\n\n    def __str__(self):\n        return str(self.obj)\n\n    def __repr__(self):\n        obj = f\"'{self.obj}'\" if isinstance(self.obj, str) else repr(self.obj)\n        return f\"{self.__class__.__name__}({obj})\"\n\n    def pretty(self, indent=0, debug=False):\n        \"\"\"\n        Return a pretty formatted representation of self.\n        \"\"\"\n        debug_details = \"\"\n        if debug:\n            debug_details += f\"<isliteral={self.isliteral!r}, iscanonical={self.iscanonical!r}>\"\n\n        obj = f\"'{self.obj}'\" if isinstance(self.obj, str) else repr(self.obj)\n        return (\" \" * indent) + f\"{self.__class__.__name__}({debug_details}{obj})\"\n\n\nclass Function(Expression):\n    \"\"\"\n    Boolean function.\n\n    A boolean function takes n (one or more) boolean expressions as arguments\n    where n is called the order of the function and maps them to one of the base\n    elements TRUE or FALSE. Implemented functions are AND, OR and NOT.\n    \"\"\"\n\n    def __init__(self, *args):\n        super(Function, self).__init__()\n\n        # Specifies an infix notation of an operator for printing such as | or &.\n        self.operator = None\n\n        assert all(\n            isinstance(arg, Expression) for arg in args\n        ), f\"Bad arguments: all arguments must be an Expression: {args!r}\"\n        self.args = tuple(args)\n\n    def __str__(self):\n        args = self.args\n        if len(args) == 1:\n            if self.isliteral:\n                return f\"{self.operator}{args[0]}\"\n            return f\"{self.operator}({args[0]})\"\n\n        args_str = []\n        for arg in args:\n            if arg.isliteral:\n                args_str.append(str(arg))\n            else:\n                args_str.append(f\"({arg})\")\n\n        return self.operator.join(args_str)\n\n    def __repr__(self):\n        args = \", \".join(map(repr, self.args))\n        return f\"{self.__class__.__name__}({args})\"\n\n    def pretty(self, indent=0, debug=False):\n        \"\"\"\n        Return a pretty formatted representation of self as an indented tree.\n\n        If debug is True, also prints debug information for each expression arg.\n\n        For example:\n\n        >>> print(BooleanAlgebra().parse(\n        ...    u'not a and not b and not (a and ba and c) and c or c').pretty())\n        OR(\n          AND(\n            NOT(Symbol('a')),\n            NOT(Symbol('b')),\n            NOT(\n              AND(\n                Symbol('a'),\n                Symbol('ba'),\n                Symbol('c')\n              )\n            ),\n            Symbol('c')\n          ),\n          Symbol('c')\n        )\n        \"\"\"\n        debug_details = \"\"\n        if debug:\n            debug_details += f\"<isliteral={self.isliteral!r}, iscanonical={self.iscanonical!r}\"\n            identity = getattr(self, \"identity\", None)\n            if identity is not None:\n                debug_details += f\", identity={identity!r}\"\n\n            annihilator = getattr(self, \"annihilator\", None)\n            if annihilator is not None:\n                debug_details += f\", annihilator={annihilator!r}\"\n\n            dual = getattr(self, \"dual\", None)\n            if dual is not None:\n                debug_details += f\", dual={dual!r}\"\n            debug_details += \">\"\n        cls = self.__class__.__name__\n        args = [a.pretty(indent=indent + 2, debug=debug) for a in self.args]\n        pfargs = \",\\n\".join(args)\n        cur_indent = \" \" * indent\n        new_line = \"\" if self.isliteral else \"\\n\"\n        return f\"{cur_indent}{cls}({debug_details}{new_line}{pfargs}\\n{cur_indent})\"\n\n\nclass NOT(Function):\n    \"\"\"\n    Boolean NOT operation.\n\n    The NOT operation takes exactly one argument. If this argument is a Symbol\n    the resulting expression is also called a literal.\n\n    The operator \"~\" can be used as abbreviation for NOT, e.g. instead of NOT(x)\n    one can write ~x (where x is some boolean expression). Also for printing \"~\"\n    is used for better readability.\n\n    You can subclass to define alternative string representation.\n\n    For example:\n\n    >>> class NOT2(NOT):\n    ...     def __init__(self, *args):\n    ...         super(NOT2, self).__init__(*args)\n    ...         self.operator = '!'\n    \"\"\"\n\n    def __init__(self, arg1):\n        super(NOT, self).__init__(arg1)\n        self.isliteral = isinstance(self.args[0], Symbol)\n        self.operator = \"~\"\n\n    def literalize(self):\n        \"\"\"\n        Return an expression where NOTs are only occurring as literals.\n        \"\"\"\n        expr = self.demorgan()\n        if isinstance(expr, self.__class__):\n            return expr\n        return expr.literalize()\n\n    def simplify(self):\n        \"\"\"\n        Return a simplified expr in canonical form.\n\n        This means double negations are canceled out and all contained boolean\n        objects are in their canonical form.\n        \"\"\"\n        if self.iscanonical:\n            return self\n\n        expr = self.cancel()\n        if not isinstance(expr, self.__class__):\n            return expr.simplify()\n\n        if expr.args[0] in (\n            self.TRUE,\n            self.FALSE,\n        ):\n            return expr.args[0].dual\n\n        expr = self.__class__(expr.args[0].simplify())\n        expr.iscanonical = True\n        return expr\n\n    def cancel(self):\n        \"\"\"\n        Cancel itself and following NOTs as far as possible.\n        Returns the simplified expression.\n        \"\"\"\n        expr = self\n        while True:\n            arg = expr.args[0]\n            if not isinstance(arg, self.__class__):\n                return expr\n            expr = arg.args[0]\n            if not isinstance(expr, self.__class__):\n                return expr\n\n    def demorgan(self):\n        \"\"\"\n        Return a expr where the NOT function is moved inward.\n        This is achieved by canceling double NOTs and using De Morgan laws.\n        \"\"\"\n        expr = self.cancel()\n        if expr.isliteral or not isinstance(expr, self.NOT):\n            return expr\n        op = expr.args[0]\n        return op.dual(*(self.__class__(arg).cancel() for arg in op.args))\n\n    def __call__(self, **kwargs):\n        \"\"\"\n        Return the evaluated (negated) value for this function.\n        \"\"\"\n        return not self.args[0](**kwargs)\n\n    def __lt__(self, other):\n        return self.args[0] < other\n\n    def pretty(self, indent=1, debug=False):\n        \"\"\"\n        Return a pretty formatted representation of self.\n        Include additional debug details if `debug` is True.\n        \"\"\"\n        debug_details = \"\"\n        if debug:\n            debug_details += f\"<isliteral={self.isliteral!r}, iscanonical={self.iscanonical!r}>\"\n        if self.isliteral:\n            pretty_literal = self.args[0].pretty(indent=0, debug=debug)\n            return (\" \" * indent) + f\"{self.__class__.__name__}({debug_details}{pretty_literal})\"\n        else:\n            return super(NOT, self).pretty(indent=indent, debug=debug)\n\n\nclass DualBase(Function):\n    \"\"\"\n    Base class for AND and OR function.\n\n    This class uses the duality principle to combine similar methods of AND\n    and OR. Both operations take two or more arguments and can be created using\n    \"|\" for OR and \"&\" for AND.\n    \"\"\"\n\n    _pyoperator = None\n\n    def __init__(self, arg1, arg2, *args):\n        super(DualBase, self).__init__(arg1, arg2, *args)\n\n        # identity element for the specific operation.\n        # This will be TRUE for the AND operation and FALSE for the OR operation.\n        self.identity = None\n\n        # annihilator element for this function.\n        # This will be FALSE for the AND operation and TRUE for the OR operation.\n        self.annihilator = None\n\n        # dual class of this function.\n        # This means OR.dual returns AND and AND.dual returns OR.\n        self.dual = None\n\n    def __contains__(self, expr):\n        \"\"\"\n        Test if expr is a subterm of this expression.\n        \"\"\"\n        if expr in self.args:\n            return True\n\n        if isinstance(expr, self.__class__):\n            return all(arg in self.args for arg in expr.args)\n\n    def simplify(self, sort=True):\n        \"\"\"\n        Return a new simplified expression in canonical form from this\n        expression.\n\n        For simplification of AND and OR fthe ollowing rules are used\n        recursively bottom up:\n\n        - Associativity (output does not contain same operations nested)::\n\n            (A & B) & C = A & (B & C) = A & B & C\n            (A | B) | C = A | (B | C) = A | B | C\n         \n         \n        - Annihilation::\n\n            A & 0 = 0, A | 1 = 1\n\n        - Idempotence (e.g. removing duplicates)::\n\n            A & A = A, A | A = A\n\n        - Identity::\n\n            A & 1 = A, A | 0 = A\n\n        - Complementation::\n\n            A & ~A = 0, A | ~A = 1\n\n        - Elimination::\n\n            (A & B) | (A & ~B) = A, (A | B) & (A | ~B) = A\n\n        - Absorption::\n\n            A & (A | B) = A, A | (A & B) = A\n\n        - Negative absorption::\n\n            A & (~A | B) = A & B, A | (~A & B) = A | B\n\n        - Commutativity (output is always sorted)::\n\n            A & B = B & A, A | B = B | A\n\n        Other boolean objects are also in their canonical form.\n        \"\"\"\n        # TODO: Refactor DualBase.simplify into different \"sub-evals\".\n\n        # If self is already canonical do nothing.\n        if self.iscanonical:\n            return self\n\n        # Otherwise bring arguments into canonical form.\n        args = [arg.simplify() for arg in self.args]\n\n        # Create new instance of own class with canonical args.\n        # TODO: Only create new class if some args changed.\n        expr = self.__class__(*args)\n\n        # Literalize before doing anything, this also applies De Morgan's Law\n        expr = expr.literalize()\n\n        # Associativity:\n        #     (A & B) & C = A & (B & C) = A & B & C\n        #     (A | B) | C = A | (B | C) = A | B | C\n        expr = expr.flatten()\n\n        # Annihilation: A & 0 = 0, A | 1 = 1\n        if self.annihilator in expr.args:\n            return self.annihilator\n\n        # Idempotence: A & A = A, A | A = A\n        # this boils down to removing duplicates\n        args = []\n        for arg in expr.args:\n            if arg not in args:\n                args.append(arg)\n        if len(args) == 1:\n            return args[0]\n\n        # Identity: A & 1 = A, A | 0 = A\n        if self.identity in args:\n            args.remove(self.identity)\n            if len(args) == 1:\n                return args[0]\n\n        # Complementation: A & ~A = 0, A | ~A = 1\n        for arg in args:\n            if self.NOT(arg) in args:\n                return self.annihilator\n\n        # Elimination: (A & B) | (A & ~B) = A, (A | B) & (A | ~B) = A\n        i = 0\n        while i < len(args) - 1:\n            j = i + 1\n            ai = args[i]\n            if not isinstance(ai, self.dual):\n                i += 1\n                continue\n            while j < len(args):\n                aj = args[j]\n                if not isinstance(aj, self.dual) or len(ai.args) != len(aj.args):\n                    j += 1\n                    continue\n\n                # Find terms where only one arg is different.\n                negated = None\n                for arg in ai.args:\n                    # FIXME: what does this pass Do?\n                    if arg in aj.args:\n                        pass\n                    elif self.NOT(arg).cancel() in aj.args:\n                        if negated is None:\n                            negated = arg\n                        else:\n                            negated = None\n                            break\n                    else:\n                        negated = None\n                        break\n\n                # If the different arg is a negation simplify the expr.\n                if negated is not None:\n                    # Cancel out one of the two terms.\n                    del args[j]\n                    aiargs = list(ai.args)\n                    aiargs.remove(negated)\n                    if len(aiargs) == 1:\n                        args[i] = aiargs[0]\n                    else:\n                        args[i] = self.dual(*aiargs)\n\n                    if len(args) == 1:\n                        return args[0]\n                    else:\n                        # Now the other simplifications have to be redone.\n                        return self.__class__(*args).simplify()\n                j += 1\n            i += 1\n\n        # Absorption: A & (A | B) = A, A | (A & B) = A\n        # Negative absorption: A & (~A | B) = A & B, A | (~A & B) = A | B\n        args = self.absorb(args)\n        if len(args) == 1:\n            return args[0]\n\n        # Commutativity: A & B = B & A, A | B = B | A\n        if sort:\n            args.sort()\n\n        # Create new (now canonical) expression.\n        expr = self.__class__(*args)\n        expr.iscanonical = True\n        return expr\n\n    def flatten(self):\n        \"\"\"\n        Return a new expression where nested terms of this expression are\n        flattened as far as possible.\n\n        E.g.::\n\n            A & (B & C) becomes A & B & C.\n        \"\"\"\n        args = list(self.args)\n        i = 0\n        for arg in self.args:\n            if isinstance(arg, self.__class__):\n                args[i : i + 1] = arg.args\n                i += len(arg.args)\n            else:\n                i += 1\n\n        return self.__class__(*args)\n", "contexts_below": "    def subtract(self, expr, simplify):\n         \"\"\"\n         Return a new expression where the `expr` expression has been removed\n         from this expression if it exists.\n         \"\"\"\n         args = self.args\n         if expr in self.args:\n             args = list(self.args)\n             args.remove(expr)\n         elif isinstance(expr, self.__class__):\n             if all(arg in self.args for arg in expr.args):\n                 args = tuple(arg for arg in self.args if arg not in expr)\n         if len(args) == 0:\n             return None\n         if len(args) == 1:\n             return args[0]\n \n         newexpr = self.__class__(*args)\n         if simplify:\n             newexpr = newexpr.simplify()\n         return newexpr\n \n     def distributive(self):\n         \"\"\"\n         Return a term where the leading AND or OR terms are switched.\n \n         This is done by applying the distributive laws::\n \n             A & (B|C) = (A&B) | (A&C)\n             A | (B&C) = (A|B) & (A|C)\n         \"\"\"\n         dual = self.dual\n         args = list(self.args)\n         for i, arg in enumerate(args):\n             if isinstance(arg, dual):\n                 args[i] = arg.args\n             else:\n                 args[i] = (arg,)\n \n         prod = itertools.product(*args)\n         args = tuple(self.__class__(*arg).simplify() for arg in prod)\n \n         if len(args) == 1:\n             return args[0]\n         else:\n             return dual(*args)\n \n     def __lt__(self, other):\n         comparator = Expression.__lt__(self, other)\n         if comparator is not NotImplemented:\n             return comparator\n \n         if isinstance(other, self.__class__):\n             lenself = len(self.args)\n             lenother = len(other.args)\n             for i in range(min(lenself, lenother)):\n                 if self.args[i] == other.args[i]:\n                     continue\n \n                 comparator = self.args[i] < other.args[i]\n                 if comparator is not NotImplemented:\n                     return comparator\n \n             if lenself != lenother:\n                 return lenself < lenother\n         return NotImplemented\n \n     def __call__(self, **kwargs):\n         \"\"\"\n         Return the evaluation of this expression by calling each of its arg as\n         arg(**kwargs) and applying its corresponding Python operator (and or or)\n         to the results.\n \n         Reduce is used as in e.g. AND(a, b, c, d) == AND(a, AND(b, AND(c, d)))\n         ore.g. OR(a, b, c, d) == OR(a, OR(b, OR(c, d)))\n         \"\"\"\n         return reduce(self._pyoperator, (a(**kwargs) for a in self.args))\n \n \n class AND(DualBase):\n     \"\"\"\n     Boolean AND operation, taking two or more arguments.\n \n     It can also be created by using \"&\" between two boolean expressions.\n \n     You can subclass to define alternative string representation by overriding\n     self.operator.\n     \n     For example:\n \n     >>> class AND2(AND):\n     ...     def __init__(self, *args):\n     ...         super(AND2, self).__init__(*args)\n     ...         self.operator = 'AND'\n     \"\"\"\n \n     _pyoperator = and_operator\n \n     def __init__(self, arg1, arg2, *args):\n         super(AND, self).__init__(arg1, arg2, *args)\n         self.sort_order = 10\n         self.identity = self.TRUE\n         self.annihilator = self.FALSE\n         self.dual = self.OR\n         self.operator = \"&\"\n \n \n class OR(DualBase):\n     \"\"\"\n     Boolean OR operation, taking two or more arguments\n \n     It can also be created by using \"|\" between two boolean expressions.\n \n     You can subclass to define alternative string representation by overriding\n     self.operator.\n \n     For example:\n \n     >>> class OR2(OR):\n     ...     def __init__(self, *args):\n     ...         super(OR2, self).__init__(*args)\n     ...         self.operator = 'OR'\n     \"\"\"\n \n     _pyoperator = or_operator\n \n     def __init__(self, arg1, arg2, *args):\n         super(OR, self).__init__(arg1, arg2, *args)\n         self.sort_order = 25\n         self.identity = self.FALSE\n         self.annihilator = self.TRUE\n         self.dual = self.AND\n         self.operator = \"|\"\n ", "input_code": "def absorb(self, args):\n\"\"\"\nGiven an `args` sequence of expressions, return a new list of expression\napplying absorption and negative absorption.\n\nSee https://en.wikipedia.org/wiki/Absorption_law\n\nAbsorption::\n\n    A & (A | B) = A, A | (A & B) = A\n\nNegative absorption::\n\n    A & (~A | B) = A & B, A | (~A & B) = A | B\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def absorb(self, args):\n        \"\"\"\n        Given an `args` sequence of expressions, return a new list of expression\n        applying absorption and negative absorption.\n\n        See https://en.wikipedia.org/wiki/Absorption_law\n\n        Absorption::\n\n            A & (A | B) = A, A | (A & B) = A\n\n        Negative absorption::\n\n            A & (~A | B) = A & B, A | (~A & B) = A | B\n        \"\"\"\n        args = list(args)\n        if not args:\n            args = list(self.args)\n        i = 0\n        while i < len(args):\n            absorber = args[i]\n            j = 0\n            while j < len(args):\n                if j == i:\n                    j += 1\n                    continue\n                target = args[j]\n                if not isinstance(target, self.dual):\n                    j += 1\n                    continue\n\n                # Absorption\n                if absorber in target:\n                    del args[j]\n                    if j < i:\n                        i -= 1\n                    continue\n\n                # Negative absorption\n                neg_absorber = self.NOT(absorber).cancel()\n                if neg_absorber in target:\n                    b = target.subtract(neg_absorber, simplify=False)\n                    if b is None:\n                        del args[j]\n                        if j < i:\n                            i -= 1\n                        continue\n                    else:\n                        args[j] = b\n                        j += 1\n                        continue\n\n                if isinstance(absorber, self.dual):\n                    remove = None\n                    for arg in absorber.args:\n                        narg = self.NOT(arg).cancel()\n                        if arg in target.args:\n                            pass\n                        elif narg in target.args:\n                            if remove is None:\n                                remove = narg\n                            else:\n                                remove = None\n                                break\n                        else:\n                            remove = None\n                            break\n                    if remove is not None:\n                        args[j] = target.subtract(remove, simplify=True)\n                j += 1\n            i += 1\n\n        return args", "signature": "def absorb(self, args):", "completion_path": "boolean/boolean.py"}
{"ce_id": "62b86707b4d922cb0e688c2a", "namespace": "62b86707b4d922cb0e688c2a", "namespace_real": "krake.krake.controller.kubernetes.hooks.on", "real_proj_path": "rak-n-rok---Krake/", "type": "class", "class_name": "hooks", "function_name": "on", "contexts_above": "\"\"\"This module defines the Hook Dispatcher and listeners for registering and\nexecuting hooks. Hook Dispatcher emits hooks based on :class:`Hook` attributes which\ndefine when the hook will be executed.\n\n\"\"\"\nimport asyncio\nimport logging\nimport random\nfrom base64 import b64encode\nfrom collections import defaultdict\nfrom contextlib import suppress\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom functools import reduce\nfrom operator import getitem\nfrom enum import Enum, auto\nfrom inspect import iscoroutinefunction\nfrom OpenSSL import crypto\nfrom typing import NamedTuple\n\nimport yarl\nfrom aiohttp import ClientConnectorError\n\nfrom krake.controller import Observer\nfrom krake.controller.kubernetes.client import KubernetesClient, InvalidManifestError\nfrom krake.utils import camel_to_snake_case, get_kubernetes_resource_idx\nfrom kubernetes_asyncio.client.rest import ApiException\nfrom kubernetes_asyncio.client.api_client import ApiClient\nfrom kubernetes_asyncio import client\nfrom krake.data.kubernetes import ClusterState, Application, Cluster\nfrom yarl import URL\nfrom secrets import token_urlsafe\n\nfrom kubernetes_asyncio.client import (\n    Configuration,\n    V1Secret,\n    V1EnvVar,\n    V1VolumeMount,\n    V1Volume,\n    V1SecretKeySelector,\n    V1EnvVarSource,\n)\nfrom kubernetes_asyncio.config.kube_config import KubeConfigLoader\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass HookType(Enum):\n    ResourcePreCreate = auto()\n    ResourcePostCreate = auto()\n    ResourcePreUpdate = auto()\n    ResourcePostUpdate = auto()\n    ResourcePreDelete = auto()\n    ResourcePostDelete = auto()\n    ApplicationMangling = auto()\n    ApplicationPreMigrate = auto()\n    ApplicationPostMigrate = auto()\n    ApplicationPreReconcile = auto()\n    ApplicationPostReconcile = auto()\n    ApplicationPreDelete = auto()\n    ApplicationPostDelete = auto()\n    ClusterCreation = auto()\n    ClusterDeletion = auto()\n\n\nclass HookDispatcher(object):\n    \"\"\"Simple wrapper around a registry of handlers associated to :class:`Hook`\n     attributes. Each :class:`Hook` attribute defines when the handler will be\n     executed.\n\n    Listeners for certain hooks can be registered via :meth:`on`. Registered\n    listeners are executed via :meth:`hook`.\n\n    Example:\n        .. code:: python\n\n        listen = HookDispatcher()\n\n        @listen.on(HookType.PreApply)\n        def to_perform_before_app_creation(app, cluster, resource, controller):\n            # Do Stuff\n\n        @listen.on(HookType.PostApply)\n        def another_to_perform_after_app_creation(app, cluster, resource, resp):\n            # Do Stuff\n\n        @listen.on(HookType.PostDelete)\n        def to_perform_after_app_deletion(app, cluster, resource, resp):\n            # Do Stuff\n\n    \"\"\"\n\n    def __init__(self):\n        self.registry = defaultdict(list)\n", "contexts_below": "    async def hook(self, hook, **kwargs):\n         \"\"\"Execute the list of handlers associated to the provided :class:`Hook`\n         attribute.\n \n         Args:\n             hook (HookType): The hook attribute for which to execute handlers.\n \n         \"\"\"\n         try:\n             handlers = self.registry[hook]\n         except KeyError:\n             pass\n         else:\n             for handler in handlers:\n                 if iscoroutinefunction(handler):\n                     await handler(**kwargs)\n                 else:\n                     handler(**kwargs)\n \n \n listen = HookDispatcher()\n \n \n @listen.on(HookType.ResourcePostCreate)\n @listen.on(HookType.ResourcePostUpdate)\n async def register_service(app, cluster, resource, response):\n     \"\"\"Register endpoint of Kubernetes Service object on creation and update.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application the service belongs to\n         cluster (krake.data.kubernetes.Cluster): The cluster on which the\n             application is running\n         resource (dict): Kubernetes object description as specified in the\n             specification of the application.\n         response (kubernetes_asyncio.client.V1Service): Response of the\n             Kubernetes API\n \n     \"\"\"\n     if resource[\"kind\"] != \"Service\":\n         return\n \n     service_name = resource[\"metadata\"][\"name\"]\n \n     if response.spec and response.spec.type == \"LoadBalancer\":\n         # For a \"LoadBalancer\" type of Service, an external IP is given in the cluster\n         # by a load balancer controller to the service. In this case, the \"port\"\n         # specified in the spec is reachable from the outside.\n         if (\n             not response.status.load_balancer\n             or not response.status.load_balancer.ingress\n         ):\n             # When a \"LoadBalancer\" type of service is created, the IP is given by an\n             # additional controller (e.g. a controller that requests a floating IP to an\n             # OpenStack infrastructure). This process can take some time, but the\n             # Service itself already exist before the IP is assigned. In the case of an\n             # error with the controller, the IP is also not given. This \"<pending>\" IP\n             # just expresses that the Service exists, but the IP is not ready yet.\n             external_ip = \"<pending>\"\n         else:\n             external_ip = response.status.load_balancer.ingress[0].ip\n \n         if not response.spec.ports:\n             external_port = \"<pending>\"\n         else:\n             external_port = response.spec.ports[0].port\n         app.status.services[service_name] = f\"{external_ip}:{external_port}\"\n         return\n \n     node_port = None\n     # Ensure that ports are specified\n     if response.spec and response.spec.ports:\n         node_port = response.spec.ports[0].node_port\n \n     # If the service does not have a node port, remove a potential reference\n     # and return.\n     if node_port is None:\n         try:\n             del app.status.services[service_name]\n         except KeyError:\n             pass\n         return\n \n     # Determine URL of Kubernetes cluster API\n     loader = KubeConfigLoader(cluster.spec.kubeconfig)\n     config = Configuration()\n     await loader.load_and_set(config)\n     cluster_url = yarl.URL(config.host)\n \n     app.status.services[service_name] = f\"{cluster_url.host}:{node_port}\"\n \n \n @listen.on(HookType.ResourcePostDelete)\n async def unregister_service(app, resource, **kwargs):\n     \"\"\"Unregister endpoint of Kubernetes Service object on deletion.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application the service belongs to\n         resource (dict): Kubernetes object description as specified in the\n             specification of the application.\n \n     \"\"\"\n     if resource[\"kind\"] != \"Service\":\n         return\n \n     service_name = resource[\"metadata\"][\"name\"]\n     try:\n         del app.status.services[service_name]\n     except KeyError:\n         pass\n \n \n @listen.on(HookType.ResourcePostDelete)\n async def remove_resource_from_last_observed_manifest(app, resource, **kwargs):\n     \"\"\"Remove a given resource from the last_observed_manifest after its deletion\n \n     Args:\n         app (krake.data.kubernetes.Application): Application the service belongs to\n         resource (dict): Kubernetes object description as specified in the\n             specification of the application.\n \n     \"\"\"\n     try:\n         idx = get_kubernetes_resource_idx(app.status.last_observed_manifest, resource)\n     except IndexError:\n         return\n \n     app.status.last_observed_manifest.pop(idx)\n \n \n def update_last_applied_manifest_dict_from_resp(\n     last_applied_manifest, observer_schema, response\n ):\n     \"\"\"Together with :func:``update_last_applied_manifest_list_from_resp``, this\n     function is called recursively to update a partial ``last_applied_manifest``\n     from a partial Kubernetes response\n \n     Args:\n         last_applied_manifest (dict): partial ``last_applied_manifest`` being\n             updated\n         observer_schema (dict): partial ``observer_schema``\n         response (dict): partial response from the Kubernetes API.\n \n     Raises:\n         KeyError: If the observed field is not present in the Kubernetes response\n \n     This function go through all observed fields, and initialized their value in\n     last_applied_manifest if they are not yet present\n \n     \"\"\"\n     for key, value in observer_schema.items():\n \n         # Keys in the response are in camelCase\n         camel_key = camel_to_snake_case(key)\n \n         if camel_key not in response:\n             # An observed key should always be present in the k8s response\n             raise KeyError(\n                 f\"Observed key {camel_key} is not present in response {response}\"\n             )\n \n         if isinstance(value, dict):\n             if key not in last_applied_manifest:\n                 # The dictionary is observed, but not present in\n                 # last_applied_manifest\n                 last_applied_manifest[key] = {}\n \n             update_last_applied_manifest_dict_from_resp(\n                 last_applied_manifest[key], observer_schema[key], response[camel_key]\n             )\n \n         elif isinstance(value, list):\n             if key not in last_applied_manifest:\n                 # The list is observed, but not present in last_applied_manifest\n                 last_applied_manifest[key] = []\n \n             update_last_applied_manifest_list_from_resp(\n                 last_applied_manifest[key], observer_schema[key], response[camel_key]\n             )\n \n         elif key not in last_applied_manifest:\n             # If key not present in last_applied_manifest, and value is neither a\n             # dict nor a list, simply add it.\n             last_applied_manifest[key] = response[camel_key]\n \n \n def update_last_applied_manifest_list_from_resp(\n     last_applied_manifest, observer_schema, response\n ):\n     \"\"\"Together with :func:``update_last_applied_manifest_dict_from_resp``, this\n     function is called recursively to update a partial ``last_applied_manifest``\n     from a partial Kubernetes response\n \n     Args:\n         last_applied_manifest (list): partial ``last_applied_manifest`` being\n             updated\n         observer_schema (list): partial ``observer_schema``\n         response (list): partial response from the Kubernetes API.\n \n     This function go through all observed fields, and initialized their value in\n     last_applied_manifest if they are not yet present\n \n     \"\"\"\n     # Looping over the observed resource, except the last element which is the\n     # special control dictionary\n     for idx, val in enumerate(observer_schema[:-1]):\n \n         if idx >= len(response):\n             # Element is observed but not present in k8s response, so following\n             # elements will also not exist.\n             #\n             # This doesn't raise an Exception as observing the element of a list\n             # doesn't ensure its presence. The list length is controlled by the\n             # special control dictionary\n             return\n \n         if isinstance(val, dict):\n             if idx >= len(last_applied_manifest):\n                 # The dict is observed, but not present in last_applied_manifest\n                 last_applied_manifest.append({})\n \n             update_last_applied_manifest_dict_from_resp(\n                 last_applied_manifest[idx], observer_schema[idx], response[idx]\n             )\n \n         elif isinstance(response[idx], list):\n             if idx >= len(last_applied_manifest):\n                 # The list is observed, but not present in last_applied_manifest\n                 last_applied_manifest.append([])\n \n             update_last_applied_manifest_list_from_resp(\n                 last_applied_manifest[idx], observer_schema[idx], response[idx]\n             )\n \n         elif idx >= len(last_applied_manifest):\n             # Element is not yet present in last_applied_manifest. Adding it.\n             last_applied_manifest.append(response[idx])\n \n \n @listen.on(HookType.ResourcePostCreate)\n @listen.on(HookType.ResourcePostUpdate)\n def update_last_applied_manifest_from_resp(app, response, **kwargs):\n     \"\"\"Hook run after the creation or update of an application in order to update the\n     `status.last_applied_manifest` using the k8s response.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application the service belongs to\n         response (kubernetes_asyncio.client.V1Status): Response of the Kubernetes API\n \n     After a Kubernetes resource has been created/updated, the\n     `status.last_applied_manifest` has to be updated. All fields already initialized\n     (either from the mangling of `spec.manifest`, or by a previous call to this\n     function) should be left untouched. Only observed fields which are not present in\n     `status.last_applied_manifest` should be initialized.\n \n     \"\"\"\n \n     if isinstance(response, dict):\n         # The Kubernetes API couldn't deserialize the k8s response into an object\n         resp = response\n     else:\n         # The Kubernetes API deserialized the k8s response into an object\n         resp = response.to_dict()\n \n     idx_applied = get_kubernetes_resource_idx(app.status.last_applied_manifest, resp)\n \n     idx_observed = get_kubernetes_resource_idx(app.status.mangled_observer_schema, resp)\n \n     update_last_applied_manifest_dict_from_resp(\n         app.status.last_applied_manifest[idx_applied],\n         app.status.mangled_observer_schema[idx_observed],\n         resp,\n     )\n \n \n @listen.on(HookType.ResourcePostCreate)\n @listen.on(HookType.ResourcePostUpdate)\n def update_last_observed_manifest_from_resp(app, response, **kwargs):\n     \"\"\"Handler to run after the creation or update of a Kubernetes resource to update\n     the last_observed_manifest from the response of the Kubernetes API.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application the service belongs to\n         response (kubernetes_asyncio.client.V1Service): Response of the\n             Kubernetes API\n \n     The target last_observed_manifest holds the value of all observed fields plus the\n     special control dictionaries for the list length\n \n     \"\"\"\n     if isinstance(response, dict):\n         # The Kubernetes API couldn't deserialize the k8s response into an object\n         resp = response\n     else:\n         # The Kubernetes API deserialized the k8s response into an object\n         resp = response.to_dict()\n \n     try:\n         idx_observed = get_kubernetes_resource_idx(\n             app.status.mangled_observer_schema,\n             resp,\n         )\n     except IndexError:\n         # All created resources should be observed\n         raise\n \n     try:\n         idx_last_observed = get_kubernetes_resource_idx(\n             app.status.last_observed_manifest,\n             resp,\n         )\n     except IndexError:\n         # If the resource is not yes present in last_observed_manifest, append it.\n         idx_last_observed = len(app.status.last_observed_manifest)\n         app.status.last_observed_manifest.append({})\n \n     # Overwrite the last_observed_manifest for this resource\n     app.status.last_observed_manifest[\n         idx_last_observed\n     ] = update_last_observed_manifest_dict(\n         app.status.mangled_observer_schema[idx_observed], resp\n     )\n \n \n def update_last_observed_manifest_dict(observed_resource, response):\n     \"\"\"Together with :func:``update_last_observed_manifest_list``, recursively\n     crafts the ``last_observed_manifest`` from the Kubernetes :attr:``response``.\n \n     Args:\n         observed_resource (dict): The schema to observe for the partial given resource\n         response (dict): The partial Kubernetes response for this resource.\n \n     Raises:\n         KeyError: If an observed key is not present in the Kubernetes response\n \n     Returns:\n         dict: The dictionary of observed keys and their value\n \n     Get the value of all observed fields from the Kubernetes response\n     \"\"\"\n     res = {}\n     for key, value in observed_resource.items():\n \n         camel_key = camel_to_snake_case(key)\n         if camel_key not in response:\n             raise KeyError(\n                 f\"Observed key {camel_key} is not present in response {response}\"\n             )\n \n         if isinstance(value, dict):\n             res[key] = update_last_observed_manifest_dict(value, response[camel_key])\n \n         elif isinstance(value, list):\n             res[key] = update_last_observed_manifest_list(value, response[camel_key])\n \n         else:\n             res[key] = response[camel_key]\n \n     return res\n \n \n def update_last_observed_manifest_list(observed_resource, response):\n     \"\"\"Together with :func:``update_last_observed_manifest_dict``, recursively\n     crafts the ``last_observed_manifest`` from the Kubernetes :attr:``response``.\n \n     Args:\n         observed_resource (list): the schema to observe for the partial given resource\n         response (list): the partial Kubernetes response for this resource.\n \n     Returns:\n         list: The list of observed elements, plus the special list length control\n             dictionary\n \n     Get the value of all observed elements from the Kubernetes response\n     \"\"\"\n \n     if not response:\n         return [{\"observer_schema_list_current_length\": 0}]\n \n     res = []\n     # Looping over the observed resource, except the last element which is the special\n     # control dictionary\n     for idx, val in enumerate(observed_resource[:-1]):\n \n         if idx >= len(response):\n             # Element is not present in the Kubernetes response, nothing more to do\n             break\n \n         if type(response[idx]) == dict:\n             res.append(update_last_observed_manifest_dict(val, response[idx]))\n \n         elif type(response[idx]) == list:\n             res.append(update_last_observed_manifest_list(val, response[idx]))\n \n         else:\n             res.append(response[idx])\n \n     # Append the special control dictionary to the list\n     res.append({\"observer_schema_list_current_length\": len(response)})\n \n     return res\n \n \n def update_last_applied_manifest_dict_from_spec(\n     resource_status_new, resource_status_old, resource_observed\n ):\n     \"\"\"Together with :func:``update_last_applied_manifest_list_from_spec``, this\n     function is called recursively to update a partial ``last_applied_manifest``\n \n     Args:\n         resource_status_new (dict): partial ``last_applied_manifest`` being updated\n         resource_status_old (dict): partial of the current ``last_applied_manifest``\n         resource_observed (dict): partial observer_schema for the manifest file\n             being updated\n \n     \"\"\"\n     for key, value in resource_observed.items():\n \n         if key not in resource_status_old:\n             continue\n \n         if key in resource_status_new:\n \n             if isinstance(value, dict):\n                 update_last_applied_manifest_dict_from_spec(\n                     resource_status_new[key],\n                     resource_status_old[key],\n                     resource_observed[key],\n                 )\n \n             elif isinstance(value, list):\n                 update_last_applied_manifest_list_from_spec(\n                     resource_status_new[key],\n                     resource_status_old[key],\n                     resource_observed[key],\n                 )\n \n         else:\n             # If the key is not present the spec.manifest, we first need to\n             # initialize it\n \n             if isinstance(value, dict):\n                 resource_status_new[key] = {}\n                 update_last_applied_manifest_dict_from_spec(\n                     resource_status_new[key],\n                     resource_status_old[key],\n                     resource_observed[key],\n                 )\n \n             elif isinstance(value, list):\n                 resource_status_new[key] = []\n                 update_last_applied_manifest_list_from_spec(\n                     resource_status_new[key],\n                     resource_status_old[key],\n                     resource_observed[key],\n                 )\n \n             else:\n                 resource_status_new[key] = resource_status_old[key]\n \n \n def update_last_applied_manifest_list_from_spec(\n     resource_status_new, resource_status_old, resource_observed\n ):\n     \"\"\"Together with :func:``update_last_applied_manifest_dict_from_spec``, this\n     function is called recursively to update a partial ``last_applied_manifest``\n \n     Args:\n         resource_status_new (list): partial ``last_applied_manifest`` being updated\n         resource_status_old (list): partial of the current ``last_applied_manifest``\n         resource_observed (list): partial observer_schema for the manifest file\n             being updated\n \n     \"\"\"\n \n     # Looping over the observed resource, except the last element which is the\n     # special control dictionary\n     for idx, val in enumerate(resource_observed[:-1]):\n \n         if idx >= len(resource_status_old):\n             # The element in not in the current last_applied_manifest, and neither\n             # is the rest of the list\n             break\n \n         if idx < len(resource_status_new):\n             # The element is present in spec.manifest and in the current\n             # last_applied_manifest. Updating observed fields\n \n             if isinstance(val, dict):\n                 update_last_applied_manifest_dict_from_spec(\n                     resource_status_new[idx],\n                     resource_status_old[idx],\n                     resource_observed[idx],\n                 )\n \n             elif isinstance(val, list):\n                 update_last_applied_manifest_list_from_spec(\n                     resource_status_new[idx],\n                     resource_status_old[idx],\n                     resource_observed[idx],\n                 )\n \n         else:\n             # If the element is not present in the spec.manifest, we first have to\n             # initialize it.\n \n             if isinstance(val, dict):\n                 resource_status_new.append({})\n                 update_last_applied_manifest_dict_from_spec(\n                     resource_status_new[idx],\n                     resource_status_old[idx],\n                     resource_observed[idx],\n                 )\n \n             elif isinstance(val, list):\n                 resource_status_new.append([])\n                 update_last_applied_manifest_list_from_spec(\n                     resource_status_new[idx],\n                     resource_status_old[idx],\n                     resource_observed[idx],\n                 )\n \n             else:\n                 resource_status_new.append(resource_status_old[idx])\n \n \n def update_last_applied_manifest_from_spec(app):\n     \"\"\"Update the status.last_applied_manifest of an application from spec.manifests\n \n     Args:\n         app (krake.data.kubernetes.Application): Application to update\n \n     This function is called on application creation and updates. The\n     last_applied_manifest of an application is initialized as a copy of spec.manifest,\n     and is augmented by all known observed fields not yet initialized (i.e. all observed\n     fields or resources which are present in the current last_applied_manifest but not\n     in the spec.manifest)\n \n     \"\"\"\n \n     # The new last_applied_manifest is initialized as a copy of the spec.manifest, and\n     # augmented by all observed fields which are present in the current\n     # last_applied_manifest but not in the original spec.manifest\n     new_last_applied_manifest = deepcopy(app.spec.manifest)\n \n     # Loop over observed resources and observed fields, and check if they should be\n     # added to the new last_applied_manifest (i.e. present in the current\n     # last_applied_manifest but not in spec.manifest)\n     for resource_observed in app.status.mangled_observer_schema:\n \n         # If the resource is not present in the current last_applied_manifest, there is\n         # nothing to do. Whether the resource was initialized by spec.manifest doesn't\n         # matter.\n         try:\n             idx_status_old = get_kubernetes_resource_idx(\n                 app.status.last_applied_manifest, resource_observed\n             )\n         except IndexError:\n             continue\n \n         # As the resource is present in the current last_applied_manifest, we need to go\n         # through it to check if observed fields should be set to their current value\n         # (i.e. fields are present in the current last_applied_manifest, but not in\n         # spec.manifest)\n         try:\n             # Check if the observed resource is present in spec.manifest\n             idx_status_new = get_kubernetes_resource_idx(\n                 new_last_applied_manifest, resource_observed\n             )\n         except IndexError:\n             # The resource is observed but is not present in the spec.manifest.\n             # Create an empty resource, which will be augmented in\n             # update_last_applied_manifest_dict_from_spec with the observed and known\n             # fields.\n             new_last_applied_manifest.append({})\n             idx_status_new = len(new_last_applied_manifest) - 1\n \n         update_last_applied_manifest_dict_from_spec(\n             new_last_applied_manifest[idx_status_new],\n             app.status.last_applied_manifest[idx_status_old],\n             resource_observed,\n         )\n \n     app.status.last_applied_manifest = new_last_applied_manifest\n \n \n class KubernetesApplicationObserver(Observer):\n     \"\"\"Observer specific for Kubernetes Applications. One observer is created for each\n     Application managed by the Controller, but not one per Kubernetes resource\n     (Deployment, Service...). If several resources are defined by an Application, they\n     are all monitored by the same observer.\n \n     The observer gets the actual status of the resources on the cluster using the\n     Kubernetes API, and compare it to the status stored in the API.\n \n     The observer is:\n      * started at initial Krake resource creation;\n \n      * deleted when a resource needs to be updated, then started again when it is done;\n \n      * simply deleted on resource deletion.\n \n     Args:\n         cluster (krake.data.kubernetes.Cluster): the cluster on which the observed\n             Application is created.\n         resource (krake.data.kubernetes.Application): the application that will be\n             observed.\n         on_res_update (coroutine): a coroutine called when a resource's actual status\n             differs from the status sent by the database. Its signature is:\n             ``(resource) -> updated_resource``. ``updated_resource`` is the instance of\n             the resource that is up-to-date with the API. The Observer internal instance\n             of the resource to observe will be updated. If the API cannot be contacted,\n             ``None`` can be returned. In this case the internal instance of the Observer\n             will not be updated.\n         time_step (int, optional): how frequently the Observer should watch the actual\n             status of the resources.\n \n     \"\"\"\n \n     def __init__(self, cluster, resource, on_res_update, time_step=2):\n         super().__init__(resource, on_res_update, time_step)\n         self.cluster = cluster\n \n     async def poll_resource(self):\n         \"\"\"Fetch the current status of the Application monitored by the Observer.\n \n         Returns:\n             krake.data.core.Status: the status object created using information from the\n                 real world Applications resource.\n \n         \"\"\"\n         app = self.resource\n \n         status = deepcopy(app.status)\n         status.last_observed_manifest = []\n         # For each observed kubernetes resource of the Application,\n         # get its current status on the cluster.\n         for desired_resource in app.status.last_applied_manifest:\n             kube = KubernetesClient(self.cluster.spec.kubeconfig)\n             idx_observed = get_kubernetes_resource_idx(\n                 app.status.mangled_observer_schema, desired_resource\n             )\n             observed_resource = app.status.mangled_observer_schema[idx_observed]\n             async with kube:\n                 try:\n                     group, version, kind, name, namespace = kube.get_immutables(\n                         desired_resource\n                     )\n                     resource_api = await kube.get_resource_api(group, version, kind)\n                     resp = await resource_api.read(kind, name, namespace)\n                 except ApiException as err:\n                     if err.status == 404:\n                         # Resource does not exist\n                         continue\n                     # Otherwise, log the unexpected errors\n                     logger.error(err)\n \n             observed_manifest = update_last_observed_manifest_dict(\n                 observed_resource, resp.to_dict()\n             )\n             status.last_observed_manifest.append(observed_manifest)\n \n         return status\n \n \n class KubernetesClusterObserver(Observer):\n     \"\"\"Observer specific for Kubernetes Clusters. One observer is created for each\n     Cluster managed by the Controller.\n \n     The observer gets the actual status of the cluster using the\n     Kubernetes API, and compare it to the status stored in the API.\n \n     The observer is:\n      * started at initial Krake resource creation;\n \n      * deleted when a resource needs to be updated, then started again when it is done;\n \n      * simply deleted on resource deletion.\n \n     Args:\n         cluster (krake.data.kubernetes.Cluster): the cluster which will be observed.\n         on_res_update (coroutine): a coroutine called when a resource's actual status\n             differs from the status sent by the database. Its signature is:\n             ``(resource) -> updated_resource``. ``updated_resource`` is the instance of\n             the resource that is up-to-date with the API. The Observer internal instance\n             of the resource to observe will be updated. If the API cannot be contacted,\n             ``None`` can be returned. In this case the internal instance of the Observer\n             will not be updated.\n         time_step (int, optional): how frequently the Observer should watch the actual\n             status of the resources.\n \n     \"\"\"\n \n     def __init__(self, cluster, on_res_update, time_step=2):\n         super().__init__(cluster, on_res_update, time_step)\n         self.cluster = cluster\n \n     async def poll_resource(self):\n         \"\"\"Fetch the current status of the Cluster monitored by the Observer.\n \n         Returns:\n             krake.data.core.Status: the status object created using information from the\n                 real world Cluster.\n \n         \"\"\"\n         status = deepcopy(self.cluster.status)\n         # For each observed kubernetes cluster registered in Krake,\n         # get its current node status.\n         loader = KubeConfigLoader(self.cluster.spec.kubeconfig)\n         config = Configuration()\n         await loader.load_and_set(config)\n         kube = ApiClient(config)\n \n         async with kube as api:\n             v1 = client.CoreV1Api(api)\n             try:\n                 response = await v1.list_node()\n \n             except ClientConnectorError as err:\n                 status.state = ClusterState.OFFLINE\n                 self.cluster.status.state = ClusterState.OFFLINE\n                 # Log the error\n                 logger.debug(err)\n                 return status\n \n             condition_dict = {\n                 \"MemoryPressure\": [],\n                 \"DiskPressure\": [],\n                 \"PIDPressure\": [],\n                 \"Ready\": [],\n             }\n \n             for item in response.items:\n                 for condition in item.status.conditions:\n                     condition_dict[condition.type].append(condition.status)\n                 if (\n                     condition_dict[\"MemoryPressure\"] == [\"True\"]\n                     or condition_dict[\"DiskPressure\"] == [\"True\"]\n                     or condition_dict[\"PIDPressure\"] == [\"True\"]\n                 ):\n                     status.state = ClusterState.UNHEALTHY\n                     self.cluster.status.state = ClusterState.UNHEALTHY\n                     return status\n                 elif (\n                     condition_dict[\"Ready\"] == [\"True\"]\n                     and status.state is ClusterState.OFFLINE\n                 ):\n                     status.state = ClusterState.CONNECTING\n                     self.cluster.status.state = ClusterState.CONNECTING\n                     return status\n                 elif condition_dict[\"Ready\"] == [\"True\"]:\n                     status.state = ClusterState.ONLINE\n                     self.cluster.status.state = ClusterState.ONLINE\n                     return status\n                 else:\n                     status.state = ClusterState.NOTREADY\n                     self.cluster.status.state = ClusterState.NOTREADY\n                     return status\n \n \n @listen.on(HookType.ApplicationPostReconcile)\n @listen.on(HookType.ApplicationPostMigrate)\n @listen.on(HookType.ClusterCreation)\n async def register_observer(controller, resource, start=True, **kwargs):\n     \"\"\"Create an observer for the given Application or Cluster, and start it as a\n     background task if wanted.\n \n     If an observer already existed for this Application or Cluster, it is stopped\n     and deleted.\n \n     Args:\n         controller (KubernetesController): the controller for which the observer will be\n             added in the list of working observers.\n         resource (krake.data.kubernetes.Application): the Application to observe or\n         resource (krake.data.kubernetes.Cluster): the Cluster to observe.\n         start (bool, optional): if False, does not start the observer as background\n             task.\n \n     \"\"\"\n     if resource.kind == Application.kind:\n         cluster = await controller.kubernetes_api.read_cluster(\n             namespace=resource.status.running_on.namespace,\n             name=resource.status.running_on.name,\n         )\n \n         observer = KubernetesApplicationObserver(\n             cluster,\n             resource,\n             controller.on_status_update,\n             time_step=controller.observer_time_step,\n         )\n \n     elif resource.kind == Cluster.kind:\n         observer = KubernetesClusterObserver(\n             resource,\n             controller.on_status_update,\n             time_step=controller.observer_time_step,\n         )\n     else:\n         logger.debug(\"Unknown resource kind. No observer was registered.\", resource)\n         return\n \n     logger.debug(f\"Start observer for {resource.kind} %r\", resource.metadata.name)\n     task = None\n     if start:\n         task = controller.loop.create_task(observer.run())\n \n     controller.observers[resource.metadata.uid] = (observer, task)\n \n \n @listen.on(HookType.ApplicationPreReconcile)\n @listen.on(HookType.ApplicationPreMigrate)\n @listen.on(HookType.ApplicationPreDelete)\n @listen.on(HookType.ClusterDeletion)\n async def unregister_observer(controller, resource, **kwargs):\n     \"\"\"Stop and delete the observer for the given Application or Cluster. If no observer\n     is started, do nothing.\n \n     Args:\n         controller (KubernetesController): the controller for which the observer will be\n             removed from the list of working observers.\n         resource (krake.data.kubernetes.Application): the Application whose observer\n         will be stopped or\n         resource (krake.data.kubernetes.Cluster): the Cluster whose observer will be\n         stopped.\n \n     \"\"\"\n     if resource.metadata.uid not in controller.observers:\n         return\n \n     logger.debug(f\"Stop observer for {resource.kind} %r\", resource.metadata.name)\n     _, task = controller.observers.pop(resource.metadata.uid)\n     task.cancel()\n \n     with suppress(asyncio.CancelledError):\n         await task\n \n \n def utc_difference():\n     \"\"\"Get the difference in seconds between the current time and the current UTC time.\n \n     Returns:\n         int: the time difference in seconds.\n \n     \"\"\"\n     delta = datetime.now() - datetime.utcnow()\n     return delta.seconds\n \n \n def generate_certificate(config):\n     \"\"\"Create and sign a new certificate using the one defined in the complete hook\n     configuration as intermediate certificate.\n \n     Args:\n         config (krake.data.config.CompleteHookConfiguration): the configuration of the\n             complete hook.\n \n     Returns:\n         CertificatePair: the content of the certificate created and its corresponding\n             key.\n \n     \"\"\"\n     with open(config.intermediate_src, \"rb\") as f:\n         intermediate_src = crypto.load_certificate(crypto.FILETYPE_PEM, f.read())\n     with open(config.intermediate_key_src, \"rb\") as f:\n         intermediate_key_src = crypto.load_privatekey(crypto.FILETYPE_PEM, f.read())\n \n     client_cert = crypto.X509()\n \n     # Set general information\n     client_cert.set_version(3)\n     client_cert.set_serial_number(random.randint(50000000000000, 100000000000000))\n     # If not set before, TLS will not accept to use this certificate in UTC cases, as\n     # the server time may be earlier.\n     time_offset = utc_difference() * -1\n     client_cert.gmtime_adj_notBefore(time_offset)\n     client_cert.gmtime_adj_notAfter(1 * 365 * 24 * 60 * 60)\n \n     # Set issuer and subject\n     intermediate_subject = intermediate_src.get_subject()\n     client_cert.set_issuer(intermediate_subject)\n     client_subj = crypto.X509Name(intermediate_subject)\n     client_subj.CN = config.hook_user\n     client_cert.set_subject(client_subj)\n \n     # Create and set the private key\n     client_key = crypto.PKey()\n     client_key.generate_key(crypto.TYPE_RSA, 2048)\n     client_cert.set_pubkey(client_key)\n \n     client_cert.sign(intermediate_key_src, \"sha256\")\n \n     cert_dump = crypto.dump_certificate(crypto.FILETYPE_PEM, client_cert).decode()\n     key_dump = crypto.dump_privatekey(crypto.FILETYPE_PEM, client_key).decode()\n     return CertificatePair(cert=cert_dump, key=key_dump)\n \n \n def generate_default_observer_schema(app):\n     \"\"\"Generate the default observer schema for each Kubernetes resource present in\n     ``spec.manifest`` for which a custom observer schema hasn't been specified.\n \n     Args:\n         app (krake.data.kubernetes.Application): The application for which to generate a\n             default observer schema\n     \"\"\"\n \n     app.status.mangled_observer_schema = deepcopy(app.spec.observer_schema)\n \n     for resource_manifest in app.spec.manifest:\n         try:\n             get_kubernetes_resource_idx(\n                 app.status.mangled_observer_schema, resource_manifest\n             )\n \n         except IndexError:\n             # Only create a default observer schema, if a custom observer schema hasn't\n             # been set by the user.\n             app.status.mangled_observer_schema.append(\n                 generate_default_observer_schema_dict(\n                     resource_manifest,\n                     first_level=True,\n                 )\n             )\n \n \n def generate_default_observer_schema_dict(manifest_dict, first_level=False):\n     \"\"\"Together with :func:``generate_default_observer_schema_list``, this function is\n     called recursively to generate part of a default ``observer_schema`` from part of a\n     Kubernetes resource, defined respectively by ``manifest_dict`` or ``manifest_list``.\n \n     Args:\n         manifest_dict (dict): Partial Kubernetes resources\n         first_level (bool, optional): If True, indicates that the dictionary represents\n             the whole observer schema of a Kubernetes resource\n \n     Returns:\n         dict: Generated partial observer_schema\n \n     This function creates a new dictionary from ``manifest_dict`` and replaces all\n     non-list and non-dict values by ``None``.\n \n     In case of ``first_level`` dictionary (i.e. complete ``observer_schema`` for a\n     resource), the values of the identifying fields are copied from the manifest file.\n \n     \"\"\"\n     observer_schema_dict = {}\n \n     for key, value in manifest_dict.items():\n \n         if isinstance(value, dict):\n             observer_schema_dict[key] = generate_default_observer_schema_dict(value)\n \n         elif isinstance(value, list):\n             observer_schema_dict[key] = generate_default_observer_schema_list(value)\n \n         else:\n             observer_schema_dict[key] = None\n \n     if first_level:\n         observer_schema_dict[\"apiVersion\"] = manifest_dict[\"apiVersion\"]\n         observer_schema_dict[\"kind\"] = manifest_dict[\"kind\"]\n         observer_schema_dict[\"metadata\"][\"name\"] = manifest_dict[\"metadata\"][\"name\"]\n \n         if (\n             \"spec\" in manifest_dict\n             and \"type\" in manifest_dict[\"spec\"]\n             and manifest_dict[\"spec\"][\"type\"] == \"LoadBalancer\"\n         ):\n             observer_schema_dict[\"status\"] = {\"load_balancer\": {\"ingress\": None}}\n \n     return observer_schema_dict\n \n \n def generate_default_observer_schema_list(manifest_list):\n     \"\"\"Together with :func:``generate_default_observer_schema_dict``, this function is\n     called recursively to generate part of a default ``observer_schema`` from part of a\n     Kubernetes resource, defined respectively by ``manifest_list`` or ``manifest_dict``.\n \n     Args:\n         manifest_list (list): Partial Kubernetes resources\n \n     Returns:\n         list: Generated partial observer_schema\n \n     This function creates a new list from ``manifest_list`` and replaces all non-list\n     and non-dict elements by ``None``.\n \n     Additionally, it generates the default list control dictionary, using the current\n     length of the list as default minimum and maximum values.\n \n     \"\"\"\n     observer_schema_list = []\n \n     for value in manifest_list:\n \n         if isinstance(value, dict):\n             observer_schema_list.append(generate_default_observer_schema_dict(value))\n \n         elif isinstance(value, list):\n             observer_schema_list.append(generate_default_observer_schema_list(value))\n \n         else:\n             observer_schema_list.append(None)\n \n     observer_schema_list.append(\n         {\n             \"observer_schema_list_min_length\": len(manifest_list),\n             \"observer_schema_list_max_length\": len(manifest_list),\n         }\n     )\n \n     return observer_schema_list\n \n \n @listen.on(HookType.ApplicationMangling)\n async def complete(app, api_endpoint, ssl_context, config):\n     \"\"\"Execute application complete hook defined by :class:`Complete`.\n     Hook mangles given application and injects complete hooks variables.\n \n     Application complete hook is disabled by default.\n     User enables this hook by the --hook-complete argument in rok cli.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application object processed\n             when the hook is called\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         config (krake.data.config.HooksConfiguration): Complete hook\n             configuration.\n \n     \"\"\"\n     if \"complete\" not in app.spec.hooks:\n         return\n \n     # Use the endpoint of the API only if the external endpoint has not been set.\n     if config.complete.external_endpoint:\n         api_endpoint = config.complete.external_endpoint\n \n     app.status.complete_token = \\\n         app.status.complete_token if app.status.complete_token else token_urlsafe()\n \n     # Generate only once the certificate and key for a specific Application\n     generated_cert = CertificatePair(\n         cert=app.status.complete_cert, key=app.status.complete_key\n     )\n     if ssl_context and generated_cert == (None, None):\n         generated_cert = generate_certificate(config.complete)\n         app.status.complete_cert = generated_cert.cert\n         app.status.complete_key = generated_cert.key\n \n     hook = Complete(\n         api_endpoint,\n         ssl_context,\n         hook_user=config.complete.hook_user,\n         cert_dest=config.complete.cert_dest,\n         env_token=config.complete.env_token,\n         env_url=config.complete.env_url,\n     )\n     hook.mangle_app(\n         app.metadata.name,\n         app.metadata.namespace,\n         app.status.complete_token,\n         app.status.last_applied_manifest,\n         config.complete.intermediate_src,\n         generated_cert,\n         app.status.mangled_observer_schema,\n         \"complete\"\n     )\n \n \n @listen.on(HookType.ApplicationMangling)\n async def shutdown(app, api_endpoint, ssl_context, config):\n     \"\"\"Executes an application shutdown hook defined by :class:`Shutdown`.\n     The hook mangles the given application and injects shutdown hooks variables.\n \n     Application shutdown hook is disabled by default.\n     User enables this hook by the --hook-shutdown argument in rok cli.\n \n     Args:\n         app (krake.data.kubernetes.Application): Application object processed\n             when the hook is called\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         config (krake.data.config.HooksConfiguration): Shutdown hook\n             configuration.\n \n     \"\"\"\n     if \"shutdown\" not in app.spec.hooks:\n         return\n \n     # Use the endpoint of the API only if the external endpoint has not been set.\n     if config.shutdown.external_endpoint:\n         api_endpoint = config.shutdown.external_endpoint\n \n     app.status.shutdown_token = \\\n         app.status.shutdown_token if app.status.shutdown_token else token_urlsafe()\n \n     # Generate only once the certificate and key for a specific Application\n     generated_cert = CertificatePair(\n         cert=app.status.shutdown_cert, key=app.status.shutdown_key\n     )\n     if ssl_context and generated_cert == (None, None):\n         generated_cert = generate_certificate(config.shutdown)\n         app.status.shutdown_cert = generated_cert.cert\n         app.status.shutdown_key = generated_cert.key\n \n     hook = Shutdown(\n         api_endpoint,\n         ssl_context,\n         hook_user=config.shutdown.hook_user,\n         cert_dest=config.shutdown.cert_dest,\n         env_token=config.shutdown.env_token,\n         env_url=config.shutdown.env_url,\n     )\n     hook.mangle_app(\n         app.metadata.name,\n         app.metadata.namespace,\n         app.status.shutdown_token,\n         app.status.last_applied_manifest,\n         config.shutdown.intermediate_src,\n         generated_cert,\n         app.status.mangled_observer_schema,\n         \"shutdown\"\n     )\n \n \n @listen.on(HookType.ResourcePreDelete)\n async def pre_shutdown(controller, app, **kwargs):\n     \"\"\"\n \n     Args:\n         app (krake.data.kubernetes.Application): Application object processed\n             when the hook is called\n     \"\"\"\n     if \"shutdown\" not in app.spec.hooks:\n         return\n \n     return\n \n \n class SubResource(NamedTuple):\n     group: str\n     name: str\n     body: dict\n     path: tuple\n \n \n class CertificatePair(NamedTuple):\n     \"\"\"Tuple which contains a certificate and its corresponding key.\n \n     Attributes:\n         cert (str): content of a certificate.\n         key (str): content of the key that corresponds to the certificate.\n \n     \"\"\"\n \n     cert: str\n     key: str\n \n \n class Hook(object):\n \n     hook_resources = ()\n \n     ca_name = \"ca-bundle.pem\"\n     cert_name = \"cert.pem\"\n     key_name = \"key.pem\"\n \n     def __init__(\n         self, api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n     ):\n         self.api_endpoint = api_endpoint\n         self.ssl_context = ssl_context\n         self.hook_user = hook_user\n         self.cert_dest = cert_dest\n         self.env_token = env_token\n         self.env_url = env_url\n \n     def mangle_app(\n         self,\n         name,\n         namespace,\n         token,\n         last_applied_manifest,\n         intermediate_src,\n         generated_cert,\n         mangled_observer_schema,\n         hook_type=\"\",\n     ):\n         \"\"\"Mangle a given application and inject complete hook resources and\n         sub-resources into the :attr:`last_applied_manifest` object by :meth:`mangle`.\n         Also mangle the observer_schema as new resources and sub-resources should\n         be observed.\n \n         :attr:`last_applied_manifest` is created as a deep copy of the desired\n         application resources, as defined by user. It can be updated by custom hook\n         resources or modified by custom hook sub-resources. It is used as a desired\n         state for the Krake deployment process.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             token (str): Complete hook authentication token\n             last_applied_manifest (list): Application resources\n             intermediate_src (str): content of the certificate that is used to sign new\n                 certificates for the complete hook.\n             generated_cert (CertificatePair): tuple that contains the content of the\n                 new signed certificate for the Application, and the content of its\n                 corresponding key.\n             mangled_observer_schema (list): Observed fields\n             hook_type (str, optional): Name of the hook the app should be mangled for\n \n         \"\"\"\n \n         secret_certs_name = \"-\".join([name, \"krake\", hook_type, \"secret\", \"certs\"])\n         secret_token_name = \"-\".join([name, \"krake\", hook_type, \"secret\", \"token\"])\n         volume_name = \"-\".join([name, \"krake\", hook_type, \"volume\"])\n         ca_certs = (\n             self.ssl_context.get_ca_certs(binary_form=True)\n             if self.ssl_context\n             else None\n         )\n \n         # Extract all different namespaces\n         # FIXME: too many assumptions here: do we create one ConfigMap for each\n         #  namespace?\n         resource_namespaces = {\n             resource[\"metadata\"].get(\"namespace\", \"default\")\n             for resource in last_applied_manifest\n         }\n \n         hook_resources = []\n         hook_sub_resources = []\n         if ca_certs:\n             hook_resources.extend(\n                 [\n                     self.secret_certs(\n                         secret_certs_name,\n                         resource_namespace,\n                         intermediate_src=intermediate_src,\n                         generated_cert=generated_cert,\n                         ca_certs=ca_certs,\n                     )\n                     for resource_namespace in resource_namespaces\n                 ]\n             )\n             hook_sub_resources.extend(\n                 [*self.volumes(secret_certs_name, volume_name, self.cert_dest)]\n             )\n \n         hook_resources.extend(\n             [\n                 self.secret_token(\n                     secret_token_name,\n                     name,\n                     namespace,\n                     resource_namespace,\n                     self.api_endpoint,\n                     token,\n                 )\n                 for resource_namespace in resource_namespaces\n             ]\n         )\n         hook_sub_resources.extend(\n             [\n                 *self.env_vars(secret_token_name),\n             ]\n         )\n \n         self.mangle(\n             hook_resources,\n             last_applied_manifest,\n             mangled_observer_schema,\n         )\n         self.mangle(\n             hook_sub_resources,\n             last_applied_manifest,\n             mangled_observer_schema,\n             is_sub_resource=True,\n         )\n \n     def mangle(\n         self,\n         items,\n         last_applied_manifest,\n         mangled_observer_schema,\n         is_sub_resource=False,\n     ):\n         \"\"\"Mangle applications desired state with custom hook resources or\n         sub-resources.\n \n         Example:\n             .. code:: python\n \n             last_applied_manifest = [\n                 {\n                     'apiVersion': 'v1',\n                     'kind': 'Pod',\n                     'metadata': {'name': 'test', 'namespace': 'default'},\n                     'spec': {'containers': [{'name': 'test'}]}\n                 }\n             ]\n             mangled_observer_schema = [\n                 {\n                     'apiVersion': 'v1',\n                     'kind': 'Pod',\n                     'metadata': {'name': 'test', 'namespace': 'default'},\n                     'spec': {\n                         'containers': [\n                             {'name': None},\n                             {\n                                 'observer_schema_list_max_length': 1,\n                                 'observer_schema_list_min_length': 1,\n                             },\n                         ]\n                     },\n                 }\n             ]\n             hook_resources = [\n                 {\n                     'apiVersion': 'v1',\n                     'kind': 'Secret',\n                     'metadata': {'name': 'sct', 'namespace': 'default'}\n                 }\n             ]\n             hook_sub_resources = [\n                 SubResource(\n                     group='env', name='env', body={'name': 'test', 'value': 'test'},\n                     path=(('spec', 'containers'),)\n                 )\n             ]\n \n             mangle(\n                 hook_resources,\n                 last_applied_manifest,\n                 mangled_observer_schema,\n             )\n             mangle(\n                 hook_sub_resources,\n                 last_applied_manifest,\n                 mangled_observer_schema,\n                 is_sub_resource=True\n             )\n \n             assert last_applied_manifest == [\n                 {\n                     \"apiVersion\": \"v1\",\n                     \"kind\": \"Pod\",\n                     \"metadata\": {\"name\": \"test\", 'namespace': 'default'},\n                     \"spec\": {\n                         \"containers\": [\n                             {\n                                 \"name\": \"test\",\n                                 \"env\": [{\"name\": \"test\", \"value\": \"test\"}]\n                             }\n                         ]\n                     },\n                 },\n                 {\"apiVersion\": \"v1\", \"kind\": \"Secret\", \"metadata\": {\"name\": \"sct\"}},\n             ]\n \n             assert mangled_observer_schema == [\n                 {\n                     \"apiVersion\": \"v1\",\n                     \"kind\": \"Pod\",\n                     \"metadata\": {\"name\": \"test\", \"namespace\": None},\n                     \"spec\": {\n                         \"containers\": [\n                             {\n                                 \"name\": None,\n                                 \"env\": [\n                                     {\"name\": None, \"value\": None},\n                                     {\n                                         \"observer_schema_list_max_length\": 1,\n                                         \"observer_schema_list_min_length\": 1,\n                                     },\n                                 ],\n                             },\n                             {\n                                 \"observer_schema_list_max_length\": 1,\n                                 \"observer_schema_list_min_length\": 1,\n                             },\n                         ]\n                     },\n                 },\n                 {\n                     \"apiVersion\": \"v1\",\n                     \"kind\": \"Secret\",\n                     \"metadata\": {\"name\": \"sct\", \"namespace\": None},\n                 },\n             ]\n \n         Args:\n             items (list[SubResource]): Custom hook resources or sub-resources\n             last_applied_manifest (list): Application resources\n             mangled_observer_schema (list): Observed resources\n             is_sub_resource (bool, optional): if False, the function only extend the\n                 list of Kubernetes resources defined in :attr:`last_applied_manifest`\n                 with new hook resources. Otherwise, the function injects each new hook\n                 sub-resource into the :attr:`last_applied_manifest` object\n                 sub-resources. Defaults to False.\n \n         \"\"\"\n \n         if not items:\n             return\n \n         if not is_sub_resource:\n             last_applied_manifest.extend(items)\n             for sub_resource in items:\n                 # Generate the default observer schema for each resource\n                 mangled_observer_schema.append(\n                     generate_default_observer_schema_dict(\n                         sub_resource,\n                         first_level=True,\n                     )\n                 )\n             return\n \n         def inject(sub_resource, sub_resource_to_mangle, observed_resource_to_mangle):\n             \"\"\"Inject a hooks defined sub-resource into a Kubernetes sub-resource.\n \n             Args:\n                 sub_resource (SubResource): Hook sub-resource that needs to be injected\n                     into :attr:`last_applied_manifest`\n                 sub_resource_to_mangle (object): Kubernetes sub-resources from\n                     :attr:`last_applied_manifest` which need to be processed\n                 observed_resource_to_mangle (dict): partial mangled_observer_schema\n                     corresponding to the Kubernetes sub-resource.\n \n             Raises:\n                 InvalidManifestError: if the sub-resource which will be mangled is not a\n                     list or a dict.\n \n             \"\"\"\n \n             # Create sub-resource group if not present in the Kubernetes sub-resource\n             if sub_resource.group not in sub_resource_to_mangle:\n                 # FIXME: This assumes the subresource group contains a list\n                 sub_resource_to_mangle.update({sub_resource.group: []})\n \n             # Create sub-resource group if not present in the observed fields\n             if sub_resource.group not in observed_resource_to_mangle:\n                 observed_resource_to_mangle.update(\n                     {\n                         sub_resource.group: [\n                             {\n                                 \"observer_schema_list_min_length\": 0,\n                                 \"observer_schema_list_max_length\": 0,\n                             }\n                         ]\n                     }\n                 )\n \n             # Inject sub-resource\n             # If sub-resource name is already there update it, if not, append it\n             if sub_resource.name in [\n                 g[\"name\"] for g in sub_resource_to_mangle[sub_resource.group]\n             ]:\n                 # FIXME: Assuming we are dealing with a list\n                 for idx, item in enumerate(sub_resource_to_mangle[sub_resource.group]):\n                     if item[\"name\"]:\n                         if hasattr(item, \"body\"):\n                             sub_resource_to_mangle[item.group][idx] = item[\"body\"]\n             else:\n                 sub_resource_to_mangle[sub_resource.group].append(sub_resource.body)\n \n             # Make sure the value is observed\n             if sub_resource.name not in [\n                 g[\"name\"] for g in observed_resource_to_mangle[sub_resource.group][:-1]\n             ]:\n                 observed_resource_to_mangle[sub_resource.group].insert(\n                     -1, generate_default_observer_schema_dict(sub_resource.body)\n                 )\n                 observed_resource_to_mangle[sub_resource.group][-1][\n                     \"observer_schema_list_min_length\"\n                 ] += 1\n                 observed_resource_to_mangle[sub_resource.group][-1][\n                     \"observer_schema_list_max_length\"\n                 ] += 1\n \n         for resource in last_applied_manifest:\n             # Complete hook is applied only on defined Kubernetes resources\n             if resource[\"kind\"] not in self.hook_resources:\n                 continue\n \n             for sub_resource in items:\n                 sub_resources_to_mangle = None\n                 idx_observed = get_kubernetes_resource_idx(\n                     mangled_observer_schema, resource\n                 )\n                 for keys in sub_resource.path:\n                     try:\n                         sub_resources_to_mangle = reduce(getitem, keys, resource)\n                     except KeyError:\n                         continue\n \n                     break\n \n                 # Create the path to the observed sub-resource, if it doesn't yet exist\n                 try:\n                     observed_sub_resources = reduce(\n                         getitem, keys, mangled_observer_schema[idx_observed]\n                     )\n                 except KeyError:\n                     Complete.create_path(\n                         mangled_observer_schema[idx_observed], list(keys)\n                     )\n                     observed_sub_resources = reduce(\n                         getitem, keys, mangled_observer_schema[idx_observed]\n                     )\n \n                 if isinstance(sub_resources_to_mangle, list):\n                     for idx, sub_resource_to_mangle in enumerate(\n                         sub_resources_to_mangle\n                     ):\n \n                         # Ensure that each element of the list is observed.\n                         idx_observed = idx\n                         if idx >= len(observed_sub_resources[:-1]):\n                             idx_observed = len(observed_sub_resources[:-1])\n                             # FIXME: Assuming each element of the list contains a\n                             # dictionary, therefore initializing new elements with an\n                             # empty dict\n                             observed_sub_resources.insert(-1, {})\n                         observed_sub_resource = observed_sub_resources[idx_observed]\n \n                         # FIXME: This is assuming a list always contains dict\n                         inject(\n                             sub_resource, sub_resource_to_mangle, observed_sub_resource\n                         )\n \n                 elif isinstance(sub_resources_to_mangle, dict):\n                     inject(\n                         sub_resource, sub_resources_to_mangle, observed_sub_resources\n                     )\n \n                 else:\n                     message = (\n                         f\"The sub-resource to mangle {sub_resources_to_mangle!r} has an\"\n                         \"invalid type, should be in '[dict, list]'\"\n                     )\n                     raise InvalidManifestError(message)\n \n     @staticmethod\n     def attribute_map(obj):\n         \"\"\"Convert a Kubernetes object to dict based on its attribute mapping\n \n         Example:\n             .. code:: python\n \n             from kubernetes_asyncio.client import V1VolumeMount\n \n             d = attribute_map(\n                     V1VolumeMount(name=\"name\", mount_path=\"path\")\n             )\n             assert d == {'mountPath': 'path', 'name': 'name'}\n \n         Args:\n             obj (object): Kubernetes object\n \n         Returns:\n             dict: Converted Kubernetes object\n \n         \"\"\"\n         return {\n             obj.attribute_map[attr]: getattr(obj, attr)\n             for attr, _ in obj.to_dict().items()\n             if getattr(obj, attr) is not None\n         }\n \n     @staticmethod\n     def create_path(mangled_observer_schema, keys):\n         \"\"\"Create the path to the observed field in the observer schema.\n \n         When a sub-resource is mangled, it should be observed. This function creates\n         the path to the subresource to observe.\n \n         Args:\n             mangled_observer_schema (dict): Partial observer schema of a resource\n             keys (list): list of keys forming the path to the sub-resource to\n                 observe\n \n         FIXME: This assumes we are only adding keys to dict. We don't consider lists\n \n         \"\"\"\n \n         # Unpack the first key first, as it contains the base directory\n         key = keys.pop(0)\n \n         # If the key is the last of the list, we reached the end of the path.\n         if len(keys) == 0:\n             mangled_observer_schema[key] = None\n             return\n \n         if key not in mangled_observer_schema:\n             mangled_observer_schema[key] = {}\n         Hook.create_path(mangled_observer_schema[key], keys)\n \n     def secret_certs(\n         self,\n         secret_name,\n         namespace,\n         ca_certs=None,\n         intermediate_src=None,\n         generated_cert=None,\n     ):\n         \"\"\"Create a complete hooks secret resource.\n \n         Complete hook secret stores Krake CAs and client certificates to communicate\n         with the Krake API.\n \n         Args:\n             secret_name (str): Secret name\n             namespace (str): Kubernetes namespace where the Secret will be created.\n             ca_certs (list): Krake CA list\n             intermediate_src (str): content of the certificate that is used to sign new\n                 certificates for the complete hook.\n             generated_cert (CertificatePair): tuple that contains the content of the\n                 new signed certificate for the Application, and the content of its\n                 corresponding key.\n \n         Returns:\n             dict: complete hook secret resource\n \n         \"\"\"\n         ca_certs_pem = \"\"\n         for ca_cert in ca_certs:\n             x509 = crypto.load_certificate(crypto.FILETYPE_ASN1, ca_cert)\n             ca_certs_pem += crypto.dump_certificate(crypto.FILETYPE_PEM, x509).decode()\n \n         # Add the intermediate certificate into the chain\n         with open(intermediate_src, \"r\") as f:\n             intermediate_src_content = f.read()\n         ca_certs_pem += intermediate_src_content\n \n         data = {\n             self.ca_name: self._encode_to_64(ca_certs_pem),\n             self.cert_name: self._encode_to_64(generated_cert.cert),\n             self.key_name: self._encode_to_64(generated_cert.key),\n         }\n         return self.secret(secret_name, data, namespace)\n \n     def secret_token(\n         self, secret_name, name, namespace, resource_namespace, api_endpoint, token\n     ):\n         \"\"\"Create a hooks secret resource.\n \n         The hook secret stores Krake authentication token\n         and hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n             name (str): Application name\n             namespace (str): Application namespace\n             resource_namespace (str): Kubernetes namespace where the\n                 Secret will be created.\n             api_endpoint (str): Krake API endpoint\n             token (str): Complete hook authentication token\n \n         Returns:\n             dict: complete hook secret resource\n \n         \"\"\"\n         pass\n \n     def volumes(self, secret_name, volume_name, mount_path):\n         \"\"\"Create complete hooks volume and volume mount sub-resources\n \n         Complete hook volume gives access to hook's secret, which stores\n         Krake CAs and client certificates to communicate with the Krake API.\n         Complete hook volume mount puts the volume into the application\n \n         Args:\n             secret_name (str): Secret name\n             volume_name (str): Volume name\n             mount_path (list): Volume mount path\n \n         Returns:\n             list: List of complete hook volume and volume mount sub-resources\n \n         \"\"\"\n         volume = V1Volume(name=volume_name, secret={\"secretName\": secret_name})\n         volume_mount = V1VolumeMount(name=volume_name, mount_path=mount_path)\n         return [\n             SubResource(\n                 group=\"volumes\",\n                 name=volume.name,\n                 body=self.attribute_map(volume),\n                 path=((\"spec\", \"template\", \"spec\"), (\"spec\",)),\n             ),\n             SubResource(\n                 group=\"volumeMounts\",\n                 name=volume_mount.name,\n                 body=self.attribute_map(volume_mount),\n                 path=(\n                     (\"spec\", \"template\", \"spec\", \"containers\"),\n                     (\"spec\", \"containers\"),  # kind: Pod\n                 ),\n             ),\n         ]\n \n     @staticmethod\n     def _encode_to_64(string):\n         \"\"\"Compute the base 64 encoding of a string.\n \n         Args:\n             string (str): the string to encode.\n \n         Returns:\n             str: the result of the encoding.\n \n         \"\"\"\n         return b64encode(string.encode()).decode()\n \n     def secret(self, secret_name, secret_data, namespace, _type=\"Opaque\"):\n         \"\"\"Create a secret resource.\n \n         Args:\n             secret_name (str): Secret name\n             secret_data (dict): Secret data\n             namespace (str): Kubernetes namespace where the Secret will be created.\n             _type (str, optional): Secret type. Defaults to Opaque.\n \n         Returns:\n             dict: secret resource\n \n         \"\"\"\n         return self.attribute_map(\n             V1Secret(\n                 api_version=\"v1\",\n                 kind=\"Secret\",\n                 data=secret_data,\n                 metadata={\"name\": secret_name, \"namespace\": namespace},\n                 type=_type,\n             )\n         )\n \n     @staticmethod\n     def create_hook_url(name, namespace, api_endpoint):\n         \"\"\"Create an applications' hook URL.\n         Function needs to be specified for each hook.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             api_endpoint (str): Krake API endpoint\n \n         Returns:\n             str: Application shutdown url\n \n         \"\"\"\n         pass\n \n     def env_vars(self, secret_name):\n         \"\"\"Create the hooks' environment variables sub-resources.\n         Function needs to be specified for each hook.\n \n         Creates hook environment variables to store Krake authentication token\n         and a hook URL for the given applications.\n \n         Args:\n             secret_name (str): Secret name\n \n         Returns:\n             list: List of shutdown hook environment variables sub-resources\n \n         \"\"\"\n         pass\n \n \n class Complete(Hook):\n     \"\"\"Mangle given application and inject complete hooks variables into it.\n \n     Hook injects a Kubernetes secret, which stores Krake authentication token\n     and the Krake complete hook URL for the given application. The variables\n     from Kubernetes secret are imported as environment variables\n     into the application resource definition. Only resources defined in\n     :args:`hook_resources` can be modified.\n \n     Names of environment variables are defined in the application controller\n     configuration file.\n \n     If TLS is enabled on the Krake API, the complete hook injects a Kubernetes secret,\n     and it's corresponding volume and volume mount definitions for the Krake CA,\n     the client certificate with the right CN, and its key. The directory where the\n     secret is mounted is defined in the configuration.\n \n     Args:\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         cert_dest (str, optional): Path of the directory where the CA, client\n             certificate and key to the Krake API will be stored.\n         env_token (str, optional): Name of the environment variable, which stores Krake\n             authentication token.\n         env_url (str, optional): Name of the environment variable,\n             which stores Krake complete hook URL.\n \n     \"\"\"\n \n     hook_resources = (\"Pod\", \"Deployment\", \"ReplicationController\")\n \n     def __init__(\n         self, api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n     ):\n         super().__init__(\n             api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n         )\n         self.env_url = env_url\n \n     def secret_token(\n         self, secret_name, name, namespace, resource_namespace, api_endpoint, token\n     ):\n         \"\"\"Create complete hooks secret resource.\n \n         Complete hook secret stores Krake authentication token\n         and complete hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n             name (str): Application name\n             namespace (str): Application namespace\n             resource_namespace (str): Kubernetes namespace where the\n                 Secret will be created.\n             api_endpoint (str): Krake API endpoint\n             token (str): Complete hook authentication token\n \n         Returns:\n             dict: complete hook secret resource\n \n         \"\"\"\n         complete_url = self.create_hook_url(name, namespace, api_endpoint)\n         data = {\n             self.env_token.lower(): self._encode_to_64(token),\n             self.env_url.lower(): self._encode_to_64(complete_url),\n         }\n         return self.secret(secret_name, data, resource_namespace)\n \n     @staticmethod\n     def create_hook_url(name, namespace, api_endpoint):\n         \"\"\"Create an applications' complete URL.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             api_endpoint (str): Krake API endpoint\n \n         Returns:\n             str: Application complete url\n \n         \"\"\"\n         api_url = URL(api_endpoint)\n         return str(\n             api_url.with_path(\n                 f\"/kubernetes/namespaces/{namespace}/applications/{name}/complete\"\n             )\n         )\n \n     def env_vars(self, secret_name):\n         \"\"\"Create complete hooks environment variables sub-resources\n \n         Create complete hook environment variables store Krake authentication token\n         and complete hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n \n         Returns:\n             list: List of complete hook environment variables sub-resources\n \n         \"\"\"\n         sub_resources = []\n \n         env_token = V1EnvVar(\n             name=self.env_token,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(\n                             name=secret_name, key=self.env_token.lower()\n                         )\n                     )\n                 )\n             ),\n         )\n         env_url = V1EnvVar(\n             name=self.env_url,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(name=secret_name, key=self.env_url.lower())\n                     )\n                 )\n             ),\n         )\n \n         for env in (env_token, env_url):\n             sub_resources.append(\n                 SubResource(\n                     group=\"env\",\n                     name=env.name,\n                     body=self.attribute_map(env),\n                     path=(\n                         (\"spec\", \"template\", \"spec\", \"containers\"),\n                         (\"spec\", \"containers\"),  # kind: Pod\n                     ),\n                 )\n             )\n         return sub_resources\n \n \n class Shutdown(Hook):\n     \"\"\"Mangle given application and inject shutdown hooks variables into it.\n \n     Hook injects a Kubernetes secret, which stores Krake authentication token\n     and the Krake complete hook URL for the given application. The variables\n     from the Kubernetes secret are imported as environment variables\n     into the application resource definition. Only resources defined in\n     :args:`hook_resources` can be modified.\n \n     Names of environment variables are defined in the application controller\n     configuration file.\n \n     If TLS is enabled on the Krake API, the shutdown hook injects a Kubernetes secret,\n     and it's corresponding volume and volume mount definitions for the Krake CA,\n     the client certificate with the right CN, and its key. The directory where the\n     secret is mounted is defined in the configuration.\n \n     Args:\n         api_endpoint (str): the given API endpoint\n         ssl_context (ssl.SSLContext): SSL context to communicate with the API endpoint\n         cert_dest (str, optional): Path of the directory where the CA, client\n             certificate and key to the Krake API will be stored.\n         env_token (str, optional): Name of the environment variable, which stores Krake\n             authentication token.\n         env_url (str, optional): Name of the environment variable,\n             which stores Krake complete hook URL.\n \n     \"\"\"\n \n     hook_resources = (\"Pod\", \"Deployment\", \"ReplicationController\")\n \n     def __init__(\n         self, api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n     ):\n         super().__init__(\n             api_endpoint, ssl_context, hook_user, cert_dest, env_token, env_url\n         )\n         self.env_url = env_url\n \n     def secret_token(\n         self, secret_name, name, namespace, resource_namespace, api_endpoint, token\n     ):\n         \"\"\"Create shutdown hooks secret resource.\n \n         Shutdown hook secret stores Krake authentication token\n         and shutdown hook URL for given application.\n \n         Args:\n             secret_name (str): Secret name\n             name (str): Application name\n             namespace (str): Application namespace\n             resource_namespace (str): Kubernetes namespace where the\n                 Secret will be created.\n             api_endpoint (str): Krake API endpoint\n             token (str): Shutdown hook authentication token\n \n         Returns:\n             dict: shutdown hook secret resource\n \n         \"\"\"\n         shutdown_url = self.create_hook_url(name, namespace, api_endpoint)\n         data = {\n             self.env_token.lower(): self._encode_to_64(token),\n             self.env_url.lower(): self._encode_to_64(shutdown_url),\n         }\n         return self.secret(secret_name, data, resource_namespace)\n \n     @staticmethod\n     def create_hook_url(name, namespace, api_endpoint):\n         \"\"\"Create an applications' shutdown URL.\n \n         Args:\n             name (str): Application name\n             namespace (str): Application namespace\n             api_endpoint (str): Krake API endpoint\n \n         Returns:\n             str: Application shutdown url\n \n         \"\"\"\n         api_url = URL(api_endpoint)\n         return str(\n             api_url.with_path(\n                 f\"/kubernetes/namespaces/{namespace}/applications/{name}/shutdown\"\n             )\n         )\n \n     def env_vars(self, secret_name):\n         \"\"\"Create shutdown hooks environment variables sub-resources.\n \n         Creates shutdown hook environment variables to store Krake authentication token\n         and a shutdown hook URL for given applications.\n \n         Args:\n             secret_name (str): Secret name\n \n         Returns:\n             list: List of shutdown hook environment variables sub-resources\n \n         \"\"\"\n         sub_resources = []\n \n         env_resources = []\n \n         env_token = V1EnvVar(\n             name=self.env_token,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(\n                             name=secret_name,\n                             key=self.env_token.lower()\n                         )\n                     )\n                 )\n             )\n         )\n         env_resources.append(env_token)\n \n         env_url = V1EnvVar(\n             name=self.env_url,\n             value_from=self.attribute_map(\n                 V1EnvVarSource(\n                     secret_key_ref=self.attribute_map(\n                         V1SecretKeySelector(name=secret_name, key=self.env_url.lower())\n                     )\n                 )\n             ),\n         )\n         env_resources.append(env_url)\n \n         for env in env_resources:\n             sub_resources.append(\n                 SubResource(\n                     group=\"env\",\n                     name=env.name,\n                     body=self.attribute_map(env),\n                     path=(\n                         (\"spec\", \"template\", \"spec\", \"containers\"),\n                         (\"spec\", \"containers\"),  # kind: Pod\n                     ),\n                 )\n             )\n         return sub_resources\n ", "input_code": "def on(self, hook):\n\"\"\"\nDecorator function to add a new handler to the registry.\n\nArgs:\n    hook (HookType): Hook attribute for which to register the handler.\n\nReturns:\n    callable: Decorator for registering listeners for the specified\n    hook.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def on(self, hook):\n        \"\"\"Decorator function to add a new handler to the registry.\n\n        Args:\n            hook (HookType): Hook attribute for which to register the handler.\n\n        Returns:\n            callable: Decorator for registering listeners for the specified\n            hook.\n\n        \"\"\"\n\n        def decorator(handler):\n            self.registry[hook].append(handler)\n\n            return handler\n\n        return decorator", "signature": "def on(self, hook):", "completion_path": "krake/krake/controller/kubernetes/hooks.py"}
{"ce_id": "62b86729b4d922cb0e688c2f", "namespace": "62b86729b4d922cb0e688c2f", "namespace_real": "krake.tests.conftest.base_config", "real_proj_path": "rak-n-rok---Krake/", "type": "function", "class_name": null, "function_name": "base_config", "contexts_above": "import asyncio\nimport os\nimport random\nimport signal\nimport sys\nimport subprocess\nimport urllib\nfrom io import BytesIO\nfrom copy import deepcopy\nfrom tempfile import TemporaryDirectory\nfrom pathlib import Path\nfrom typing import NamedTuple, List\nimport time\nimport logging.config\nfrom textwrap import dedent\nimport json\nfrom zipfile import ZipFile\n\nimport requests\nimport pytest\nimport aiohttp\nimport shutil\nfrom aiohttp import web\nfrom krake.controller import create_ssl_context\nfrom prometheus_async import aio\nfrom prometheus_client import Gauge, CollectorRegistry, CONTENT_TYPE_LATEST\nfrom contextlib import suppress\n\n# Prepend package directory for working imports\nfrom krake.data.config import (\n    ApiConfiguration,\n    HooksConfiguration,\n    MagnumConfiguration,\n    TlsClientConfiguration,\n    ControllerConfiguration,\n    SchedulerConfiguration,\n    KubernetesConfiguration,\n)\n\npackage_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\"))\nsys.path.insert(0, package_dir)\n\n\nlogging.config.dictConfig(\n    {\n        \"version\": 1,\n        \"handlers\": {\"console\": {\"class\": \"logging.StreamHandler\", \"level\": \"DEBUG\"}},\n        \"loggers\": {\"krake\": {\"handlers\": [\"console\"]}},\n    }\n)\n\n\ndef pytest_addoption(parser):\n    \"\"\"Register :mod:`argparse`-style options and ini-style config values for pytest.\n\n    Called once at the beginning of a test run.\n\n    Args:\n        parser (pytest.config.Parser): pytest parser\n\n    \"\"\"\n    parser.addoption(\n        \"--runslow\", action=\"store_true\", default=False, help=\"run slow tests\"\n    )\n\n\ndef pytest_configure(config):\n    \"\"\"Allows plugins and conftest files to perform initial configuration.\n\n    Args:\n        config (pytest.config.Config): config object\n\n    \"\"\"\n    config.addinivalue_line(\"markers\", \"slow: mark test as slow to run\")\n    config.addinivalue_line(\n        \"markers\", \"timeout(time): mark async test with maximal duration\"\n    )\n\n\ndef pytest_collection_modifyitems(config, items):\n    \"\"\"Called after pytest collection has been performed, may filter or\n    re-order the items in-place.\n\n    Args:\n        config (pytest.config.Config): config object\n        items (List[pytest.nodes.Item]): list of test item objects\n\n    \"\"\"\n    if not config.getoption(\"--runslow\"):\n        skip_slow = pytest.mark.skip(reason=\"need --runslow option to run\")\n        for item in items:\n            if \"slow\" in item.keywords:\n                item.add_marker(skip_slow)\n\n\ndef wait_for_url(url, timeout=5, condition=None):\n    \"\"\"Wait until an URL endpoint is reachable.\n\n    The ``condition`` callable takes the HTTP response as argument and checks if it\n    suits a certain format.\n\n    The signature of ``condition`` is:\n\n    .. function:: my_condition(response)\n\n        :param requests.Response response: the Response object of the HTTP request\n        :return: true if the condition is met\n        :rtype: bool\n\n    Args:\n        url (str): URL endpoint\n        timeout (int, optional): Timeout. Defaults to 5s\n        condition (callable, optional): Condition that has to be met.\n\n    Raises:\n        TimeoutError: When timeout is reached\n\n    \"\"\"\n    start = time.time()\n\n    while True:\n        try:\n            resp = requests.get(url)\n            assert resp.status_code == 200\n            if condition:\n                assert condition(resp)\n        except (requests.ConnectionError, AssertionError):\n            time.sleep(0.1)\n            if time.time() - start > timeout:\n                raise TimeoutError(f\"Cannot connect to {url}\")\n        else:\n            return\n\n\nasync def await_for_url(url, loop, timeout=5):\n    start = loop.time()\n\n    while True:\n        try:\n            async with aiohttp.ClientSession(raise_for_status=True) as client:\n                resp = await client.get(url)\n        except aiohttp.ClientError:\n            await asyncio.sleep(0.1)\n            if loop.time() - start > timeout:\n                raise TimeoutError(f\"Cannot connect to {url!r}\")\n        else:\n            return resp\n\n\n@pytest.fixture(scope=\"session\")\ndef etcd_server():\n    def check_etcd_health(response):\n        with suppress(json.decoder.JSONDecodeError):\n            jresp = response.json()\n            with suppress(KeyError):\n                return jresp[\"health\"] == \"true\"\n        return False\n\n    etcd_host = \"127.0.0.1\"\n    etcd_port = 3379\n\n    with TemporaryDirectory() as tmpdir:\n        command = [\n            \"etcd\",\n            \"--data-dir\",\n            tmpdir,\n            \"--name\",\n            \"krake-testing\",\n            \"--listen-client-urls\",\n            f\"http://{etcd_host}:{etcd_port}\",\n            \"--advertise-client-urls\",\n            f\"http://{etcd_host}:{etcd_port}\",\n            \"--listen-peer-urls\",\n            f\"http://{etcd_host}:{etcd_port + 1}\",\n            \"--initial-advertise-peer-urls\",\n            f\"http://{etcd_host}:{etcd_port + 1}\",\n        ]\n        with subprocess.Popen(command) as proc:\n            try:\n                wait_for_url(\n                    f\"http://{etcd_host}:{etcd_port}/health\",\n                    condition=check_etcd_health,\n                )\n                yield etcd_host, etcd_port\n            finally:\n                proc.terminate()\n\n\n@pytest.fixture\nasync def etcd_client(etcd_server, loop):\n    # Use the patched etcd3 client (see #293)\n    from krake.api.database import EtcdClient\n\n    host, port = etcd_server\n\n    async with EtcdClient(host=host, port=port) as client:\n        yield client\n        await client.delete_range(all=True)\n\n\n@pytest.fixture\nasync def db(etcd_server, etcd_client, loop):\n    from krake.api.database import Session\n\n    host, port = etcd_server\n\n    async with Session(host=host, port=port, loop=loop) as session:\n        yield session\n\n\n@pytest.fixture\ndef user():\n    return \"testuser\"\n\n", "contexts_below": "\n @pytest.fixture\n def config(etcd_server, user):\n     \"\"\"Generate a default configuration for the API, which leverages a test instance of\n     etcd.\n \n     Args:\n         etcd_server ((str, int)): the information to connect to the etcd instance.\n         user (str): the name of the user for the static authentication.\n \n     Returns:\n         ApiConfiguration: the generated configuration.\n \n     \"\"\"\n     etcd_host, etcd_port = etcd_server\n     config = base_config(user, etcd_host=etcd_host, etcd_port=etcd_port)\n     return ApiConfiguration.deserialize(config, creation_ignored=True)\n \n \n @pytest.fixture\n def no_db_config(user):\n     \"\"\"Create a configuration for the API component without database being created and\n     running in the background.\n \n     Returns:\n         ApiConfiguration: the generated configuration.\n \n     \"\"\"\n     config = base_config(user)\n     return ApiConfiguration.deserialize(config, creation_ignored=True)\n \n \n @pytest.fixture\n def log_to_file_config(tmp_path):\n     \"\"\"Returns a function that can generate a dictionary that can be used as\n     configuration for the logging module. Such a dictionary is part of the Krake\n     components configuration.\n     The generated configuration sets the \"INFO\" log level, and only logs to a file. The\n     path to the file can be provided. If not, a file is created by default in a\n     temporary directory.\n \n     FIXME: This should be removed when issue #282 has been closed.\n     \"\"\"\n     base_file_path = str(tmp_path / \"krake.log\")\n \n     def generate_log_config(file_path=None):\n         \"\"\"Generate the actual dictionary for logging.\n \n         Args:\n             file_path (str): path to the file to which the logs will be written. If not\n                 specified, a temporary file is used by default.\n \n         Returns:\n             (dict[str, Any], str): a tuple that contains first the generated dictionary,\n                 and second the path to the file where the logs will be written.\n \n         \"\"\"\n         final_file_path = base_file_path\n         if file_path is not None:\n             final_file_path = file_path\n \n         log_format = \"%(asctime)s - [%(name)s] - [%(levelname)-5s] - %(message)s\"\n         return (\n             {\n                 \"version\": 1,\n                 \"level\": \"INFO\",\n                 \"formatters\": {\"krake\": {\"format\": log_format}},\n                 \"handlers\": {\n                     \"file\": {\n                         \"class\": \"logging.FileHandler\",\n                         \"formatter\": \"krake\",\n                         \"filename\": final_file_path,\n                     }\n                 },\n                 \"loggers\": {\"krake\": {\"handlers\": [\"file\"], \"propagate\": False}},\n             },\n             final_file_path,\n         )\n \n     return generate_log_config\n \n \n @pytest.fixture\n def tls_client_config():\n     \"\"\"Create a configuration for the \"tls\" field in the controllers configuration.\n \n     Returns:\n         TlsClientConfiguration: the created configuration.\n \n     \"\"\"\n     config = {\n         \"enabled\": False,\n         \"client_cert\": \"cert_path\",\n         \"client_key\": \"key_path\",\n         \"client_ca\": \"client_ca_path\",\n     }\n     return TlsClientConfiguration.deserialize(config, creation_ignored=True)\n \n \n @pytest.fixture\n def gc_config(tls_client_config):\n     \"\"\"Create a configuration for the Garbage Collector.\n \n     Returns:\n         ControllerConfiguration: the created configuration.\n \n     \"\"\"\n \n     config = {\"tls\": tls_client_config.serialize(), \"log\": {}}\n     return ControllerConfiguration.deserialize(config, creation_ignored=True)\n \n \n @pytest.fixture\n def kube_config(tls_client_config):\n     \"\"\"Create a configuration for the Kubernetes Controller.\n \n     Returns:\n         KubernetesConfiguration: the created configuration.\n \n     \"\"\"\n \n     config = {\n         \"tls\": tls_client_config.serialize(),\n         \"hooks\": {\n             \"complete\": {\n                 \"intermediate_src\": \"/etc/krake/certs/kube.pem\",\n                 \"intermediate_key_src\": \"/etc/krake/certs/kube-key.pem\",\n             },\n             \"shutdown\": {\n                 \"intermediate_src\": \"/etc/krake/certs/kube.pem\",\n                 \"intermediate_key_src\": \"/etc/krake/certs/kube-key.pem\",\n             },\n         },\n         \"log\": {},\n     }\n     return KubernetesConfiguration.deserialize(config, creation_ignored=True)\n \n \n @pytest.fixture\n def magnum_config(tls_client_config):\n     \"\"\"Create a configuration for the Magnum Controller.\n \n     Returns:\n         MagnumConfiguration: the created configuration.\n \n     \"\"\"\n \n     config = {\"tls\": tls_client_config.serialize(), \"log\": {}}\n     return MagnumConfiguration.deserialize(config, creation_ignored=True)\n \n \n @pytest.fixture\n def scheduler_config(tls_client_config):\n     \"\"\"Create a configuration for the Scheduler.\n \n     Returns:\n         SchedulerConfiguration: the created configuration.\n \n     \"\"\"\n \n     config = {\"tls\": tls_client_config.serialize(), \"log\": {}}\n     return SchedulerConfiguration.deserialize(config, creation_ignored=True)\n \n \n class KeystoneInfo(NamedTuple):\n     host: str\n     port: int\n \n     username: str\n     user_domain_name: str\n     password: str\n     project_name: str\n     project_domain_name: str\n \n     @property\n     def auth_url(self):\n         return f\"http://{self.host}:{self.port}/v3\"\n \n \n @pytest.fixture(scope=\"session\")\n def keystone():\n     pytest.importorskip(\"keystone\")\n \n     host = \"localhost\"\n     port = 5050\n \n     config_template = dedent(\n         \"\"\"\n         [fernet_tokens]\n         key_repository = {tempdir}/fernet-keys\n \n         [fernet_receipts]\n         key_repository = {tempdir}/fernet-keys\n \n         [DEFAULT]\n         log_dir = {tempdir}/logs\n \n         [assignment]\n         driver = sql\n \n         [cache]\n         enabled = false\n \n         [catalog]\n         driver = sql\n \n         [policy]\n         driver = rules\n \n         [credential]\n         key_repository = {tempdir}/credential-keys\n \n         [token]\n         provider = fernet\n         expiration = 21600\n \n         [database]\n         connection = sqlite:///{tempdir}/keystone.db\n         \"\"\"\n     )\n \n     with TemporaryDirectory() as tempdir:\n         config_file = Path(tempdir) / \"keystone.conf\"\n \n         # Create keystone configuration\n         with config_file.open(\"w\") as fd:\n             fd.write(config_template.format(tempdir=tempdir))\n \n         (Path(tempdir) / \"fernet-keys\").mkdir(mode=0o700)\n         (Path(tempdir) / \"credential-keys\").mkdir(mode=0o700)\n         (Path(tempdir) / \"logs\").mkdir()\n \n         user = os.getuid()\n         group = os.getgid()\n \n         # Populate identity service database\n         subprocess.check_call(\n             [\"keystone-manage\", \"--config-file\", str(config_file), \"db_sync\"]\n         )\n         # Initialize Fernet key repositories\n         subprocess.check_call(\n             [\n                 \"keystone-manage\",\n                 \"--config-file\",\n                 str(config_file),\n                 \"fernet_setup\",\n                 \"--keystone-user\",\n                 str(user),\n                 \"--keystone-group\",\n                 str(group),\n             ]\n         )\n         subprocess.check_call(\n             [\n                 \"keystone-manage\",\n                 \"--config-file\",\n                 str(config_file),\n                 \"credential_setup\",\n                 \"--keystone-user\",\n                 str(user),\n                 \"--keystone-group\",\n                 str(group),\n             ]\n         )\n         # Bootstrap identity service\n         subprocess.check_call(\n             [\n                 \"keystone-manage\",\n                 \"--config-file\",\n                 str(config_file),\n                 \"bootstrap\",\n                 \"--bootstrap-password\",\n                 \"admin\",\n                 \"--bootstrap-admin-url\",\n                 f\"http://{host}:{port}/v3/\",\n                 \"--bootstrap-internal-url\",\n                 f\"http://{host}:{port}/v3/\",\n                 \"--bootstrap-public-url\",\n                 f\"http://{host}:{port}/v3/\",\n                 \"--bootstrap-region-id\",\n                 \"DefaultRegion\",\n             ]\n         )\n \n         command = [\n             \"keystone-wsgi-public\",\n             \"--host\",\n             host,\n             \"--port\",\n             str(port),\n             \"--\",\n             \"--config-file\",\n             str(config_file),\n         ]\n         with subprocess.Popen(command) as proc:\n             try:\n                 wait_for_url(f\"http://{host}:{port}/v3\", timeout=30)\n                 info = KeystoneInfo(\n                     host=host,\n                     port=port,\n                     username=\"admin\",\n                     password=\"admin\",\n                     user_domain_name=\"Default\",\n                     project_name=\"admin\",\n                     project_domain_name=\"Default\",\n                 )\n                 yield info\n             finally:\n                 time.sleep(1)\n                 proc.terminate()\n \n \n class KeycloakInfo(NamedTuple):\n     port: int\n     realm: str\n     client_id: str\n     client_secret: str\n     grant_type: str\n     username: str\n     password: str\n \n     @property\n     def auth_url(self):\n         return f\"http://localhost:{self.port}\"\n \n \n @pytest.fixture\n def keycloak():\n     \"\"\"Fixture to create a Keycloak instance running in the background. The instance is\n     stopped after a test that uses this fixture finished.\n \n     Returns:\n         KeycloakInfo: the different values needed to connect to the running instance.\n \n     \"\"\"\n     version = \"11.0.2\"\n     with TemporaryDirectory() as tempdir:\n \n         url = urllib.request.urlopen(\n             f\"https://downloads.jboss.org/keycloak/{version}/keycloak-{version}.zip\"\n         )\n \n         # Download Keycloak's zip and directly unzip the downloaded file.\n         # See https://stackoverflow.com/questions/42326428/zipfile-in-python-file-permission  # noqa\n         zip_unix_system = 3\n         with ZipFile(BytesIO(url.read())) as zf:\n             for info in zf.infolist():\n                 extracted_path = zf.extract(info, tempdir)\n \n                 if info.create_system == zip_unix_system:\n                     unix_attributes = info.external_attr >> 16\n                     if unix_attributes:\n                         os.chmod(extracted_path, unix_attributes)\n \n         keycloak_dir = Path(tempdir) / f\"keycloak-{version}\"\n         subprocess.check_call(\n             [\n                 \"support/keycloak\",\n                 \"--temp-dir\",\n                 tempdir,\n                 \"init\",\n                 \"--keycloak-dir\",\n                 keycloak_dir,\n             ]\n         )\n \n         process = subprocess.Popen(\n             [\"support/keycloak\", \"--temp-dir\", tempdir, \"credentials\"],\n             stdout=subprocess.PIPE,\n             stderr=subprocess.PIPE,\n         )\n         out, _ = process.communicate()\n         keycloak_cred = json.loads(out)\n \n         info = KeycloakInfo(**keycloak_cred)\n \n         with subprocess.Popen(\n             f\"support/keycloak --temp-dir {tempdir}\", shell=True, preexec_fn=os.setsid\n         ) as proc:\n             try:\n                 wait_for_url(\n                     f\"http://localhost:{info.port}/auth/realms/{info.realm}/\",\n                     timeout=90,\n                 )\n                 yield info\n             except TimeoutError:\n                 print(\"The URL could not be reached before the timeout.\")\n             finally:\n                 pid = proc.pid\n                 time.sleep(1)\n                 proc.terminate()\n                 os.killpg(os.getpgid(pid), signal.SIGTERM)\n                 time.sleep(1)\n \n \n class RecordsContext(object):\n     def __init__(self, db, records):\n         self.db = db\n         self.records = records\n \n     async def __aenter__(self):\n         for record in self.records:\n             await self.db.put(record)\n         return self.records\n \n     async def __aexit__(self, *exc):\n         for record in reversed(self.records):\n             await self.db.delete(record)\n \n \n @pytest.fixture\n def rbac_allow(db, user):\n     from tests.factories.core import RoleFactory, RoleBindingFactory\n     from krake.data.core import Verb, RoleRule\n \n     def rbac_creator(api, resource, verb, namespace=\"testing\", override_user=None):\n         \"\"\"Add a role and role binding for the provided resource in the given namespace.\n         This can then be leveraged to test the RBAC mechanism.\n \n         Args:\n             api (str): name of the API of the resource for which a role has to be given\n                 permission:\n             resource (str): name of the resource's kind for which a role has to be given\n                 permission:\n             verb (str, Verb): verb or name of the verb that corresponds to the action\n                 which should be allowed on the resource.\n             namespace (str): namespace where the action is allowed.\n             override_user (str): if provided, change the user for which the permission\n                 is added. Otherwise, use the tests default.\n \n         Returns:\n             RecordsContext: context manager in which the permission is added.\n \n         \"\"\"\n         role_user = user\n         if override_user:\n             role_user = override_user\n \n         if isinstance(verb, str):\n             verb = Verb.__members__[verb]\n \n         namespaces = []\n         if namespace:\n             namespaces.append(namespace)\n \n         role = RoleFactory(\n             rules=[\n                 RoleRule(\n                     api=api, namespaces=namespaces, resources=[resource], verbs=[verb]\n                 )\n             ]\n         )\n         binding = RoleBindingFactory(users=[role_user], roles=[role.metadata.name])\n \n         return RecordsContext(db, [role, binding])\n \n     return rbac_creator\n \n \n class Certificate(NamedTuple):\n     \"\"\"Path to certificate issued by :class:`PublicKeyRepository` and its\n     corresponding private key.\n     \"\"\"\n \n     cert: str\n     key: str\n \n \n class PublicKeyRepository(object):\n     \"\"\"Pytest fixture for testing public key infrastructure.\n \n     The repository uses the ``cfssl`` executable for creating and signing\n     certificates.\n \n     The repository must be used with the context protocol:\n \n     .. code:: python\n \n         with PublicKeyRepository() as pki:\n             cert = pki.gencert(\"me\")\n \n     Three types of certificates can be created:\n \n      * a CA is always created;\n      * an intermediate certificate can be created, which cannot be used for client\n        authentication (cfssl \"intermediate-ca\" profile) OR;\n      * a certificate ready for client authentication (cfssl \"krake-test-ca\" profile).\n \n     Attributes:\n         ca (Certificate): Certificate Authority of this repository created by\n             :meth:`genca`.\n \n     \"\"\"\n \n     ca_csr = {\n         \"CN\": \"Krake CA\",\n         \"key\": {\"algo\": \"ecdsa\", \"size\": 256},\n         \"names\": [{\"O\": \"Acme Corporation\"}],\n     }\n \n     ca_config = {\n         \"signing\": {\n             \"profiles\": {\n                 \"krake-test-ca\": {\n                     \"usages\": [\n                         \"signing\",\n                         \"key encipherment\",\n                         \"server auth\",\n                         \"client auth\",\n                     ],\n                     \"expiry\": \"8760h\",\n                 },\n                 \"intermediate-ca\": {\n                     \"usages\": [\n                         \"signing\",\n                         \"key encipherment\",\n                         \"server auth\",\n                         \"client auth\",\n                         \"cert sign\",\n                         \"crl sign\",\n                     ],\n                     \"ca_constraint\": {\"is_ca\": True, \"max_path_len\": 1},\n                     \"expiry\": \"8760h\",\n                 },\n             }\n         }\n     }\n \n     client_csr = {\n         \"CN\": None,\n         \"hosts\": [\"127.0.0.1\"],\n         \"key\": {\"algo\": \"ecdsa\", \"size\": 256},\n         \"names\": [{\"O\": \"Acme Corporation\"}],\n     }\n \n     def __init__(self):\n         self._tempdir = None\n         self.clients = None\n         self.ca = None\n         self.ca_config_file = None\n \n     def __enter__(self):\n         self._tempdir = TemporaryDirectory(prefix=\"pki-\")\n         return self\n \n     def __exit__(self, *exc):\n         self._tempdir.cleanup()\n         self.ca = None\n         self.ca_config_file = None\n \n     @property\n     def tempdir(self):\n         \"\"\"Temporary directory holding all certificates, keys and config\n         files. It is created when entering the context and removed on exit.\n         \"\"\"\n         if self._tempdir is None:\n             return None\n         return Path(self._tempdir.name)\n \n     def gencert(self, name, is_intermediate=False):\n         \"\"\"Generate client certificate signed by the CA managed by this repository.\n \n         Args:\n             name (str): Common name of the certificate\n             is_intermediate (bool): if True, the certificate will be able to sign other\n                 certificates, but cannot be used for client authentication.\n \n         Returns:\n             Certificate: Named tuple of paths to the certificate and\n             corresponding private key.\n         \"\"\"\n         if self.ca is None:\n             self.genca()\n \n         client_csr = dict(self.client_csr, CN=name)\n         client_csr_file = self.tempdir / f\"{name}-csr.json\"\n \n         client_cert_file = self.tempdir / f\"{name}.pem\"\n         client_key_file = self.tempdir / f\"{name}-key.pem\"\n \n         profile = \"krake-test-ca\"\n         if is_intermediate:\n             profile = \"intermediate-ca\"\n \n         if not client_key_file.exists():\n             with client_csr_file.open(\"w\") as fd:\n                 json.dump(client_csr, fd, indent=4)\n \n             certs = self.cfssl(\n                 \"gencert\",\n                 \"-profile\",\n                 profile,\n                 \"-config\",\n                 str(self.ca_config_file),\n                 \"-ca\",\n                 self.ca.cert,\n                 \"-ca-key\",\n                 self.ca.key,\n                 str(client_csr_file),\n             )\n \n             with client_key_file.open(\"w\") as fd:\n                 fd.write(certs[\"key\"])\n             client_key_file.chmod(0o600)\n \n             with client_cert_file.open(\"w\") as fd:\n                 fd.write(certs[\"cert\"])\n \n         return Certificate(cert=str(client_cert_file), key=str(client_key_file))\n \n     def genca(self):\n         \"\"\"Initialize the CA certificate of the repository.\n \n         This method is automatically called by :meth:`gencert` if :attr:`ca`\n         is None.\n         \"\"\"\n         ca_csr_file = self.tempdir / \"ca-csr.json\"\n         ca_key_file = self.tempdir / \"ca-key.pem\"\n         ca_cert_file = self.tempdir / \"ca.pem\"\n \n         self.ca_config_file = self.tempdir / \"ca-config.json\"\n         self.ca = Certificate(cert=str(ca_cert_file), key=str(ca_key_file))\n \n         with ca_csr_file.open(\"w\") as fd:\n             json.dump(self.ca_csr, fd, indent=4)\n \n         certs = self.cfssl(\"gencert\", \"-initca\", str(ca_csr_file))\n \n         with ca_key_file.open(\"w\") as fd:\n             fd.write(certs[\"key\"])\n         ca_key_file.chmod(0o600)\n \n         with ca_cert_file.open(\"w\") as fd:\n             fd.write(certs[\"cert\"])\n \n         with open(self.ca_config_file, \"w\") as fd:\n             json.dump(self.ca_config, fd, indent=4)\n \n     @staticmethod\n     def cfssl(*command):\n         \"\"\"Execute an ``cfssl`` command. The output is directly parsed as JSON\n         and returned.\n \n         Args:\n             *command: command line arguments for ``cfssl``\n \n         Returns:\n             JSON output of the cfssl command\n \n         \"\"\"\n         with subprocess.Popen((\"cfssl\",) + command, stdout=subprocess.PIPE) as proc:\n             try:\n                 data = json.load(proc.stdout)\n             except json.JSONDecodeError:\n                 returncode = proc.poll()\n                 if returncode is not None and returncode != 0:\n                     raise subprocess.CalledProcessError(returncode, command)\n                 raise\n \n         if proc.returncode != 0:\n             raise subprocess.CalledProcessError(proc.returncode, command)\n \n         return data\n \n \n @pytest.fixture(scope=\"session\")\n def pki():\n     \"\"\"Public key infrastructure fixture\"\"\"\n     if not shutil.which(\"cfssl\"):\n         pytest.skip(\"Executable 'cfssl' not found\")\n \n     with PublicKeyRepository() as repo:\n         yield repo\n \n \n @pytest.fixture\n def client_ssl_context(pki):\n     \"\"\"Create a decorator to create an SSL context to be used by a\n     :class:`krake.client.Client`. It accepts a user as parameter for the certificate CN.\n \n     Args:\n         pki (PublicKeyRepository): the SSL components generated by the pki fixture.\n \n     Returns:\n         function: the generated decorator, which depends on the user provided.\n \n     \"\"\"\n \n     def create_client_ssl_context(user):\n         \"\"\"Generate an SSL context, with the CA, the certificate and key. The\n         certificate's CN has the provided user.\n \n         Args:\n             user (str): the CN for which the certificate should be generated.\n \n         Returns:\n             ssl.SSLContext: the created SSL context.\n \n         \"\"\"\n         client_cert = pki.gencert(user)\n         client_tls = TlsClientConfiguration(\n             enabled=True,\n             client_ca=pki.ca.cert,\n             client_cert=client_cert.cert,\n             client_key=client_cert.key,\n         )\n         return create_ssl_context(client_tls)\n \n     return create_client_ssl_context\n \n \n @pytest.fixture\n def hooks_config(pki):\n     \"\"\"Generate the configuration for using the hooks of the KubernetesController.\n \n     Args:\n         pki (PublicKeyRepository): Already-prepared certificate environment.\n \n     Returns:\n         HooksConfiguration: the generated configuration.\n \n     \"\"\"\n     client_complete_cert = pki.gencert(\"test-complete-hook-signing\",\n                                        is_intermediate=True)\n     client_shutdown_cert = pki.gencert(\"test-shutdown-hook-signing\",\n                                        is_intermediate=True)\n     return deepcopy(\n         HooksConfiguration.deserialize(\n             {\n                 \"complete\": {\n                     \"hook_user\": \"test-complete-hook-user\",\n                     \"intermediate_src\": client_complete_cert.cert,\n                     \"intermediate_key_src\": client_complete_cert.key,\n                     \"cert_dest\": \"/etc/krake_complete_certs\",\n                     \"env_token\": \"KRAKE_COMPLETE_TOKEN\",\n                     \"env_url\": \"KRAKE_COMPLETE_URL\",\n                 },\n                 \"shutdown\": {\n                     \"hook_user\": \"test-shutdown-hook-user\",\n                     \"intermediate_src\": client_shutdown_cert.cert,\n                     \"intermediate_key_src\": client_shutdown_cert.key,\n                     \"cert_dest\": \"/etc/krake_shutdown_certs\",\n                     \"env_token\": \"KRAKE_SHUTDOWN_TOKEN\",\n                     \"env_url\": \"KRAKE_SHUTDOWN_URL\",\n                 }\n             }\n         )\n     )\n \n \n class PrometheusExporter(NamedTuple):\n     \"\"\"Tuple yielded by the :func:`prometheus_exporter` fixture describing\n     server connection information and the name of the provided metric.\n     \"\"\"\n \n     host: str\n     port: int\n     metric: str\n \n \n @pytest.fixture\n async def prometheus_exporter(loop, aiohttp_server):\n     \"\"\"Heat-demand exporter fixture. Heat demand exporter generates heat\n     demand metric `heat_demand_zone_1` with random value.\n     \"\"\"\n     metric_name = \"heat_demand_zone_1\"\n     interval = 1  # refresh metric value interval[s]\n \n     registry = CollectorRegistry(auto_describe=True)\n \n     async def heat_demand_metric():\n         metric = Gauge(metric_name, \"float - heat demand (kW)\", registry=registry)\n         while True:\n             metric.set(round(random.random(), 2))\n             await asyncio.sleep(interval)\n \n     async def start_metric(app):\n         app[\"metric\"] = loop.create_task(heat_demand_metric())\n \n     async def cleanup_metric(app):\n         app[\"metric\"].cancel()\n         try:\n             await app[\"metric\"]\n         except asyncio.CancelledError:\n             pass\n \n     async def server_stats(request):\n         \"\"\"Return a web response with the plain text version of the metrics.\"\"\"\n         resp = web.Response(body=aio.web.generate_latest(registry))\n \n         # This is set separately because aiohttp complains about \";\"\" in\n         # content_type thinking it means there's also a charset.\n         # @see https://github.com/aio-libs/aiohttp/issues/2197\n         resp.content_type = CONTENT_TYPE_LATEST\n \n         return resp\n \n     app = web.Application()\n     app.router.add_get(\"/metrics\", server_stats)\n     app.on_startup.append(start_metric)\n     app.on_cleanup.append(cleanup_metric)\n \n     server = await aiohttp_server(app)\n \n     yield PrometheusExporter(host=server.host, port=server.port, metric=metric_name)\n \n \n class Prometheus(NamedTuple):\n     \"\"\"Tuple yielded by the :func:`prometheus` fixture. It contains\n     information about the Prometheus server connection.\n     \"\"\"\n \n     scheme: str\n     host: str\n     port: int\n     exporter: PrometheusExporter\n \n \n @pytest.fixture\n async def prometheus(prometheus_exporter, loop):\n     prometheus_host = \"localhost\"\n     prometheus_port = 5055\n \n     if not shutil.which(\"prometheus\"):\n         pytest.skip(\"Executable 'prometheus' not found\")\n \n     config = dedent(\n         \"\"\"\n         global:\n             scrape_interval: 1s\n         scrape_configs:\n             - job_name: prometheus\n               static_configs:\n                 - targets:\n                   - {prometheus_host}:{prometheus_port}\n             - job_name: heat-demand-exporter\n               static_configs:\n                 - targets:\n                   - {exporter_host}:{exporter_port}\n         \"\"\"\n     )\n \n     async def await_for_prometheus(url, timeout=10):\n         \"\"\"Wait until the Prometheus server is booted up and the first metric\n         is scraped.\n         \"\"\"\n         start = loop.time()\n \n         while True:\n             resp = await await_for_url(url, loop)\n             body = await resp.json()\n \n             # If the returned metric list is not empty, stop waiting.\n             if body[\"data\"][\"result\"]:\n                 return\n \n             if loop.time() - start > timeout:\n                 raise TimeoutError(f\"Cannot get metric from {url!r}\")\n \n             # Prometheus' first scrap takes some time\n             await asyncio.sleep(0.25)\n \n     with TemporaryDirectory() as tempdir:\n         config_file = Path(tempdir) / \"prometheus.yml\"\n \n         # Create prometheus configuration\n         with config_file.open(\"w\") as fd:\n             fd.write(\n                 config.format(\n                     prometheus_host=prometheus_host,\n                     prometheus_port=prometheus_port,\n                     exporter_host=prometheus_exporter.host,\n                     exporter_port=prometheus_exporter.port,\n                 )\n             )\n \n         command = [\n             \"prometheus\",\n             \"--config.file\",\n             str(config_file),\n             \"--storage.tsdb.path\",\n             str(Path(tempdir) / \"data\"),\n             \"--web.enable-admin-api\",\n             \"--web.listen-address\",\n             \":\" + str(prometheus_port),\n         ]\n         with subprocess.Popen(command) as prometheus:\n             try:\n                 await await_for_prometheus(\n                     f\"http://{prometheus_host}:{prometheus_port}\"\n                     f\"/api/v1/query?query={prometheus_exporter.metric}\"\n                 )\n                 yield Prometheus(\n                     scheme=\"http\",\n                     host=prometheus_host,\n                     port=prometheus_port,\n                     exporter=prometheus_exporter,\n                 )\n             finally:\n                 prometheus.terminate()\n \n \n def write_properties(properties, file_path):\n     \"\"\"Create a file with the provided parameters: each key-value pair is written as:\n     \"<key>=<value>\", one line per key.\n \n     Args:\n         properties (dict[str, Any]): dictionary that contains the parameters to write.\n         file_path (pathlib.Path): name of the file in which the properties will be\n             written.\n     \"\"\"\n     with open(file_path, \"w\") as f:\n         for key, value in properties.items():\n             f.write(f\"{key}={value}\\n\")\n \n \n class Zookeeper(NamedTuple):\n     \"\"\"Contains the information to connect to a Zookeeper instance.\n \n     Attributes:\n         host (str): host of the Zookeeper instance.\n         port (int): port of the Zookeeper instance.\n \n     \"\"\"\n \n     host: str\n     port: int\n \n \n async def write_command_to_port(loop, host, port, command=b\"dump\"):\n     \"\"\"Send a byte string to a specific port on the provided host. Read the complete\n     output and return it.\n \n     Args:\n         loop (asyncio.AbstractEventLoop): the current loop.\n         host (str): the host to which the command should be sent.\n         port (int): the port on which the command should be sent.\n         command (bytes): the command to send.\n \n     Returns:\n         bytes: the output read from the host.\n \n     \"\"\"\n     # If the process that listens at the endpoint is not ready, the socket connector\n     # raises an OSError.\n     # FIXME: the OSError may be changed with another error, for instance\n     #  ConnectionRefusedError. This works locally but not on the pipeline.\n     with suppress(OSError):\n         reader, writer = await asyncio.open_connection(host, port)\n         writer.write(command)\n         data = await reader.read(512)\n         writer.close()\n         return data\n \n \n @pytest.fixture\n async def zookeeper(tmp_path, loop):\n     if not shutil.which(\"zookeeper-server-start\"):\n         pytest.skip(\"Executable 'zookeeper-server-start' not found\")\n \n     zookeeper_port = 30007\n     properties = {\n         \"4lw.commands.whitelist\": \"*\",  # Allows sending all commands to Zookeeper\n         \"admin.enableServer\": False,\n         \"clientPort\": zookeeper_port,\n         \"dataDir\": tmp_path,\n         \"maxClientCnxns\": 0,\n     }\n     properties_path = tmp_path / \"zookeeper.properties\"\n     write_properties(properties, properties_path)\n \n     command = [\"zookeeper-server-start\", properties_path]\n \n     with subprocess.Popen(command) as zookeeper:\n         try:\n             timeout = 10\n             start = loop.time()\n             # Wait for the Zookeeper instance to be ready.\n             while True:\n                 data = await write_command_to_port(loop, \"localhost\", zookeeper_port)\n                 if data:\n                     break\n \n                 if loop.time() - start > timeout:\n                     raise TimeoutError(\"The instance was not ready before the timeout\")\n                 await asyncio.sleep(0.25)\n \n             yield Zookeeper(host=\"localhost\", port=zookeeper_port)\n         finally:\n             zookeeper.terminate()\n \n \n class Kafka(NamedTuple):\n     \"\"\"Contains the information to connect to a Kafka instance.\n \n     Attributes:\n         host (str): host of the Kafka instance.\n         port (int): port of the Kafka instance.\n \n     \"\"\"\n \n     host: str\n     port: int\n \n \n @pytest.fixture\n async def kafka(zookeeper, tmp_path, loop):\n     if not shutil.which(\"kafka-server-start\"):\n         pytest.skip(\"Executable 'kafka-server-start' not found\")\n \n     broker_id = 42\n     kafka_host = \"localhost\"\n     kafka_port = 31007\n     properties = {\n         \"auto.create.topics.enable\": True,\n         \"broker.id\": broker_id,\n         \"delete.topic.enable\": True,\n         \"listeners\": f\"PLAINTEXT://{kafka_host}:{kafka_port}\",\n         \"log.cleaner.enable\": True,\n         \"log.dirs\": tmp_path,\n         \"offsets.topic.replication.factor\": 1,  # Allows having only one broker\n         \"transaction.state.log.replication.factor\": 1,  # Allows having only one broker\n         \"transaction.state.log.min.isr\": 1,  # Allows having only one broker\n         \"zookeeper.connect\": f\"{zookeeper.host}:{zookeeper.port}\",\n         \"zookeeper.connection.timeout.ms\": 6000,\n     }\n     properties_path = tmp_path / \"kafka.properties\"\n     write_properties(properties, properties_path)\n \n     command = [\"kafka-server-start\", properties_path]\n \n     with subprocess.Popen(command) as kafka:\n         try:\n             timeout = 20\n             start = loop.time()\n             # Wait for the Kafka instance to be ready.\n             while True:\n                 dump_return = await write_command_to_port(\n                     loop, zookeeper.host, zookeeper.port\n                 )\n \n                 # If the ID appears in the list of broker IDs in the Zookeeper status,\n                 # it means the broker is ready.\n                 if f\"/brokers/ids/{broker_id}\".encode() in dump_return:\n                     break\n \n                 if loop.time() - start > timeout:\n                     raise TimeoutError(\"The instance was not ready before the timeout\")\n \n                 await asyncio.sleep(1)\n \n             yield Kafka(host=kafka_host, port=kafka_port)\n         finally:\n             kafka.terminate()\n \n \n class KsqlMetric(NamedTuple):\n     \"\"\"Entry in a KSQL table, where each row corresponds to a metric and its value. The\n     value can be updated any time by a new input from Kafka.\n \n     Attributes:\n         name (str): name attribute of an entry in the KSQL database.\n         value (int): value attribute of an entry in the KSQL database.\n \n     \"\"\"\n \n     name: str\n     value: int\n \n \n class KafkaTable(NamedTuple):\n     \"\"\"Data about a KSQL table that contains the value of different metrics, one per\n     row.\n \n     Attributes:\n         metrics (list[KsqlMetric]): definitions of the metrics inserted into the\n             database.\n         comparison_column (str): name of the KSQL column which contains the metrics\n             names, and thus whose content is compared to the name of the chosen metric.\n         value_column (str): name of the KSQL column which contains the current value of\n             all metrics.\n         table (str): name of the table in which the metrics have been added (so this\n             table has at least two columns, namely \"<comparison_column>\" and\n             \"<value_column>\").\n \n     \"\"\"\n \n     metrics: List[KsqlMetric]\n     comparison_column: str\n     value_column: str\n     table: str\n \n \n class KsqlServer(NamedTuple):\n     \"\"\"Contains the information to connect to a KSQL database.\n \n     Attributes:\n         host (str): host of the KSQL database.\n         port (int): port of the KSQL database.\n         kafka_table (KafkaTable): information regarding the KSQL table present in the\n             KSQL database.\n         scheme (str): scheme to connect to the KSQL database.\n \n     \"\"\"\n \n     host: str\n     port: int\n     kafka_table: KafkaTable\n     scheme: str = \"http\"\n \n \n async def send_command(client, url, command):\n     \"\"\"Send a KSQL command to the provided URL.\n \n     Args:\n         client (aiohttp.ClientSession): client to use for sending the command.\n         url (str): URL to which the command should be sent.\n         command (dict): command to send to the KSQL database.\n \n     \"\"\"\n     resp = await client.post(url + \"/ksql\", json=command)\n     assert resp.status == 200, f\"The following command failed: {command!r}\"\n \n \n async def insert_entries(url):\n     \"\"\"Prepare a KSQL database by adding a stream, a table constructed from the stream,\n     and by sending some elements to the stream. The stream has two columns: the metric\n     name, and the number of time it appeared in the stream.\n \n     Args:\n         url (str): URL of the KSQL database.\n \n     Returns:\n         KafkaTable: necessary information regarding all elements inserted in the\n             database.\n \n     \"\"\"\n     value_column = \"num_write\"\n     comparison_column = \"zone\"\n     table = \"heat_demand_zones_metrics\"\n     metrics = [\n         KsqlMetric(name=\"heat_demand_1\", value=2),  # Because it is inserted twice.\n         KsqlMetric(name=\"heat_demand_2\", value=1),\n     ]\n \n     base_command = {\"ksql\": None, \"streamsProperties\": {}}\n     build_commands = [\n         (\n             \"CREATE STREAM heat_demand_zones\"\n             f\" ({comparison_column} STRING KEY, value INTEGER) WITH\"\n             \" (kafka_topic='heat_demand_zones', value_format='json', partitions=1);\"\n         ),\n         (\n             f\"CREATE TABLE {table} AS SELECT {comparison_column}, COUNT(*)\"\n             f\" AS {value_column}\"\n             f\" FROM heat_demand_zones GROUP BY {comparison_column} EMIT CHANGES;\"\n         ),  # Table from the stream, counts the number of inserted entries for each zone\n     ]\n \n     insert_commands = [\n         (\n             f\"INSERT INTO heat_demand_zones ({comparison_column}, value) VALUES\"\n             f\" ('{metrics[0].name}', 84);\"\n         ),\n         (\n             f\"INSERT INTO heat_demand_zones ({comparison_column}, value) VALUES\"\n             f\" ('{metrics[1].name}', 23);\"\n         ),\n         (\n             f\"INSERT INTO heat_demand_zones ({comparison_column}, value) VALUES\"\n             f\" ('{metrics[0].name}', 17);\"\n         ),\n     ]\n     async with aiohttp.ClientSession() as client:\n         for command in build_commands:\n             base_command[\"ksql\"] = command\n             await send_command(client, url, base_command)\n \n         # Between the creation of the stream/table and the insertion of entries, some\n         # time is necessary.\n         await asyncio.sleep(15)\n \n         for command in insert_commands:\n             base_command[\"ksql\"] = command\n             await send_command(client, url, base_command)\n \n     return KafkaTable(\n         metrics=metrics,\n         comparison_column=comparison_column,\n         value_column=value_column,\n         table=table,\n     )\n \n \n @pytest.fixture\n async def ksql(kafka, tmp_path, loop):\n     \"\"\"Start a KSQL database. Insert some dummy metrics inside. The state of the\n     database at the end of this fixture is the following:\n \n      * a stream called \"heat_demand_zones\", with the following attributes:\n          * zone (as string): the name of the zone;\n          * value (as integer): an arbitrary value;\n      * a table created from the stream, it has the following attributes:\n          * zone (as string): same as for the stream;\n          * num_write (as integer): the amount of time an entry was added for the current\n            zone.\n      * Three entries added to the stream:\n          * two for the zone \"heat_demand_1\";\n          * one for the zone \"heat_demand_2\".\n \n     \"\"\"\n \n     if not shutil.which(\"ksql-server-start\"):\n         pytest.skip(\"Executable 'ksql-server-start' not found\")\n \n     ksql_host = \"0.0.0.0\"\n     ksql_port = 32007\n     url = f\"http://{ksql_host}:{ksql_port}\"\n     properties = {\n         \"listeners\": url,\n         \"ksql.logging.processing.topic.auto.create\": \"true\",\n         \"ksql.logging.processing.stream.auto.create\": \"true\",\n         \"bootstrap.servers\": f\"{kafka.host}:{kafka.port}\",\n         \"compression.type\": \"snappy\",\n         \"ksql.streams.state.dir\": tmp_path,\n     }\n     properties_path = tmp_path / \"ksql-server.properties\"\n     write_properties(properties, properties_path)\n \n     command = [\"ksql-server-start\", properties_path]\n \n     with subprocess.Popen(command) as ksql:\n         try:\n             timeout = 60\n             start = loop.time()\n             # Wait for the KSQL instance to be ready.\n             while True:\n                 resp = None\n                 async with aiohttp.ClientSession() as client:\n                     try:\n                         resp = await client.get(url + \"/info\")\n                     except aiohttp.ClientConnectorError:\n                         pass\n \n                 if resp and resp.status == 200:\n                     break\n                 if loop.time() - start > timeout:\n                     raise TimeoutError(\"The instance was not ready before the timeout\")\n \n                 await asyncio.sleep(1)\n \n             kafka_table = await insert_entries(url)\n             yield KsqlServer(host=ksql_host, port=ksql_port, kafka_table=kafka_table)\n         finally:\n             ksql.terminate()\n ", "input_code": "def base_config(user, etcd_host='localhost', etcd_port=2379):\n\"\"\"\nCreates a configuration with some simple parameters, which have a default value\nthat can be set.\n\nArgs:\n    user (str): the name of the user for the static authentication\n    etcd_host (str): the host for the database.\n    etcd_port (int): the port for the database.\n\nReturns:\n    dict: the created configuration.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def base_config(user, etcd_host=\"localhost\", etcd_port=2379):\n    \"\"\"Creates a configuration with some simple parameters, which have a default value\n    that can be set.\n\n    Args:\n        user (str): the name of the user for the static authentication\n        etcd_host (str): the host for the database.\n        etcd_port (int): the port for the database.\n\n    Returns:\n        dict: the created configuration.\n\n    \"\"\"\n    return {\n        \"tls\": {\n            \"enabled\": False,\n            \"cert\": \"cert_path\",\n            \"key\": \"key_path\",\n            \"client_ca\": \"client_ca_path\",\n        },\n        \"authentication\": {\n            \"allow_anonymous\": True,\n            \"strategy\": {\n                \"keystone\": {\"enabled\": False, \"endpoint\": \"http://localhost\"},\n                \"keycloak\": {\n                    \"enabled\": False,\n                    \"endpoint\": \"no_endpoint\",\n                    \"realm\": \"krake\",\n                },\n                \"static\": {\"enabled\": True, \"name\": user},\n            },\n            \"cors_origin\": \"http://example.com\",\n        },\n        \"authorization\": \"always-allow\",\n        \"etcd\": {\"host\": etcd_host, \"port\": etcd_port, \"retry_transactions\": 0},\n        \"docs\": {\"problem_base_url\": \"http://example.com/problem\"},\n        \"log\": {},\n    }", "signature": "def base_config(user, etcd_host='localhost', etcd_port=2379):", "completion_path": "krake/tests/conftest.py"}
{"ce_id": "62b8a4a4755ee91dce50a3d2", "namespace": "62b8a4a4755ee91dce50a3d2", "namespace_real": "dateutil.tz._common._fromutc", "real_proj_path": "pexip---os-python-dateutil/", "type": "class", "class_name": "_common", "function_name": "_fromutc", "contexts_above": "from six import PY2\n\nfrom functools import wraps\n\nfrom datetime import datetime, timedelta, tzinfo\n\n\nZERO = timedelta(0)\n\n__all__ = ['tzname_in_python2', 'enfold']\n\n\ndef tzname_in_python2(namefunc):\n    \"\"\"Change unicode output into bytestrings in Python 2\n\n    tzname() API changed in Python 3. It used to return bytes, but was changed\n    to unicode strings\n    \"\"\"\n    if PY2:\n        @wraps(namefunc)\n        def adjust_encoding(*args, **kwargs):\n            name = namefunc(*args, **kwargs)\n            if name is not None:\n                name = name.encode()\n\n            return name\n\n        return adjust_encoding\n    else:\n        return namefunc\n\n\n# The following is adapted from Alexander Belopolsky's tz library\n# https://github.com/abalkin/tz\nif hasattr(datetime, 'fold'):\n    # This is the pre-python 3.6 fold situation\n    def enfold(dt, fold=1):\n        \"\"\"\n        Provides a unified interface for assigning the ``fold`` attribute to\n        datetimes both before and after the implementation of PEP-495.\n\n        :param fold:\n            The value for the ``fold`` attribute in the returned datetime. This\n            should be either 0 or 1.\n\n        :return:\n            Returns an object for which ``getattr(dt, 'fold', 0)`` returns\n            ``fold`` for all versions of Python. In versions prior to\n            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a\n            subclass of :py:class:`datetime.datetime` with the ``fold``\n            attribute added, if ``fold`` is 1.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        return dt.replace(fold=fold)\n\nelse:\n    class _DatetimeWithFold(datetime):\n        \"\"\"\n        This is a class designed to provide a PEP 495-compliant interface for\n        Python versions before 3.6. It is used only for dates in a fold, so\n        the ``fold`` attribute is fixed at ``1``.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        __slots__ = ()\n\n        def replace(self, *args, **kwargs):\n            \"\"\"\n            Return a datetime with the same attributes, except for those\n            attributes given new values by whichever keyword arguments are\n            specified. Note that tzinfo=None can be specified to create a naive\n            datetime from an aware datetime with no conversion of date and time\n            data.\n\n            This is reimplemented in ``_DatetimeWithFold`` because pypy3 will\n            return a ``datetime.datetime`` even if ``fold`` is unchanged.\n            \"\"\"\n            argnames = (\n                'year', 'month', 'day', 'hour', 'minute', 'second',\n                'microsecond', 'tzinfo'\n            )\n\n            for arg, argname in zip(args, argnames):\n                if argname in kwargs:\n                    raise TypeError('Duplicate argument: {}'.format(argname))\n\n                kwargs[argname] = arg\n\n            for argname in argnames:\n                if argname not in kwargs:\n                    kwargs[argname] = getattr(self, argname)\n\n            dt_class = self.__class__ if kwargs.get('fold', 1) else datetime\n\n            return dt_class(**kwargs)\n\n        @property\n        def fold(self):\n            return 1\n\n    def enfold(dt, fold=1):\n        \"\"\"\n        Provides a unified interface for assigning the ``fold`` attribute to\n        datetimes both before and after the implementation of PEP-495.\n\n        :param fold:\n            The value for the ``fold`` attribute in the returned datetime. This\n            should be either 0 or 1.\n\n        :return:\n            Returns an object for which ``getattr(dt, 'fold', 0)`` returns\n            ``fold`` for all versions of Python. In versions prior to\n            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a\n            subclass of :py:class:`datetime.datetime` with the ``fold``\n            attribute added, if ``fold`` is 1.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        if getattr(dt, 'fold', 0) == fold:\n            return dt\n\n        args = dt.timetuple()[:6]\n        args += (dt.microsecond, dt.tzinfo)\n\n        if fold:\n            return _DatetimeWithFold(*args)\n        else:\n            return datetime(*args)\n\n\ndef _validate_fromutc_inputs(f):\n    \"\"\"\n    The CPython version of ``fromutc`` checks that the input is a ``datetime``\n    object and that ``self`` is attached as its ``tzinfo``.\n    \"\"\"\n    @wraps(f)\n    def fromutc(self, dt):\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        return f(self, dt)\n\n    return fromutc\n\n\nclass _tzinfo(tzinfo):\n    \"\"\"\n    Base class for all ``dateutil`` ``tzinfo`` objects.\n    \"\"\"\n\n    def is_ambiguous(self, dt):\n        \"\"\"\n        Whether or not the \"wall time\" of a given datetime is ambiguous in this\n        zone.\n\n        :param dt:\n            A :py:class:`datetime.datetime`, naive or time zone aware.\n\n\n        :return:\n            Returns ``True`` if ambiguous, ``False`` otherwise.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n\n        dt = dt.replace(tzinfo=self)\n\n        wall_0 = enfold(dt, fold=0)\n        wall_1 = enfold(dt, fold=1)\n\n        same_offset = wall_0.utcoffset() == wall_1.utcoffset()\n        same_dt = wall_0.replace(tzinfo=None) == wall_1.replace(tzinfo=None)\n\n        return same_dt and not same_offset\n\n    def _fold_status(self, dt_utc, dt_wall):\n        \"\"\"\n        Determine the fold status of a \"wall\" datetime, given a representation\n        of the same datetime as a (naive) UTC datetime. This is calculated based\n        on the assumption that ``dt.utcoffset() - dt.dst()`` is constant for all\n        datetimes, and that this offset is the actual number of hours separating\n        ``dt_utc`` and ``dt_wall``.\n\n        :param dt_utc:\n            Representation of the datetime as UTC\n\n        :param dt_wall:\n            Representation of the datetime as \"wall time\". This parameter must\n            either have a `fold` attribute or have a fold-naive\n            :class:`datetime.tzinfo` attached, otherwise the calculation may\n            fail.\n        \"\"\"\n        if self.is_ambiguous(dt_wall):\n            delta_wall = dt_wall - dt_utc\n            _fold = int(delta_wall == (dt_utc.utcoffset() - dt_utc.dst()))\n        else:\n            _fold = 0\n\n        return _fold\n\n    def _fold(self, dt):\n        return getattr(dt, 'fold', 0)\n", "contexts_below": "    @_validate_fromutc_inputs\n     def fromutc(self, dt):\n         \"\"\"\n         Given a timezone-aware datetime in a given timezone, calculates a\n         timezone-aware datetime in a new timezone.\n \n         Since this is the one time that we *know* we have an unambiguous\n         datetime object, we take this opportunity to determine whether the\n         datetime is ambiguous and in a \"fold\" state (e.g. if it's the first\n         occurrence, chronologically, of the ambiguous datetime).\n \n         :param dt:\n             A timezone-aware :class:`datetime.datetime` object.\n         \"\"\"\n         dt_wall = self._fromutc(dt)\n \n         # Calculate the fold status given the two datetimes.\n         _fold = self._fold_status(dt, dt_wall)\n \n         # Set the default fold value for ambiguous dates\n         return enfold(dt_wall, fold=_fold)\n \n \n class tzrangebase(_tzinfo):\n     \"\"\"\n     This is an abstract base class for time zones represented by an annual\n     transition into and out of DST. Child classes should implement the following\n     methods:\n \n         * ``__init__(self, *args, **kwargs)``\n         * ``transitions(self, year)`` - this is expected to return a tuple of\n           datetimes representing the DST on and off transitions in standard\n           time.\n \n     A fully initialized ``tzrangebase`` subclass should also provide the\n     following attributes:\n         * ``hasdst``: Boolean whether or not the zone uses DST.\n         * ``_dst_offset`` / ``_std_offset``: :class:`datetime.timedelta` objects\n           representing the respective UTC offsets.\n         * ``_dst_abbr`` / ``_std_abbr``: Strings representing the timezone short\n           abbreviations in DST and STD, respectively.\n         * ``_hasdst``: Whether or not the zone has DST.\n \n     .. versionadded:: 2.6.0\n     \"\"\"\n     def __init__(self):\n         raise NotImplementedError('tzrangebase is an abstract base class')\n \n     def utcoffset(self, dt):\n         isdst = self._isdst(dt)\n \n         if isdst is None:\n             return None\n         elif isdst:\n             return self._dst_offset\n         else:\n             return self._std_offset\n \n     def dst(self, dt):\n         isdst = self._isdst(dt)\n \n         if isdst is None:\n             return None\n         elif isdst:\n             return self._dst_base_offset\n         else:\n             return ZERO\n \n     @tzname_in_python2\n     def tzname(self, dt):\n         if self._isdst(dt):\n             return self._dst_abbr\n         else:\n             return self._std_abbr\n \n     def fromutc(self, dt):\n         \"\"\" Given a datetime in UTC, return local time \"\"\"\n         if not isinstance(dt, datetime):\n             raise TypeError(\"fromutc() requires a datetime argument\")\n \n         if dt.tzinfo is not self:\n             raise ValueError(\"dt.tzinfo is not self\")\n \n         # Get transitions - if there are none, fixed offset\n         transitions = self.transitions(dt.year)\n         if transitions is None:\n             return dt + self.utcoffset(dt)\n \n         # Get the transition times in UTC\n         dston, dstoff = transitions\n \n         dston -= self._std_offset\n         dstoff -= self._std_offset\n \n         utc_transitions = (dston, dstoff)\n         dt_utc = dt.replace(tzinfo=None)\n \n         isdst = self._naive_isdst(dt_utc, utc_transitions)\n \n         if isdst:\n             dt_wall = dt + self._dst_offset\n         else:\n             dt_wall = dt + self._std_offset\n \n         _fold = int(not isdst and self.is_ambiguous(dt_wall))\n \n         return enfold(dt_wall, fold=_fold)\n \n     def is_ambiguous(self, dt):\n         \"\"\"\n         Whether or not the \"wall time\" of a given datetime is ambiguous in this\n         zone.\n \n         :param dt:\n             A :py:class:`datetime.datetime`, naive or time zone aware.\n \n \n         :return:\n             Returns ``True`` if ambiguous, ``False`` otherwise.\n \n         .. versionadded:: 2.6.0\n         \"\"\"\n         if not self.hasdst:\n             return False\n \n         start, end = self.transitions(dt.year)\n \n         dt = dt.replace(tzinfo=None)\n         return (end <= dt < end + self._dst_base_offset)\n \n     def _isdst(self, dt):\n         if not self.hasdst:\n             return False\n         elif dt is None:\n             return None\n \n         transitions = self.transitions(dt.year)\n \n         if transitions is None:\n             return False\n \n         dt = dt.replace(tzinfo=None)\n \n         isdst = self._naive_isdst(dt, transitions)\n \n         # Handle ambiguous dates\n         if not isdst and self.is_ambiguous(dt):\n             return not self._fold(dt)\n         else:\n             return isdst\n \n     def _naive_isdst(self, dt, transitions):\n         dston, dstoff = transitions\n \n         dt = dt.replace(tzinfo=None)\n \n         if dston < dstoff:\n             isdst = dston <= dt < dstoff\n         else:\n             isdst = not dstoff <= dt < dston\n \n         return isdst\n \n     @property\n     def _dst_base_offset(self):\n         return self._dst_offset - self._std_offset\n \n     __hash__ = None\n \n     def __ne__(self, other):\n         return not (self == other)\n \n     def __repr__(self):\n         return \"%s(...)\" % self.__class__.__name__\n \n     __reduce__ = object.__reduce__\n ", "input_code": "def _fromutc(self, dt):\n\"\"\"\nGiven a timezone-aware datetime in a given timezone, calculates a\ntimezone-aware datetime in a new timezone.\n\nSince this is the one time that we *know* we have an unambiguous\ndatetime object, we take this opportunity to determine whether the\ndatetime is ambiguous and in a \"fold\" state (e.g. if it's the first\noccurrence, chronologically, of the ambiguous datetime).\n\n:param dt:\n    A timezone-aware :class:`datetime.datetime` object.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def _fromutc(self, dt):\n        \"\"\"\n        Given a timezone-aware datetime in a given timezone, calculates a\n        timezone-aware datetime in a new timezone.\n\n        Since this is the one time that we *know* we have an unambiguous\n        datetime object, we take this opportunity to determine whether the\n        datetime is ambiguous and in a \"fold\" state (e.g. if it's the first\n        occurrence, chronologically, of the ambiguous datetime).\n\n        :param dt:\n            A timezone-aware :class:`datetime.datetime` object.\n        \"\"\"\n\n        # Re-implement the algorithm from Python's datetime.py\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # The original datetime.py code assumes that `dst()` defaults to\n        # zero during ambiguous times. PEP 495 inverts this presumption, so\n        # for pre-PEP 495 versions of python, we need to tweak the algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n\n        dt += delta\n        # Set fold=1 so we can default to being in the fold for\n        # ambiguous dates.\n        dtdst = enfold(dt, fold=1).dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                             \"results; cannot convert\")\n        return dt + dtdst", "signature": "def _fromutc(self, dt):", "completion_path": "dateutil/tz/_common.py"}
{"ce_id": "62b8982f755ee91dce50a241", "namespace": "62b8982f755ee91dce50a241", "namespace_real": "dateutil.relativedelta.normalized", "real_proj_path": "pexip---os-python-dateutil/", "type": "class", "class_name": "relativedelta", "function_name": "normalized", "contexts_above": "# -*- coding: utf-8 -*-\nimport datetime\nimport calendar\n\nimport operator\nfrom math import copysign\n\nfrom six import integer_types\nfrom warnings import warn\n\nfrom ._common import weekday\n\nMO, TU, WE, TH, FR, SA, SU = weekdays = tuple(weekday(x) for x in range(7))\n\n__all__ = [\"relativedelta\", \"MO\", \"TU\", \"WE\", \"TH\", \"FR\", \"SA\", \"SU\"]\n\n\nclass relativedelta(object):\n    \"\"\"\n    The relativedelta type is designed to be applied to an existing datetime and\n    can replace specific components of that datetime, or represents an interval\n    of time.\n\n    It is based on the specification of the excellent work done by M.-A. Lemburg\n    in his\n    `mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/>`_ extension.\n    However, notice that this type does *NOT* implement the same algorithm as\n    his work. Do *NOT* expect it to behave like mx.DateTime's counterpart.\n\n    There are two different ways to build a relativedelta instance. The\n    first one is passing it two date/datetime classes::\n\n        relativedelta(datetime1, datetime2)\n\n    The second one is passing it any number of the following keyword arguments::\n\n        relativedelta(arg1=x,arg2=y,arg3=z...)\n\n        year, month, day, hour, minute, second, microsecond:\n            Absolute information (argument is singular); adding or subtracting a\n            relativedelta with absolute information does not perform an arithmetic\n            operation, but rather REPLACES the corresponding value in the\n            original datetime with the value(s) in relativedelta.\n\n        years, months, weeks, days, hours, minutes, seconds, microseconds:\n            Relative information, may be negative (argument is plural); adding\n            or subtracting a relativedelta with relative information performs\n            the corresponding arithmetic operation on the original datetime value\n            with the information in the relativedelta.\n\n        weekday: \n            One of the weekday instances (MO, TU, etc) available in the\n            relativedelta module. These instances may receive a parameter N,\n            specifying the Nth weekday, which could be positive or negative\n            (like MO(+1) or MO(-2)). Not specifying it is the same as specifying\n            +1. You can also use an integer, where 0=MO. This argument is always\n            relative e.g. if the calculated date is already Monday, using MO(1)\n            or MO(-1) won't change the day. To effectively make it absolute, use\n            it in combination with the day argument (e.g. day=1, MO(1) for first\n            Monday of the month).\n\n        leapdays:\n            Will add given days to the date found, if year is a leap\n            year, and the date found is post 28 of february.\n\n        yearday, nlyearday:\n            Set the yearday or the non-leap year day (jump leap days).\n            These are converted to day/month/leapdays information.\n\n    There are relative and absolute forms of the keyword\n    arguments. The plural is relative, and the singular is\n    absolute. For each argument in the order below, the absolute form\n    is applied first (by setting each attribute to that value) and\n    then the relative form (by adding the value to the attribute).\n\n    The order of attributes considered when this relativedelta is\n    added to a datetime is:\n\n    1. Year\n    2. Month\n    3. Day\n    4. Hours\n    5. Minutes\n    6. Seconds\n    7. Microseconds\n\n    Finally, weekday is applied, using the rule described above.\n\n    For example\n\n    >>> from datetime import datetime\n    >>> from dateutil.relativedelta import relativedelta, MO\n    >>> dt = datetime(2018, 4, 9, 13, 37, 0)\n    >>> delta = relativedelta(hours=25, day=1, weekday=MO(1))\n    >>> dt + delta\n    datetime.datetime(2018, 4, 2, 14, 37)\n\n    First, the day is set to 1 (the first of the month), then 25 hours\n    are added, to get to the 2nd day and 14th hour, finally the\n    weekday is applied, but since the 2nd is already a Monday there is\n    no effect.\n\n    \"\"\"\n\n    def __init__(self, dt1=None, dt2=None,\n                 years=0, months=0, days=0, leapdays=0, weeks=0,\n                 hours=0, minutes=0, seconds=0, microseconds=0,\n                 year=None, month=None, day=None, weekday=None,\n                 yearday=None, nlyearday=None,\n                 hour=None, minute=None, second=None, microsecond=None):\n\n        if dt1 and dt2:\n            # datetime is a subclass of date. So both must be date\n            if not (isinstance(dt1, datetime.date) and\n                    isinstance(dt2, datetime.date)):\n                raise TypeError(\"relativedelta only diffs datetime/date\")\n\n            # We allow two dates, or two datetimes, so we coerce them to be\n            # of the same type\n            if (isinstance(dt1, datetime.datetime) !=\n                    isinstance(dt2, datetime.datetime)):\n                if not isinstance(dt1, datetime.datetime):\n                    dt1 = datetime.datetime.fromordinal(dt1.toordinal())\n                elif not isinstance(dt2, datetime.datetime):\n                    dt2 = datetime.datetime.fromordinal(dt2.toordinal())\n\n            self.years = 0\n            self.months = 0\n            self.days = 0\n            self.leapdays = 0\n            self.hours = 0\n            self.minutes = 0\n            self.seconds = 0\n            self.microseconds = 0\n            self.year = None\n            self.month = None\n            self.day = None\n            self.weekday = None\n            self.hour = None\n            self.minute = None\n            self.second = None\n            self.microsecond = None\n            self._has_time = 0\n\n            # Get year / month delta between the two\n            months = (dt1.year - dt2.year) * 12 + (dt1.month - dt2.month)\n            self._set_months(months)\n\n            # Remove the year/month delta so the timedelta is just well-defined\n            # time units (seconds, days and microseconds)\n            dtm = self.__radd__(dt2)\n\n            # If we've overshot our target, make an adjustment\n            if dt1 < dt2:\n                compare = operator.gt\n                increment = 1\n            else:\n                compare = operator.lt\n                increment = -1\n\n            while compare(dt1, dtm):\n                months += increment\n                self._set_months(months)\n                dtm = self.__radd__(dt2)\n\n            # Get the timedelta between the \"months-adjusted\" date and dt1\n            delta = dt1 - dtm\n            self.seconds = delta.seconds + delta.days * 86400\n            self.microseconds = delta.microseconds\n        else:\n            # Check for non-integer values in integer-only quantities\n            if any(x is not None and x != int(x) for x in (years, months)):\n                raise ValueError(\"Non-integer years and months are \"\n                                 \"ambiguous and not currently supported.\")\n\n            # Relative information\n            self.years = int(years)\n            self.months = int(months)\n            self.days = days + weeks * 7\n            self.leapdays = leapdays\n            self.hours = hours\n            self.minutes = minutes\n            self.seconds = seconds\n            self.microseconds = microseconds\n\n            # Absolute information\n            self.year = year\n            self.month = month\n            self.day = day\n            self.hour = hour\n            self.minute = minute\n            self.second = second\n            self.microsecond = microsecond\n\n            if any(x is not None and int(x) != x\n                   for x in (year, month, day, hour,\n                             minute, second, microsecond)):\n                # For now we'll deprecate floats - later it'll be an error.\n                warn(\"Non-integer value passed as absolute information. \" +\n                     \"This is not a well-defined condition and will raise \" +\n                     \"errors in future versions.\", DeprecationWarning)\n\n            if isinstance(weekday, integer_types):\n                self.weekday = weekdays[weekday]\n            else:\n                self.weekday = weekday\n\n            yday = 0\n            if nlyearday:\n                yday = nlyearday\n            elif yearday:\n                yday = yearday\n                if yearday > 59:\n                    self.leapdays = -1\n            if yday:\n                ydayidx = [31, 59, 90, 120, 151, 181, 212,\n                           243, 273, 304, 334, 366]\n                for idx, ydays in enumerate(ydayidx):\n                    if yday <= ydays:\n                        self.month = idx+1\n                        if idx == 0:\n                            self.day = yday\n                        else:\n                            self.day = yday-ydayidx[idx-1]\n                        break\n                else:\n                    raise ValueError(\"invalid year day (%d)\" % yday)\n\n        self._fix()\n\n    def _fix(self):\n        if abs(self.microseconds) > 999999:\n            s = _sign(self.microseconds)\n            div, mod = divmod(self.microseconds * s, 1000000)\n            self.microseconds = mod * s\n            self.seconds += div * s\n        if abs(self.seconds) > 59:\n            s = _sign(self.seconds)\n            div, mod = divmod(self.seconds * s, 60)\n            self.seconds = mod * s\n            self.minutes += div * s\n        if abs(self.minutes) > 59:\n            s = _sign(self.minutes)\n            div, mod = divmod(self.minutes * s, 60)\n            self.minutes = mod * s\n            self.hours += div * s\n        if abs(self.hours) > 23:\n            s = _sign(self.hours)\n            div, mod = divmod(self.hours * s, 24)\n            self.hours = mod * s\n            self.days += div * s\n        if abs(self.months) > 11:\n            s = _sign(self.months)\n            div, mod = divmod(self.months * s, 12)\n            self.months = mod * s\n            self.years += div * s\n        if (self.hours or self.minutes or self.seconds or self.microseconds\n                or self.hour is not None or self.minute is not None or\n                self.second is not None or self.microsecond is not None):\n            self._has_time = 1\n        else:\n            self._has_time = 0\n\n    @property\n    def weeks(self):\n        return int(self.days / 7.0)\n\n    @weeks.setter\n    def weeks(self, value):\n        self.days = self.days - (self.weeks * 7) + value * 7\n\n    def _set_months(self, months):\n        self.months = months\n        if abs(self.months) > 11:\n            s = _sign(self.months)\n            div, mod = divmod(self.months * s, 12)\n            self.months = mod * s\n            self.years = div * s\n        else:\n            self.years = 0\n", "contexts_below": "    def __add__(self, other):\n         if isinstance(other, relativedelta):\n             return self.__class__(years=other.years + self.years,\n                                  months=other.months + self.months,\n                                  days=other.days + self.days,\n                                  hours=other.hours + self.hours,\n                                  minutes=other.minutes + self.minutes,\n                                  seconds=other.seconds + self.seconds,\n                                  microseconds=(other.microseconds +\n                                                self.microseconds),\n                                  leapdays=other.leapdays or self.leapdays,\n                                  year=(other.year if other.year is not None\n                                        else self.year),\n                                  month=(other.month if other.month is not None\n                                         else self.month),\n                                  day=(other.day if other.day is not None\n                                       else self.day),\n                                  weekday=(other.weekday if other.weekday is not None\n                                           else self.weekday),\n                                  hour=(other.hour if other.hour is not None\n                                        else self.hour),\n                                  minute=(other.minute if other.minute is not None\n                                          else self.minute),\n                                  second=(other.second if other.second is not None\n                                          else self.second),\n                                  microsecond=(other.microsecond if other.microsecond\n                                               is not None else\n                                               self.microsecond))\n         if isinstance(other, datetime.timedelta):\n             return self.__class__(years=self.years,\n                                   months=self.months,\n                                   days=self.days + other.days,\n                                   hours=self.hours,\n                                   minutes=self.minutes,\n                                   seconds=self.seconds + other.seconds,\n                                   microseconds=self.microseconds + other.microseconds,\n                                   leapdays=self.leapdays,\n                                   year=self.year,\n                                   month=self.month,\n                                   day=self.day,\n                                   weekday=self.weekday,\n                                   hour=self.hour,\n                                   minute=self.minute,\n                                   second=self.second,\n                                   microsecond=self.microsecond)\n         if not isinstance(other, datetime.date):\n             return NotImplemented\n         elif self._has_time and not isinstance(other, datetime.datetime):\n             other = datetime.datetime.fromordinal(other.toordinal())\n         year = (self.year or other.year)+self.years\n         month = self.month or other.month\n         if self.months:\n             assert 1 <= abs(self.months) <= 12\n             month += self.months\n             if month > 12:\n                 year += 1\n                 month -= 12\n             elif month < 1:\n                 year -= 1\n                 month += 12\n         day = min(calendar.monthrange(year, month)[1],\n                   self.day or other.day)\n         repl = {\"year\": year, \"month\": month, \"day\": day}\n         for attr in [\"hour\", \"minute\", \"second\", \"microsecond\"]:\n             value = getattr(self, attr)\n             if value is not None:\n                 repl[attr] = value\n         days = self.days\n         if self.leapdays and month > 2 and calendar.isleap(year):\n             days += self.leapdays\n         ret = (other.replace(**repl)\n                + datetime.timedelta(days=days,\n                                     hours=self.hours,\n                                     minutes=self.minutes,\n                                     seconds=self.seconds,\n                                     microseconds=self.microseconds))\n         if self.weekday:\n             weekday, nth = self.weekday.weekday, self.weekday.n or 1\n             jumpdays = (abs(nth) - 1) * 7\n             if nth > 0:\n                 jumpdays += (7 - ret.weekday() + weekday) % 7\n             else:\n                 jumpdays += (ret.weekday() - weekday) % 7\n                 jumpdays *= -1\n             ret += datetime.timedelta(days=jumpdays)\n         return ret\n \n     def __radd__(self, other):\n         return self.__add__(other)\n \n     def __rsub__(self, other):\n         return self.__neg__().__radd__(other)\n \n     def __sub__(self, other):\n         if not isinstance(other, relativedelta):\n             return NotImplemented   # In case the other object defines __rsub__\n         return self.__class__(years=self.years - other.years,\n                              months=self.months - other.months,\n                              days=self.days - other.days,\n                              hours=self.hours - other.hours,\n                              minutes=self.minutes - other.minutes,\n                              seconds=self.seconds - other.seconds,\n                              microseconds=self.microseconds - other.microseconds,\n                              leapdays=self.leapdays or other.leapdays,\n                              year=(self.year if self.year is not None\n                                    else other.year),\n                              month=(self.month if self.month is not None else\n                                     other.month),\n                              day=(self.day if self.day is not None else\n                                   other.day),\n                              weekday=(self.weekday if self.weekday is not None else\n                                       other.weekday),\n                              hour=(self.hour if self.hour is not None else\n                                    other.hour),\n                              minute=(self.minute if self.minute is not None else\n                                      other.minute),\n                              second=(self.second if self.second is not None else\n                                      other.second),\n                              microsecond=(self.microsecond if self.microsecond\n                                           is not None else\n                                           other.microsecond))\n \n     def __abs__(self):\n         return self.__class__(years=abs(self.years),\n                               months=abs(self.months),\n                               days=abs(self.days),\n                               hours=abs(self.hours),\n                               minutes=abs(self.minutes),\n                               seconds=abs(self.seconds),\n                               microseconds=abs(self.microseconds),\n                               leapdays=self.leapdays,\n                               year=self.year,\n                               month=self.month,\n                               day=self.day,\n                               weekday=self.weekday,\n                               hour=self.hour,\n                               minute=self.minute,\n                               second=self.second,\n                               microsecond=self.microsecond)\n \n     def __neg__(self):\n         return self.__class__(years=-self.years,\n                              months=-self.months,\n                              days=-self.days,\n                              hours=-self.hours,\n                              minutes=-self.minutes,\n                              seconds=-self.seconds,\n                              microseconds=-self.microseconds,\n                              leapdays=self.leapdays,\n                              year=self.year,\n                              month=self.month,\n                              day=self.day,\n                              weekday=self.weekday,\n                              hour=self.hour,\n                              minute=self.minute,\n                              second=self.second,\n                              microsecond=self.microsecond)\n \n     def __bool__(self):\n         return not (not self.years and\n                     not self.months and\n                     not self.days and\n                     not self.hours and\n                     not self.minutes and\n                     not self.seconds and\n                     not self.microseconds and\n                     not self.leapdays and\n                     self.year is None and\n                     self.month is None and\n                     self.day is None and\n                     self.weekday is None and\n                     self.hour is None and\n                     self.minute is None and\n                     self.second is None and\n                     self.microsecond is None)\n     # Compatibility with Python 2.x\n     __nonzero__ = __bool__\n \n     def __mul__(self, other):\n         try:\n             f = float(other)\n         except TypeError:\n             return NotImplemented\n \n         return self.__class__(years=int(self.years * f),\n                              months=int(self.months * f),\n                              days=int(self.days * f),\n                              hours=int(self.hours * f),\n                              minutes=int(self.minutes * f),\n                              seconds=int(self.seconds * f),\n                              microseconds=int(self.microseconds * f),\n                              leapdays=self.leapdays,\n                              year=self.year,\n                              month=self.month,\n                              day=self.day,\n                              weekday=self.weekday,\n                              hour=self.hour,\n                              minute=self.minute,\n                              second=self.second,\n                              microsecond=self.microsecond)\n \n     __rmul__ = __mul__\n \n     def __eq__(self, other):\n         if not isinstance(other, relativedelta):\n             return NotImplemented\n         if self.weekday or other.weekday:\n             if not self.weekday or not other.weekday:\n                 return False\n             if self.weekday.weekday != other.weekday.weekday:\n                 return False\n             n1, n2 = self.weekday.n, other.weekday.n\n             if n1 != n2 and not ((not n1 or n1 == 1) and (not n2 or n2 == 1)):\n                 return False\n         return (self.years == other.years and\n                 self.months == other.months and\n                 self.days == other.days and\n                 self.hours == other.hours and\n                 self.minutes == other.minutes and\n                 self.seconds == other.seconds and\n                 self.microseconds == other.microseconds and\n                 self.leapdays == other.leapdays and\n                 self.year == other.year and\n                 self.month == other.month and\n                 self.day == other.day and\n                 self.hour == other.hour and\n                 self.minute == other.minute and\n                 self.second == other.second and\n                 self.microsecond == other.microsecond)\n \n     def __hash__(self):\n         return hash((\n             self.weekday,\n             self.years,\n             self.months,\n             self.days,\n             self.hours,\n             self.minutes,\n             self.seconds,\n             self.microseconds,\n             self.leapdays,\n             self.year,\n             self.month,\n             self.day,\n             self.hour,\n             self.minute,\n             self.second,\n             self.microsecond,\n         ))\n \n     def __ne__(self, other):\n         return not self.__eq__(other)\n \n     def __div__(self, other):\n         try:\n             reciprocal = 1 / float(other)\n         except TypeError:\n             return NotImplemented\n \n         return self.__mul__(reciprocal)\n \n     __truediv__ = __div__\n \n     def __repr__(self):\n         l = []\n         for attr in [\"years\", \"months\", \"days\", \"leapdays\",\n                      \"hours\", \"minutes\", \"seconds\", \"microseconds\"]:\n             value = getattr(self, attr)\n             if value:\n                 l.append(\"{attr}={value:+g}\".format(attr=attr, value=value))\n         for attr in [\"year\", \"month\", \"day\", \"weekday\",\n                      \"hour\", \"minute\", \"second\", \"microsecond\"]:\n             value = getattr(self, attr)\n             if value is not None:\n                 l.append(\"{attr}={value}\".format(attr=attr, value=repr(value)))\n         return \"{classname}({attrs})\".format(classname=self.__class__.__name__,\n                                              attrs=\", \".join(l))\n \n \n def _sign(x):\n     return int(copysign(1, x))\n \n # vim:ts=4:sw=4:et\n ", "input_code": "def normalized(self):\n\"\"\"\nReturn a version of this object represented entirely using integer\nvalues for the relative attributes.\n\n>>> relativedelta(days=1.5, hours=2).normalized()\nrelativedelta(days=+1, hours=+14)\n\n:return:\n    Returns a :class:`dateutil.relativedelta.relativedelta` object.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def normalized(self):\n        \"\"\"\n        Return a version of this object represented entirely using integer\n        values for the relative attributes.\n\n        >>> relativedelta(days=1.5, hours=2).normalized()\n        relativedelta(days=+1, hours=+14)\n\n        :return:\n            Returns a :class:`dateutil.relativedelta.relativedelta` object.\n        \"\"\"\n        # Cascade remainders down (rounding each to roughly nearest microsecond)\n        days = int(self.days)\n\n        hours_f = round(self.hours + 24 * (self.days - days), 11)\n        hours = int(hours_f)\n\n        minutes_f = round(self.minutes + 60 * (hours_f - hours), 10)\n        minutes = int(minutes_f)\n\n        seconds_f = round(self.seconds + 60 * (minutes_f - minutes), 8)\n        seconds = int(seconds_f)\n\n        microseconds = round(self.microseconds + 1e6 * (seconds_f - seconds))\n\n        # Constructor carries overflow back up with call to _fix()\n        return self.__class__(years=self.years, months=self.months,\n                              days=days, hours=hours, minutes=minutes,\n                              seconds=seconds, microseconds=microseconds,\n                              leapdays=self.leapdays, year=self.year,\n                              month=self.month, day=self.day,\n                              weekday=self.weekday, hour=self.hour,\n                              minute=self.minute, second=self.second,\n                              microsecond=self.microsecond)", "signature": "def normalized(self):", "completion_path": "dateutil/relativedelta.py"}
{"ce_id": "62b89640755ee91dce50a114", "namespace": "62b89640755ee91dce50a114", "namespace_real": "dateutil.tz._common.tzname_in_python2", "real_proj_path": "pexip---os-python-dateutil/", "type": "function", "class_name": null, "function_name": "tzname_in_python2", "contexts_above": "from six import PY2\n\nfrom functools import wraps\n\nfrom datetime import datetime, timedelta, tzinfo\n\n\nZERO = timedelta(0)\n\n__all__ = ['tzname_in_python2', 'enfold']\n\n", "contexts_below": "\n # The following is adapted from Alexander Belopolsky's tz library\n # https://github.com/abalkin/tz\n if hasattr(datetime, 'fold'):\n     # This is the pre-python 3.6 fold situation\n     def enfold(dt, fold=1):\n         \"\"\"\n         Provides a unified interface for assigning the ``fold`` attribute to\n         datetimes both before and after the implementation of PEP-495.\n \n         :param fold:\n             The value for the ``fold`` attribute in the returned datetime. This\n             should be either 0 or 1.\n \n         :return:\n             Returns an object for which ``getattr(dt, 'fold', 0)`` returns\n             ``fold`` for all versions of Python. In versions prior to\n             Python 3.6, this is a ``_DatetimeWithFold`` object, which is a\n             subclass of :py:class:`datetime.datetime` with the ``fold``\n             attribute added, if ``fold`` is 1.\n \n         .. versionadded:: 2.6.0\n         \"\"\"\n         return dt.replace(fold=fold)\n \n else:\n     class _DatetimeWithFold(datetime):\n         \"\"\"\n         This is a class designed to provide a PEP 495-compliant interface for\n         Python versions before 3.6. It is used only for dates in a fold, so\n         the ``fold`` attribute is fixed at ``1``.\n \n         .. versionadded:: 2.6.0\n         \"\"\"\n         __slots__ = ()\n \n         def replace(self, *args, **kwargs):\n             \"\"\"\n             Return a datetime with the same attributes, except for those\n             attributes given new values by whichever keyword arguments are\n             specified. Note that tzinfo=None can be specified to create a naive\n             datetime from an aware datetime with no conversion of date and time\n             data.\n \n             This is reimplemented in ``_DatetimeWithFold`` because pypy3 will\n             return a ``datetime.datetime`` even if ``fold`` is unchanged.\n             \"\"\"\n             argnames = (\n                 'year', 'month', 'day', 'hour', 'minute', 'second',\n                 'microsecond', 'tzinfo'\n             )\n \n             for arg, argname in zip(args, argnames):\n                 if argname in kwargs:\n                     raise TypeError('Duplicate argument: {}'.format(argname))\n \n                 kwargs[argname] = arg\n \n             for argname in argnames:\n                 if argname not in kwargs:\n                     kwargs[argname] = getattr(self, argname)\n \n             dt_class = self.__class__ if kwargs.get('fold', 1) else datetime\n \n             return dt_class(**kwargs)\n \n         @property\n         def fold(self):\n             return 1\n \n     def enfold(dt, fold=1):\n         \"\"\"\n         Provides a unified interface for assigning the ``fold`` attribute to\n         datetimes both before and after the implementation of PEP-495.\n \n         :param fold:\n             The value for the ``fold`` attribute in the returned datetime. This\n             should be either 0 or 1.\n \n         :return:\n             Returns an object for which ``getattr(dt, 'fold', 0)`` returns\n             ``fold`` for all versions of Python. In versions prior to\n             Python 3.6, this is a ``_DatetimeWithFold`` object, which is a\n             subclass of :py:class:`datetime.datetime` with the ``fold``\n             attribute added, if ``fold`` is 1.\n \n         .. versionadded:: 2.6.0\n         \"\"\"\n         if getattr(dt, 'fold', 0) == fold:\n             return dt\n \n         args = dt.timetuple()[:6]\n         args += (dt.microsecond, dt.tzinfo)\n \n         if fold:\n             return _DatetimeWithFold(*args)\n         else:\n             return datetime(*args)\n \n \n def _validate_fromutc_inputs(f):\n     \"\"\"\n     The CPython version of ``fromutc`` checks that the input is a ``datetime``\n     object and that ``self`` is attached as its ``tzinfo``.\n     \"\"\"\n     @wraps(f)\n     def fromutc(self, dt):\n         if not isinstance(dt, datetime):\n             raise TypeError(\"fromutc() requires a datetime argument\")\n         if dt.tzinfo is not self:\n             raise ValueError(\"dt.tzinfo is not self\")\n \n         return f(self, dt)\n \n     return fromutc\n \n \n class _tzinfo(tzinfo):\n     \"\"\"\n     Base class for all ``dateutil`` ``tzinfo`` objects.\n     \"\"\"\n \n     def is_ambiguous(self, dt):\n         \"\"\"\n         Whether or not the \"wall time\" of a given datetime is ambiguous in this\n         zone.\n \n         :param dt:\n             A :py:class:`datetime.datetime`, naive or time zone aware.\n \n \n         :return:\n             Returns ``True`` if ambiguous, ``False`` otherwise.\n \n         .. versionadded:: 2.6.0\n         \"\"\"\n \n         dt = dt.replace(tzinfo=self)\n \n         wall_0 = enfold(dt, fold=0)\n         wall_1 = enfold(dt, fold=1)\n \n         same_offset = wall_0.utcoffset() == wall_1.utcoffset()\n         same_dt = wall_0.replace(tzinfo=None) == wall_1.replace(tzinfo=None)\n \n         return same_dt and not same_offset\n \n     def _fold_status(self, dt_utc, dt_wall):\n         \"\"\"\n         Determine the fold status of a \"wall\" datetime, given a representation\n         of the same datetime as a (naive) UTC datetime. This is calculated based\n         on the assumption that ``dt.utcoffset() - dt.dst()`` is constant for all\n         datetimes, and that this offset is the actual number of hours separating\n         ``dt_utc`` and ``dt_wall``.\n \n         :param dt_utc:\n             Representation of the datetime as UTC\n \n         :param dt_wall:\n             Representation of the datetime as \"wall time\". This parameter must\n             either have a `fold` attribute or have a fold-naive\n             :class:`datetime.tzinfo` attached, otherwise the calculation may\n             fail.\n         \"\"\"\n         if self.is_ambiguous(dt_wall):\n             delta_wall = dt_wall - dt_utc\n             _fold = int(delta_wall == (dt_utc.utcoffset() - dt_utc.dst()))\n         else:\n             _fold = 0\n \n         return _fold\n \n     def _fold(self, dt):\n         return getattr(dt, 'fold', 0)\n \n     def _fromutc(self, dt):\n         \"\"\"\n         Given a timezone-aware datetime in a given timezone, calculates a\n         timezone-aware datetime in a new timezone.\n \n         Since this is the one time that we *know* we have an unambiguous\n         datetime object, we take this opportunity to determine whether the\n         datetime is ambiguous and in a \"fold\" state (e.g. if it's the first\n         occurrence, chronologically, of the ambiguous datetime).\n \n         :param dt:\n             A timezone-aware :class:`datetime.datetime` object.\n         \"\"\"\n \n         # Re-implement the algorithm from Python's datetime.py\n         dtoff = dt.utcoffset()\n         if dtoff is None:\n             raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                              \"result\")\n \n         # The original datetime.py code assumes that `dst()` defaults to\n         # zero during ambiguous times. PEP 495 inverts this presumption, so\n         # for pre-PEP 495 versions of python, we need to tweak the algorithm.\n         dtdst = dt.dst()\n         if dtdst is None:\n             raise ValueError(\"fromutc() requires a non-None dst() result\")\n         delta = dtoff - dtdst\n \n         dt += delta\n         # Set fold=1 so we can default to being in the fold for\n         # ambiguous dates.\n         dtdst = enfold(dt, fold=1).dst()\n         if dtdst is None:\n             raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                              \"results; cannot convert\")\n         return dt + dtdst\n \n     @_validate_fromutc_inputs\n     def fromutc(self, dt):\n         \"\"\"\n         Given a timezone-aware datetime in a given timezone, calculates a\n         timezone-aware datetime in a new timezone.\n \n         Since this is the one time that we *know* we have an unambiguous\n         datetime object, we take this opportunity to determine whether the\n         datetime is ambiguous and in a \"fold\" state (e.g. if it's the first\n         occurrence, chronologically, of the ambiguous datetime).\n \n         :param dt:\n             A timezone-aware :class:`datetime.datetime` object.\n         \"\"\"\n         dt_wall = self._fromutc(dt)\n \n         # Calculate the fold status given the two datetimes.\n         _fold = self._fold_status(dt, dt_wall)\n \n         # Set the default fold value for ambiguous dates\n         return enfold(dt_wall, fold=_fold)\n \n \n class tzrangebase(_tzinfo):\n     \"\"\"\n     This is an abstract base class for time zones represented by an annual\n     transition into and out of DST. Child classes should implement the following\n     methods:\n \n         * ``__init__(self, *args, **kwargs)``\n         * ``transitions(self, year)`` - this is expected to return a tuple of\n           datetimes representing the DST on and off transitions in standard\n           time.\n \n     A fully initialized ``tzrangebase`` subclass should also provide the\n     following attributes:\n         * ``hasdst``: Boolean whether or not the zone uses DST.\n         * ``_dst_offset`` / ``_std_offset``: :class:`datetime.timedelta` objects\n           representing the respective UTC offsets.\n         * ``_dst_abbr`` / ``_std_abbr``: Strings representing the timezone short\n           abbreviations in DST and STD, respectively.\n         * ``_hasdst``: Whether or not the zone has DST.\n \n     .. versionadded:: 2.6.0\n     \"\"\"\n     def __init__(self):\n         raise NotImplementedError('tzrangebase is an abstract base class')\n \n     def utcoffset(self, dt):\n         isdst = self._isdst(dt)\n \n         if isdst is None:\n             return None\n         elif isdst:\n             return self._dst_offset\n         else:\n             return self._std_offset\n \n     def dst(self, dt):\n         isdst = self._isdst(dt)\n \n         if isdst is None:\n             return None\n         elif isdst:\n             return self._dst_base_offset\n         else:\n             return ZERO\n \n     @tzname_in_python2\n     def tzname(self, dt):\n         if self._isdst(dt):\n             return self._dst_abbr\n         else:\n             return self._std_abbr\n \n     def fromutc(self, dt):\n         \"\"\" Given a datetime in UTC, return local time \"\"\"\n         if not isinstance(dt, datetime):\n             raise TypeError(\"fromutc() requires a datetime argument\")\n \n         if dt.tzinfo is not self:\n             raise ValueError(\"dt.tzinfo is not self\")\n \n         # Get transitions - if there are none, fixed offset\n         transitions = self.transitions(dt.year)\n         if transitions is None:\n             return dt + self.utcoffset(dt)\n \n         # Get the transition times in UTC\n         dston, dstoff = transitions\n \n         dston -= self._std_offset\n         dstoff -= self._std_offset\n \n         utc_transitions = (dston, dstoff)\n         dt_utc = dt.replace(tzinfo=None)\n \n         isdst = self._naive_isdst(dt_utc, utc_transitions)\n \n         if isdst:\n             dt_wall = dt + self._dst_offset\n         else:\n             dt_wall = dt + self._std_offset\n \n         _fold = int(not isdst and self.is_ambiguous(dt_wall))\n \n         return enfold(dt_wall, fold=_fold)\n \n     def is_ambiguous(self, dt):\n         \"\"\"\n         Whether or not the \"wall time\" of a given datetime is ambiguous in this\n         zone.\n \n         :param dt:\n             A :py:class:`datetime.datetime`, naive or time zone aware.\n \n \n         :return:\n             Returns ``True`` if ambiguous, ``False`` otherwise.\n \n         .. versionadded:: 2.6.0\n         \"\"\"\n         if not self.hasdst:\n             return False\n \n         start, end = self.transitions(dt.year)\n \n         dt = dt.replace(tzinfo=None)\n         return (end <= dt < end + self._dst_base_offset)\n \n     def _isdst(self, dt):\n         if not self.hasdst:\n             return False\n         elif dt is None:\n             return None\n \n         transitions = self.transitions(dt.year)\n \n         if transitions is None:\n             return False\n \n         dt = dt.replace(tzinfo=None)\n \n         isdst = self._naive_isdst(dt, transitions)\n \n         # Handle ambiguous dates\n         if not isdst and self.is_ambiguous(dt):\n             return not self._fold(dt)\n         else:\n             return isdst\n \n     def _naive_isdst(self, dt, transitions):\n         dston, dstoff = transitions\n \n         dt = dt.replace(tzinfo=None)\n \n         if dston < dstoff:\n             isdst = dston <= dt < dstoff\n         else:\n             isdst = not dstoff <= dt < dston\n \n         return isdst\n \n     @property\n     def _dst_base_offset(self):\n         return self._dst_offset - self._std_offset\n \n     __hash__ = None\n \n     def __ne__(self, other):\n         return not (self == other)\n \n     def __repr__(self):\n         return \"%s(...)\" % self.__class__.__name__\n \n     __reduce__ = object.__reduce__\n ", "input_code": "def tzname_in_python2(namefunc):\n\"\"\"\nChange unicode output into bytestrings in Python 2\n\ntzname() API changed in Python 3. It used to return bytes, but was changed\nto unicode strings\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def tzname_in_python2(namefunc):\n    \"\"\"Change unicode output into bytestrings in Python 2\n\n    tzname() API changed in Python 3. It used to return bytes, but was changed\n    to unicode strings\n    \"\"\"\n    if PY2:\n        @wraps(namefunc)\n        def adjust_encoding(*args, **kwargs):\n            name = namefunc(*args, **kwargs)\n            if name is not None:\n                name = name.encode()\n\n            return name\n\n        return adjust_encoding\n    else:\n        return namefunc", "signature": "def tzname_in_python2(namefunc):", "completion_path": "dateutil/tz/_common.py"}
{"ce_id": "62b87d24d292efb640a55670", "namespace": "62b87d24d292efb640a55670", "namespace_real": "src.prestoplot._version.get_versions", "real_proj_path": "eykd---prestoplot/", "type": "function", "class_name": null, "function_name": "get_versions", "contexts_above": "# This file helps to compute a version number in source trees obtained from\n# git-archive tarball (such as those provided by githubs download-from-tag\n# feature). Distribution tarballs (built by setup.py sdist) and build\n# directories (produced by setup.py build) will contain a much shorter file\n# that just contains the computed version number.\n\n# This file is released into the public domain. Generated by\n# versioneer-0.22 (https://github.com/python-versioneer/python-versioneer)\n\n\"\"\"Git implementation of _version.py.\"\"\"\n\nimport errno\nimport functools\nimport os\nimport re\nimport subprocess\nimport sys\nfrom typing import Callable, Dict\n\n\ndef get_keywords():\n    \"\"\"Get the keywords needed to look up the version information.\"\"\"\n    # these strings will be replaced by git during git-archive.\n    # setup.py/versioneer.py will grep for the variable names, so they must\n    # each be defined on a line of their own. _version.py will just call\n    # get_keywords().\n    git_refnames = \"$Format:%d$\"\n    git_full = \"$Format:%H$\"\n    git_date = \"$Format:%ci$\"\n    keywords = {\"refnames\": git_refnames, \"full\": git_full, \"date\": git_date}\n    return keywords\n\n\nclass VersioneerConfig:\n    \"\"\"Container for Versioneer configuration parameters.\"\"\"\n\n\ndef get_config():\n    \"\"\"Create, populate and return the VersioneerConfig() object.\"\"\"\n    # these strings are filled in when 'setup.py versioneer' creates\n    # _version.py\n    cfg = VersioneerConfig()\n    cfg.VCS = \"git\"\n    cfg.style = \"pep440\"\n    cfg.tag_prefix = \"\"\n    cfg.parentdir_prefix = \"None\"\n    cfg.versionfile_source = \"src/prestoplot/_version.py\"\n    cfg.verbose = False\n    return cfg\n\n\nclass NotThisMethod(Exception):\n    \"\"\"Exception raised if a method is not valid for the current scenario.\"\"\"\n\n\nLONG_VERSION_PY: Dict[str, str] = {}\nHANDLERS: Dict[str, Dict[str, Callable]] = {}\n\n\ndef register_vcs_handler(vcs, method):  # decorator\n    \"\"\"Create decorator to mark a method as the handler of a VCS.\"\"\"\n\n    def decorate(f):\n        \"\"\"Store f in HANDLERS[vcs][method].\"\"\"\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n\n    return decorate\n\n\ndef run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):\n    \"\"\"Call the given command(s).\"\"\"\n    assert isinstance(commands, list)\n    process = None\n\n    popen_kwargs = {}\n    if sys.platform == \"win32\":\n        # This hides the console window if pythonw.exe is used\n        startupinfo = subprocess.STARTUPINFO()\n        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n        popen_kwargs[\"startupinfo\"] = startupinfo\n\n    for command in commands:\n        try:\n            dispcmd = str([command] + args)\n            # remember shell=False, so use git.cmd on windows, not just git\n            process = subprocess.Popen(\n                [command] + args,\n                cwd=cwd,\n                env=env,\n                stdout=subprocess.PIPE,\n                stderr=(subprocess.PIPE if hide_stderr else None),\n                **popen_kwargs\n            )\n            break\n        except OSError:\n            e = sys.exc_info()[1]\n            if e.errno == errno.ENOENT:\n                continue\n            if verbose:\n                print(\"unable to run %s\" % dispcmd)\n                print(e)\n            return None, None\n    else:\n        if verbose:\n            print(\"unable to find command, tried %s\" % (commands,))\n        return None, None\n    stdout = process.communicate()[0].strip().decode()\n    if process.returncode != 0:\n        if verbose:\n            print(\"unable to run %s (error)\" % dispcmd)\n            print(\"stdout was %s\" % stdout)\n        return None, process.returncode\n    return stdout, process.returncode\n\n\ndef versions_from_parentdir(parentdir_prefix, root, verbose):\n    \"\"\"Try to determine the version from the parent directory name.\n\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    \"\"\"\n    rootdirs = []\n\n    for _ in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {\n                \"version\": dirname[len(parentdir_prefix) :],\n                \"full-revisionid\": None,\n                \"dirty\": False,\n                \"error\": None,\n                \"date\": None,\n            }\n        rootdirs.append(root)\n        root = os.path.dirname(root)  # up a level\n\n    if verbose:\n        print(\n            \"Tried directories %s but none started with prefix %s\"\n            % (str(rootdirs), parentdir_prefix)\n        )\n    raise NotThisMethod(\"rootdir doesn't start with parentdir_prefix\")\n\n\n@register_vcs_handler(\"git\", \"get_keywords\")\ndef git_get_keywords(versionfile_abs):\n    \"\"\"Extract version information from the given file.\"\"\"\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don't want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        with open(versionfile_abs, \"r\") as fobj:\n            for line in fobj:\n                if line.strip().startswith(\"git_refnames =\"):\n                    mo = re.search(r'=\\s*\"(.*)\"', line)\n                    if mo:\n                        keywords[\"refnames\"] = mo.group(1)\n                if line.strip().startswith(\"git_full =\"):\n                    mo = re.search(r'=\\s*\"(.*)\"', line)\n                    if mo:\n                        keywords[\"full\"] = mo.group(1)\n                if line.strip().startswith(\"git_date =\"):\n                    mo = re.search(r'=\\s*\"(.*)\"', line)\n                    if mo:\n                        keywords[\"date\"] = mo.group(1)\n    except OSError:\n        pass\n    return keywords\n\n\n@register_vcs_handler(\"git\", \"keywords\")\ndef git_versions_from_keywords(keywords, tag_prefix, verbose):\n    \"\"\"Get version information from git keywords.\"\"\"\n    if \"refnames\" not in keywords:\n        raise NotThisMethod(\"Short version file found\")\n    date = keywords.get(\"date\")\n    if date is not None:\n        # Use only the last line.  Previous lines may contain GPG signature\n        # information.\n        date = date.splitlines()[-1]\n\n        # git-2.2.0 added \"%cI\", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer \"%ci\" (which expands to an \"ISO-8601\n        # -like\" string, which we must then edit to make compliant), because\n        # it's been around since git-1.5.3, and it's too difficult to\n        # discover which version we're using, or to work around using an\n        # older one.\n        date = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n    refnames = keywords[\"refnames\"].strip()\n    if refnames.startswith(\"$Format\"):\n        if verbose:\n            print(\"keywords are unexpanded, not using\")\n        raise NotThisMethod(\"unexpanded keywords, not a git-archive tarball\")\n    refs = {r.strip() for r in refnames.strip(\"()\").split(\",\")}\n    # starting in git-1.8.3, tags are listed as \"tag: foo-1.0\" instead of\n    # just \"foo-1.0\". If we see a \"tag: \" prefix, prefer those.\n    TAG = \"tag: \"\n    tags = {r[len(TAG) :] for r in refs if r.startswith(TAG)}\n    if not tags:\n        # Either we're using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like \"release\" and\n        # \"stabilization\", as well as \"HEAD\" and \"master\".\n        tags = {r for r in refs if re.search(r\"\\d\", r)}\n        if verbose:\n            print(\"discarding '%s', no digits\" % \",\".join(refs - tags))\n    if verbose:\n        print(\"likely tags: %s\" % \",\".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. \"2.0\" over \"2.0rc1\"\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix) :]\n            # Filter out refs that exactly match prefix or that don't start\n            # with a number once the prefix is stripped (mostly a concern\n            # when prefix is '')\n            if not re.match(r\"\\d\", r):\n                continue\n            if verbose:\n                print(\"picking %s\" % r)\n            return {\n                \"version\": r,\n                \"full-revisionid\": keywords[\"full\"].strip(),\n                \"dirty\": False,\n                \"error\": None,\n                \"date\": date,\n            }\n    # no suitable tags, so version is \"0+unknown\", but full hex is still there\n    if verbose:\n        print(\"no suitable tags, using unknown + full revision id\")\n    return {\n        \"version\": \"0+unknown\",\n        \"full-revisionid\": keywords[\"full\"].strip(),\n        \"dirty\": False,\n        \"error\": \"no suitable tags\",\n        \"date\": None,\n    }\n\n\n@register_vcs_handler(\"git\", \"pieces_from_vcs\")\ndef git_pieces_from_vcs(tag_prefix, root, verbose, runner=run_command):\n    \"\"\"Get version from 'git describe' in the root of the source tree.\n\n    This only gets called if the git-archive 'subst' keywords were *not*\n    expanded, and _version.py hasn't already been rewritten with a short\n    version string, meaning we're inside a checked out source tree.\n    \"\"\"\n    GITS = [\"git\"]\n    if sys.platform == \"win32\":\n        GITS = [\"git.cmd\", \"git.exe\"]\n\n    # GIT_DIR can interfere with correct operation of Versioneer.\n    # It may be intended to be passed to the Versioneer-versioned project,\n    # but that should not change where we get our version from.\n    env = os.environ.copy()\n    env.pop(\"GIT_DIR\", None)\n    runner = functools.partial(runner, env=env)\n\n    _, rc = runner(GITS, [\"rev-parse\", \"--git-dir\"], cwd=root, hide_stderr=True)\n    if rc != 0:\n        if verbose:\n            print(\"Directory %s not under git control\" % root)\n        raise NotThisMethod(\"'git rev-parse --git-dir' returned error\")\n\n    MATCH_ARGS = [\"--match\", \"%s*\" % tag_prefix] if tag_prefix else []\n\n    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]\n    # if there isn't one, this yields HEX[-dirty] (no NUM)\n    describe_out, rc = runner(\n        GITS,\n        [\"describe\", \"--tags\", \"--dirty\", \"--always\", \"--long\", *MATCH_ARGS],\n        cwd=root,\n    )\n    # --long was added in git-1.5.5\n    if describe_out is None:\n        raise NotThisMethod(\"'git describe' failed\")\n    describe_out = describe_out.strip()\n    full_out, rc = runner(GITS, [\"rev-parse\", \"HEAD\"], cwd=root)\n    if full_out is None:\n        raise NotThisMethod(\"'git rev-parse' failed\")\n    full_out = full_out.strip()\n\n    pieces = {}\n    pieces[\"long\"] = full_out\n    pieces[\"short\"] = full_out[:7]  # maybe improved later\n    pieces[\"error\"] = None\n\n    branch_name, rc = runner(GITS, [\"rev-parse\", \"--abbrev-ref\", \"HEAD\"], cwd=root)\n    # --abbrev-ref was added in git-1.6.3\n    if rc != 0 or branch_name is None:\n        raise NotThisMethod(\"'git rev-parse --abbrev-ref' returned error\")\n    branch_name = branch_name.strip()\n\n    if branch_name == \"HEAD\":\n        # If we aren't exactly on a branch, pick a branch which represents\n        # the current commit. If all else fails, we are on a branchless\n        # commit.\n        branches, rc = runner(GITS, [\"branch\", \"--contains\"], cwd=root)\n        # --contains was added in git-1.5.4\n        if rc != 0 or branches is None:\n            raise NotThisMethod(\"'git branch --contains' returned error\")\n        branches = branches.split(\"\\n\")\n\n        # Remove the first line if we're running detached\n        if \"(\" in branches[0]:\n            branches.pop(0)\n\n        # Strip off the leading \"* \" from the list of branches.\n        branches = [branch[2:] for branch in branches]\n        if \"master\" in branches:\n            branch_name = \"master\"\n        elif not branches:\n            branch_name = None\n        else:\n            # Pick the first branch that is returned. Good or bad.\n            branch_name = branches[0]\n\n    pieces[\"branch\"] = branch_name\n\n    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]\n    # TAG might have hyphens.\n    git_describe = describe_out\n\n    # look for -dirty suffix\n    dirty = git_describe.endswith(\"-dirty\")\n    pieces[\"dirty\"] = dirty\n    if dirty:\n        git_describe = git_describe[: git_describe.rindex(\"-dirty\")]\n\n    # now we have TAG-NUM-gHEX or HEX\n\n    if \"-\" in git_describe:\n        # TAG-NUM-gHEX\n        mo = re.search(r\"^(.+)-(\\d+)-g([0-9a-f]+)$\", git_describe)\n        if not mo:\n            # unparsable. Maybe git-describe is misbehaving?\n            pieces[\"error\"] = \"unable to parse git-describe output: '%s'\" % describe_out\n            return pieces\n\n        # tag\n        full_tag = mo.group(1)\n        if not full_tag.startswith(tag_prefix):\n            if verbose:\n                fmt = \"tag '%s' doesn't start with prefix '%s'\"\n                print(fmt % (full_tag, tag_prefix))\n            pieces[\"error\"] = \"tag '%s' doesn't start with prefix '%s'\" % (\n                full_tag,\n                tag_prefix,\n            )\n            return pieces\n        pieces[\"closest-tag\"] = full_tag[len(tag_prefix) :]\n\n        # distance: number of commits since tag\n        pieces[\"distance\"] = int(mo.group(2))\n\n        # commit: short hex revision ID\n        pieces[\"short\"] = mo.group(3)\n\n    else:\n        # HEX: no tags\n        pieces[\"closest-tag\"] = None\n        count_out, rc = runner(GITS, [\"rev-list\", \"HEAD\", \"--count\"], cwd=root)\n        pieces[\"distance\"] = int(count_out)  # total number of commits\n\n    # commit date: see ISO-8601 comment in git_versions_from_keywords()\n    date = runner(GITS, [\"show\", \"-s\", \"--format=%ci\", \"HEAD\"], cwd=root)[0].strip()\n    # Use only the last line.  Previous lines may contain GPG signature\n    # information.\n    date = date.splitlines()[-1]\n    pieces[\"date\"] = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n\n    return pieces\n\n\ndef plus_or_dot(pieces):\n    \"\"\"Return a + if we don't already have one, else return a .\"\"\"\n    if \"+\" in pieces.get(\"closest-tag\", \"\"):\n        return \".\"\n    return \"+\"\n\n\ndef render_pep440(pieces):\n    \"\"\"Build up version string, with post-release \"local version identifier\".\n\n    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty\n\n    Exceptions:\n    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += plus_or_dot(pieces)\n            rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0+untagged.%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n\n\ndef render_pep440_branch(pieces):\n    \"\"\"TAG[[.dev0]+DISTANCE.gHEX[.dirty]] .\n\n    The \".dev0\" means not master branch. Note that .dev0 sorts backwards\n    (a feature branch will appear \"older\" than the master branch).\n\n    Exceptions:\n    1: no tags. 0[.dev0]+untagged.DISTANCE.gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            if pieces[\"branch\"] != \"master\":\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0\"\n        if pieces[\"branch\"] != \"master\":\n            rendered += \".dev0\"\n        rendered += \"+untagged.%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n\n\ndef pep440_split_post(ver):\n    \"\"\"Split pep440 version string at the post-release segment.\n\n    Returns the release segments before the post-release and the\n    post-release version number (or -1 if no post-release segment is present).\n    \"\"\"\n    vc = str.split(ver, \".post\")\n    return vc[0], int(vc[1] or 0) if len(vc) == 2 else None\n\n\ndef render_pep440_pre(pieces):\n    \"\"\"TAG[.postN.devDISTANCE] -- No -dirty.\n\n    Exceptions:\n    1: no tags. 0.post0.devDISTANCE\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        if pieces[\"distance\"]:\n            # update the post release segment\n            tag_version, post_version = pep440_split_post(pieces[\"closest-tag\"])\n            rendered = tag_version\n            if post_version is not None:\n                rendered += \".post%d.dev%d\" % (post_version + 1, pieces[\"distance\"])\n            else:\n                rendered += \".post0.dev%d\" % (pieces[\"distance\"])\n        else:\n            # no commits, use the tag as the version\n            rendered = pieces[\"closest-tag\"]\n    else:\n        # exception #1\n        rendered = \"0.post0.dev%d\" % pieces[\"distance\"]\n    return rendered\n\n\ndef render_pep440_post(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]+gHEX] .\n\n    The \".dev0\" means dirty. Note that .dev0 sorts backwards\n    (a dirty tree will appear \"older\" than the corresponding clean one),\n    but you shouldn't be releasing software with -dirty anyways.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%d\" % pieces[\"distance\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"g%s\" % pieces[\"short\"]\n    else:\n        # exception #1\n        rendered = \"0.post%d\" % pieces[\"distance\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dev0\"\n        rendered += \"+g%s\" % pieces[\"short\"]\n    return rendered\n\n\ndef render_pep440_post_branch(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]+gHEX[.dirty]] .\n\n    The \".dev0\" means not master branch.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]+gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%d\" % pieces[\"distance\"]\n            if pieces[\"branch\"] != \"master\":\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"g%s\" % pieces[\"short\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0.post%d\" % pieces[\"distance\"]\n        if pieces[\"branch\"] != \"master\":\n            rendered += \".dev0\"\n        rendered += \"+g%s\" % pieces[\"short\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n\n\ndef render_pep440_old(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]] .\n\n    The \".dev0\" means dirty.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%d\" % pieces[\"distance\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dev0\"\n    else:\n        # exception #1\n        rendered = \"0.post%d\" % pieces[\"distance\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dev0\"\n    return rendered\n\n\ndef render_git_describe(pieces):\n    \"\"\"TAG[-DISTANCE-gHEX][-dirty].\n\n    Like 'git describe --tags --dirty --always'.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"]:\n            rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n    else:\n        # exception #1\n        rendered = pieces[\"short\"]\n    if pieces[\"dirty\"]:\n        rendered += \"-dirty\"\n    return rendered\n\n\ndef render_git_describe_long(pieces):\n    \"\"\"TAG-DISTANCE-gHEX[-dirty].\n\n    Like 'git describe --tags --dirty --always -long'.\n    The distance/hash is unconditional.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n    else:\n        # exception #1\n        rendered = pieces[\"short\"]\n    if pieces[\"dirty\"]:\n        rendered += \"-dirty\"\n    return rendered\n\n\ndef render(pieces, style):\n    \"\"\"Render the given version pieces into the requested style.\"\"\"\n    if pieces[\"error\"]:\n        return {\n            \"version\": \"unknown\",\n            \"full-revisionid\": pieces.get(\"long\"),\n            \"dirty\": None,\n            \"error\": pieces[\"error\"],\n            \"date\": None,\n        }\n\n    if not style or style == \"default\":\n        style = \"pep440\"  # the default\n\n    if style == \"pep440\":\n        rendered = render_pep440(pieces)\n    elif style == \"pep440-branch\":\n        rendered = render_pep440_branch(pieces)\n    elif style == \"pep440-pre\":\n        rendered = render_pep440_pre(pieces)\n    elif style == \"pep440-post\":\n        rendered = render_pep440_post(pieces)\n    elif style == \"pep440-post-branch\":\n        rendered = render_pep440_post_branch(pieces)\n    elif style == \"pep440-old\":\n        rendered = render_pep440_old(pieces)\n    elif style == \"git-describe\":\n        rendered = render_git_describe(pieces)\n    elif style == \"git-describe-long\":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(\"unknown style '%s'\" % style)\n\n    return {\n        \"version\": rendered,\n        \"full-revisionid\": pieces[\"long\"],\n        \"dirty\": pieces[\"dirty\"],\n        \"error\": None,\n        \"date\": pieces.get(\"date\"),\n    }\n\n", "contexts_below": "", "input_code": "def get_versions():\n\"\"\"\nGet version information or return default if unable to do so.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def get_versions():\n    \"\"\"Get version information or return default if unable to do so.\"\"\"\n    # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have\n    # __file__, we can work backwards from there to the root. Some\n    # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which\n    # case we can only use expanded keywords.\n\n    cfg = get_config()\n    verbose = cfg.verbose\n\n    try:\n        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix, verbose)\n    except NotThisMethod:\n        pass\n\n    try:\n        root = os.path.realpath(__file__)\n        # versionfile_source is the relative path from the top of the source\n        # tree (where the .git directory might live) to this file. Invert\n        # this to find the root from __file__.\n        for _ in cfg.versionfile_source.split(\"/\"):\n            root = os.path.dirname(root)\n    except NameError:\n        return {\n            \"version\": \"0+unknown\",\n            \"full-revisionid\": None,\n            \"dirty\": None,\n            \"error\": \"unable to find root of source tree\",\n            \"date\": None,\n        }\n\n    try:\n        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)\n        return render(pieces, cfg.style)\n    except NotThisMethod:\n        pass\n\n    try:\n        if cfg.parentdir_prefix:\n            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n    except NotThisMethod:\n        pass\n\n    return {\n        \"version\": \"0+unknown\",\n        \"full-revisionid\": None,\n        \"dirty\": None,\n        \"error\": \"unable to compute version\",\n        \"date\": None,\n    }", "signature": "def get_versions():", "completion_path": "src/prestoplot/_version.py"}
{"ce_id": "62b87d24d292efb640a5566f", "namespace": "62b87d24d292efb640a5566f", "namespace_real": "src.prestoplot._version.render", "real_proj_path": "eykd---prestoplot/", "type": "function", "class_name": null, "function_name": "render", "contexts_above": "# This file helps to compute a version number in source trees obtained from\n# git-archive tarball (such as those provided by githubs download-from-tag\n# feature). Distribution tarballs (built by setup.py sdist) and build\n# directories (produced by setup.py build) will contain a much shorter file\n# that just contains the computed version number.\n\n# This file is released into the public domain. Generated by\n# versioneer-0.22 (https://github.com/python-versioneer/python-versioneer)\n\n\"\"\"Git implementation of _version.py.\"\"\"\n\nimport errno\nimport functools\nimport os\nimport re\nimport subprocess\nimport sys\nfrom typing import Callable, Dict\n\n\ndef get_keywords():\n    \"\"\"Get the keywords needed to look up the version information.\"\"\"\n    # these strings will be replaced by git during git-archive.\n    # setup.py/versioneer.py will grep for the variable names, so they must\n    # each be defined on a line of their own. _version.py will just call\n    # get_keywords().\n    git_refnames = \"$Format:%d$\"\n    git_full = \"$Format:%H$\"\n    git_date = \"$Format:%ci$\"\n    keywords = {\"refnames\": git_refnames, \"full\": git_full, \"date\": git_date}\n    return keywords\n\n\nclass VersioneerConfig:\n    \"\"\"Container for Versioneer configuration parameters.\"\"\"\n\n\ndef get_config():\n    \"\"\"Create, populate and return the VersioneerConfig() object.\"\"\"\n    # these strings are filled in when 'setup.py versioneer' creates\n    # _version.py\n    cfg = VersioneerConfig()\n    cfg.VCS = \"git\"\n    cfg.style = \"pep440\"\n    cfg.tag_prefix = \"\"\n    cfg.parentdir_prefix = \"None\"\n    cfg.versionfile_source = \"src/prestoplot/_version.py\"\n    cfg.verbose = False\n    return cfg\n\n\nclass NotThisMethod(Exception):\n    \"\"\"Exception raised if a method is not valid for the current scenario.\"\"\"\n\n\nLONG_VERSION_PY: Dict[str, str] = {}\nHANDLERS: Dict[str, Dict[str, Callable]] = {}\n\n\ndef register_vcs_handler(vcs, method):  # decorator\n    \"\"\"Create decorator to mark a method as the handler of a VCS.\"\"\"\n\n    def decorate(f):\n        \"\"\"Store f in HANDLERS[vcs][method].\"\"\"\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n\n    return decorate\n\n\ndef run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):\n    \"\"\"Call the given command(s).\"\"\"\n    assert isinstance(commands, list)\n    process = None\n\n    popen_kwargs = {}\n    if sys.platform == \"win32\":\n        # This hides the console window if pythonw.exe is used\n        startupinfo = subprocess.STARTUPINFO()\n        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n        popen_kwargs[\"startupinfo\"] = startupinfo\n\n    for command in commands:\n        try:\n            dispcmd = str([command] + args)\n            # remember shell=False, so use git.cmd on windows, not just git\n            process = subprocess.Popen(\n                [command] + args,\n                cwd=cwd,\n                env=env,\n                stdout=subprocess.PIPE,\n                stderr=(subprocess.PIPE if hide_stderr else None),\n                **popen_kwargs\n            )\n            break\n        except OSError:\n            e = sys.exc_info()[1]\n            if e.errno == errno.ENOENT:\n                continue\n            if verbose:\n                print(\"unable to run %s\" % dispcmd)\n                print(e)\n            return None, None\n    else:\n        if verbose:\n            print(\"unable to find command, tried %s\" % (commands,))\n        return None, None\n    stdout = process.communicate()[0].strip().decode()\n    if process.returncode != 0:\n        if verbose:\n            print(\"unable to run %s (error)\" % dispcmd)\n            print(\"stdout was %s\" % stdout)\n        return None, process.returncode\n    return stdout, process.returncode\n\n\ndef versions_from_parentdir(parentdir_prefix, root, verbose):\n    \"\"\"Try to determine the version from the parent directory name.\n\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    \"\"\"\n    rootdirs = []\n\n    for _ in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {\n                \"version\": dirname[len(parentdir_prefix) :],\n                \"full-revisionid\": None,\n                \"dirty\": False,\n                \"error\": None,\n                \"date\": None,\n            }\n        rootdirs.append(root)\n        root = os.path.dirname(root)  # up a level\n\n    if verbose:\n        print(\n            \"Tried directories %s but none started with prefix %s\"\n            % (str(rootdirs), parentdir_prefix)\n        )\n    raise NotThisMethod(\"rootdir doesn't start with parentdir_prefix\")\n\n\n@register_vcs_handler(\"git\", \"get_keywords\")\ndef git_get_keywords(versionfile_abs):\n    \"\"\"Extract version information from the given file.\"\"\"\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don't want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        with open(versionfile_abs, \"r\") as fobj:\n            for line in fobj:\n                if line.strip().startswith(\"git_refnames =\"):\n                    mo = re.search(r'=\\s*\"(.*)\"', line)\n                    if mo:\n                        keywords[\"refnames\"] = mo.group(1)\n                if line.strip().startswith(\"git_full =\"):\n                    mo = re.search(r'=\\s*\"(.*)\"', line)\n                    if mo:\n                        keywords[\"full\"] = mo.group(1)\n                if line.strip().startswith(\"git_date =\"):\n                    mo = re.search(r'=\\s*\"(.*)\"', line)\n                    if mo:\n                        keywords[\"date\"] = mo.group(1)\n    except OSError:\n        pass\n    return keywords\n\n\n@register_vcs_handler(\"git\", \"keywords\")\ndef git_versions_from_keywords(keywords, tag_prefix, verbose):\n    \"\"\"Get version information from git keywords.\"\"\"\n    if \"refnames\" not in keywords:\n        raise NotThisMethod(\"Short version file found\")\n    date = keywords.get(\"date\")\n    if date is not None:\n        # Use only the last line.  Previous lines may contain GPG signature\n        # information.\n        date = date.splitlines()[-1]\n\n        # git-2.2.0 added \"%cI\", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer \"%ci\" (which expands to an \"ISO-8601\n        # -like\" string, which we must then edit to make compliant), because\n        # it's been around since git-1.5.3, and it's too difficult to\n        # discover which version we're using, or to work around using an\n        # older one.\n        date = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n    refnames = keywords[\"refnames\"].strip()\n    if refnames.startswith(\"$Format\"):\n        if verbose:\n            print(\"keywords are unexpanded, not using\")\n        raise NotThisMethod(\"unexpanded keywords, not a git-archive tarball\")\n    refs = {r.strip() for r in refnames.strip(\"()\").split(\",\")}\n    # starting in git-1.8.3, tags are listed as \"tag: foo-1.0\" instead of\n    # just \"foo-1.0\". If we see a \"tag: \" prefix, prefer those.\n    TAG = \"tag: \"\n    tags = {r[len(TAG) :] for r in refs if r.startswith(TAG)}\n    if not tags:\n        # Either we're using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like \"release\" and\n        # \"stabilization\", as well as \"HEAD\" and \"master\".\n        tags = {r for r in refs if re.search(r\"\\d\", r)}\n        if verbose:\n            print(\"discarding '%s', no digits\" % \",\".join(refs - tags))\n    if verbose:\n        print(\"likely tags: %s\" % \",\".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. \"2.0\" over \"2.0rc1\"\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix) :]\n            # Filter out refs that exactly match prefix or that don't start\n            # with a number once the prefix is stripped (mostly a concern\n            # when prefix is '')\n            if not re.match(r\"\\d\", r):\n                continue\n            if verbose:\n                print(\"picking %s\" % r)\n            return {\n                \"version\": r,\n                \"full-revisionid\": keywords[\"full\"].strip(),\n                \"dirty\": False,\n                \"error\": None,\n                \"date\": date,\n            }\n    # no suitable tags, so version is \"0+unknown\", but full hex is still there\n    if verbose:\n        print(\"no suitable tags, using unknown + full revision id\")\n    return {\n        \"version\": \"0+unknown\",\n        \"full-revisionid\": keywords[\"full\"].strip(),\n        \"dirty\": False,\n        \"error\": \"no suitable tags\",\n        \"date\": None,\n    }\n\n\n@register_vcs_handler(\"git\", \"pieces_from_vcs\")\ndef git_pieces_from_vcs(tag_prefix, root, verbose, runner=run_command):\n    \"\"\"Get version from 'git describe' in the root of the source tree.\n\n    This only gets called if the git-archive 'subst' keywords were *not*\n    expanded, and _version.py hasn't already been rewritten with a short\n    version string, meaning we're inside a checked out source tree.\n    \"\"\"\n    GITS = [\"git\"]\n    if sys.platform == \"win32\":\n        GITS = [\"git.cmd\", \"git.exe\"]\n\n    # GIT_DIR can interfere with correct operation of Versioneer.\n    # It may be intended to be passed to the Versioneer-versioned project,\n    # but that should not change where we get our version from.\n    env = os.environ.copy()\n    env.pop(\"GIT_DIR\", None)\n    runner = functools.partial(runner, env=env)\n\n    _, rc = runner(GITS, [\"rev-parse\", \"--git-dir\"], cwd=root, hide_stderr=True)\n    if rc != 0:\n        if verbose:\n            print(\"Directory %s not under git control\" % root)\n        raise NotThisMethod(\"'git rev-parse --git-dir' returned error\")\n\n    MATCH_ARGS = [\"--match\", \"%s*\" % tag_prefix] if tag_prefix else []\n\n    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]\n    # if there isn't one, this yields HEX[-dirty] (no NUM)\n    describe_out, rc = runner(\n        GITS,\n        [\"describe\", \"--tags\", \"--dirty\", \"--always\", \"--long\", *MATCH_ARGS],\n        cwd=root,\n    )\n    # --long was added in git-1.5.5\n    if describe_out is None:\n        raise NotThisMethod(\"'git describe' failed\")\n    describe_out = describe_out.strip()\n    full_out, rc = runner(GITS, [\"rev-parse\", \"HEAD\"], cwd=root)\n    if full_out is None:\n        raise NotThisMethod(\"'git rev-parse' failed\")\n    full_out = full_out.strip()\n\n    pieces = {}\n    pieces[\"long\"] = full_out\n    pieces[\"short\"] = full_out[:7]  # maybe improved later\n    pieces[\"error\"] = None\n\n    branch_name, rc = runner(GITS, [\"rev-parse\", \"--abbrev-ref\", \"HEAD\"], cwd=root)\n    # --abbrev-ref was added in git-1.6.3\n    if rc != 0 or branch_name is None:\n        raise NotThisMethod(\"'git rev-parse --abbrev-ref' returned error\")\n    branch_name = branch_name.strip()\n\n    if branch_name == \"HEAD\":\n        # If we aren't exactly on a branch, pick a branch which represents\n        # the current commit. If all else fails, we are on a branchless\n        # commit.\n        branches, rc = runner(GITS, [\"branch\", \"--contains\"], cwd=root)\n        # --contains was added in git-1.5.4\n        if rc != 0 or branches is None:\n            raise NotThisMethod(\"'git branch --contains' returned error\")\n        branches = branches.split(\"\\n\")\n\n        # Remove the first line if we're running detached\n        if \"(\" in branches[0]:\n            branches.pop(0)\n\n        # Strip off the leading \"* \" from the list of branches.\n        branches = [branch[2:] for branch in branches]\n        if \"master\" in branches:\n            branch_name = \"master\"\n        elif not branches:\n            branch_name = None\n        else:\n            # Pick the first branch that is returned. Good or bad.\n            branch_name = branches[0]\n\n    pieces[\"branch\"] = branch_name\n\n    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]\n    # TAG might have hyphens.\n    git_describe = describe_out\n\n    # look for -dirty suffix\n    dirty = git_describe.endswith(\"-dirty\")\n    pieces[\"dirty\"] = dirty\n    if dirty:\n        git_describe = git_describe[: git_describe.rindex(\"-dirty\")]\n\n    # now we have TAG-NUM-gHEX or HEX\n\n    if \"-\" in git_describe:\n        # TAG-NUM-gHEX\n        mo = re.search(r\"^(.+)-(\\d+)-g([0-9a-f]+)$\", git_describe)\n        if not mo:\n            # unparsable. Maybe git-describe is misbehaving?\n            pieces[\"error\"] = \"unable to parse git-describe output: '%s'\" % describe_out\n            return pieces\n\n        # tag\n        full_tag = mo.group(1)\n        if not full_tag.startswith(tag_prefix):\n            if verbose:\n                fmt = \"tag '%s' doesn't start with prefix '%s'\"\n                print(fmt % (full_tag, tag_prefix))\n            pieces[\"error\"] = \"tag '%s' doesn't start with prefix '%s'\" % (\n                full_tag,\n                tag_prefix,\n            )\n            return pieces\n        pieces[\"closest-tag\"] = full_tag[len(tag_prefix) :]\n\n        # distance: number of commits since tag\n        pieces[\"distance\"] = int(mo.group(2))\n\n        # commit: short hex revision ID\n        pieces[\"short\"] = mo.group(3)\n\n    else:\n        # HEX: no tags\n        pieces[\"closest-tag\"] = None\n        count_out, rc = runner(GITS, [\"rev-list\", \"HEAD\", \"--count\"], cwd=root)\n        pieces[\"distance\"] = int(count_out)  # total number of commits\n\n    # commit date: see ISO-8601 comment in git_versions_from_keywords()\n    date = runner(GITS, [\"show\", \"-s\", \"--format=%ci\", \"HEAD\"], cwd=root)[0].strip()\n    # Use only the last line.  Previous lines may contain GPG signature\n    # information.\n    date = date.splitlines()[-1]\n    pieces[\"date\"] = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n\n    return pieces\n\n\ndef plus_or_dot(pieces):\n    \"\"\"Return a + if we don't already have one, else return a .\"\"\"\n    if \"+\" in pieces.get(\"closest-tag\", \"\"):\n        return \".\"\n    return \"+\"\n\n\ndef render_pep440(pieces):\n    \"\"\"Build up version string, with post-release \"local version identifier\".\n\n    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty\n\n    Exceptions:\n    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += plus_or_dot(pieces)\n            rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0+untagged.%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n\n\ndef render_pep440_branch(pieces):\n    \"\"\"TAG[[.dev0]+DISTANCE.gHEX[.dirty]] .\n\n    The \".dev0\" means not master branch. Note that .dev0 sorts backwards\n    (a feature branch will appear \"older\" than the master branch).\n\n    Exceptions:\n    1: no tags. 0[.dev0]+untagged.DISTANCE.gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            if pieces[\"branch\"] != \"master\":\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0\"\n        if pieces[\"branch\"] != \"master\":\n            rendered += \".dev0\"\n        rendered += \"+untagged.%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n\n\ndef pep440_split_post(ver):\n    \"\"\"Split pep440 version string at the post-release segment.\n\n    Returns the release segments before the post-release and the\n    post-release version number (or -1 if no post-release segment is present).\n    \"\"\"\n    vc = str.split(ver, \".post\")\n    return vc[0], int(vc[1] or 0) if len(vc) == 2 else None\n\n\ndef render_pep440_pre(pieces):\n    \"\"\"TAG[.postN.devDISTANCE] -- No -dirty.\n\n    Exceptions:\n    1: no tags. 0.post0.devDISTANCE\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        if pieces[\"distance\"]:\n            # update the post release segment\n            tag_version, post_version = pep440_split_post(pieces[\"closest-tag\"])\n            rendered = tag_version\n            if post_version is not None:\n                rendered += \".post%d.dev%d\" % (post_version + 1, pieces[\"distance\"])\n            else:\n                rendered += \".post0.dev%d\" % (pieces[\"distance\"])\n        else:\n            # no commits, use the tag as the version\n            rendered = pieces[\"closest-tag\"]\n    else:\n        # exception #1\n        rendered = \"0.post0.dev%d\" % pieces[\"distance\"]\n    return rendered\n\n\ndef render_pep440_post(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]+gHEX] .\n\n    The \".dev0\" means dirty. Note that .dev0 sorts backwards\n    (a dirty tree will appear \"older\" than the corresponding clean one),\n    but you shouldn't be releasing software with -dirty anyways.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%d\" % pieces[\"distance\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"g%s\" % pieces[\"short\"]\n    else:\n        # exception #1\n        rendered = \"0.post%d\" % pieces[\"distance\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dev0\"\n        rendered += \"+g%s\" % pieces[\"short\"]\n    return rendered\n\n\ndef render_pep440_post_branch(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]+gHEX[.dirty]] .\n\n    The \".dev0\" means not master branch.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]+gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%d\" % pieces[\"distance\"]\n            if pieces[\"branch\"] != \"master\":\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"g%s\" % pieces[\"short\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0.post%d\" % pieces[\"distance\"]\n        if pieces[\"branch\"] != \"master\":\n            rendered += \".dev0\"\n        rendered += \"+g%s\" % pieces[\"short\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n\n\ndef render_pep440_old(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]] .\n\n    The \".dev0\" means dirty.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%d\" % pieces[\"distance\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dev0\"\n    else:\n        # exception #1\n        rendered = \"0.post%d\" % pieces[\"distance\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dev0\"\n    return rendered\n\n\ndef render_git_describe(pieces):\n    \"\"\"TAG[-DISTANCE-gHEX][-dirty].\n\n    Like 'git describe --tags --dirty --always'.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"]:\n            rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n    else:\n        # exception #1\n        rendered = pieces[\"short\"]\n    if pieces[\"dirty\"]:\n        rendered += \"-dirty\"\n    return rendered\n\n\ndef render_git_describe_long(pieces):\n    \"\"\"TAG-DISTANCE-gHEX[-dirty].\n\n    Like 'git describe --tags --dirty --always -long'.\n    The distance/hash is unconditional.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n    else:\n        # exception #1\n        rendered = pieces[\"short\"]\n    if pieces[\"dirty\"]:\n        rendered += \"-dirty\"\n    return rendered\n\n", "contexts_below": "\n def get_versions():\n     \"\"\"Get version information or return default if unable to do so.\"\"\"\n     # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have\n     # __file__, we can work backwards from there to the root. Some\n     # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which\n     # case we can only use expanded keywords.\n \n     cfg = get_config()\n     verbose = cfg.verbose\n \n     try:\n         return git_versions_from_keywords(get_keywords(), cfg.tag_prefix, verbose)\n     except NotThisMethod:\n         pass\n \n     try:\n         root = os.path.realpath(__file__)\n         # versionfile_source is the relative path from the top of the source\n         # tree (where the .git directory might live) to this file. Invert\n         # this to find the root from __file__.\n         for _ in cfg.versionfile_source.split(\"/\"):\n             root = os.path.dirname(root)\n     except NameError:\n         return {\n             \"version\": \"0+unknown\",\n             \"full-revisionid\": None,\n             \"dirty\": None,\n             \"error\": \"unable to find root of source tree\",\n             \"date\": None,\n         }\n \n     try:\n         pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)\n         return render(pieces, cfg.style)\n     except NotThisMethod:\n         pass\n \n     try:\n         if cfg.parentdir_prefix:\n             return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n     except NotThisMethod:\n         pass\n \n     return {\n         \"version\": \"0+unknown\",\n         \"full-revisionid\": None,\n         \"dirty\": None,\n         \"error\": \"unable to compute version\",\n         \"date\": None,\n     }\n ", "input_code": "def render(pieces, style):\n\"\"\"\nRender the given version pieces into the requested style.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def render(pieces, style):\n    \"\"\"Render the given version pieces into the requested style.\"\"\"\n    if pieces[\"error\"]:\n        return {\n            \"version\": \"unknown\",\n            \"full-revisionid\": pieces.get(\"long\"),\n            \"dirty\": None,\n            \"error\": pieces[\"error\"],\n            \"date\": None,\n        }\n\n    if not style or style == \"default\":\n        style = \"pep440\"  # the default\n\n    if style == \"pep440\":\n        rendered = render_pep440(pieces)\n    elif style == \"pep440-branch\":\n        rendered = render_pep440_branch(pieces)\n    elif style == \"pep440-pre\":\n        rendered = render_pep440_pre(pieces)\n    elif style == \"pep440-post\":\n        rendered = render_pep440_post(pieces)\n    elif style == \"pep440-post-branch\":\n        rendered = render_pep440_post_branch(pieces)\n    elif style == \"pep440-old\":\n        rendered = render_pep440_old(pieces)\n    elif style == \"git-describe\":\n        rendered = render_git_describe(pieces)\n    elif style == \"git-describe-long\":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(\"unknown style '%s'\" % style)\n\n    return {\n        \"version\": rendered,\n        \"full-revisionid\": pieces[\"long\"],\n        \"dirty\": pieces[\"dirty\"],\n        \"error\": None,\n        \"date\": pieces.get(\"date\"),\n    }", "signature": "def render(pieces, style):", "completion_path": "src/prestoplot/_version.py"}
{"ce_id": "62b87d24d292efb640a5566d", "namespace": "62b87d24d292efb640a5566d", "namespace_real": "src.prestoplot._version.plus_or_dot", "real_proj_path": "eykd---prestoplot/", "type": "function", "class_name": null, "function_name": "plus_or_dot", "contexts_above": "# This file helps to compute a version number in source trees obtained from\n# git-archive tarball (such as those provided by githubs download-from-tag\n# feature). Distribution tarballs (built by setup.py sdist) and build\n# directories (produced by setup.py build) will contain a much shorter file\n# that just contains the computed version number.\n\n# This file is released into the public domain. Generated by\n# versioneer-0.22 (https://github.com/python-versioneer/python-versioneer)\n\n\"\"\"Git implementation of _version.py.\"\"\"\n\nimport errno\nimport functools\nimport os\nimport re\nimport subprocess\nimport sys\nfrom typing import Callable, Dict\n\n\ndef get_keywords():\n    \"\"\"Get the keywords needed to look up the version information.\"\"\"\n    # these strings will be replaced by git during git-archive.\n    # setup.py/versioneer.py will grep for the variable names, so they must\n    # each be defined on a line of their own. _version.py will just call\n    # get_keywords().\n    git_refnames = \"$Format:%d$\"\n    git_full = \"$Format:%H$\"\n    git_date = \"$Format:%ci$\"\n    keywords = {\"refnames\": git_refnames, \"full\": git_full, \"date\": git_date}\n    return keywords\n\n\nclass VersioneerConfig:\n    \"\"\"Container for Versioneer configuration parameters.\"\"\"\n\n\ndef get_config():\n    \"\"\"Create, populate and return the VersioneerConfig() object.\"\"\"\n    # these strings are filled in when 'setup.py versioneer' creates\n    # _version.py\n    cfg = VersioneerConfig()\n    cfg.VCS = \"git\"\n    cfg.style = \"pep440\"\n    cfg.tag_prefix = \"\"\n    cfg.parentdir_prefix = \"None\"\n    cfg.versionfile_source = \"src/prestoplot/_version.py\"\n    cfg.verbose = False\n    return cfg\n\n\nclass NotThisMethod(Exception):\n    \"\"\"Exception raised if a method is not valid for the current scenario.\"\"\"\n\n\nLONG_VERSION_PY: Dict[str, str] = {}\nHANDLERS: Dict[str, Dict[str, Callable]] = {}\n\n\ndef register_vcs_handler(vcs, method):  # decorator\n    \"\"\"Create decorator to mark a method as the handler of a VCS.\"\"\"\n\n    def decorate(f):\n        \"\"\"Store f in HANDLERS[vcs][method].\"\"\"\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n\n    return decorate\n\n\ndef run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):\n    \"\"\"Call the given command(s).\"\"\"\n    assert isinstance(commands, list)\n    process = None\n\n    popen_kwargs = {}\n    if sys.platform == \"win32\":\n        # This hides the console window if pythonw.exe is used\n        startupinfo = subprocess.STARTUPINFO()\n        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n        popen_kwargs[\"startupinfo\"] = startupinfo\n\n    for command in commands:\n        try:\n            dispcmd = str([command] + args)\n            # remember shell=False, so use git.cmd on windows, not just git\n            process = subprocess.Popen(\n                [command] + args,\n                cwd=cwd,\n                env=env,\n                stdout=subprocess.PIPE,\n                stderr=(subprocess.PIPE if hide_stderr else None),\n                **popen_kwargs\n            )\n            break\n        except OSError:\n            e = sys.exc_info()[1]\n            if e.errno == errno.ENOENT:\n                continue\n            if verbose:\n                print(\"unable to run %s\" % dispcmd)\n                print(e)\n            return None, None\n    else:\n        if verbose:\n            print(\"unable to find command, tried %s\" % (commands,))\n        return None, None\n    stdout = process.communicate()[0].strip().decode()\n    if process.returncode != 0:\n        if verbose:\n            print(\"unable to run %s (error)\" % dispcmd)\n            print(\"stdout was %s\" % stdout)\n        return None, process.returncode\n    return stdout, process.returncode\n\n\ndef versions_from_parentdir(parentdir_prefix, root, verbose):\n    \"\"\"Try to determine the version from the parent directory name.\n\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    \"\"\"\n    rootdirs = []\n\n    for _ in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {\n                \"version\": dirname[len(parentdir_prefix) :],\n                \"full-revisionid\": None,\n                \"dirty\": False,\n                \"error\": None,\n                \"date\": None,\n            }\n        rootdirs.append(root)\n        root = os.path.dirname(root)  # up a level\n\n    if verbose:\n        print(\n            \"Tried directories %s but none started with prefix %s\"\n            % (str(rootdirs), parentdir_prefix)\n        )\n    raise NotThisMethod(\"rootdir doesn't start with parentdir_prefix\")\n\n\n@register_vcs_handler(\"git\", \"get_keywords\")\ndef git_get_keywords(versionfile_abs):\n    \"\"\"Extract version information from the given file.\"\"\"\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don't want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        with open(versionfile_abs, \"r\") as fobj:\n            for line in fobj:\n                if line.strip().startswith(\"git_refnames =\"):\n                    mo = re.search(r'=\\s*\"(.*)\"', line)\n                    if mo:\n                        keywords[\"refnames\"] = mo.group(1)\n                if line.strip().startswith(\"git_full =\"):\n                    mo = re.search(r'=\\s*\"(.*)\"', line)\n                    if mo:\n                        keywords[\"full\"] = mo.group(1)\n                if line.strip().startswith(\"git_date =\"):\n                    mo = re.search(r'=\\s*\"(.*)\"', line)\n                    if mo:\n                        keywords[\"date\"] = mo.group(1)\n    except OSError:\n        pass\n    return keywords\n\n\n@register_vcs_handler(\"git\", \"keywords\")\ndef git_versions_from_keywords(keywords, tag_prefix, verbose):\n    \"\"\"Get version information from git keywords.\"\"\"\n    if \"refnames\" not in keywords:\n        raise NotThisMethod(\"Short version file found\")\n    date = keywords.get(\"date\")\n    if date is not None:\n        # Use only the last line.  Previous lines may contain GPG signature\n        # information.\n        date = date.splitlines()[-1]\n\n        # git-2.2.0 added \"%cI\", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer \"%ci\" (which expands to an \"ISO-8601\n        # -like\" string, which we must then edit to make compliant), because\n        # it's been around since git-1.5.3, and it's too difficult to\n        # discover which version we're using, or to work around using an\n        # older one.\n        date = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n    refnames = keywords[\"refnames\"].strip()\n    if refnames.startswith(\"$Format\"):\n        if verbose:\n            print(\"keywords are unexpanded, not using\")\n        raise NotThisMethod(\"unexpanded keywords, not a git-archive tarball\")\n    refs = {r.strip() for r in refnames.strip(\"()\").split(\",\")}\n    # starting in git-1.8.3, tags are listed as \"tag: foo-1.0\" instead of\n    # just \"foo-1.0\". If we see a \"tag: \" prefix, prefer those.\n    TAG = \"tag: \"\n    tags = {r[len(TAG) :] for r in refs if r.startswith(TAG)}\n    if not tags:\n        # Either we're using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like \"release\" and\n        # \"stabilization\", as well as \"HEAD\" and \"master\".\n        tags = {r for r in refs if re.search(r\"\\d\", r)}\n        if verbose:\n            print(\"discarding '%s', no digits\" % \",\".join(refs - tags))\n    if verbose:\n        print(\"likely tags: %s\" % \",\".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. \"2.0\" over \"2.0rc1\"\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix) :]\n            # Filter out refs that exactly match prefix or that don't start\n            # with a number once the prefix is stripped (mostly a concern\n            # when prefix is '')\n            if not re.match(r\"\\d\", r):\n                continue\n            if verbose:\n                print(\"picking %s\" % r)\n            return {\n                \"version\": r,\n                \"full-revisionid\": keywords[\"full\"].strip(),\n                \"dirty\": False,\n                \"error\": None,\n                \"date\": date,\n            }\n    # no suitable tags, so version is \"0+unknown\", but full hex is still there\n    if verbose:\n        print(\"no suitable tags, using unknown + full revision id\")\n    return {\n        \"version\": \"0+unknown\",\n        \"full-revisionid\": keywords[\"full\"].strip(),\n        \"dirty\": False,\n        \"error\": \"no suitable tags\",\n        \"date\": None,\n    }\n\n\n@register_vcs_handler(\"git\", \"pieces_from_vcs\")\ndef git_pieces_from_vcs(tag_prefix, root, verbose, runner=run_command):\n    \"\"\"Get version from 'git describe' in the root of the source tree.\n\n    This only gets called if the git-archive 'subst' keywords were *not*\n    expanded, and _version.py hasn't already been rewritten with a short\n    version string, meaning we're inside a checked out source tree.\n    \"\"\"\n    GITS = [\"git\"]\n    if sys.platform == \"win32\":\n        GITS = [\"git.cmd\", \"git.exe\"]\n\n    # GIT_DIR can interfere with correct operation of Versioneer.\n    # It may be intended to be passed to the Versioneer-versioned project,\n    # but that should not change where we get our version from.\n    env = os.environ.copy()\n    env.pop(\"GIT_DIR\", None)\n    runner = functools.partial(runner, env=env)\n\n    _, rc = runner(GITS, [\"rev-parse\", \"--git-dir\"], cwd=root, hide_stderr=True)\n    if rc != 0:\n        if verbose:\n            print(\"Directory %s not under git control\" % root)\n        raise NotThisMethod(\"'git rev-parse --git-dir' returned error\")\n\n    MATCH_ARGS = [\"--match\", \"%s*\" % tag_prefix] if tag_prefix else []\n\n    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]\n    # if there isn't one, this yields HEX[-dirty] (no NUM)\n    describe_out, rc = runner(\n        GITS,\n        [\"describe\", \"--tags\", \"--dirty\", \"--always\", \"--long\", *MATCH_ARGS],\n        cwd=root,\n    )\n    # --long was added in git-1.5.5\n    if describe_out is None:\n        raise NotThisMethod(\"'git describe' failed\")\n    describe_out = describe_out.strip()\n    full_out, rc = runner(GITS, [\"rev-parse\", \"HEAD\"], cwd=root)\n    if full_out is None:\n        raise NotThisMethod(\"'git rev-parse' failed\")\n    full_out = full_out.strip()\n\n    pieces = {}\n    pieces[\"long\"] = full_out\n    pieces[\"short\"] = full_out[:7]  # maybe improved later\n    pieces[\"error\"] = None\n\n    branch_name, rc = runner(GITS, [\"rev-parse\", \"--abbrev-ref\", \"HEAD\"], cwd=root)\n    # --abbrev-ref was added in git-1.6.3\n    if rc != 0 or branch_name is None:\n        raise NotThisMethod(\"'git rev-parse --abbrev-ref' returned error\")\n    branch_name = branch_name.strip()\n\n    if branch_name == \"HEAD\":\n        # If we aren't exactly on a branch, pick a branch which represents\n        # the current commit. If all else fails, we are on a branchless\n        # commit.\n        branches, rc = runner(GITS, [\"branch\", \"--contains\"], cwd=root)\n        # --contains was added in git-1.5.4\n        if rc != 0 or branches is None:\n            raise NotThisMethod(\"'git branch --contains' returned error\")\n        branches = branches.split(\"\\n\")\n\n        # Remove the first line if we're running detached\n        if \"(\" in branches[0]:\n            branches.pop(0)\n\n        # Strip off the leading \"* \" from the list of branches.\n        branches = [branch[2:] for branch in branches]\n        if \"master\" in branches:\n            branch_name = \"master\"\n        elif not branches:\n            branch_name = None\n        else:\n            # Pick the first branch that is returned. Good or bad.\n            branch_name = branches[0]\n\n    pieces[\"branch\"] = branch_name\n\n    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]\n    # TAG might have hyphens.\n    git_describe = describe_out\n\n    # look for -dirty suffix\n    dirty = git_describe.endswith(\"-dirty\")\n    pieces[\"dirty\"] = dirty\n    if dirty:\n        git_describe = git_describe[: git_describe.rindex(\"-dirty\")]\n\n    # now we have TAG-NUM-gHEX or HEX\n\n    if \"-\" in git_describe:\n        # TAG-NUM-gHEX\n        mo = re.search(r\"^(.+)-(\\d+)-g([0-9a-f]+)$\", git_describe)\n        if not mo:\n            # unparsable. Maybe git-describe is misbehaving?\n            pieces[\"error\"] = \"unable to parse git-describe output: '%s'\" % describe_out\n            return pieces\n\n        # tag\n        full_tag = mo.group(1)\n        if not full_tag.startswith(tag_prefix):\n            if verbose:\n                fmt = \"tag '%s' doesn't start with prefix '%s'\"\n                print(fmt % (full_tag, tag_prefix))\n            pieces[\"error\"] = \"tag '%s' doesn't start with prefix '%s'\" % (\n                full_tag,\n                tag_prefix,\n            )\n            return pieces\n        pieces[\"closest-tag\"] = full_tag[len(tag_prefix) :]\n\n        # distance: number of commits since tag\n        pieces[\"distance\"] = int(mo.group(2))\n\n        # commit: short hex revision ID\n        pieces[\"short\"] = mo.group(3)\n\n    else:\n        # HEX: no tags\n        pieces[\"closest-tag\"] = None\n        count_out, rc = runner(GITS, [\"rev-list\", \"HEAD\", \"--count\"], cwd=root)\n        pieces[\"distance\"] = int(count_out)  # total number of commits\n\n    # commit date: see ISO-8601 comment in git_versions_from_keywords()\n    date = runner(GITS, [\"show\", \"-s\", \"--format=%ci\", \"HEAD\"], cwd=root)[0].strip()\n    # Use only the last line.  Previous lines may contain GPG signature\n    # information.\n    date = date.splitlines()[-1]\n    pieces[\"date\"] = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n\n    return pieces\n\n", "contexts_below": "\n def render_pep440(pieces):\n     \"\"\"Build up version string, with post-release \"local version identifier\".\n \n     Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n     get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty\n \n     Exceptions:\n     1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += plus_or_dot(pieces)\n             rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n             if pieces[\"dirty\"]:\n                 rendered += \".dirty\"\n     else:\n         # exception #1\n         rendered = \"0+untagged.%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n         if pieces[\"dirty\"]:\n             rendered += \".dirty\"\n     return rendered\n \n \n def render_pep440_branch(pieces):\n     \"\"\"TAG[[.dev0]+DISTANCE.gHEX[.dirty]] .\n \n     The \".dev0\" means not master branch. Note that .dev0 sorts backwards\n     (a feature branch will appear \"older\" than the master branch).\n \n     Exceptions:\n     1: no tags. 0[.dev0]+untagged.DISTANCE.gHEX[.dirty]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             if pieces[\"branch\"] != \"master\":\n                 rendered += \".dev0\"\n             rendered += plus_or_dot(pieces)\n             rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n             if pieces[\"dirty\"]:\n                 rendered += \".dirty\"\n     else:\n         # exception #1\n         rendered = \"0\"\n         if pieces[\"branch\"] != \"master\":\n             rendered += \".dev0\"\n         rendered += \"+untagged.%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n         if pieces[\"dirty\"]:\n             rendered += \".dirty\"\n     return rendered\n \n \n def pep440_split_post(ver):\n     \"\"\"Split pep440 version string at the post-release segment.\n \n     Returns the release segments before the post-release and the\n     post-release version number (or -1 if no post-release segment is present).\n     \"\"\"\n     vc = str.split(ver, \".post\")\n     return vc[0], int(vc[1] or 0) if len(vc) == 2 else None\n \n \n def render_pep440_pre(pieces):\n     \"\"\"TAG[.postN.devDISTANCE] -- No -dirty.\n \n     Exceptions:\n     1: no tags. 0.post0.devDISTANCE\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         if pieces[\"distance\"]:\n             # update the post release segment\n             tag_version, post_version = pep440_split_post(pieces[\"closest-tag\"])\n             rendered = tag_version\n             if post_version is not None:\n                 rendered += \".post%d.dev%d\" % (post_version + 1, pieces[\"distance\"])\n             else:\n                 rendered += \".post0.dev%d\" % (pieces[\"distance\"])\n         else:\n             # no commits, use the tag as the version\n             rendered = pieces[\"closest-tag\"]\n     else:\n         # exception #1\n         rendered = \"0.post0.dev%d\" % pieces[\"distance\"]\n     return rendered\n \n \n def render_pep440_post(pieces):\n     \"\"\"TAG[.postDISTANCE[.dev0]+gHEX] .\n \n     The \".dev0\" means dirty. Note that .dev0 sorts backwards\n     (a dirty tree will appear \"older\" than the corresponding clean one),\n     but you shouldn't be releasing software with -dirty anyways.\n \n     Exceptions:\n     1: no tags. 0.postDISTANCE[.dev0]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += \".post%d\" % pieces[\"distance\"]\n             if pieces[\"dirty\"]:\n                 rendered += \".dev0\"\n             rendered += plus_or_dot(pieces)\n             rendered += \"g%s\" % pieces[\"short\"]\n     else:\n         # exception #1\n         rendered = \"0.post%d\" % pieces[\"distance\"]\n         if pieces[\"dirty\"]:\n             rendered += \".dev0\"\n         rendered += \"+g%s\" % pieces[\"short\"]\n     return rendered\n \n \n def render_pep440_post_branch(pieces):\n     \"\"\"TAG[.postDISTANCE[.dev0]+gHEX[.dirty]] .\n \n     The \".dev0\" means not master branch.\n \n     Exceptions:\n     1: no tags. 0.postDISTANCE[.dev0]+gHEX[.dirty]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += \".post%d\" % pieces[\"distance\"]\n             if pieces[\"branch\"] != \"master\":\n                 rendered += \".dev0\"\n             rendered += plus_or_dot(pieces)\n             rendered += \"g%s\" % pieces[\"short\"]\n             if pieces[\"dirty\"]:\n                 rendered += \".dirty\"\n     else:\n         # exception #1\n         rendered = \"0.post%d\" % pieces[\"distance\"]\n         if pieces[\"branch\"] != \"master\":\n             rendered += \".dev0\"\n         rendered += \"+g%s\" % pieces[\"short\"]\n         if pieces[\"dirty\"]:\n             rendered += \".dirty\"\n     return rendered\n \n \n def render_pep440_old(pieces):\n     \"\"\"TAG[.postDISTANCE[.dev0]] .\n \n     The \".dev0\" means dirty.\n \n     Exceptions:\n     1: no tags. 0.postDISTANCE[.dev0]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += \".post%d\" % pieces[\"distance\"]\n             if pieces[\"dirty\"]:\n                 rendered += \".dev0\"\n     else:\n         # exception #1\n         rendered = \"0.post%d\" % pieces[\"distance\"]\n         if pieces[\"dirty\"]:\n             rendered += \".dev0\"\n     return rendered\n \n \n def render_git_describe(pieces):\n     \"\"\"TAG[-DISTANCE-gHEX][-dirty].\n \n     Like 'git describe --tags --dirty --always'.\n \n     Exceptions:\n     1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"]:\n             rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n     else:\n         # exception #1\n         rendered = pieces[\"short\"]\n     if pieces[\"dirty\"]:\n         rendered += \"-dirty\"\n     return rendered\n \n \n def render_git_describe_long(pieces):\n     \"\"\"TAG-DISTANCE-gHEX[-dirty].\n \n     Like 'git describe --tags --dirty --always -long'.\n     The distance/hash is unconditional.\n \n     Exceptions:\n     1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n     else:\n         # exception #1\n         rendered = pieces[\"short\"]\n     if pieces[\"dirty\"]:\n         rendered += \"-dirty\"\n     return rendered\n \n \n def render(pieces, style):\n     \"\"\"Render the given version pieces into the requested style.\"\"\"\n     if pieces[\"error\"]:\n         return {\n             \"version\": \"unknown\",\n             \"full-revisionid\": pieces.get(\"long\"),\n             \"dirty\": None,\n             \"error\": pieces[\"error\"],\n             \"date\": None,\n         }\n \n     if not style or style == \"default\":\n         style = \"pep440\"  # the default\n \n     if style == \"pep440\":\n         rendered = render_pep440(pieces)\n     elif style == \"pep440-branch\":\n         rendered = render_pep440_branch(pieces)\n     elif style == \"pep440-pre\":\n         rendered = render_pep440_pre(pieces)\n     elif style == \"pep440-post\":\n         rendered = render_pep440_post(pieces)\n     elif style == \"pep440-post-branch\":\n         rendered = render_pep440_post_branch(pieces)\n     elif style == \"pep440-old\":\n         rendered = render_pep440_old(pieces)\n     elif style == \"git-describe\":\n         rendered = render_git_describe(pieces)\n     elif style == \"git-describe-long\":\n         rendered = render_git_describe_long(pieces)\n     else:\n         raise ValueError(\"unknown style '%s'\" % style)\n \n     return {\n         \"version\": rendered,\n         \"full-revisionid\": pieces[\"long\"],\n         \"dirty\": pieces[\"dirty\"],\n         \"error\": None,\n         \"date\": pieces.get(\"date\"),\n     }\n \n \n def get_versions():\n     \"\"\"Get version information or return default if unable to do so.\"\"\"\n     # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have\n     # __file__, we can work backwards from there to the root. Some\n     # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which\n     # case we can only use expanded keywords.\n \n     cfg = get_config()\n     verbose = cfg.verbose\n \n     try:\n         return git_versions_from_keywords(get_keywords(), cfg.tag_prefix, verbose)\n     except NotThisMethod:\n         pass\n \n     try:\n         root = os.path.realpath(__file__)\n         # versionfile_source is the relative path from the top of the source\n         # tree (where the .git directory might live) to this file. Invert\n         # this to find the root from __file__.\n         for _ in cfg.versionfile_source.split(\"/\"):\n             root = os.path.dirname(root)\n     except NameError:\n         return {\n             \"version\": \"0+unknown\",\n             \"full-revisionid\": None,\n             \"dirty\": None,\n             \"error\": \"unable to find root of source tree\",\n             \"date\": None,\n         }\n \n     try:\n         pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)\n         return render(pieces, cfg.style)\n     except NotThisMethod:\n         pass\n \n     try:\n         if cfg.parentdir_prefix:\n             return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n     except NotThisMethod:\n         pass\n \n     return {\n         \"version\": \"0+unknown\",\n         \"full-revisionid\": None,\n         \"dirty\": None,\n         \"error\": \"unable to compute version\",\n         \"date\": None,\n     }\n ", "input_code": "def plus_or_dot(pieces):\n\"\"\"\nReturn a + if we don't already have one, else return a .\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def plus_or_dot(pieces):\n    \"\"\"Return a + if we don't already have one, else return a .\"\"\"\n    if \"+\" in pieces.get(\"closest-tag\", \"\"):\n        return \".\"\n    return \"+\"", "signature": "def plus_or_dot(pieces):", "completion_path": "src/prestoplot/_version.py"}
{"ce_id": "62b87d23d292efb640a5566b", "namespace": "62b87d23d292efb640a5566b", "namespace_real": "src.prestoplot._version.run_command", "real_proj_path": "eykd---prestoplot/", "type": "function", "class_name": null, "function_name": "run_command", "contexts_above": "# This file helps to compute a version number in source trees obtained from\n# git-archive tarball (such as those provided by githubs download-from-tag\n# feature). Distribution tarballs (built by setup.py sdist) and build\n# directories (produced by setup.py build) will contain a much shorter file\n# that just contains the computed version number.\n\n# This file is released into the public domain. Generated by\n# versioneer-0.22 (https://github.com/python-versioneer/python-versioneer)\n\n\"\"\"Git implementation of _version.py.\"\"\"\n\nimport errno\nimport functools\nimport os\nimport re\nimport subprocess\nimport sys\nfrom typing import Callable, Dict\n\n\ndef get_keywords():\n    \"\"\"Get the keywords needed to look up the version information.\"\"\"\n    # these strings will be replaced by git during git-archive.\n    # setup.py/versioneer.py will grep for the variable names, so they must\n    # each be defined on a line of their own. _version.py will just call\n    # get_keywords().\n    git_refnames = \"$Format:%d$\"\n    git_full = \"$Format:%H$\"\n    git_date = \"$Format:%ci$\"\n    keywords = {\"refnames\": git_refnames, \"full\": git_full, \"date\": git_date}\n    return keywords\n\n\nclass VersioneerConfig:\n    \"\"\"Container for Versioneer configuration parameters.\"\"\"\n\n\ndef get_config():\n    \"\"\"Create, populate and return the VersioneerConfig() object.\"\"\"\n    # these strings are filled in when 'setup.py versioneer' creates\n    # _version.py\n    cfg = VersioneerConfig()\n    cfg.VCS = \"git\"\n    cfg.style = \"pep440\"\n    cfg.tag_prefix = \"\"\n    cfg.parentdir_prefix = \"None\"\n    cfg.versionfile_source = \"src/prestoplot/_version.py\"\n    cfg.verbose = False\n    return cfg\n\n\nclass NotThisMethod(Exception):\n    \"\"\"Exception raised if a method is not valid for the current scenario.\"\"\"\n\n\nLONG_VERSION_PY: Dict[str, str] = {}\nHANDLERS: Dict[str, Dict[str, Callable]] = {}\n\n\ndef register_vcs_handler(vcs, method):  # decorator\n    \"\"\"Create decorator to mark a method as the handler of a VCS.\"\"\"\n\n    def decorate(f):\n        \"\"\"Store f in HANDLERS[vcs][method].\"\"\"\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n\n    return decorate\n\n", "contexts_below": "\n def versions_from_parentdir(parentdir_prefix, root, verbose):\n     \"\"\"Try to determine the version from the parent directory name.\n \n     Source tarballs conventionally unpack into a directory that includes both\n     the project name and a version string. We will also support searching up\n     two directory levels for an appropriately named parent directory\n     \"\"\"\n     rootdirs = []\n \n     for _ in range(3):\n         dirname = os.path.basename(root)\n         if dirname.startswith(parentdir_prefix):\n             return {\n                 \"version\": dirname[len(parentdir_prefix) :],\n                 \"full-revisionid\": None,\n                 \"dirty\": False,\n                 \"error\": None,\n                 \"date\": None,\n             }\n         rootdirs.append(root)\n         root = os.path.dirname(root)  # up a level\n \n     if verbose:\n         print(\n             \"Tried directories %s but none started with prefix %s\"\n             % (str(rootdirs), parentdir_prefix)\n         )\n     raise NotThisMethod(\"rootdir doesn't start with parentdir_prefix\")\n \n \n @register_vcs_handler(\"git\", \"get_keywords\")\n def git_get_keywords(versionfile_abs):\n     \"\"\"Extract version information from the given file.\"\"\"\n     # the code embedded in _version.py can just fetch the value of these\n     # keywords. When used from setup.py, we don't want to import _version.py,\n     # so we do it with a regexp instead. This function is not used from\n     # _version.py.\n     keywords = {}\n     try:\n         with open(versionfile_abs, \"r\") as fobj:\n             for line in fobj:\n                 if line.strip().startswith(\"git_refnames =\"):\n                     mo = re.search(r'=\\s*\"(.*)\"', line)\n                     if mo:\n                         keywords[\"refnames\"] = mo.group(1)\n                 if line.strip().startswith(\"git_full =\"):\n                     mo = re.search(r'=\\s*\"(.*)\"', line)\n                     if mo:\n                         keywords[\"full\"] = mo.group(1)\n                 if line.strip().startswith(\"git_date =\"):\n                     mo = re.search(r'=\\s*\"(.*)\"', line)\n                     if mo:\n                         keywords[\"date\"] = mo.group(1)\n     except OSError:\n         pass\n     return keywords\n \n \n @register_vcs_handler(\"git\", \"keywords\")\n def git_versions_from_keywords(keywords, tag_prefix, verbose):\n     \"\"\"Get version information from git keywords.\"\"\"\n     if \"refnames\" not in keywords:\n         raise NotThisMethod(\"Short version file found\")\n     date = keywords.get(\"date\")\n     if date is not None:\n         # Use only the last line.  Previous lines may contain GPG signature\n         # information.\n         date = date.splitlines()[-1]\n \n         # git-2.2.0 added \"%cI\", which expands to an ISO-8601 -compliant\n         # datestamp. However we prefer \"%ci\" (which expands to an \"ISO-8601\n         # -like\" string, which we must then edit to make compliant), because\n         # it's been around since git-1.5.3, and it's too difficult to\n         # discover which version we're using, or to work around using an\n         # older one.\n         date = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n     refnames = keywords[\"refnames\"].strip()\n     if refnames.startswith(\"$Format\"):\n         if verbose:\n             print(\"keywords are unexpanded, not using\")\n         raise NotThisMethod(\"unexpanded keywords, not a git-archive tarball\")\n     refs = {r.strip() for r in refnames.strip(\"()\").split(\",\")}\n     # starting in git-1.8.3, tags are listed as \"tag: foo-1.0\" instead of\n     # just \"foo-1.0\". If we see a \"tag: \" prefix, prefer those.\n     TAG = \"tag: \"\n     tags = {r[len(TAG) :] for r in refs if r.startswith(TAG)}\n     if not tags:\n         # Either we're using git < 1.8.3, or there really are no tags. We use\n         # a heuristic: assume all version tags have a digit. The old git %d\n         # expansion behaves like git log --decorate=short and strips out the\n         # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n         # between branches and tags. By ignoring refnames without digits, we\n         # filter out many common branch names like \"release\" and\n         # \"stabilization\", as well as \"HEAD\" and \"master\".\n         tags = {r for r in refs if re.search(r\"\\d\", r)}\n         if verbose:\n             print(\"discarding '%s', no digits\" % \",\".join(refs - tags))\n     if verbose:\n         print(\"likely tags: %s\" % \",\".join(sorted(tags)))\n     for ref in sorted(tags):\n         # sorting will prefer e.g. \"2.0\" over \"2.0rc1\"\n         if ref.startswith(tag_prefix):\n             r = ref[len(tag_prefix) :]\n             # Filter out refs that exactly match prefix or that don't start\n             # with a number once the prefix is stripped (mostly a concern\n             # when prefix is '')\n             if not re.match(r\"\\d\", r):\n                 continue\n             if verbose:\n                 print(\"picking %s\" % r)\n             return {\n                 \"version\": r,\n                 \"full-revisionid\": keywords[\"full\"].strip(),\n                 \"dirty\": False,\n                 \"error\": None,\n                 \"date\": date,\n             }\n     # no suitable tags, so version is \"0+unknown\", but full hex is still there\n     if verbose:\n         print(\"no suitable tags, using unknown + full revision id\")\n     return {\n         \"version\": \"0+unknown\",\n         \"full-revisionid\": keywords[\"full\"].strip(),\n         \"dirty\": False,\n         \"error\": \"no suitable tags\",\n         \"date\": None,\n     }\n \n \n @register_vcs_handler(\"git\", \"pieces_from_vcs\")\n def git_pieces_from_vcs(tag_prefix, root, verbose, runner=run_command):\n     \"\"\"Get version from 'git describe' in the root of the source tree.\n \n     This only gets called if the git-archive 'subst' keywords were *not*\n     expanded, and _version.py hasn't already been rewritten with a short\n     version string, meaning we're inside a checked out source tree.\n     \"\"\"\n     GITS = [\"git\"]\n     if sys.platform == \"win32\":\n         GITS = [\"git.cmd\", \"git.exe\"]\n \n     # GIT_DIR can interfere with correct operation of Versioneer.\n     # It may be intended to be passed to the Versioneer-versioned project,\n     # but that should not change where we get our version from.\n     env = os.environ.copy()\n     env.pop(\"GIT_DIR\", None)\n     runner = functools.partial(runner, env=env)\n \n     _, rc = runner(GITS, [\"rev-parse\", \"--git-dir\"], cwd=root, hide_stderr=True)\n     if rc != 0:\n         if verbose:\n             print(\"Directory %s not under git control\" % root)\n         raise NotThisMethod(\"'git rev-parse --git-dir' returned error\")\n \n     MATCH_ARGS = [\"--match\", \"%s*\" % tag_prefix] if tag_prefix else []\n \n     # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]\n     # if there isn't one, this yields HEX[-dirty] (no NUM)\n     describe_out, rc = runner(\n         GITS,\n         [\"describe\", \"--tags\", \"--dirty\", \"--always\", \"--long\", *MATCH_ARGS],\n         cwd=root,\n     )\n     # --long was added in git-1.5.5\n     if describe_out is None:\n         raise NotThisMethod(\"'git describe' failed\")\n     describe_out = describe_out.strip()\n     full_out, rc = runner(GITS, [\"rev-parse\", \"HEAD\"], cwd=root)\n     if full_out is None:\n         raise NotThisMethod(\"'git rev-parse' failed\")\n     full_out = full_out.strip()\n \n     pieces = {}\n     pieces[\"long\"] = full_out\n     pieces[\"short\"] = full_out[:7]  # maybe improved later\n     pieces[\"error\"] = None\n \n     branch_name, rc = runner(GITS, [\"rev-parse\", \"--abbrev-ref\", \"HEAD\"], cwd=root)\n     # --abbrev-ref was added in git-1.6.3\n     if rc != 0 or branch_name is None:\n         raise NotThisMethod(\"'git rev-parse --abbrev-ref' returned error\")\n     branch_name = branch_name.strip()\n \n     if branch_name == \"HEAD\":\n         # If we aren't exactly on a branch, pick a branch which represents\n         # the current commit. If all else fails, we are on a branchless\n         # commit.\n         branches, rc = runner(GITS, [\"branch\", \"--contains\"], cwd=root)\n         # --contains was added in git-1.5.4\n         if rc != 0 or branches is None:\n             raise NotThisMethod(\"'git branch --contains' returned error\")\n         branches = branches.split(\"\\n\")\n \n         # Remove the first line if we're running detached\n         if \"(\" in branches[0]:\n             branches.pop(0)\n \n         # Strip off the leading \"* \" from the list of branches.\n         branches = [branch[2:] for branch in branches]\n         if \"master\" in branches:\n             branch_name = \"master\"\n         elif not branches:\n             branch_name = None\n         else:\n             # Pick the first branch that is returned. Good or bad.\n             branch_name = branches[0]\n \n     pieces[\"branch\"] = branch_name\n \n     # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]\n     # TAG might have hyphens.\n     git_describe = describe_out\n \n     # look for -dirty suffix\n     dirty = git_describe.endswith(\"-dirty\")\n     pieces[\"dirty\"] = dirty\n     if dirty:\n         git_describe = git_describe[: git_describe.rindex(\"-dirty\")]\n \n     # now we have TAG-NUM-gHEX or HEX\n \n     if \"-\" in git_describe:\n         # TAG-NUM-gHEX\n         mo = re.search(r\"^(.+)-(\\d+)-g([0-9a-f]+)$\", git_describe)\n         if not mo:\n             # unparsable. Maybe git-describe is misbehaving?\n             pieces[\"error\"] = \"unable to parse git-describe output: '%s'\" % describe_out\n             return pieces\n \n         # tag\n         full_tag = mo.group(1)\n         if not full_tag.startswith(tag_prefix):\n             if verbose:\n                 fmt = \"tag '%s' doesn't start with prefix '%s'\"\n                 print(fmt % (full_tag, tag_prefix))\n             pieces[\"error\"] = \"tag '%s' doesn't start with prefix '%s'\" % (\n                 full_tag,\n                 tag_prefix,\n             )\n             return pieces\n         pieces[\"closest-tag\"] = full_tag[len(tag_prefix) :]\n \n         # distance: number of commits since tag\n         pieces[\"distance\"] = int(mo.group(2))\n \n         # commit: short hex revision ID\n         pieces[\"short\"] = mo.group(3)\n \n     else:\n         # HEX: no tags\n         pieces[\"closest-tag\"] = None\n         count_out, rc = runner(GITS, [\"rev-list\", \"HEAD\", \"--count\"], cwd=root)\n         pieces[\"distance\"] = int(count_out)  # total number of commits\n \n     # commit date: see ISO-8601 comment in git_versions_from_keywords()\n     date = runner(GITS, [\"show\", \"-s\", \"--format=%ci\", \"HEAD\"], cwd=root)[0].strip()\n     # Use only the last line.  Previous lines may contain GPG signature\n     # information.\n     date = date.splitlines()[-1]\n     pieces[\"date\"] = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n \n     return pieces\n \n \n def plus_or_dot(pieces):\n     \"\"\"Return a + if we don't already have one, else return a .\"\"\"\n     if \"+\" in pieces.get(\"closest-tag\", \"\"):\n         return \".\"\n     return \"+\"\n \n \n def render_pep440(pieces):\n     \"\"\"Build up version string, with post-release \"local version identifier\".\n \n     Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n     get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty\n \n     Exceptions:\n     1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += plus_or_dot(pieces)\n             rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n             if pieces[\"dirty\"]:\n                 rendered += \".dirty\"\n     else:\n         # exception #1\n         rendered = \"0+untagged.%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n         if pieces[\"dirty\"]:\n             rendered += \".dirty\"\n     return rendered\n \n \n def render_pep440_branch(pieces):\n     \"\"\"TAG[[.dev0]+DISTANCE.gHEX[.dirty]] .\n \n     The \".dev0\" means not master branch. Note that .dev0 sorts backwards\n     (a feature branch will appear \"older\" than the master branch).\n \n     Exceptions:\n     1: no tags. 0[.dev0]+untagged.DISTANCE.gHEX[.dirty]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             if pieces[\"branch\"] != \"master\":\n                 rendered += \".dev0\"\n             rendered += plus_or_dot(pieces)\n             rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n             if pieces[\"dirty\"]:\n                 rendered += \".dirty\"\n     else:\n         # exception #1\n         rendered = \"0\"\n         if pieces[\"branch\"] != \"master\":\n             rendered += \".dev0\"\n         rendered += \"+untagged.%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n         if pieces[\"dirty\"]:\n             rendered += \".dirty\"\n     return rendered\n \n \n def pep440_split_post(ver):\n     \"\"\"Split pep440 version string at the post-release segment.\n \n     Returns the release segments before the post-release and the\n     post-release version number (or -1 if no post-release segment is present).\n     \"\"\"\n     vc = str.split(ver, \".post\")\n     return vc[0], int(vc[1] or 0) if len(vc) == 2 else None\n \n \n def render_pep440_pre(pieces):\n     \"\"\"TAG[.postN.devDISTANCE] -- No -dirty.\n \n     Exceptions:\n     1: no tags. 0.post0.devDISTANCE\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         if pieces[\"distance\"]:\n             # update the post release segment\n             tag_version, post_version = pep440_split_post(pieces[\"closest-tag\"])\n             rendered = tag_version\n             if post_version is not None:\n                 rendered += \".post%d.dev%d\" % (post_version + 1, pieces[\"distance\"])\n             else:\n                 rendered += \".post0.dev%d\" % (pieces[\"distance\"])\n         else:\n             # no commits, use the tag as the version\n             rendered = pieces[\"closest-tag\"]\n     else:\n         # exception #1\n         rendered = \"0.post0.dev%d\" % pieces[\"distance\"]\n     return rendered\n \n \n def render_pep440_post(pieces):\n     \"\"\"TAG[.postDISTANCE[.dev0]+gHEX] .\n \n     The \".dev0\" means dirty. Note that .dev0 sorts backwards\n     (a dirty tree will appear \"older\" than the corresponding clean one),\n     but you shouldn't be releasing software with -dirty anyways.\n \n     Exceptions:\n     1: no tags. 0.postDISTANCE[.dev0]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += \".post%d\" % pieces[\"distance\"]\n             if pieces[\"dirty\"]:\n                 rendered += \".dev0\"\n             rendered += plus_or_dot(pieces)\n             rendered += \"g%s\" % pieces[\"short\"]\n     else:\n         # exception #1\n         rendered = \"0.post%d\" % pieces[\"distance\"]\n         if pieces[\"dirty\"]:\n             rendered += \".dev0\"\n         rendered += \"+g%s\" % pieces[\"short\"]\n     return rendered\n \n \n def render_pep440_post_branch(pieces):\n     \"\"\"TAG[.postDISTANCE[.dev0]+gHEX[.dirty]] .\n \n     The \".dev0\" means not master branch.\n \n     Exceptions:\n     1: no tags. 0.postDISTANCE[.dev0]+gHEX[.dirty]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += \".post%d\" % pieces[\"distance\"]\n             if pieces[\"branch\"] != \"master\":\n                 rendered += \".dev0\"\n             rendered += plus_or_dot(pieces)\n             rendered += \"g%s\" % pieces[\"short\"]\n             if pieces[\"dirty\"]:\n                 rendered += \".dirty\"\n     else:\n         # exception #1\n         rendered = \"0.post%d\" % pieces[\"distance\"]\n         if pieces[\"branch\"] != \"master\":\n             rendered += \".dev0\"\n         rendered += \"+g%s\" % pieces[\"short\"]\n         if pieces[\"dirty\"]:\n             rendered += \".dirty\"\n     return rendered\n \n \n def render_pep440_old(pieces):\n     \"\"\"TAG[.postDISTANCE[.dev0]] .\n \n     The \".dev0\" means dirty.\n \n     Exceptions:\n     1: no tags. 0.postDISTANCE[.dev0]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += \".post%d\" % pieces[\"distance\"]\n             if pieces[\"dirty\"]:\n                 rendered += \".dev0\"\n     else:\n         # exception #1\n         rendered = \"0.post%d\" % pieces[\"distance\"]\n         if pieces[\"dirty\"]:\n             rendered += \".dev0\"\n     return rendered\n \n \n def render_git_describe(pieces):\n     \"\"\"TAG[-DISTANCE-gHEX][-dirty].\n \n     Like 'git describe --tags --dirty --always'.\n \n     Exceptions:\n     1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"]:\n             rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n     else:\n         # exception #1\n         rendered = pieces[\"short\"]\n     if pieces[\"dirty\"]:\n         rendered += \"-dirty\"\n     return rendered\n \n \n def render_git_describe_long(pieces):\n     \"\"\"TAG-DISTANCE-gHEX[-dirty].\n \n     Like 'git describe --tags --dirty --always -long'.\n     The distance/hash is unconditional.\n \n     Exceptions:\n     1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n     else:\n         # exception #1\n         rendered = pieces[\"short\"]\n     if pieces[\"dirty\"]:\n         rendered += \"-dirty\"\n     return rendered\n \n \n def render(pieces, style):\n     \"\"\"Render the given version pieces into the requested style.\"\"\"\n     if pieces[\"error\"]:\n         return {\n             \"version\": \"unknown\",\n             \"full-revisionid\": pieces.get(\"long\"),\n             \"dirty\": None,\n             \"error\": pieces[\"error\"],\n             \"date\": None,\n         }\n \n     if not style or style == \"default\":\n         style = \"pep440\"  # the default\n \n     if style == \"pep440\":\n         rendered = render_pep440(pieces)\n     elif style == \"pep440-branch\":\n         rendered = render_pep440_branch(pieces)\n     elif style == \"pep440-pre\":\n         rendered = render_pep440_pre(pieces)\n     elif style == \"pep440-post\":\n         rendered = render_pep440_post(pieces)\n     elif style == \"pep440-post-branch\":\n         rendered = render_pep440_post_branch(pieces)\n     elif style == \"pep440-old\":\n         rendered = render_pep440_old(pieces)\n     elif style == \"git-describe\":\n         rendered = render_git_describe(pieces)\n     elif style == \"git-describe-long\":\n         rendered = render_git_describe_long(pieces)\n     else:\n         raise ValueError(\"unknown style '%s'\" % style)\n \n     return {\n         \"version\": rendered,\n         \"full-revisionid\": pieces[\"long\"],\n         \"dirty\": pieces[\"dirty\"],\n         \"error\": None,\n         \"date\": pieces.get(\"date\"),\n     }\n \n \n def get_versions():\n     \"\"\"Get version information or return default if unable to do so.\"\"\"\n     # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have\n     # __file__, we can work backwards from there to the root. Some\n     # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which\n     # case we can only use expanded keywords.\n \n     cfg = get_config()\n     verbose = cfg.verbose\n \n     try:\n         return git_versions_from_keywords(get_keywords(), cfg.tag_prefix, verbose)\n     except NotThisMethod:\n         pass\n \n     try:\n         root = os.path.realpath(__file__)\n         # versionfile_source is the relative path from the top of the source\n         # tree (where the .git directory might live) to this file. Invert\n         # this to find the root from __file__.\n         for _ in cfg.versionfile_source.split(\"/\"):\n             root = os.path.dirname(root)\n     except NameError:\n         return {\n             \"version\": \"0+unknown\",\n             \"full-revisionid\": None,\n             \"dirty\": None,\n             \"error\": \"unable to find root of source tree\",\n             \"date\": None,\n         }\n \n     try:\n         pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)\n         return render(pieces, cfg.style)\n     except NotThisMethod:\n         pass\n \n     try:\n         if cfg.parentdir_prefix:\n             return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n     except NotThisMethod:\n         pass\n \n     return {\n         \"version\": \"0+unknown\",\n         \"full-revisionid\": None,\n         \"dirty\": None,\n         \"error\": \"unable to compute version\",\n         \"date\": None,\n     }\n ", "input_code": "def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):\n\"\"\"\nCall the given command(s).\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):\n    \"\"\"Call the given command(s).\"\"\"\n    assert isinstance(commands, list)\n    process = None\n\n    popen_kwargs = {}\n    if sys.platform == \"win32\":\n        # This hides the console window if pythonw.exe is used\n        startupinfo = subprocess.STARTUPINFO()\n        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n        popen_kwargs[\"startupinfo\"] = startupinfo\n\n    for command in commands:\n        try:\n            dispcmd = str([command] + args)\n            # remember shell=False, so use git.cmd on windows, not just git\n            process = subprocess.Popen(\n                [command] + args,\n                cwd=cwd,\n                env=env,\n                stdout=subprocess.PIPE,\n                stderr=(subprocess.PIPE if hide_stderr else None),\n                **popen_kwargs\n            )\n            break\n        except OSError:\n            e = sys.exc_info()[1]\n            if e.errno == errno.ENOENT:\n                continue\n            if verbose:\n                print(\"unable to run %s\" % dispcmd)\n                print(e)\n            return None, None\n    else:\n        if verbose:\n            print(\"unable to find command, tried %s\" % (commands,))\n        return None, None\n    stdout = process.communicate()[0].strip().decode()\n    if process.returncode != 0:\n        if verbose:\n            print(\"unable to run %s (error)\" % dispcmd)\n            print(\"stdout was %s\" % stdout)\n        return None, process.returncode\n    return stdout, process.returncode", "signature": "def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):", "completion_path": "src/prestoplot/_version.py"}
{"ce_id": "62b87d23d292efb640a55668", "namespace": "62b87d23d292efb640a55668", "namespace_real": "src.prestoplot._version.get_config", "real_proj_path": "eykd---prestoplot/", "type": "function", "class_name": null, "function_name": "get_config", "contexts_above": "# This file helps to compute a version number in source trees obtained from\n# git-archive tarball (such as those provided by githubs download-from-tag\n# feature). Distribution tarballs (built by setup.py sdist) and build\n# directories (produced by setup.py build) will contain a much shorter file\n# that just contains the computed version number.\n\n# This file is released into the public domain. Generated by\n# versioneer-0.22 (https://github.com/python-versioneer/python-versioneer)\n\n\"\"\"Git implementation of _version.py.\"\"\"\n\nimport errno\nimport functools\nimport os\nimport re\nimport subprocess\nimport sys\nfrom typing import Callable, Dict\n\n\ndef get_keywords():\n    \"\"\"Get the keywords needed to look up the version information.\"\"\"\n    # these strings will be replaced by git during git-archive.\n    # setup.py/versioneer.py will grep for the variable names, so they must\n    # each be defined on a line of their own. _version.py will just call\n    # get_keywords().\n    git_refnames = \"$Format:%d$\"\n    git_full = \"$Format:%H$\"\n    git_date = \"$Format:%ci$\"\n    keywords = {\"refnames\": git_refnames, \"full\": git_full, \"date\": git_date}\n    return keywords\n\n\nclass VersioneerConfig:\n    \"\"\"Container for Versioneer configuration parameters.\"\"\"\n\n", "contexts_below": "\n class NotThisMethod(Exception):\n     \"\"\"Exception raised if a method is not valid for the current scenario.\"\"\"\n \n \n LONG_VERSION_PY: Dict[str, str] = {}\n HANDLERS: Dict[str, Dict[str, Callable]] = {}\n \n \n def register_vcs_handler(vcs, method):  # decorator\n     \"\"\"Create decorator to mark a method as the handler of a VCS.\"\"\"\n \n     def decorate(f):\n         \"\"\"Store f in HANDLERS[vcs][method].\"\"\"\n         if vcs not in HANDLERS:\n             HANDLERS[vcs] = {}\n         HANDLERS[vcs][method] = f\n         return f\n \n     return decorate\n \n \n def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):\n     \"\"\"Call the given command(s).\"\"\"\n     assert isinstance(commands, list)\n     process = None\n \n     popen_kwargs = {}\n     if sys.platform == \"win32\":\n         # This hides the console window if pythonw.exe is used\n         startupinfo = subprocess.STARTUPINFO()\n         startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n         popen_kwargs[\"startupinfo\"] = startupinfo\n \n     for command in commands:\n         try:\n             dispcmd = str([command] + args)\n             # remember shell=False, so use git.cmd on windows, not just git\n             process = subprocess.Popen(\n                 [command] + args,\n                 cwd=cwd,\n                 env=env,\n                 stdout=subprocess.PIPE,\n                 stderr=(subprocess.PIPE if hide_stderr else None),\n                 **popen_kwargs\n             )\n             break\n         except OSError:\n             e = sys.exc_info()[1]\n             if e.errno == errno.ENOENT:\n                 continue\n             if verbose:\n                 print(\"unable to run %s\" % dispcmd)\n                 print(e)\n             return None, None\n     else:\n         if verbose:\n             print(\"unable to find command, tried %s\" % (commands,))\n         return None, None\n     stdout = process.communicate()[0].strip().decode()\n     if process.returncode != 0:\n         if verbose:\n             print(\"unable to run %s (error)\" % dispcmd)\n             print(\"stdout was %s\" % stdout)\n         return None, process.returncode\n     return stdout, process.returncode\n \n \n def versions_from_parentdir(parentdir_prefix, root, verbose):\n     \"\"\"Try to determine the version from the parent directory name.\n \n     Source tarballs conventionally unpack into a directory that includes both\n     the project name and a version string. We will also support searching up\n     two directory levels for an appropriately named parent directory\n     \"\"\"\n     rootdirs = []\n \n     for _ in range(3):\n         dirname = os.path.basename(root)\n         if dirname.startswith(parentdir_prefix):\n             return {\n                 \"version\": dirname[len(parentdir_prefix) :],\n                 \"full-revisionid\": None,\n                 \"dirty\": False,\n                 \"error\": None,\n                 \"date\": None,\n             }\n         rootdirs.append(root)\n         root = os.path.dirname(root)  # up a level\n \n     if verbose:\n         print(\n             \"Tried directories %s but none started with prefix %s\"\n             % (str(rootdirs), parentdir_prefix)\n         )\n     raise NotThisMethod(\"rootdir doesn't start with parentdir_prefix\")\n \n \n @register_vcs_handler(\"git\", \"get_keywords\")\n def git_get_keywords(versionfile_abs):\n     \"\"\"Extract version information from the given file.\"\"\"\n     # the code embedded in _version.py can just fetch the value of these\n     # keywords. When used from setup.py, we don't want to import _version.py,\n     # so we do it with a regexp instead. This function is not used from\n     # _version.py.\n     keywords = {}\n     try:\n         with open(versionfile_abs, \"r\") as fobj:\n             for line in fobj:\n                 if line.strip().startswith(\"git_refnames =\"):\n                     mo = re.search(r'=\\s*\"(.*)\"', line)\n                     if mo:\n                         keywords[\"refnames\"] = mo.group(1)\n                 if line.strip().startswith(\"git_full =\"):\n                     mo = re.search(r'=\\s*\"(.*)\"', line)\n                     if mo:\n                         keywords[\"full\"] = mo.group(1)\n                 if line.strip().startswith(\"git_date =\"):\n                     mo = re.search(r'=\\s*\"(.*)\"', line)\n                     if mo:\n                         keywords[\"date\"] = mo.group(1)\n     except OSError:\n         pass\n     return keywords\n \n \n @register_vcs_handler(\"git\", \"keywords\")\n def git_versions_from_keywords(keywords, tag_prefix, verbose):\n     \"\"\"Get version information from git keywords.\"\"\"\n     if \"refnames\" not in keywords:\n         raise NotThisMethod(\"Short version file found\")\n     date = keywords.get(\"date\")\n     if date is not None:\n         # Use only the last line.  Previous lines may contain GPG signature\n         # information.\n         date = date.splitlines()[-1]\n \n         # git-2.2.0 added \"%cI\", which expands to an ISO-8601 -compliant\n         # datestamp. However we prefer \"%ci\" (which expands to an \"ISO-8601\n         # -like\" string, which we must then edit to make compliant), because\n         # it's been around since git-1.5.3, and it's too difficult to\n         # discover which version we're using, or to work around using an\n         # older one.\n         date = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n     refnames = keywords[\"refnames\"].strip()\n     if refnames.startswith(\"$Format\"):\n         if verbose:\n             print(\"keywords are unexpanded, not using\")\n         raise NotThisMethod(\"unexpanded keywords, not a git-archive tarball\")\n     refs = {r.strip() for r in refnames.strip(\"()\").split(\",\")}\n     # starting in git-1.8.3, tags are listed as \"tag: foo-1.0\" instead of\n     # just \"foo-1.0\". If we see a \"tag: \" prefix, prefer those.\n     TAG = \"tag: \"\n     tags = {r[len(TAG) :] for r in refs if r.startswith(TAG)}\n     if not tags:\n         # Either we're using git < 1.8.3, or there really are no tags. We use\n         # a heuristic: assume all version tags have a digit. The old git %d\n         # expansion behaves like git log --decorate=short and strips out the\n         # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n         # between branches and tags. By ignoring refnames without digits, we\n         # filter out many common branch names like \"release\" and\n         # \"stabilization\", as well as \"HEAD\" and \"master\".\n         tags = {r for r in refs if re.search(r\"\\d\", r)}\n         if verbose:\n             print(\"discarding '%s', no digits\" % \",\".join(refs - tags))\n     if verbose:\n         print(\"likely tags: %s\" % \",\".join(sorted(tags)))\n     for ref in sorted(tags):\n         # sorting will prefer e.g. \"2.0\" over \"2.0rc1\"\n         if ref.startswith(tag_prefix):\n             r = ref[len(tag_prefix) :]\n             # Filter out refs that exactly match prefix or that don't start\n             # with a number once the prefix is stripped (mostly a concern\n             # when prefix is '')\n             if not re.match(r\"\\d\", r):\n                 continue\n             if verbose:\n                 print(\"picking %s\" % r)\n             return {\n                 \"version\": r,\n                 \"full-revisionid\": keywords[\"full\"].strip(),\n                 \"dirty\": False,\n                 \"error\": None,\n                 \"date\": date,\n             }\n     # no suitable tags, so version is \"0+unknown\", but full hex is still there\n     if verbose:\n         print(\"no suitable tags, using unknown + full revision id\")\n     return {\n         \"version\": \"0+unknown\",\n         \"full-revisionid\": keywords[\"full\"].strip(),\n         \"dirty\": False,\n         \"error\": \"no suitable tags\",\n         \"date\": None,\n     }\n \n \n @register_vcs_handler(\"git\", \"pieces_from_vcs\")\n def git_pieces_from_vcs(tag_prefix, root, verbose, runner=run_command):\n     \"\"\"Get version from 'git describe' in the root of the source tree.\n \n     This only gets called if the git-archive 'subst' keywords were *not*\n     expanded, and _version.py hasn't already been rewritten with a short\n     version string, meaning we're inside a checked out source tree.\n     \"\"\"\n     GITS = [\"git\"]\n     if sys.platform == \"win32\":\n         GITS = [\"git.cmd\", \"git.exe\"]\n \n     # GIT_DIR can interfere with correct operation of Versioneer.\n     # It may be intended to be passed to the Versioneer-versioned project,\n     # but that should not change where we get our version from.\n     env = os.environ.copy()\n     env.pop(\"GIT_DIR\", None)\n     runner = functools.partial(runner, env=env)\n \n     _, rc = runner(GITS, [\"rev-parse\", \"--git-dir\"], cwd=root, hide_stderr=True)\n     if rc != 0:\n         if verbose:\n             print(\"Directory %s not under git control\" % root)\n         raise NotThisMethod(\"'git rev-parse --git-dir' returned error\")\n \n     MATCH_ARGS = [\"--match\", \"%s*\" % tag_prefix] if tag_prefix else []\n \n     # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]\n     # if there isn't one, this yields HEX[-dirty] (no NUM)\n     describe_out, rc = runner(\n         GITS,\n         [\"describe\", \"--tags\", \"--dirty\", \"--always\", \"--long\", *MATCH_ARGS],\n         cwd=root,\n     )\n     # --long was added in git-1.5.5\n     if describe_out is None:\n         raise NotThisMethod(\"'git describe' failed\")\n     describe_out = describe_out.strip()\n     full_out, rc = runner(GITS, [\"rev-parse\", \"HEAD\"], cwd=root)\n     if full_out is None:\n         raise NotThisMethod(\"'git rev-parse' failed\")\n     full_out = full_out.strip()\n \n     pieces = {}\n     pieces[\"long\"] = full_out\n     pieces[\"short\"] = full_out[:7]  # maybe improved later\n     pieces[\"error\"] = None\n \n     branch_name, rc = runner(GITS, [\"rev-parse\", \"--abbrev-ref\", \"HEAD\"], cwd=root)\n     # --abbrev-ref was added in git-1.6.3\n     if rc != 0 or branch_name is None:\n         raise NotThisMethod(\"'git rev-parse --abbrev-ref' returned error\")\n     branch_name = branch_name.strip()\n \n     if branch_name == \"HEAD\":\n         # If we aren't exactly on a branch, pick a branch which represents\n         # the current commit. If all else fails, we are on a branchless\n         # commit.\n         branches, rc = runner(GITS, [\"branch\", \"--contains\"], cwd=root)\n         # --contains was added in git-1.5.4\n         if rc != 0 or branches is None:\n             raise NotThisMethod(\"'git branch --contains' returned error\")\n         branches = branches.split(\"\\n\")\n \n         # Remove the first line if we're running detached\n         if \"(\" in branches[0]:\n             branches.pop(0)\n \n         # Strip off the leading \"* \" from the list of branches.\n         branches = [branch[2:] for branch in branches]\n         if \"master\" in branches:\n             branch_name = \"master\"\n         elif not branches:\n             branch_name = None\n         else:\n             # Pick the first branch that is returned. Good or bad.\n             branch_name = branches[0]\n \n     pieces[\"branch\"] = branch_name\n \n     # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]\n     # TAG might have hyphens.\n     git_describe = describe_out\n \n     # look for -dirty suffix\n     dirty = git_describe.endswith(\"-dirty\")\n     pieces[\"dirty\"] = dirty\n     if dirty:\n         git_describe = git_describe[: git_describe.rindex(\"-dirty\")]\n \n     # now we have TAG-NUM-gHEX or HEX\n \n     if \"-\" in git_describe:\n         # TAG-NUM-gHEX\n         mo = re.search(r\"^(.+)-(\\d+)-g([0-9a-f]+)$\", git_describe)\n         if not mo:\n             # unparsable. Maybe git-describe is misbehaving?\n             pieces[\"error\"] = \"unable to parse git-describe output: '%s'\" % describe_out\n             return pieces\n \n         # tag\n         full_tag = mo.group(1)\n         if not full_tag.startswith(tag_prefix):\n             if verbose:\n                 fmt = \"tag '%s' doesn't start with prefix '%s'\"\n                 print(fmt % (full_tag, tag_prefix))\n             pieces[\"error\"] = \"tag '%s' doesn't start with prefix '%s'\" % (\n                 full_tag,\n                 tag_prefix,\n             )\n             return pieces\n         pieces[\"closest-tag\"] = full_tag[len(tag_prefix) :]\n \n         # distance: number of commits since tag\n         pieces[\"distance\"] = int(mo.group(2))\n \n         # commit: short hex revision ID\n         pieces[\"short\"] = mo.group(3)\n \n     else:\n         # HEX: no tags\n         pieces[\"closest-tag\"] = None\n         count_out, rc = runner(GITS, [\"rev-list\", \"HEAD\", \"--count\"], cwd=root)\n         pieces[\"distance\"] = int(count_out)  # total number of commits\n \n     # commit date: see ISO-8601 comment in git_versions_from_keywords()\n     date = runner(GITS, [\"show\", \"-s\", \"--format=%ci\", \"HEAD\"], cwd=root)[0].strip()\n     # Use only the last line.  Previous lines may contain GPG signature\n     # information.\n     date = date.splitlines()[-1]\n     pieces[\"date\"] = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n \n     return pieces\n \n \n def plus_or_dot(pieces):\n     \"\"\"Return a + if we don't already have one, else return a .\"\"\"\n     if \"+\" in pieces.get(\"closest-tag\", \"\"):\n         return \".\"\n     return \"+\"\n \n \n def render_pep440(pieces):\n     \"\"\"Build up version string, with post-release \"local version identifier\".\n \n     Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n     get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty\n \n     Exceptions:\n     1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += plus_or_dot(pieces)\n             rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n             if pieces[\"dirty\"]:\n                 rendered += \".dirty\"\n     else:\n         # exception #1\n         rendered = \"0+untagged.%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n         if pieces[\"dirty\"]:\n             rendered += \".dirty\"\n     return rendered\n \n \n def render_pep440_branch(pieces):\n     \"\"\"TAG[[.dev0]+DISTANCE.gHEX[.dirty]] .\n \n     The \".dev0\" means not master branch. Note that .dev0 sorts backwards\n     (a feature branch will appear \"older\" than the master branch).\n \n     Exceptions:\n     1: no tags. 0[.dev0]+untagged.DISTANCE.gHEX[.dirty]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             if pieces[\"branch\"] != \"master\":\n                 rendered += \".dev0\"\n             rendered += plus_or_dot(pieces)\n             rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n             if pieces[\"dirty\"]:\n                 rendered += \".dirty\"\n     else:\n         # exception #1\n         rendered = \"0\"\n         if pieces[\"branch\"] != \"master\":\n             rendered += \".dev0\"\n         rendered += \"+untagged.%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n         if pieces[\"dirty\"]:\n             rendered += \".dirty\"\n     return rendered\n \n \n def pep440_split_post(ver):\n     \"\"\"Split pep440 version string at the post-release segment.\n \n     Returns the release segments before the post-release and the\n     post-release version number (or -1 if no post-release segment is present).\n     \"\"\"\n     vc = str.split(ver, \".post\")\n     return vc[0], int(vc[1] or 0) if len(vc) == 2 else None\n \n \n def render_pep440_pre(pieces):\n     \"\"\"TAG[.postN.devDISTANCE] -- No -dirty.\n \n     Exceptions:\n     1: no tags. 0.post0.devDISTANCE\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         if pieces[\"distance\"]:\n             # update the post release segment\n             tag_version, post_version = pep440_split_post(pieces[\"closest-tag\"])\n             rendered = tag_version\n             if post_version is not None:\n                 rendered += \".post%d.dev%d\" % (post_version + 1, pieces[\"distance\"])\n             else:\n                 rendered += \".post0.dev%d\" % (pieces[\"distance\"])\n         else:\n             # no commits, use the tag as the version\n             rendered = pieces[\"closest-tag\"]\n     else:\n         # exception #1\n         rendered = \"0.post0.dev%d\" % pieces[\"distance\"]\n     return rendered\n \n \n def render_pep440_post(pieces):\n     \"\"\"TAG[.postDISTANCE[.dev0]+gHEX] .\n \n     The \".dev0\" means dirty. Note that .dev0 sorts backwards\n     (a dirty tree will appear \"older\" than the corresponding clean one),\n     but you shouldn't be releasing software with -dirty anyways.\n \n     Exceptions:\n     1: no tags. 0.postDISTANCE[.dev0]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += \".post%d\" % pieces[\"distance\"]\n             if pieces[\"dirty\"]:\n                 rendered += \".dev0\"\n             rendered += plus_or_dot(pieces)\n             rendered += \"g%s\" % pieces[\"short\"]\n     else:\n         # exception #1\n         rendered = \"0.post%d\" % pieces[\"distance\"]\n         if pieces[\"dirty\"]:\n             rendered += \".dev0\"\n         rendered += \"+g%s\" % pieces[\"short\"]\n     return rendered\n \n \n def render_pep440_post_branch(pieces):\n     \"\"\"TAG[.postDISTANCE[.dev0]+gHEX[.dirty]] .\n \n     The \".dev0\" means not master branch.\n \n     Exceptions:\n     1: no tags. 0.postDISTANCE[.dev0]+gHEX[.dirty]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += \".post%d\" % pieces[\"distance\"]\n             if pieces[\"branch\"] != \"master\":\n                 rendered += \".dev0\"\n             rendered += plus_or_dot(pieces)\n             rendered += \"g%s\" % pieces[\"short\"]\n             if pieces[\"dirty\"]:\n                 rendered += \".dirty\"\n     else:\n         # exception #1\n         rendered = \"0.post%d\" % pieces[\"distance\"]\n         if pieces[\"branch\"] != \"master\":\n             rendered += \".dev0\"\n         rendered += \"+g%s\" % pieces[\"short\"]\n         if pieces[\"dirty\"]:\n             rendered += \".dirty\"\n     return rendered\n \n \n def render_pep440_old(pieces):\n     \"\"\"TAG[.postDISTANCE[.dev0]] .\n \n     The \".dev0\" means dirty.\n \n     Exceptions:\n     1: no tags. 0.postDISTANCE[.dev0]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += \".post%d\" % pieces[\"distance\"]\n             if pieces[\"dirty\"]:\n                 rendered += \".dev0\"\n     else:\n         # exception #1\n         rendered = \"0.post%d\" % pieces[\"distance\"]\n         if pieces[\"dirty\"]:\n             rendered += \".dev0\"\n     return rendered\n \n \n def render_git_describe(pieces):\n     \"\"\"TAG[-DISTANCE-gHEX][-dirty].\n \n     Like 'git describe --tags --dirty --always'.\n \n     Exceptions:\n     1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"]:\n             rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n     else:\n         # exception #1\n         rendered = pieces[\"short\"]\n     if pieces[\"dirty\"]:\n         rendered += \"-dirty\"\n     return rendered\n \n \n def render_git_describe_long(pieces):\n     \"\"\"TAG-DISTANCE-gHEX[-dirty].\n \n     Like 'git describe --tags --dirty --always -long'.\n     The distance/hash is unconditional.\n \n     Exceptions:\n     1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n     else:\n         # exception #1\n         rendered = pieces[\"short\"]\n     if pieces[\"dirty\"]:\n         rendered += \"-dirty\"\n     return rendered\n \n \n def render(pieces, style):\n     \"\"\"Render the given version pieces into the requested style.\"\"\"\n     if pieces[\"error\"]:\n         return {\n             \"version\": \"unknown\",\n             \"full-revisionid\": pieces.get(\"long\"),\n             \"dirty\": None,\n             \"error\": pieces[\"error\"],\n             \"date\": None,\n         }\n \n     if not style or style == \"default\":\n         style = \"pep440\"  # the default\n \n     if style == \"pep440\":\n         rendered = render_pep440(pieces)\n     elif style == \"pep440-branch\":\n         rendered = render_pep440_branch(pieces)\n     elif style == \"pep440-pre\":\n         rendered = render_pep440_pre(pieces)\n     elif style == \"pep440-post\":\n         rendered = render_pep440_post(pieces)\n     elif style == \"pep440-post-branch\":\n         rendered = render_pep440_post_branch(pieces)\n     elif style == \"pep440-old\":\n         rendered = render_pep440_old(pieces)\n     elif style == \"git-describe\":\n         rendered = render_git_describe(pieces)\n     elif style == \"git-describe-long\":\n         rendered = render_git_describe_long(pieces)\n     else:\n         raise ValueError(\"unknown style '%s'\" % style)\n \n     return {\n         \"version\": rendered,\n         \"full-revisionid\": pieces[\"long\"],\n         \"dirty\": pieces[\"dirty\"],\n         \"error\": None,\n         \"date\": pieces.get(\"date\"),\n     }\n \n \n def get_versions():\n     \"\"\"Get version information or return default if unable to do so.\"\"\"\n     # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have\n     # __file__, we can work backwards from there to the root. Some\n     # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which\n     # case we can only use expanded keywords.\n \n     cfg = get_config()\n     verbose = cfg.verbose\n \n     try:\n         return git_versions_from_keywords(get_keywords(), cfg.tag_prefix, verbose)\n     except NotThisMethod:\n         pass\n \n     try:\n         root = os.path.realpath(__file__)\n         # versionfile_source is the relative path from the top of the source\n         # tree (where the .git directory might live) to this file. Invert\n         # this to find the root from __file__.\n         for _ in cfg.versionfile_source.split(\"/\"):\n             root = os.path.dirname(root)\n     except NameError:\n         return {\n             \"version\": \"0+unknown\",\n             \"full-revisionid\": None,\n             \"dirty\": None,\n             \"error\": \"unable to find root of source tree\",\n             \"date\": None,\n         }\n \n     try:\n         pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)\n         return render(pieces, cfg.style)\n     except NotThisMethod:\n         pass\n \n     try:\n         if cfg.parentdir_prefix:\n             return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n     except NotThisMethod:\n         pass\n \n     return {\n         \"version\": \"0+unknown\",\n         \"full-revisionid\": None,\n         \"dirty\": None,\n         \"error\": \"unable to compute version\",\n         \"date\": None,\n     }\n ", "input_code": "def get_config():\n\"\"\"\nCreate, populate and return the VersioneerConfig() object.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def get_config():\n    \"\"\"Create, populate and return the VersioneerConfig() object.\"\"\"\n    # these strings are filled in when 'setup.py versioneer' creates\n    # _version.py\n    cfg = VersioneerConfig()\n    cfg.VCS = \"git\"\n    cfg.style = \"pep440\"\n    cfg.tag_prefix = \"\"\n    cfg.parentdir_prefix = \"None\"\n    cfg.versionfile_source = \"src/prestoplot/_version.py\"\n    cfg.verbose = False\n    return cfg", "signature": "def get_config():", "completion_path": "src/prestoplot/_version.py"}
{"ce_id": "62b87d23d292efb640a55667", "namespace": "62b87d23d292efb640a55667", "namespace_real": "src.prestoplot._version.register_vcs_handler", "real_proj_path": "eykd---prestoplot/", "type": "function", "class_name": null, "function_name": "register_vcs_handler", "contexts_above": "# This file helps to compute a version number in source trees obtained from\n# git-archive tarball (such as those provided by githubs download-from-tag\n# feature). Distribution tarballs (built by setup.py sdist) and build\n# directories (produced by setup.py build) will contain a much shorter file\n# that just contains the computed version number.\n\n# This file is released into the public domain. Generated by\n# versioneer-0.22 (https://github.com/python-versioneer/python-versioneer)\n\n\"\"\"Git implementation of _version.py.\"\"\"\n\nimport errno\nimport functools\nimport os\nimport re\nimport subprocess\nimport sys\nfrom typing import Callable, Dict\n\n\ndef get_keywords():\n    \"\"\"Get the keywords needed to look up the version information.\"\"\"\n    # these strings will be replaced by git during git-archive.\n    # setup.py/versioneer.py will grep for the variable names, so they must\n    # each be defined on a line of their own. _version.py will just call\n    # get_keywords().\n    git_refnames = \"$Format:%d$\"\n    git_full = \"$Format:%H$\"\n    git_date = \"$Format:%ci$\"\n    keywords = {\"refnames\": git_refnames, \"full\": git_full, \"date\": git_date}\n    return keywords\n\n\nclass VersioneerConfig:\n    \"\"\"Container for Versioneer configuration parameters.\"\"\"\n\n\ndef get_config():\n    \"\"\"Create, populate and return the VersioneerConfig() object.\"\"\"\n    # these strings are filled in when 'setup.py versioneer' creates\n    # _version.py\n    cfg = VersioneerConfig()\n    cfg.VCS = \"git\"\n    cfg.style = \"pep440\"\n    cfg.tag_prefix = \"\"\n    cfg.parentdir_prefix = \"None\"\n    cfg.versionfile_source = \"src/prestoplot/_version.py\"\n    cfg.verbose = False\n    return cfg\n\n\nclass NotThisMethod(Exception):\n    \"\"\"Exception raised if a method is not valid for the current scenario.\"\"\"\n\n\nLONG_VERSION_PY: Dict[str, str] = {}\nHANDLERS: Dict[str, Dict[str, Callable]] = {}\n\n", "contexts_below": "\n def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):\n     \"\"\"Call the given command(s).\"\"\"\n     assert isinstance(commands, list)\n     process = None\n \n     popen_kwargs = {}\n     if sys.platform == \"win32\":\n         # This hides the console window if pythonw.exe is used\n         startupinfo = subprocess.STARTUPINFO()\n         startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n         popen_kwargs[\"startupinfo\"] = startupinfo\n \n     for command in commands:\n         try:\n             dispcmd = str([command] + args)\n             # remember shell=False, so use git.cmd on windows, not just git\n             process = subprocess.Popen(\n                 [command] + args,\n                 cwd=cwd,\n                 env=env,\n                 stdout=subprocess.PIPE,\n                 stderr=(subprocess.PIPE if hide_stderr else None),\n                 **popen_kwargs\n             )\n             break\n         except OSError:\n             e = sys.exc_info()[1]\n             if e.errno == errno.ENOENT:\n                 continue\n             if verbose:\n                 print(\"unable to run %s\" % dispcmd)\n                 print(e)\n             return None, None\n     else:\n         if verbose:\n             print(\"unable to find command, tried %s\" % (commands,))\n         return None, None\n     stdout = process.communicate()[0].strip().decode()\n     if process.returncode != 0:\n         if verbose:\n             print(\"unable to run %s (error)\" % dispcmd)\n             print(\"stdout was %s\" % stdout)\n         return None, process.returncode\n     return stdout, process.returncode\n \n \n def versions_from_parentdir(parentdir_prefix, root, verbose):\n     \"\"\"Try to determine the version from the parent directory name.\n \n     Source tarballs conventionally unpack into a directory that includes both\n     the project name and a version string. We will also support searching up\n     two directory levels for an appropriately named parent directory\n     \"\"\"\n     rootdirs = []\n \n     for _ in range(3):\n         dirname = os.path.basename(root)\n         if dirname.startswith(parentdir_prefix):\n             return {\n                 \"version\": dirname[len(parentdir_prefix) :],\n                 \"full-revisionid\": None,\n                 \"dirty\": False,\n                 \"error\": None,\n                 \"date\": None,\n             }\n         rootdirs.append(root)\n         root = os.path.dirname(root)  # up a level\n \n     if verbose:\n         print(\n             \"Tried directories %s but none started with prefix %s\"\n             % (str(rootdirs), parentdir_prefix)\n         )\n     raise NotThisMethod(\"rootdir doesn't start with parentdir_prefix\")\n \n \n @register_vcs_handler(\"git\", \"get_keywords\")\n def git_get_keywords(versionfile_abs):\n     \"\"\"Extract version information from the given file.\"\"\"\n     # the code embedded in _version.py can just fetch the value of these\n     # keywords. When used from setup.py, we don't want to import _version.py,\n     # so we do it with a regexp instead. This function is not used from\n     # _version.py.\n     keywords = {}\n     try:\n         with open(versionfile_abs, \"r\") as fobj:\n             for line in fobj:\n                 if line.strip().startswith(\"git_refnames =\"):\n                     mo = re.search(r'=\\s*\"(.*)\"', line)\n                     if mo:\n                         keywords[\"refnames\"] = mo.group(1)\n                 if line.strip().startswith(\"git_full =\"):\n                     mo = re.search(r'=\\s*\"(.*)\"', line)\n                     if mo:\n                         keywords[\"full\"] = mo.group(1)\n                 if line.strip().startswith(\"git_date =\"):\n                     mo = re.search(r'=\\s*\"(.*)\"', line)\n                     if mo:\n                         keywords[\"date\"] = mo.group(1)\n     except OSError:\n         pass\n     return keywords\n \n \n @register_vcs_handler(\"git\", \"keywords\")\n def git_versions_from_keywords(keywords, tag_prefix, verbose):\n     \"\"\"Get version information from git keywords.\"\"\"\n     if \"refnames\" not in keywords:\n         raise NotThisMethod(\"Short version file found\")\n     date = keywords.get(\"date\")\n     if date is not None:\n         # Use only the last line.  Previous lines may contain GPG signature\n         # information.\n         date = date.splitlines()[-1]\n \n         # git-2.2.0 added \"%cI\", which expands to an ISO-8601 -compliant\n         # datestamp. However we prefer \"%ci\" (which expands to an \"ISO-8601\n         # -like\" string, which we must then edit to make compliant), because\n         # it's been around since git-1.5.3, and it's too difficult to\n         # discover which version we're using, or to work around using an\n         # older one.\n         date = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n     refnames = keywords[\"refnames\"].strip()\n     if refnames.startswith(\"$Format\"):\n         if verbose:\n             print(\"keywords are unexpanded, not using\")\n         raise NotThisMethod(\"unexpanded keywords, not a git-archive tarball\")\n     refs = {r.strip() for r in refnames.strip(\"()\").split(\",\")}\n     # starting in git-1.8.3, tags are listed as \"tag: foo-1.0\" instead of\n     # just \"foo-1.0\". If we see a \"tag: \" prefix, prefer those.\n     TAG = \"tag: \"\n     tags = {r[len(TAG) :] for r in refs if r.startswith(TAG)}\n     if not tags:\n         # Either we're using git < 1.8.3, or there really are no tags. We use\n         # a heuristic: assume all version tags have a digit. The old git %d\n         # expansion behaves like git log --decorate=short and strips out the\n         # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n         # between branches and tags. By ignoring refnames without digits, we\n         # filter out many common branch names like \"release\" and\n         # \"stabilization\", as well as \"HEAD\" and \"master\".\n         tags = {r for r in refs if re.search(r\"\\d\", r)}\n         if verbose:\n             print(\"discarding '%s', no digits\" % \",\".join(refs - tags))\n     if verbose:\n         print(\"likely tags: %s\" % \",\".join(sorted(tags)))\n     for ref in sorted(tags):\n         # sorting will prefer e.g. \"2.0\" over \"2.0rc1\"\n         if ref.startswith(tag_prefix):\n             r = ref[len(tag_prefix) :]\n             # Filter out refs that exactly match prefix or that don't start\n             # with a number once the prefix is stripped (mostly a concern\n             # when prefix is '')\n             if not re.match(r\"\\d\", r):\n                 continue\n             if verbose:\n                 print(\"picking %s\" % r)\n             return {\n                 \"version\": r,\n                 \"full-revisionid\": keywords[\"full\"].strip(),\n                 \"dirty\": False,\n                 \"error\": None,\n                 \"date\": date,\n             }\n     # no suitable tags, so version is \"0+unknown\", but full hex is still there\n     if verbose:\n         print(\"no suitable tags, using unknown + full revision id\")\n     return {\n         \"version\": \"0+unknown\",\n         \"full-revisionid\": keywords[\"full\"].strip(),\n         \"dirty\": False,\n         \"error\": \"no suitable tags\",\n         \"date\": None,\n     }\n \n \n @register_vcs_handler(\"git\", \"pieces_from_vcs\")\n def git_pieces_from_vcs(tag_prefix, root, verbose, runner=run_command):\n     \"\"\"Get version from 'git describe' in the root of the source tree.\n \n     This only gets called if the git-archive 'subst' keywords were *not*\n     expanded, and _version.py hasn't already been rewritten with a short\n     version string, meaning we're inside a checked out source tree.\n     \"\"\"\n     GITS = [\"git\"]\n     if sys.platform == \"win32\":\n         GITS = [\"git.cmd\", \"git.exe\"]\n \n     # GIT_DIR can interfere with correct operation of Versioneer.\n     # It may be intended to be passed to the Versioneer-versioned project,\n     # but that should not change where we get our version from.\n     env = os.environ.copy()\n     env.pop(\"GIT_DIR\", None)\n     runner = functools.partial(runner, env=env)\n \n     _, rc = runner(GITS, [\"rev-parse\", \"--git-dir\"], cwd=root, hide_stderr=True)\n     if rc != 0:\n         if verbose:\n             print(\"Directory %s not under git control\" % root)\n         raise NotThisMethod(\"'git rev-parse --git-dir' returned error\")\n \n     MATCH_ARGS = [\"--match\", \"%s*\" % tag_prefix] if tag_prefix else []\n \n     # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]\n     # if there isn't one, this yields HEX[-dirty] (no NUM)\n     describe_out, rc = runner(\n         GITS,\n         [\"describe\", \"--tags\", \"--dirty\", \"--always\", \"--long\", *MATCH_ARGS],\n         cwd=root,\n     )\n     # --long was added in git-1.5.5\n     if describe_out is None:\n         raise NotThisMethod(\"'git describe' failed\")\n     describe_out = describe_out.strip()\n     full_out, rc = runner(GITS, [\"rev-parse\", \"HEAD\"], cwd=root)\n     if full_out is None:\n         raise NotThisMethod(\"'git rev-parse' failed\")\n     full_out = full_out.strip()\n \n     pieces = {}\n     pieces[\"long\"] = full_out\n     pieces[\"short\"] = full_out[:7]  # maybe improved later\n     pieces[\"error\"] = None\n \n     branch_name, rc = runner(GITS, [\"rev-parse\", \"--abbrev-ref\", \"HEAD\"], cwd=root)\n     # --abbrev-ref was added in git-1.6.3\n     if rc != 0 or branch_name is None:\n         raise NotThisMethod(\"'git rev-parse --abbrev-ref' returned error\")\n     branch_name = branch_name.strip()\n \n     if branch_name == \"HEAD\":\n         # If we aren't exactly on a branch, pick a branch which represents\n         # the current commit. If all else fails, we are on a branchless\n         # commit.\n         branches, rc = runner(GITS, [\"branch\", \"--contains\"], cwd=root)\n         # --contains was added in git-1.5.4\n         if rc != 0 or branches is None:\n             raise NotThisMethod(\"'git branch --contains' returned error\")\n         branches = branches.split(\"\\n\")\n \n         # Remove the first line if we're running detached\n         if \"(\" in branches[0]:\n             branches.pop(0)\n \n         # Strip off the leading \"* \" from the list of branches.\n         branches = [branch[2:] for branch in branches]\n         if \"master\" in branches:\n             branch_name = \"master\"\n         elif not branches:\n             branch_name = None\n         else:\n             # Pick the first branch that is returned. Good or bad.\n             branch_name = branches[0]\n \n     pieces[\"branch\"] = branch_name\n \n     # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]\n     # TAG might have hyphens.\n     git_describe = describe_out\n \n     # look for -dirty suffix\n     dirty = git_describe.endswith(\"-dirty\")\n     pieces[\"dirty\"] = dirty\n     if dirty:\n         git_describe = git_describe[: git_describe.rindex(\"-dirty\")]\n \n     # now we have TAG-NUM-gHEX or HEX\n \n     if \"-\" in git_describe:\n         # TAG-NUM-gHEX\n         mo = re.search(r\"^(.+)-(\\d+)-g([0-9a-f]+)$\", git_describe)\n         if not mo:\n             # unparsable. Maybe git-describe is misbehaving?\n             pieces[\"error\"] = \"unable to parse git-describe output: '%s'\" % describe_out\n             return pieces\n \n         # tag\n         full_tag = mo.group(1)\n         if not full_tag.startswith(tag_prefix):\n             if verbose:\n                 fmt = \"tag '%s' doesn't start with prefix '%s'\"\n                 print(fmt % (full_tag, tag_prefix))\n             pieces[\"error\"] = \"tag '%s' doesn't start with prefix '%s'\" % (\n                 full_tag,\n                 tag_prefix,\n             )\n             return pieces\n         pieces[\"closest-tag\"] = full_tag[len(tag_prefix) :]\n \n         # distance: number of commits since tag\n         pieces[\"distance\"] = int(mo.group(2))\n \n         # commit: short hex revision ID\n         pieces[\"short\"] = mo.group(3)\n \n     else:\n         # HEX: no tags\n         pieces[\"closest-tag\"] = None\n         count_out, rc = runner(GITS, [\"rev-list\", \"HEAD\", \"--count\"], cwd=root)\n         pieces[\"distance\"] = int(count_out)  # total number of commits\n \n     # commit date: see ISO-8601 comment in git_versions_from_keywords()\n     date = runner(GITS, [\"show\", \"-s\", \"--format=%ci\", \"HEAD\"], cwd=root)[0].strip()\n     # Use only the last line.  Previous lines may contain GPG signature\n     # information.\n     date = date.splitlines()[-1]\n     pieces[\"date\"] = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n \n     return pieces\n \n \n def plus_or_dot(pieces):\n     \"\"\"Return a + if we don't already have one, else return a .\"\"\"\n     if \"+\" in pieces.get(\"closest-tag\", \"\"):\n         return \".\"\n     return \"+\"\n \n \n def render_pep440(pieces):\n     \"\"\"Build up version string, with post-release \"local version identifier\".\n \n     Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n     get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty\n \n     Exceptions:\n     1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += plus_or_dot(pieces)\n             rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n             if pieces[\"dirty\"]:\n                 rendered += \".dirty\"\n     else:\n         # exception #1\n         rendered = \"0+untagged.%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n         if pieces[\"dirty\"]:\n             rendered += \".dirty\"\n     return rendered\n \n \n def render_pep440_branch(pieces):\n     \"\"\"TAG[[.dev0]+DISTANCE.gHEX[.dirty]] .\n \n     The \".dev0\" means not master branch. Note that .dev0 sorts backwards\n     (a feature branch will appear \"older\" than the master branch).\n \n     Exceptions:\n     1: no tags. 0[.dev0]+untagged.DISTANCE.gHEX[.dirty]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             if pieces[\"branch\"] != \"master\":\n                 rendered += \".dev0\"\n             rendered += plus_or_dot(pieces)\n             rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n             if pieces[\"dirty\"]:\n                 rendered += \".dirty\"\n     else:\n         # exception #1\n         rendered = \"0\"\n         if pieces[\"branch\"] != \"master\":\n             rendered += \".dev0\"\n         rendered += \"+untagged.%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n         if pieces[\"dirty\"]:\n             rendered += \".dirty\"\n     return rendered\n \n \n def pep440_split_post(ver):\n     \"\"\"Split pep440 version string at the post-release segment.\n \n     Returns the release segments before the post-release and the\n     post-release version number (or -1 if no post-release segment is present).\n     \"\"\"\n     vc = str.split(ver, \".post\")\n     return vc[0], int(vc[1] or 0) if len(vc) == 2 else None\n \n \n def render_pep440_pre(pieces):\n     \"\"\"TAG[.postN.devDISTANCE] -- No -dirty.\n \n     Exceptions:\n     1: no tags. 0.post0.devDISTANCE\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         if pieces[\"distance\"]:\n             # update the post release segment\n             tag_version, post_version = pep440_split_post(pieces[\"closest-tag\"])\n             rendered = tag_version\n             if post_version is not None:\n                 rendered += \".post%d.dev%d\" % (post_version + 1, pieces[\"distance\"])\n             else:\n                 rendered += \".post0.dev%d\" % (pieces[\"distance\"])\n         else:\n             # no commits, use the tag as the version\n             rendered = pieces[\"closest-tag\"]\n     else:\n         # exception #1\n         rendered = \"0.post0.dev%d\" % pieces[\"distance\"]\n     return rendered\n \n \n def render_pep440_post(pieces):\n     \"\"\"TAG[.postDISTANCE[.dev0]+gHEX] .\n \n     The \".dev0\" means dirty. Note that .dev0 sorts backwards\n     (a dirty tree will appear \"older\" than the corresponding clean one),\n     but you shouldn't be releasing software with -dirty anyways.\n \n     Exceptions:\n     1: no tags. 0.postDISTANCE[.dev0]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += \".post%d\" % pieces[\"distance\"]\n             if pieces[\"dirty\"]:\n                 rendered += \".dev0\"\n             rendered += plus_or_dot(pieces)\n             rendered += \"g%s\" % pieces[\"short\"]\n     else:\n         # exception #1\n         rendered = \"0.post%d\" % pieces[\"distance\"]\n         if pieces[\"dirty\"]:\n             rendered += \".dev0\"\n         rendered += \"+g%s\" % pieces[\"short\"]\n     return rendered\n \n \n def render_pep440_post_branch(pieces):\n     \"\"\"TAG[.postDISTANCE[.dev0]+gHEX[.dirty]] .\n \n     The \".dev0\" means not master branch.\n \n     Exceptions:\n     1: no tags. 0.postDISTANCE[.dev0]+gHEX[.dirty]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += \".post%d\" % pieces[\"distance\"]\n             if pieces[\"branch\"] != \"master\":\n                 rendered += \".dev0\"\n             rendered += plus_or_dot(pieces)\n             rendered += \"g%s\" % pieces[\"short\"]\n             if pieces[\"dirty\"]:\n                 rendered += \".dirty\"\n     else:\n         # exception #1\n         rendered = \"0.post%d\" % pieces[\"distance\"]\n         if pieces[\"branch\"] != \"master\":\n             rendered += \".dev0\"\n         rendered += \"+g%s\" % pieces[\"short\"]\n         if pieces[\"dirty\"]:\n             rendered += \".dirty\"\n     return rendered\n \n \n def render_pep440_old(pieces):\n     \"\"\"TAG[.postDISTANCE[.dev0]] .\n \n     The \".dev0\" means dirty.\n \n     Exceptions:\n     1: no tags. 0.postDISTANCE[.dev0]\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"] or pieces[\"dirty\"]:\n             rendered += \".post%d\" % pieces[\"distance\"]\n             if pieces[\"dirty\"]:\n                 rendered += \".dev0\"\n     else:\n         # exception #1\n         rendered = \"0.post%d\" % pieces[\"distance\"]\n         if pieces[\"dirty\"]:\n             rendered += \".dev0\"\n     return rendered\n \n \n def render_git_describe(pieces):\n     \"\"\"TAG[-DISTANCE-gHEX][-dirty].\n \n     Like 'git describe --tags --dirty --always'.\n \n     Exceptions:\n     1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         if pieces[\"distance\"]:\n             rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n     else:\n         # exception #1\n         rendered = pieces[\"short\"]\n     if pieces[\"dirty\"]:\n         rendered += \"-dirty\"\n     return rendered\n \n \n def render_git_describe_long(pieces):\n     \"\"\"TAG-DISTANCE-gHEX[-dirty].\n \n     Like 'git describe --tags --dirty --always -long'.\n     The distance/hash is unconditional.\n \n     Exceptions:\n     1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n     \"\"\"\n     if pieces[\"closest-tag\"]:\n         rendered = pieces[\"closest-tag\"]\n         rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n     else:\n         # exception #1\n         rendered = pieces[\"short\"]\n     if pieces[\"dirty\"]:\n         rendered += \"-dirty\"\n     return rendered\n \n \n def render(pieces, style):\n     \"\"\"Render the given version pieces into the requested style.\"\"\"\n     if pieces[\"error\"]:\n         return {\n             \"version\": \"unknown\",\n             \"full-revisionid\": pieces.get(\"long\"),\n             \"dirty\": None,\n             \"error\": pieces[\"error\"],\n             \"date\": None,\n         }\n \n     if not style or style == \"default\":\n         style = \"pep440\"  # the default\n \n     if style == \"pep440\":\n         rendered = render_pep440(pieces)\n     elif style == \"pep440-branch\":\n         rendered = render_pep440_branch(pieces)\n     elif style == \"pep440-pre\":\n         rendered = render_pep440_pre(pieces)\n     elif style == \"pep440-post\":\n         rendered = render_pep440_post(pieces)\n     elif style == \"pep440-post-branch\":\n         rendered = render_pep440_post_branch(pieces)\n     elif style == \"pep440-old\":\n         rendered = render_pep440_old(pieces)\n     elif style == \"git-describe\":\n         rendered = render_git_describe(pieces)\n     elif style == \"git-describe-long\":\n         rendered = render_git_describe_long(pieces)\n     else:\n         raise ValueError(\"unknown style '%s'\" % style)\n \n     return {\n         \"version\": rendered,\n         \"full-revisionid\": pieces[\"long\"],\n         \"dirty\": pieces[\"dirty\"],\n         \"error\": None,\n         \"date\": pieces.get(\"date\"),\n     }\n \n \n def get_versions():\n     \"\"\"Get version information or return default if unable to do so.\"\"\"\n     # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have\n     # __file__, we can work backwards from there to the root. Some\n     # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which\n     # case we can only use expanded keywords.\n \n     cfg = get_config()\n     verbose = cfg.verbose\n \n     try:\n         return git_versions_from_keywords(get_keywords(), cfg.tag_prefix, verbose)\n     except NotThisMethod:\n         pass\n \n     try:\n         root = os.path.realpath(__file__)\n         # versionfile_source is the relative path from the top of the source\n         # tree (where the .git directory might live) to this file. Invert\n         # this to find the root from __file__.\n         for _ in cfg.versionfile_source.split(\"/\"):\n             root = os.path.dirname(root)\n     except NameError:\n         return {\n             \"version\": \"0+unknown\",\n             \"full-revisionid\": None,\n             \"dirty\": None,\n             \"error\": \"unable to find root of source tree\",\n             \"date\": None,\n         }\n \n     try:\n         pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)\n         return render(pieces, cfg.style)\n     except NotThisMethod:\n         pass\n \n     try:\n         if cfg.parentdir_prefix:\n             return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n     except NotThisMethod:\n         pass\n \n     return {\n         \"version\": \"0+unknown\",\n         \"full-revisionid\": None,\n         \"dirty\": None,\n         \"error\": \"unable to compute version\",\n         \"date\": None,\n     }\n ", "input_code": "def register_vcs_handler(vcs, method):\n\"\"\"\nCreate decorator to mark a method as the handler of a VCS.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def register_vcs_handler(vcs, method):  # decorator\n    \"\"\"Create decorator to mark a method as the handler of a VCS.\"\"\"\n\n    def decorate(f):\n        \"\"\"Store f in HANDLERS[vcs][method].\"\"\"\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n\n    return decorate", "signature": "def register_vcs_handler(vcs, method):", "completion_path": "src/prestoplot/_version.py"}
{"ce_id": "62b45e945108cfac7f210a4a", "namespace": "62b45e945108cfac7f210a4a", "namespace_real": "ocfl.store.validate_hierarchy", "real_proj_path": "zimeon---ocfl-py/", "type": "class", "class_name": "store", "function_name": "validate_hierarchy", "contexts_above": "\"\"\"OCFL Storage Root library.\n\nThis code uses PyFilesystem (import fs) exclusively for access to files. This\nshould enable application beyond the operating system filesystem.\n\"\"\"\nimport json\nimport logging\nimport re\nimport fs\nfrom fs.copy import copy_dir\n\nfrom .disposition import get_dispositor\nfrom .namaste import find_namastes, Namaste\nfrom .object import Object\nfrom .pyfs import open_fs, ocfl_walk, ocfl_opendir\nfrom .validator import Validator\nfrom .validation_logger import ValidationLogger\n\n\nclass StoreException(Exception):\n    \"\"\"Exception class for OCFL Storage Root.\"\"\"\n\n\nclass Store():\n    \"\"\"Class for handling OCFL Storage Root and include OCFL Objects.\"\"\"\n\n    def __init__(self, root=None, disposition=None, lax_digests=False):\n        \"\"\"Initialize OCFL Storage Root.\"\"\"\n        self.root = root\n        self.disposition = disposition\n        self.lax_digests = lax_digests\n        self._dispositor = None\n        #\n        self.declaration_tvalue = 'ocfl_1.0'\n        self.spec_file = 'ocfl_1.0.txt'\n        self.layout_file = 'ocfl_layout.json'\n        self.registered_extensions = [\n            # '0002-flat-direct-storage-layout',  # not included because doesn't have config\n            '0003-hash-and-id-n-tuple-storage-layout',\n            '0004-hashed-n-tuple-storage-layout'\n        ]\n        #\n        self.root_fs = None\n        self.num_traversal_errors = 0\n        self.extension = None\n        self.description = None\n        self.log = None\n        self.num_objects = 0\n        self.good_objects = 0\n\n    def open_root_fs(self, create=False):\n        \"\"\"Open pyfs filesystem for this OCFL storage root.\"\"\"\n        try:\n            self.root_fs = open_fs(self.root, create=create)\n        except (fs.opener.errors.OpenerError, fs.errors.CreateFailed) as e:\n            raise StoreException(\"Failed to open OCFL storage root filesystem '%s' (%s)\" % (self.root, str(e)))\n\n    @property\n    def dispositor(self):\n        \"\"\"Instance of dispositor class.\n\n        Lazily initialized.\n        \"\"\"\n        if not self._dispositor:\n            self._dispositor = get_dispositor(disposition=self.disposition)\n        return self._dispositor\n\n    def traversal_error(self, code, **kwargs):\n        \"\"\"Record error traversing OCFL storage root.\"\"\"\n        self.num_traversal_errors += 1\n        if self.log is None:  # FIXME - What to do in non-validator context?\n            args = ', '.join('{0}={1!r}'.format(k, v) for k, v in kwargs.items())\n            logging.error(\"Traversal error %s - %s\", code, args)\n        else:\n            self.log.error(code, **kwargs)\n\n    def object_path(self, identifier):\n        \"\"\"Path to OCFL object with given identifier relative to the OCFL storage root.\"\"\"\n        return self.dispositor.identifier_to_path(identifier)\n\n    def initialize(self):\n        \"\"\"Create and initialize a new OCFL storage root.\"\"\"\n        (parent, root_dir) = fs.path.split(self.root)\n        parent_fs = open_fs(parent)\n        if parent_fs.exists(root_dir):\n            raise StoreException(\"OCFL storage root %s already exists, aborting!\" % (self.root))\n        self.root_fs = parent_fs.makedir(root_dir)\n        logging.debug(\"Created OCFL storage root at %s\", self.root)\n        # Create root declaration\n        Namaste(d=0, content=self.declaration_tvalue).write(pyfs=self.root_fs)\n        # Create a layout declaration\n        if self.disposition is not None:\n            with self.root_fs.open(self.layout_file, 'w') as fh:\n                layout = {'extension': self.disposition,\n                          'description': \"Non-standard layout from ocfl-py disposition -- FIXME\"}\n                json.dump(layout, fh, sort_keys=True, indent=2)\n        logging.info(\"Created OCFL storage root %s\", self.root)\n\n    def check_root_structure(self):\n        \"\"\"Check the OCFL storage root structure.\n\n        Assumed that self.root_fs filesystem is available. Raises\n        StoreException if there is an error.\n        \"\"\"\n        # Storage root declaration\n        namastes = find_namastes(0, pyfs=self.root_fs)\n        if len(namastes) == 0:\n            raise StoreException(\"Storage root %s lacks required 0= declaration file\" % (self.root))\n        if len(namastes) > 1:\n            raise StoreException(\"Storage root %s has more than one 0= style declaration file\" % (self.root))\n        if namastes[0].tvalue != self.declaration_tvalue:\n            raise StoreException(\"Storage root %s declaration file not as expected, got %s\" % (self.root, namastes[0].filename))\n        if not namastes[0].content_ok(pyfs=self.root_fs):\n            raise StoreException(\"Storage root %s required declaration file %s has invalid content\" % (self.root, namastes[0].filename))\n        # Specification file and layout file\n        if self.root_fs.exists(self.spec_file) and not self.root_fs.isfile(self.spec_file):\n            raise StoreException(\"Storage root %s includes a specification entry that isn't a file\" % (self.root))\n        self.extension, self.description = self.parse_layout_file()\n        # Other files are allowed...\n        return True\n\n    def parse_layout_file(self):\n        \"\"\"Read and parse layout file in OCFL storage root.\n\n        Returns:\n          - (extension, description) strings on success,\n          - (None, None) if there is now layout file (it is optional)\n          - otherwise raises a StoreException.\n        \"\"\"\n        if self.root_fs.exists(self.layout_file):\n            try:\n                with self.root_fs.open(self.layout_file) as fh:\n                    layout = json.load(fh)\n                if not isinstance(layout, dict):\n                    raise StoreException(\"Storage root %s has layout file that isn't a JSON object\" % (self.root))\n                if ('extension' not in layout or not isinstance(layout['extension'], str)\n                        or 'description' not in layout or not isinstance(layout['description'], str)):\n                    raise StoreException(\"Storage root %s has layout file doesn't have required extension and description string entries\" % (self.root))\n                return layout['extension'], layout['description']\n            except Exception as e:  # FIXME - more specific?\n                raise StoreException(\"OCFL storage root %s has layout file that can't be read (%s)\" % (self.root, str(e)))\n        else:\n            return None, None\n\n    def object_paths(self):\n        \"\"\"Generate object paths for every obect in the OCFL storage root.\n\n        Yields (dirpath) that is the path to the directory for each object\n        located, relative to the OCFL storage root and without a preceding /.\n\n        Will log any errors seen while traversing the directory tree under the\n        storage root.\n        \"\"\"\n        for (dirpath, dirs, files) in ocfl_walk(self.root_fs, is_storage_root=True):\n            if dirpath == '/':\n                if 'extensions' in dirs:\n                    self.validate_extensions_dir()\n                    dirs.remove('extensions')\n                # Ignore any other files in storage root\n            elif (len(dirs) + len(files)) == 0:\n                self.traversal_error(\"E073\", path=dirpath)\n            elif len(files) == 0:\n                pass  # Just an intermediate directory\n            else:\n                # Is this directory an OCFL object? Look for any 0= file.\n                zero_eqs = [file for file in files if file.startswith('0=')]\n                if len(zero_eqs) > 1:\n                    self.traversal_error(\"E003d\", path=dirpath)\n                elif len(zero_eqs) == 1:\n                    declaration = zero_eqs[0]\n                    match = re.match(r'''0=ocfl_object_(\\d+\\.\\d+)''', declaration)\n                    if match and match.group(1) == '1.0':\n                        yield dirpath.lstrip('/')\n                    elif match:\n                        self.traversal_error(\"E004a\", path=dirpath, version=match.group(1))\n                    else:\n                        self.traversal_error(\"E004b\", path=dirpath, declaration=declaration)\n                else:\n                    self.traversal_error(\"E072\", path=dirpath)\n\n    def validate_extensions_dir(self):\n        \"\"\"Validate content of extensions directory inside storage root.\n\n        Validate the extensions directory by checking that there aren't any\n        entries in the extensions directory that aren't directories themselves.\n        Where there are extension directories they SHOULD be registered and\n        this code relies up the registered_extensions property to list known\n        storage root extensions.\n        \"\"\"\n        for entry in self.root_fs.scandir('extensions'):\n            if entry.is_dir:\n                if entry.name not in self.registered_extensions:\n                    self.log.warning('W901', entry=entry.name)  # FIXME - No good warning code in spec\n            else:\n                self.traversal_error('E086', entry=entry.name)\n\n    def list(self):\n        \"\"\"List contents of this OCFL storage root.\"\"\"\n        self.open_root_fs()\n        self.check_root_structure()\n        self.num_objects = 0\n        for dirpath in self.object_paths():\n            with ocfl_opendir(self.root_fs, dirpath) as obj_fs:\n                # Parse inventory to extract id\n                identifier = Object(obj_fs=obj_fs).id_from_inventory()\n                print(\"%s -- id=%s\" % (dirpath, identifier))\n                self.num_objects += 1\n                # FIXME - maybe do some more stuff in here\n        logging.info(\"Found %d OCFL Objects under root %s\", self.num_objects, self.root)\n", "contexts_below": "    def validate(self, validate_objects=True, check_digests=True, show_warnings=False, show_errors=True, lang='en'):\n         \"\"\"Validate OCFL storage root and optionally all objects.\"\"\"\n         valid = True\n         self.log = ValidationLogger(show_warnings=show_warnings, show_errors=show_errors, lang=lang)\n         self.open_root_fs()\n         try:\n             self.check_root_structure()\n             logging.info(\"Storage root structure is VALID\")\n         except StoreException as e:\n             valid = False\n             logging.info(\"Storage root structure is INVALID (%s)\", str(e))\n         self.num_objects, self.good_objects = self.validate_hierarchy(validate_objects=validate_objects, check_digests=check_digests, show_warnings=show_warnings)\n         if validate_objects:\n             if self.good_objects == self.num_objects:\n                 logging.info(\"Objects checked: %d / %d are VALID\", self.good_objects, self.num_objects)\n             else:\n                 valid = False\n                 logging.info(\"Objects checked: %d / %d are INVALID\", self.num_objects - self.good_objects, self.num_objects)\n         else:\n             logging.info(\"Not checking OCFL objects\")\n         print(str(self.log))\n         if self.num_traversal_errors > 0:\n             valid = False\n             logging.info(\"Encountered %d errors traversing storage root\", self.num_traversal_errors)\n         # FIXME - do some stuff in here\n         if valid:\n             logging.info(\"Storage root %s is VALID\", self.root)\n         else:\n             logging.info(\"Storage root %s is INVALID\", self.root)\n         return valid\n \n     def add(self, object_path):\n         \"\"\"Add pre-constructed object from object_path.\"\"\"\n         self.open_root_fs()\n         self.check_root_structure()\n         # Sanity check\n         o = Object()\n         o.open_fs(object_path)\n         inventory = o.parse_inventory()\n         identifier = inventory['id']\n         # Now copy\n         path = self.object_path(identifier)\n         logging.info(\"Copying from %s to %s\", object_path, fs.path.join(self.root, path))\n         try:\n             copy_dir(o.obj_fs, '/', self.root_fs, path)\n             logging.info(\"Copied\")\n         except Exception as e:\n             logging.error(\"Copy failed: %s\", str(e))\n             raise StoreException(\"Add object failed!\")\n ", "input_code": "def validate_hierarchy(self, validate_objects=True, check_digests=True, show_warnings=False):\n\"\"\"\nValidate storage root hierarchy.\n\nReturns:\n    num_objects - number of objects checked\n    good_objects - number of objects checked that were found to be valid\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def validate_hierarchy(self, validate_objects=True, check_digests=True, show_warnings=False):\n        \"\"\"Validate storage root hierarchy.\n\n        Returns:\n            num_objects - number of objects checked\n            good_objects - number of objects checked that were found to be valid\n        \"\"\"\n        num_objects = 0\n        good_objects = 0\n        for dirpath in self.object_paths():\n            if validate_objects:\n                validator = Validator(check_digests=check_digests,\n                                      lax_digests=self.lax_digests,\n                                      show_warnings=show_warnings)\n                if validator.validate(ocfl_opendir(self.root_fs, dirpath)):\n                    good_objects += 1\n                else:\n                    logging.info(\"Object at %s in INVALID\", dirpath)\n                messages = validator.status_str(prefix='[[' + dirpath + ']]')\n                if messages != '':\n                    print(messages)\n                num_objects += 1\n        return num_objects, good_objects", "signature": "def validate_hierarchy(self, validate_objects=True, check_digests=True, show_warnings=False):", "completion_path": "ocfl/store.py"}
{"ce_id": "62b45e515108cfac7f210a3c", "namespace": "62b45e515108cfac7f210a3c", "namespace_real": "ocfl.store.initialize", "real_proj_path": "zimeon---ocfl-py/", "type": "class", "class_name": "store", "function_name": "initialize", "contexts_above": "\"\"\"OCFL Storage Root library.\n\nThis code uses PyFilesystem (import fs) exclusively for access to files. This\nshould enable application beyond the operating system filesystem.\n\"\"\"\nimport json\nimport logging\nimport re\nimport fs\nfrom fs.copy import copy_dir\n\nfrom .disposition import get_dispositor\nfrom .namaste import find_namastes, Namaste\nfrom .object import Object\nfrom .pyfs import open_fs, ocfl_walk, ocfl_opendir\nfrom .validator import Validator\nfrom .validation_logger import ValidationLogger\n\n\nclass StoreException(Exception):\n    \"\"\"Exception class for OCFL Storage Root.\"\"\"\n\n\nclass Store():\n    \"\"\"Class for handling OCFL Storage Root and include OCFL Objects.\"\"\"\n\n    def __init__(self, root=None, disposition=None, lax_digests=False):\n        \"\"\"Initialize OCFL Storage Root.\"\"\"\n        self.root = root\n        self.disposition = disposition\n        self.lax_digests = lax_digests\n        self._dispositor = None\n        #\n        self.declaration_tvalue = 'ocfl_1.0'\n        self.spec_file = 'ocfl_1.0.txt'\n        self.layout_file = 'ocfl_layout.json'\n        self.registered_extensions = [\n            # '0002-flat-direct-storage-layout',  # not included because doesn't have config\n            '0003-hash-and-id-n-tuple-storage-layout',\n            '0004-hashed-n-tuple-storage-layout'\n        ]\n        #\n        self.root_fs = None\n        self.num_traversal_errors = 0\n        self.extension = None\n        self.description = None\n        self.log = None\n        self.num_objects = 0\n        self.good_objects = 0\n\n    def open_root_fs(self, create=False):\n        \"\"\"Open pyfs filesystem for this OCFL storage root.\"\"\"\n        try:\n            self.root_fs = open_fs(self.root, create=create)\n        except (fs.opener.errors.OpenerError, fs.errors.CreateFailed) as e:\n            raise StoreException(\"Failed to open OCFL storage root filesystem '%s' (%s)\" % (self.root, str(e)))\n\n    @property\n    def dispositor(self):\n        \"\"\"Instance of dispositor class.\n\n        Lazily initialized.\n        \"\"\"\n        if not self._dispositor:\n            self._dispositor = get_dispositor(disposition=self.disposition)\n        return self._dispositor\n\n    def traversal_error(self, code, **kwargs):\n        \"\"\"Record error traversing OCFL storage root.\"\"\"\n        self.num_traversal_errors += 1\n        if self.log is None:  # FIXME - What to do in non-validator context?\n            args = ', '.join('{0}={1!r}'.format(k, v) for k, v in kwargs.items())\n            logging.error(\"Traversal error %s - %s\", code, args)\n        else:\n            self.log.error(code, **kwargs)\n\n    def object_path(self, identifier):\n        \"\"\"Path to OCFL object with given identifier relative to the OCFL storage root.\"\"\"\n        return self.dispositor.identifier_to_path(identifier)\n", "contexts_below": "    def check_root_structure(self):\n         \"\"\"Check the OCFL storage root structure.\n \n         Assumed that self.root_fs filesystem is available. Raises\n         StoreException if there is an error.\n         \"\"\"\n         # Storage root declaration\n         namastes = find_namastes(0, pyfs=self.root_fs)\n         if len(namastes) == 0:\n             raise StoreException(\"Storage root %s lacks required 0= declaration file\" % (self.root))\n         if len(namastes) > 1:\n             raise StoreException(\"Storage root %s has more than one 0= style declaration file\" % (self.root))\n         if namastes[0].tvalue != self.declaration_tvalue:\n             raise StoreException(\"Storage root %s declaration file not as expected, got %s\" % (self.root, namastes[0].filename))\n         if not namastes[0].content_ok(pyfs=self.root_fs):\n             raise StoreException(\"Storage root %s required declaration file %s has invalid content\" % (self.root, namastes[0].filename))\n         # Specification file and layout file\n         if self.root_fs.exists(self.spec_file) and not self.root_fs.isfile(self.spec_file):\n             raise StoreException(\"Storage root %s includes a specification entry that isn't a file\" % (self.root))\n         self.extension, self.description = self.parse_layout_file()\n         # Other files are allowed...\n         return True\n \n     def parse_layout_file(self):\n         \"\"\"Read and parse layout file in OCFL storage root.\n \n         Returns:\n           - (extension, description) strings on success,\n           - (None, None) if there is now layout file (it is optional)\n           - otherwise raises a StoreException.\n         \"\"\"\n         if self.root_fs.exists(self.layout_file):\n             try:\n                 with self.root_fs.open(self.layout_file) as fh:\n                     layout = json.load(fh)\n                 if not isinstance(layout, dict):\n                     raise StoreException(\"Storage root %s has layout file that isn't a JSON object\" % (self.root))\n                 if ('extension' not in layout or not isinstance(layout['extension'], str)\n                         or 'description' not in layout or not isinstance(layout['description'], str)):\n                     raise StoreException(\"Storage root %s has layout file doesn't have required extension and description string entries\" % (self.root))\n                 return layout['extension'], layout['description']\n             except Exception as e:  # FIXME - more specific?\n                 raise StoreException(\"OCFL storage root %s has layout file that can't be read (%s)\" % (self.root, str(e)))\n         else:\n             return None, None\n \n     def object_paths(self):\n         \"\"\"Generate object paths for every obect in the OCFL storage root.\n \n         Yields (dirpath) that is the path to the directory for each object\n         located, relative to the OCFL storage root and without a preceding /.\n \n         Will log any errors seen while traversing the directory tree under the\n         storage root.\n         \"\"\"\n         for (dirpath, dirs, files) in ocfl_walk(self.root_fs, is_storage_root=True):\n             if dirpath == '/':\n                 if 'extensions' in dirs:\n                     self.validate_extensions_dir()\n                     dirs.remove('extensions')\n                 # Ignore any other files in storage root\n             elif (len(dirs) + len(files)) == 0:\n                 self.traversal_error(\"E073\", path=dirpath)\n             elif len(files) == 0:\n                 pass  # Just an intermediate directory\n             else:\n                 # Is this directory an OCFL object? Look for any 0= file.\n                 zero_eqs = [file for file in files if file.startswith('0=')]\n                 if len(zero_eqs) > 1:\n                     self.traversal_error(\"E003d\", path=dirpath)\n                 elif len(zero_eqs) == 1:\n                     declaration = zero_eqs[0]\n                     match = re.match(r'''0=ocfl_object_(\\d+\\.\\d+)''', declaration)\n                     if match and match.group(1) == '1.0':\n                         yield dirpath.lstrip('/')\n                     elif match:\n                         self.traversal_error(\"E004a\", path=dirpath, version=match.group(1))\n                     else:\n                         self.traversal_error(\"E004b\", path=dirpath, declaration=declaration)\n                 else:\n                     self.traversal_error(\"E072\", path=dirpath)\n \n     def validate_extensions_dir(self):\n         \"\"\"Validate content of extensions directory inside storage root.\n \n         Validate the extensions directory by checking that there aren't any\n         entries in the extensions directory that aren't directories themselves.\n         Where there are extension directories they SHOULD be registered and\n         this code relies up the registered_extensions property to list known\n         storage root extensions.\n         \"\"\"\n         for entry in self.root_fs.scandir('extensions'):\n             if entry.is_dir:\n                 if entry.name not in self.registered_extensions:\n                     self.log.warning('W901', entry=entry.name)  # FIXME - No good warning code in spec\n             else:\n                 self.traversal_error('E086', entry=entry.name)\n \n     def list(self):\n         \"\"\"List contents of this OCFL storage root.\"\"\"\n         self.open_root_fs()\n         self.check_root_structure()\n         self.num_objects = 0\n         for dirpath in self.object_paths():\n             with ocfl_opendir(self.root_fs, dirpath) as obj_fs:\n                 # Parse inventory to extract id\n                 identifier = Object(obj_fs=obj_fs).id_from_inventory()\n                 print(\"%s -- id=%s\" % (dirpath, identifier))\n                 self.num_objects += 1\n                 # FIXME - maybe do some more stuff in here\n         logging.info(\"Found %d OCFL Objects under root %s\", self.num_objects, self.root)\n \n     def validate_hierarchy(self, validate_objects=True, check_digests=True, show_warnings=False):\n         \"\"\"Validate storage root hierarchy.\n \n         Returns:\n             num_objects - number of objects checked\n             good_objects - number of objects checked that were found to be valid\n         \"\"\"\n         num_objects = 0\n         good_objects = 0\n         for dirpath in self.object_paths():\n             if validate_objects:\n                 validator = Validator(check_digests=check_digests,\n                                       lax_digests=self.lax_digests,\n                                       show_warnings=show_warnings)\n                 if validator.validate(ocfl_opendir(self.root_fs, dirpath)):\n                     good_objects += 1\n                 else:\n                     logging.info(\"Object at %s in INVALID\", dirpath)\n                 messages = validator.status_str(prefix='[[' + dirpath + ']]')\n                 if messages != '':\n                     print(messages)\n                 num_objects += 1\n         return num_objects, good_objects\n \n     def validate(self, validate_objects=True, check_digests=True, show_warnings=False, show_errors=True, lang='en'):\n         \"\"\"Validate OCFL storage root and optionally all objects.\"\"\"\n         valid = True\n         self.log = ValidationLogger(show_warnings=show_warnings, show_errors=show_errors, lang=lang)\n         self.open_root_fs()\n         try:\n             self.check_root_structure()\n             logging.info(\"Storage root structure is VALID\")\n         except StoreException as e:\n             valid = False\n             logging.info(\"Storage root structure is INVALID (%s)\", str(e))\n         self.num_objects, self.good_objects = self.validate_hierarchy(validate_objects=validate_objects, check_digests=check_digests, show_warnings=show_warnings)\n         if validate_objects:\n             if self.good_objects == self.num_objects:\n                 logging.info(\"Objects checked: %d / %d are VALID\", self.good_objects, self.num_objects)\n             else:\n                 valid = False\n                 logging.info(\"Objects checked: %d / %d are INVALID\", self.num_objects - self.good_objects, self.num_objects)\n         else:\n             logging.info(\"Not checking OCFL objects\")\n         print(str(self.log))\n         if self.num_traversal_errors > 0:\n             valid = False\n             logging.info(\"Encountered %d errors traversing storage root\", self.num_traversal_errors)\n         # FIXME - do some stuff in here\n         if valid:\n             logging.info(\"Storage root %s is VALID\", self.root)\n         else:\n             logging.info(\"Storage root %s is INVALID\", self.root)\n         return valid\n \n     def add(self, object_path):\n         \"\"\"Add pre-constructed object from object_path.\"\"\"\n         self.open_root_fs()\n         self.check_root_structure()\n         # Sanity check\n         o = Object()\n         o.open_fs(object_path)\n         inventory = o.parse_inventory()\n         identifier = inventory['id']\n         # Now copy\n         path = self.object_path(identifier)\n         logging.info(\"Copying from %s to %s\", object_path, fs.path.join(self.root, path))\n         try:\n             copy_dir(o.obj_fs, '/', self.root_fs, path)\n             logging.info(\"Copied\")\n         except Exception as e:\n             logging.error(\"Copy failed: %s\", str(e))\n             raise StoreException(\"Add object failed!\")\n ", "input_code": "def initialize(self):\n\"\"\"\nCreate and initialize a new OCFL storage root.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def initialize(self):\n        \"\"\"Create and initialize a new OCFL storage root.\"\"\"\n        (parent, root_dir) = fs.path.split(self.root)\n        parent_fs = open_fs(parent)\n        if parent_fs.exists(root_dir):\n            raise StoreException(\"OCFL storage root %s already exists, aborting!\" % (self.root))\n        self.root_fs = parent_fs.makedir(root_dir)\n        logging.debug(\"Created OCFL storage root at %s\", self.root)\n        # Create root declaration\n        Namaste(d=0, content=self.declaration_tvalue).write(pyfs=self.root_fs)\n        # Create a layout declaration\n        if self.disposition is not None:\n            with self.root_fs.open(self.layout_file, 'w') as fh:\n                layout = {'extension': self.disposition,\n                          'description': \"Non-standard layout from ocfl-py disposition -- FIXME\"}\n                json.dump(layout, fh, sort_keys=True, indent=2)\n        logging.info(\"Created OCFL storage root %s\", self.root)", "signature": "def initialize(self):", "completion_path": "ocfl/store.py"}
{"ce_id": "62b45e2eb89c9fd354170232", "namespace": "62b45e2eb89c9fd354170232", "namespace_real": "ocfl.object_utils.next_version", "real_proj_path": "zimeon---ocfl-py/", "type": "function", "class_name": null, "function_name": "next_version", "contexts_above": "# -*- coding: utf-8 -*-\n\"\"\"Utility functions to support the OCFL Object library.\"\"\"\nimport re\nimport sys\n\nimport fs\nimport fs.path\n\nfrom ._version import __version__\nfrom .namaste import find_namastes\nfrom .pyfs import open_fs\n\n\nNORMALIZATIONS = ['uri', 'md5']  # Must match possibilities in map_filepaths()\n\n\nclass ObjectException(Exception):\n    \"\"\"Exception class for OCFL Object.\"\"\"\n\n\ndef add_object_args(parser):\n    \"\"\"Add Object settings to argparse or argument group instance parser.\"\"\"\n    # Disk scanning\n    parser.add_argument('--skip', action='append', default=['README.md', '.DS_Store'],\n                        help='directories and files to ignore')\n    parser.add_argument('--normalization', '--norm', default=None,\n                        help='filepath normalization strategy (None, %s)' %\n                        (', '.join(NORMALIZATIONS)))\n    # Versioning strategy settings\n    parser.add_argument('--no-forward-delta', action='store_true',\n                        help='do not use forward deltas')\n    parser.add_argument('--no-dedupe', '--no-dedup', action='store_true',\n                        help='do not use deduplicate files within a version')\n    # Validation settings\n    parser.add_argument('--lax-digests', action='store_true',\n                        help='allow use of any known digest')\n    # Object files\n    parser.add_argument('--objdir', '--obj',\n                        help='read from or write to OCFL object directory objdir')\n\n\ndef add_shared_args(parser):\n    \"\"\"Add arguments to be shared by any ocfl-py scripts.\"\"\"\n    parser.add_argument('--verbose', '-v', action='store_true',\n                        help=\"be more verbose\")\n    parser.add_argument('--version', action='store_true',\n                        help='Show version number and exit')\n\n\ndef check_shared_args(args):\n    \"\"\"Check arguments set with add_shared_args.\"\"\"\n    if args.version:\n        print(\"%s is part of ocfl-py version %s\" % (fs.path.basename(sys.argv[0]), __version__))\n        sys.exit(0)\n\n", "contexts_below": "\n def remove_first_directory(path):\n     \"\"\"Remove first directory from input path.\n \n     The return value will not have a trailing parh separator, even if\n     the input path does. Will return an empty string if the input path\n     has just one path segment.\n     \"\"\"\n     # FIXME - how to do this efficiently? Current code does complete\n     # split and rejoins, excluding the first directory\n     rpath = ''\n     while True:\n         (head, tail) = fs.path.split(path)\n         if path in (head, tail):\n             break\n         path = head\n         rpath = tail if rpath == '' else fs.path.join(tail, rpath)\n     return rpath\n \n \n def make_unused_filepath(filepath, used, separator='__'):\n     \"\"\"Find filepath with string appended that makes it disjoint from those in used.\"\"\"\n     n = 1\n     while True:\n         n += 1\n         f = filepath + separator + str(n)\n         if f not in used:\n             return f\n \n \n def find_path_type(path):\n     \"\"\"Return a string indicating the type of thing at the given path.\n \n     Return values:\n         'root' - looks like an OCFL Storage Root\n         'object' - looks like an OCFL Object\n         'file' - a file, might be an inventory\n         other string explains error description\n \n     Looks only at \"0=*\" Namaste files to determine the directory type.\n     \"\"\"\n     try:\n         pyfs = open_fs(path, create=False)\n     except (fs.opener.errors.OpenerError, fs.errors.CreateFailed):\n         # Failed to open path as a filesystem, try enclosing directory\n         # in case path is a file\n         (parent, filename) = fs.path.split(path)\n         try:\n             pyfs = open_fs(parent, create=False)\n         except (fs.opener.errors.OpenerError, fs.errors.CreateFailed) as e:\n             return \"path cannot be opened, and nor can parent (\" + str(e) + \")\"\n         # Can open parent, is filename a file there?\n         try:\n             info = pyfs.getinfo(filename)\n         except fs.errors.ResourceNotFound:\n             return \"path does not exist\"\n         if info.is_dir:\n             return \"directory that could not be opened as a filesystem, this should not happen\"  # pragma: no cover\n         return 'file'\n     namastes = find_namastes(0, pyfs=pyfs)\n     if len(namastes) == 0:\n         return \"no 0= declaration file\"\n     # Look at the first 0= Namaste file that is of OCFL form to determine type, if there are\n     # multiple declarations this will be caught later\n     for namaste in namastes:\n         m = re.match(r'''ocfl(_object)?_(\\d+\\.\\d+)$''', namaste.tvalue)\n         if m:\n             return 'root' if m.group(1) is None else 'object'\n     return \"unrecognized 0= declaration file or files (first is %s)\" % (namastes[0].tvalue)\n ", "input_code": "def next_version(version):\n\"\"\"\nNext version identifier following existing pattern.\n\nMust deal with both zero-prefixed and non-zero prefixed versions.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def next_version(version):\n    \"\"\"Next version identifier following existing pattern.\n\n    Must deal with both zero-prefixed and non-zero prefixed versions.\n    \"\"\"\n    m = re.match(r'''v((\\d)\\d*)$''', version)\n    if not m:\n        raise ObjectException(\"Bad version '%s'\" % version)\n    next_n = int(m.group(1)) + 1\n    if m.group(2) == '0':\n        # Zero-padded version\n        next_v = ('v0%0' + str(len(version) - 2) + 'd') % next_n\n        if len(next_v) != len(version):\n            raise ObjectException(\"Version number overflow for zero-padded version %d to %d\" % (version, next_v))\n        return next_v\n    # Not zero-padded\n    return 'v' + str(next_n)", "signature": "def next_version(version):", "completion_path": "ocfl/object_utils.py"}
{"ce_id": "62b45e23e0d4551b0392c90a", "namespace": "62b45e23e0d4551b0392c90a", "namespace_real": "ocfl.validator.validate_version_inventories", "real_proj_path": "zimeon---ocfl-py/", "type": "class", "class_name": "validator", "function_name": "validate_version_inventories", "contexts_above": "\"\"\"OCFL Validator.\n\nPhilosophy of this code is to keep it separate from the implementations\nof Store, Object and Version used to build and manipulate OCFL data, but\nto leverage lower level functions such as digest creation etc.. Code style\nis plain/verbose with detailed and specific validation errors that might\nhelp someone debug an implementation.\n\nThis code uses PyFilesystem (import fs) exclusively for access to files. This\nshould enable application beyond the operating system filesystem.\n\"\"\"\nimport json\nimport re\nimport fs\n\nfrom .digest import file_digest, normalized_digest\nfrom .inventory_validator import InventoryValidator\nfrom .namaste import find_namastes\nfrom .pyfs import open_fs, ocfl_walk, ocfl_files_identical\nfrom .validation_logger import ValidationLogger\n\n\nclass ValidatorAbortException(Exception):\n    \"\"\"Exception class to bail out of validation.\"\"\"\n\n\nclass Validator():\n    \"\"\"Class for OCFL Validator.\"\"\"\n\n    def __init__(self, log=None, show_warnings=False, show_errors=True, check_digests=True, lax_digests=False, lang='en'):\n        \"\"\"Initialize OCFL validator.\"\"\"\n        self.log = log\n        self.check_digests = check_digests\n        self.lax_digests = lax_digests\n        if self.log is None:\n            self.log = ValidationLogger(show_warnings=show_warnings, show_errors=show_errors, lang=lang)\n        self.registered_extensions = [\n            '0001-digest-algorithms', '0002-flat-direct-storage-layout',\n            '0003-hash-and-id-n-tuple-storage-layout', '0004-hashed-n-tuple-storage-layout',\n            '0005-mutable-head'\n        ]\n        # The following actually initialized in initialize() method\n        self.id = None\n        self.spec_version = None\n        self.digest_algorithm = None\n        self.content_directory = None\n        self.inventory_digest_files = None\n        self.root_inv_validator = None\n        self.obj_fs = None\n        self.initialize()\n\n    def initialize(self):\n        \"\"\"Initialize object state.\n\n        Must be called between attempts to validate objects.\n        \"\"\"\n        self.id = None\n        self.spec_version = '1.0'  # default to latest published version\n        self.digest_algorithm = 'sha512'\n        self.content_directory = 'content'\n        self.inventory_digest_files = {}  # index by version_dir, algorithms may differ\n        self.root_inv_validator = None\n        self.obj_fs = None\n\n    def status_str(self, prefix=''):\n        \"\"\"Return string representation of validation log, with optional prefix.\"\"\"\n        return self.log.status_str(prefix=prefix)\n\n    def __str__(self):\n        \"\"\"Return string representation of validation log.\"\"\"\n        return self.status_str()\n\n    def validate(self, path):\n        \"\"\"Validate OCFL object at path or pyfs root.\n\n        Returns True if valid (warnings permitted), False otherwise.\n        \"\"\"\n        self.initialize()\n        try:\n            if isinstance(path, str):\n                self.obj_fs = open_fs(path)\n            else:\n                self.obj_fs = path\n                path = self.obj_fs.desc('')\n        except fs.errors.CreateFailed:\n            self.log.error('E003e', path=path)\n            return False\n        # Object declaration, set spec version number. If there are multiple declarations,\n        # look for the lastest object version then report any others as errors\n        namastes = find_namastes(0, pyfs=self.obj_fs)\n        if len(namastes) == 0:\n            self.log.error('E003a', assumed_version=self.spec_version)\n        else:\n            spec_version = None\n            for namaste in namastes:\n                # Extract and check spec version number\n                this_file_version = None\n                for version in ('1.1', '1.0'):\n                    if namaste.filename == '0=ocfl_object_' + version:\n                        this_file_version = version\n                        break\n                if this_file_version is None:\n                    self.log.error('E006', filename=namaste.filename)\n                elif spec_version is None or this_file_version > spec_version:\n                    spec_version = this_file_version\n                    if not namaste.content_ok(pyfs=self.obj_fs):\n                        self.log.error('E007', filename=namaste.filename)\n            if spec_version is None:\n                self.log.error('E003c', assumed_version=self.spec_version)\n            else:\n                self.spec_version = spec_version\n                if len(namastes) > 1:\n                    self.log.error('E003b', files=len(namastes), using_version=self.spec_version)\n        # Object root inventory file\n        inv_file = 'inventory.json'\n        if not self.obj_fs.exists(inv_file):\n            self.log.error('E063')\n            return False\n        try:\n            inventory, inv_validator = self.validate_inventory(inv_file)\n            inventory_is_valid = self.log.num_errors == 0\n            self.root_inv_validator = inv_validator\n            all_versions = inv_validator.all_versions\n            self.id = inv_validator.id\n            self.content_directory = inv_validator.content_directory\n            self.digest_algorithm = inv_validator.digest_algorithm\n            self.validate_inventory_digest(inv_file, self.digest_algorithm)\n            # Object root\n            self.validate_object_root(all_versions, already_checked=[namaste.filename for namaste in namastes])\n            # Version inventory files\n            (prior_manifest_digests, prior_fixity_digests) = self.validate_version_inventories(all_versions)\n            if inventory_is_valid:\n                # Object content\n                self.validate_content(inventory, all_versions, prior_manifest_digests, prior_fixity_digests)\n        except ValidatorAbortException:\n            pass\n        return self.log.num_errors == 0\n\n    def validate_inventory(self, inv_file, where='root', extract_spec_version=False):\n        \"\"\"Validate a given inventory file, record errors with self.log.error().\n\n        Returns inventory object for use in later validation\n        of object content. Does not look at anything else in the\n        object itself.\n\n        where - used for reporting messages of where inventory is in object\n\n        extract_spec_version - if set True will attempt to take spec_version from the\n            inventory itself instead of using the spec_version provided\n        \"\"\"\n        try:\n            with self.obj_fs.openbin(inv_file, 'r') as fh:\n                inventory = json.load(fh)\n        except json.decoder.JSONDecodeError as e:\n            self.log.error('E033', where=where, explanation=str(e))\n            raise ValidatorAbortException\n        inv_validator = InventoryValidator(log=self.log, where=where,\n                                           lax_digests=self.lax_digests,\n                                           spec_version=self.spec_version)\n        inv_validator.validate(inventory, extract_spec_version=extract_spec_version)\n        return inventory, inv_validator\n\n    def validate_inventory_digest(self, inv_file, digest_algorithm, where=\"root\"):\n        \"\"\"Validate the appropriate inventory digest file in path.\"\"\"\n        inv_digest_file = inv_file + '.' + digest_algorithm\n        if not self.obj_fs.exists(inv_digest_file):\n            self.log.error('E058a', where=where, path=inv_digest_file)\n        else:\n            self.validate_inventory_digest_match(inv_file, inv_digest_file)\n\n    def validate_inventory_digest_match(self, inv_file, inv_digest_file):\n        \"\"\"Validate a given inventory digest for a given inventory file.\n\n        On error throws exception with debugging string intended to\n        be presented to a user.\n        \"\"\"\n        if not self.check_digests:\n            return\n        m = re.match(r'''.*\\.(\\w+)$''', inv_digest_file)\n        if m:\n            digest_algorithm = m.group(1)\n            try:\n                digest_recorded = self.read_inventory_digest(inv_digest_file)\n                digest_actual = file_digest(inv_file, digest_algorithm, pyfs=self.obj_fs)\n                if digest_actual != digest_recorded:\n                    self.log.error(\"E060\", inv_file=inv_file, actual=digest_actual, recorded=digest_recorded, inv_digest_file=inv_digest_file)\n            except Exception as e:  # pylint: disable=broad-except\n                self.log.error(\"E061\", description=str(e))\n        else:\n            self.log.error(\"E058b\", inv_digest_file=inv_digest_file)\n\n    def validate_object_root(self, version_dirs, already_checked):\n        \"\"\"Validate object root.\n\n        All expected_files must be present and no other files.\n        All expected_dirs must be present and no other dirs.\n        \"\"\"\n        expected_files = ['0=ocfl_object_' + self.spec_version, 'inventory.json',\n                          'inventory.json.' + self.digest_algorithm]\n        for entry in self.obj_fs.scandir(''):\n            if entry.is_file:\n                if entry.name not in expected_files and entry.name not in already_checked:\n                    self.log.error('E001a', file=entry.name)\n            elif entry.is_dir:\n                if entry.name in version_dirs:\n                    pass\n                elif entry.name == 'extensions':\n                    self.validate_extensions_dir()\n                elif re.match(r'''v\\d+$''', entry.name):\n                    # Looks like a version directory so give more specific error\n                    self.log.error('E046b', dir=entry.name)\n                else:\n                    # Simply an unexpected directory\n                    self.log.error('E001b', dir=entry.name)\n            else:\n                self.log.error('E001c', entry=entry.name)\n\n    def validate_extensions_dir(self):\n        \"\"\"Validate content of extensions directory inside object root.\n\n        Validate the extensions directory by checking that there aren't any\n        entries in the extensions directory that aren't directories themselves.\n        Where there are extension directories they SHOULD be registered and\n        this code relies up the registered_extensions property to list known\n        extensions.\n        \"\"\"\n        for entry in self.obj_fs.scandir('extensions'):\n            if entry.is_dir:\n                if entry.name not in self.registered_extensions:\n                    self.log.warning('W013', entry=entry.name)\n            else:\n                self.log.error('E067', entry=entry.name)\n", "contexts_below": "    def validate_content(self, inventory, version_dirs, prior_manifest_digests, prior_fixity_digests):\n         \"\"\"Validate file presence and content against inventory.\n \n         The root inventory in `inventory` is assumed to be valid and safe to use\n         for construction of file paths etc..\n         \"\"\"\n         files_seen = set()\n         # Check files in each version directory\n         for version_dir in version_dirs:\n             try:\n                 # Check contents of version directory except content_directory\n                 for entry in self.obj_fs.listdir(version_dir):\n                     if ((entry == 'inventory.json')\n                             or (version_dir in self.inventory_digest_files and entry == self.inventory_digest_files[version_dir])):\n                         pass\n                     elif entry == self.content_directory:\n                         # Check content_directory\n                         content_path = fs.path.join(version_dir, self.content_directory)\n                         num_content_files_in_version = 0\n                         for dirpath, dirs, files in ocfl_walk(self.obj_fs, content_path):\n                             if dirpath != '/' + content_path and (len(dirs) + len(files)) == 0:\n                                 self.log.error(\"E024\", where=version_dir, path=dirpath)\n                             for file in files:\n                                 files_seen.add(fs.path.join(dirpath, file).lstrip('/'))\n                                 num_content_files_in_version += 1\n                         if num_content_files_in_version == 0:\n                             self.log.warning(\"W003\", where=version_dir)\n                     elif self.obj_fs.isdir(fs.path.join(version_dir, entry)):\n                         self.log.warning(\"W002\", where=version_dir, entry=entry)\n                     else:\n                         self.log.error(\"E015\", where=version_dir, entry=entry)\n             except (fs.errors.ResourceNotFound, fs.errors.DirectoryExpected):\n                 self.log.error('E046a', version_dir=version_dir)\n         # Extract any digests in fixity and organize by filepath\n         fixity_digests = {}\n         if 'fixity' in inventory:\n             for digest_algorithm in inventory['fixity']:\n                 for digest in inventory['fixity'][digest_algorithm]:\n                     for filepath in inventory['fixity'][digest_algorithm][digest]:\n                         if filepath in files_seen:\n                             if filepath not in fixity_digests:\n                                 fixity_digests[filepath] = {}\n                             if digest_algorithm not in fixity_digests[filepath]:\n                                 fixity_digests[filepath][digest_algorithm] = {}\n                             if digest not in fixity_digests[filepath][digest_algorithm]:\n                                 fixity_digests[filepath][digest_algorithm][digest] = ['root']\n                         else:\n                             self.log.error('E093b', where='root', digest_algorithm=digest_algorithm, digest=digest, content_path=filepath)\n         # Check all files in root manifest\n         if 'manifest' in inventory:\n             for digest in inventory['manifest']:\n                 for filepath in inventory['manifest'][digest]:\n                     if filepath not in files_seen:\n                         self.log.error('E092b', where='root', content_path=filepath)\n                     else:\n                         if self.check_digests:\n                             content_digest = file_digest(filepath, digest_type=self.digest_algorithm, pyfs=self.obj_fs)\n                             if content_digest != normalized_digest(digest, digest_type=self.digest_algorithm):\n                                 self.log.error('E092a', where='root', digest_algorithm=self.digest_algorithm, digest=digest, content_path=filepath, content_digest=content_digest)\n                             known_digests = {self.digest_algorithm: content_digest}\n                             # Are there digest values in the fixity block?\n                             self.check_additional_digests(filepath, known_digests, fixity_digests, 'E093a')\n                             # Are there other digests for this same file from other inventories?\n                             self.check_additional_digests(filepath, known_digests, prior_manifest_digests, 'E092a')\n                             self.check_additional_digests(filepath, known_digests, prior_fixity_digests, 'E093a')\n                         files_seen.discard(filepath)\n         # Anything left in files_seen is not mentioned in the inventory\n         if len(files_seen) > 0:\n             self.log.error('E023a', where='root', extra_files=', '.join(sorted(files_seen)))\n \n     def check_additional_digests(self, filepath, known_digests, additional_digests, error_code):\n         \"\"\"Check all the additional digests for filepath.\n \n         This method is intended to be used both for manifest digests in prior versions and\n         for fixity digests. The digests_seen dict is used to store any values calculated\n         so that we don't recalculate digests that might appear multiple times. It is added to\n         with any additional values calculated.\n \n         Parameters:\n             filepath - path of file in object (`v1/content/something` etc.)\n             known_digests - dict of algorithm->digest that we have calculated\n             additional_digests - dict: filepath -> algorithm -> digest -> [versions appears in]\n             error_code - error code to log on mismatch (E092a for manifest, E093a for fixity)\n         \"\"\"\n         if filepath in additional_digests:\n             for digest_algorithm in additional_digests[filepath]:\n                 if digest_algorithm in known_digests:\n                     # Don't recompute anything, just use it if we've seen it before\n                     content_digest = known_digests[digest_algorithm]\n                 else:\n                     content_digest = file_digest(filepath, digest_type=digest_algorithm, pyfs=self.obj_fs)\n                     known_digests[digest_algorithm] = content_digest\n                 for digest in additional_digests[filepath][digest_algorithm]:\n                     if content_digest != normalized_digest(digest, digest_type=digest_algorithm):\n                         where = ','.join(additional_digests[filepath][digest_algorithm][digest])\n                         self.log.error(error_code, where=where, digest_algorithm=digest_algorithm, digest=digest, content_path=filepath, content_digest=content_digest)\n \n     def read_inventory_digest(self, inv_digest_file):\n         \"\"\"Read inventory digest from sidecar file.\n \n         Raise exception if there is an error, else return digest.\n         \"\"\"\n         with self.obj_fs.open(inv_digest_file, 'r') as fh:\n             line = fh.readline()\n             # we ignore any following lines, could raise exception\n         m = re.match(r'''(\\w+)\\s+(\\S+)\\s*$''', line)\n         if not m:\n             raise Exception(\"Bad inventory digest file %s, wrong format\" % (inv_digest_file))\n         if m.group(2) != 'inventory.json':\n             raise Exception(\"Bad inventory name in inventory digest file %s\" % (inv_digest_file))\n         return m.group(1)\n ", "input_code": "def validate_version_inventories(self, version_dirs):\n\"\"\"\nEach version SHOULD have an inventory up to that point.\n\nAlso keep a record of any content digests different from those in the root inventory\nso that we can also check them when validating the content.\n\nversion_dirs is an array of version directory names and is assumed to be in\nversion sequence (1, 2, 3...).\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def validate_version_inventories(self, version_dirs):\n        \"\"\"Each version SHOULD have an inventory up to that point.\n\n        Also keep a record of any content digests different from those in the root inventory\n        so that we can also check them when validating the content.\n\n        version_dirs is an array of version directory names and is assumed to be in\n        version sequence (1, 2, 3...).\n        \"\"\"\n        prior_manifest_digests = {}  # file -> algorithm -> digest -> [versions]\n        prior_fixity_digests = {}  # file -> algorithm -> digest -> [versions]\n        if len(version_dirs) == 0:\n            return prior_manifest_digests, prior_fixity_digests\n        last_version = version_dirs[-1]\n        prev_version_dir = \"NONE\"  # will be set for first directory with inventory\n        prev_spec_version = '1.0'  # lowest version\n        for version_dir in version_dirs:\n            inv_file = fs.path.join(version_dir, 'inventory.json')\n            if not self.obj_fs.exists(inv_file):\n                self.log.warning('W010', where=version_dir)\n                continue\n            # There is an inventory file for this version directory, check it\n            if version_dir == last_version:\n                # Don't validate in this case. Per the spec the inventory in the last version\n                # MUST be identical to the copy in the object root, just check that\n                root_inv_file = 'inventory.json'\n                if not ocfl_files_identical(self.obj_fs, inv_file, root_inv_file):\n                    self.log.error('E064', root_inv_file=root_inv_file, inv_file=inv_file)\n                else:\n                    # We could also just compare digest files but this gives a more helpful error for\n                    # which file has the incorrect digest if they don't match\n                    self.validate_inventory_digest(inv_file, self.digest_algorithm, where=version_dir)\n                self.inventory_digest_files[version_dir] = 'inventory.json.' + self.digest_algorithm\n                this_spec_version = self.spec_version\n            else:\n                # Note that inventories in prior versions may use different digest algorithms\n                # from the current invenotory. Also,\n                # an may accord with the same or earlier versions of the specification\n                version_inventory, inv_validator = self.validate_inventory(inv_file, where=version_dir, extract_spec_version=True)\n                this_spec_version = inv_validator.spec_version\n                digest_algorithm = inv_validator.digest_algorithm\n                self.validate_inventory_digest(inv_file, digest_algorithm, where=version_dir)\n                self.inventory_digest_files[version_dir] = 'inventory.json.' + digest_algorithm\n                if self.id and 'id' in version_inventory:\n                    if version_inventory['id'] != self.id:\n                        self.log.error('E037b', where=version_dir, root_id=self.id, version_id=version_inventory['id'])\n                if 'manifest' in version_inventory:\n                    # Check that all files listed in prior inventories are in manifest\n                    not_seen = set(prior_manifest_digests.keys())\n                    for digest in version_inventory['manifest']:\n                        for filepath in version_inventory['manifest'][digest]:\n                            # We rely on the validation to check that anything present is OK\n                            if filepath in not_seen:\n                                not_seen.remove(filepath)\n                    if len(not_seen) > 0:\n                        self.log.error('E023b', where=version_dir, missing_filepaths=', '.join(sorted(not_seen)))\n                    # Record all prior digests\n                    for unnormalized_digest in version_inventory['manifest']:\n                        digest = normalized_digest(unnormalized_digest, digest_type=digest_algorithm)\n                        for filepath in version_inventory['manifest'][unnormalized_digest]:\n                            if filepath not in prior_manifest_digests:\n                                prior_manifest_digests[filepath] = {}\n                            if digest_algorithm not in prior_manifest_digests[filepath]:\n                                prior_manifest_digests[filepath][digest_algorithm] = {}\n                            if digest not in prior_manifest_digests[filepath][digest_algorithm]:\n                                prior_manifest_digests[filepath][digest_algorithm][digest] = []\n                            prior_manifest_digests[filepath][digest_algorithm][digest].append(version_dir)\n                # Is this inventory an appropriate prior version of the object root inventory?\n                if self.root_inv_validator is not None:\n                    self.root_inv_validator.validate_as_prior_version(inv_validator)\n                # Fixity blocks are independent in each version. Record all values and the versions\n                # they occur in for later checks against content\n                if 'fixity' in version_inventory:\n                    for digest_algorithm in version_inventory['fixity']:\n                        for unnormalized_digest in version_inventory['fixity'][digest_algorithm]:\n                            digest = normalized_digest(unnormalized_digest, digest_type=digest_algorithm)\n                            for filepath in version_inventory['fixity'][digest_algorithm][unnormalized_digest]:\n                                if filepath not in prior_fixity_digests:\n                                    prior_fixity_digests[filepath] = {}\n                                if digest_algorithm not in prior_fixity_digests[filepath]:\n                                    prior_fixity_digests[filepath][digest_algorithm] = {}\n                                if digest not in prior_fixity_digests[filepath][digest_algorithm]:\n                                    prior_fixity_digests[filepath][digest_algorithm][digest] = []\n                                prior_fixity_digests[filepath][digest_algorithm][digest].append(version_dir)\n            # We are validating the inventories in sequence and each new version must\n            # follow the same or later spec version to previous inventories\n            if prev_spec_version > this_spec_version:\n                self.log.error('E103', where=version_dir, this_spec_version=this_spec_version,\n                               prev_version_dir=prev_version_dir, prev_spec_version=prev_spec_version)\n            prev_version_dir = version_dir\n            prev_spec_version = this_spec_version\n        return prior_manifest_digests, prior_fixity_digests", "signature": "def validate_version_inventories(self, version_dirs):", "completion_path": "ocfl/validator.py"}
{"ce_id": "62b45e21e0d4551b0392c8ed", "namespace": "62b45e21e0d4551b0392c8ed", "namespace_real": "ocfl.object_utils.find_path_type", "real_proj_path": "zimeon---ocfl-py/", "type": "function", "class_name": null, "function_name": "find_path_type", "contexts_above": "# -*- coding: utf-8 -*-\n\"\"\"Utility functions to support the OCFL Object library.\"\"\"\nimport re\nimport sys\n\nimport fs\nimport fs.path\n\nfrom ._version import __version__\nfrom .namaste import find_namastes\nfrom .pyfs import open_fs\n\n\nNORMALIZATIONS = ['uri', 'md5']  # Must match possibilities in map_filepaths()\n\n\nclass ObjectException(Exception):\n    \"\"\"Exception class for OCFL Object.\"\"\"\n\n\ndef add_object_args(parser):\n    \"\"\"Add Object settings to argparse or argument group instance parser.\"\"\"\n    # Disk scanning\n    parser.add_argument('--skip', action='append', default=['README.md', '.DS_Store'],\n                        help='directories and files to ignore')\n    parser.add_argument('--normalization', '--norm', default=None,\n                        help='filepath normalization strategy (None, %s)' %\n                        (', '.join(NORMALIZATIONS)))\n    # Versioning strategy settings\n    parser.add_argument('--no-forward-delta', action='store_true',\n                        help='do not use forward deltas')\n    parser.add_argument('--no-dedupe', '--no-dedup', action='store_true',\n                        help='do not use deduplicate files within a version')\n    # Validation settings\n    parser.add_argument('--lax-digests', action='store_true',\n                        help='allow use of any known digest')\n    # Object files\n    parser.add_argument('--objdir', '--obj',\n                        help='read from or write to OCFL object directory objdir')\n\n\ndef add_shared_args(parser):\n    \"\"\"Add arguments to be shared by any ocfl-py scripts.\"\"\"\n    parser.add_argument('--verbose', '-v', action='store_true',\n                        help=\"be more verbose\")\n    parser.add_argument('--version', action='store_true',\n                        help='Show version number and exit')\n\n\ndef check_shared_args(args):\n    \"\"\"Check arguments set with add_shared_args.\"\"\"\n    if args.version:\n        print(\"%s is part of ocfl-py version %s\" % (fs.path.basename(sys.argv[0]), __version__))\n        sys.exit(0)\n\n\ndef next_version(version):\n    \"\"\"Next version identifier following existing pattern.\n\n    Must deal with both zero-prefixed and non-zero prefixed versions.\n    \"\"\"\n    m = re.match(r'''v((\\d)\\d*)$''', version)\n    if not m:\n        raise ObjectException(\"Bad version '%s'\" % version)\n    next_n = int(m.group(1)) + 1\n    if m.group(2) == '0':\n        # Zero-padded version\n        next_v = ('v0%0' + str(len(version) - 2) + 'd') % next_n\n        if len(next_v) != len(version):\n            raise ObjectException(\"Version number overflow for zero-padded version %d to %d\" % (version, next_v))\n        return next_v\n    # Not zero-padded\n    return 'v' + str(next_n)\n\n\ndef remove_first_directory(path):\n    \"\"\"Remove first directory from input path.\n\n    The return value will not have a trailing parh separator, even if\n    the input path does. Will return an empty string if the input path\n    has just one path segment.\n    \"\"\"\n    # FIXME - how to do this efficiently? Current code does complete\n    # split and rejoins, excluding the first directory\n    rpath = ''\n    while True:\n        (head, tail) = fs.path.split(path)\n        if path in (head, tail):\n            break\n        path = head\n        rpath = tail if rpath == '' else fs.path.join(tail, rpath)\n    return rpath\n\n\ndef make_unused_filepath(filepath, used, separator='__'):\n    \"\"\"Find filepath with string appended that makes it disjoint from those in used.\"\"\"\n    n = 1\n    while True:\n        n += 1\n        f = filepath + separator + str(n)\n        if f not in used:\n            return f\n\n", "contexts_below": "", "input_code": "def find_path_type(path):\n\"\"\"\nReturn a string indicating the type of thing at the given path.\n\nReturn values:\n    'root' - looks like an OCFL Storage Root\n    'object' - looks like an OCFL Object\n    'file' - a file, might be an inventory\n    other string explains error description\n\nLooks only at \"0=*\" Namaste files to determine the directory type.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def find_path_type(path):\n    \"\"\"Return a string indicating the type of thing at the given path.\n\n    Return values:\n        'root' - looks like an OCFL Storage Root\n        'object' - looks like an OCFL Object\n        'file' - a file, might be an inventory\n        other string explains error description\n\n    Looks only at \"0=*\" Namaste files to determine the directory type.\n    \"\"\"\n    try:\n        pyfs = open_fs(path, create=False)\n    except (fs.opener.errors.OpenerError, fs.errors.CreateFailed):\n        # Failed to open path as a filesystem, try enclosing directory\n        # in case path is a file\n        (parent, filename) = fs.path.split(path)\n        try:\n            pyfs = open_fs(parent, create=False)\n        except (fs.opener.errors.OpenerError, fs.errors.CreateFailed) as e:\n            return \"path cannot be opened, and nor can parent (\" + str(e) + \")\"\n        # Can open parent, is filename a file there?\n        try:\n            info = pyfs.getinfo(filename)\n        except fs.errors.ResourceNotFound:\n            return \"path does not exist\"\n        if info.is_dir:\n            return \"directory that could not be opened as a filesystem, this should not happen\"  # pragma: no cover\n        return 'file'\n    namastes = find_namastes(0, pyfs=pyfs)\n    if len(namastes) == 0:\n        return \"no 0= declaration file\"\n    # Look at the first 0= Namaste file that is of OCFL form to determine type, if there are\n    # multiple declarations this will be caught later\n    for namaste in namastes:\n        m = re.match(r'''ocfl(_object)?_(\\d+\\.\\d+)$''', namaste.tvalue)\n        if m:\n            return 'root' if m.group(1) is None else 'object'\n    return \"unrecognized 0= declaration file or files (first is %s)\" % (namastes[0].tvalue)", "signature": "def find_path_type(path):", "completion_path": "ocfl/object_utils.py"}
{"ce_id": "62b45b396decaeff903e1001", "namespace": "62b45b396decaeff903e1001", "namespace_real": "auto_nag.bzcleaner.amend_bzparams", "real_proj_path": "mozilla---relman-auto-nag/", "type": "class", "class_name": "bzcleaner", "function_name": "amend_bzparams", "contexts_above": "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this file,\n# You can obtain one at http://mozilla.org/MPL/2.0/.\n\nimport argparse\nimport os\nimport sys\nimport time\nfrom collections import defaultdict\nfrom datetime import datetime\n\nfrom dateutil.relativedelta import relativedelta\nfrom jinja2 import Environment, FileSystemLoader\nfrom libmozdata import utils as lmdutils\nfrom libmozdata.bugzilla import Bugzilla\n\nfrom auto_nag import db, logger, mail, utils\nfrom auto_nag.cache import Cache\nfrom auto_nag.nag_me import Nag\n\n\nclass BzCleaner(object):\n    def __init__(self):\n        super(BzCleaner, self).__init__()\n        self._set_tool_name()\n        self.has_autofix = False\n        self.autofix_changes = {}\n        self.quota_actions = defaultdict(list)\n        self.no_manager = set()\n        self.auto_needinfo = {}\n        self.has_flags = False\n        self.cache = Cache(self.name(), self.max_days_in_cache())\n        self.test_mode = utils.get_config(\"common\", \"test\", False)\n        self.versions = None\n        logger.info(\"Run tool {}\".format(self.get_tool_path()))\n\n    def _set_tool_name(self):\n        module = sys.modules[self.__class__.__module__]\n        base = os.path.dirname(__file__)\n        scripts = os.path.join(base, \"scripts\")\n        self.__tool_path__ = os.path.relpath(module.__file__, scripts)\n        name = os.path.basename(module.__file__)\n        name = os.path.splitext(name)[0]\n        self.__tool_name__ = name\n\n    def init_versions(self):\n        self.versions = utils.get_checked_versions()\n        return bool(self.versions)\n\n    def max_days_in_cache(self):\n        \"\"\"Get the max number of days the data must be kept in cache\"\"\"\n        return self.get_config(\"max_days_in_cache\", -1)\n\n    def preamble(self):\n        return None\n\n    def description(self):\n        \"\"\"Get the description for the help\"\"\"\n        return \"\"\n\n    def name(self):\n        \"\"\"Get the tool name\"\"\"\n        return self.__tool_name__\n\n    def get_tool_path(self):\n        \"\"\"Get the tool path\"\"\"\n        return self.__tool_path__\n\n    def needinfo_template(self):\n        \"\"\"Get the txt template filename\"\"\"\n        return self.name() + \"_needinfo.txt\"\n\n    def template(self):\n        \"\"\"Get the html template filename\"\"\"\n        return self.name() + \".html\"\n\n    def subject(self):\n        \"\"\"Get the partial email subject\"\"\"\n        return self.description()\n\n    def get_email_subject(self, date):\n        \"\"\"Get the email subject with a date or not\"\"\"\n        af = \"[autofix]\" if self.has_autofix else \"\"\n        if date:\n            return \"[autonag]{} {} for the {}\".format(af, self.subject(), date)\n        return \"[autonag]{} {}\".format(af, self.subject())\n\n    def ignore_date(self):\n        \"\"\"Should we ignore the date ?\"\"\"\n        return False\n\n    def must_run(self, date):\n        \"\"\"Check if the tool must run for this date\"\"\"\n        days = self.get_config(\"must_run\", None)\n        if not days:\n            return True\n        weekday = date.weekday()\n        week = utils.get_weekdays()\n        for day in days:\n            if week[day] == weekday:\n                return True\n        return False\n\n    def has_enough_data(self):\n        \"\"\"Check if the tool has enough data to run\"\"\"\n        if self.versions is None:\n            # init_versions() has never been called\n            return True\n        return bool(self.versions)\n\n    def filter_no_nag_keyword(self):\n        \"\"\"If True, then remove the bugs with [no-nag] in whiteboard from the bug list\"\"\"\n        return True\n\n    def add_no_manager(self, bugid):\n        self.no_manager.add(str(bugid))\n\n    def has_assignee(self):\n        return False\n\n    def has_needinfo(self):\n        return False\n\n    def get_mail_to_auto_ni(self, bug):\n        return None\n\n    def all_include_fields(self):\n        return False\n\n    def get_max_ni(self):\n        return -1\n\n    def get_max_actions(self):\n        return -1\n\n    def exclude_no_action_bugs(self):\n        \"\"\"\n        If `True`, then remove bugs that have no actions from the email (e.g.,\n        needinfo got ignored due to exceeding the limit). This is applied only\n        when using the `add_prioritized_action()` method.\n\n        Returning `False` could be useful if we want to list all actions the tool\n        would do if it had no limits.\n        \"\"\"\n        return True\n\n    def ignore_meta(self):\n        return False\n\n    def columns(self):\n        \"\"\"The fields to get for the columns in email report\"\"\"\n        return [\"id\", \"summary\"]\n\n    def sort_columns(self):\n        \"\"\"Returns the key to sort columns\"\"\"\n        return None\n\n    def get_dates(self, date):\n        \"\"\"Get the dates for the bugzilla query (changedafter and changedbefore fields)\"\"\"\n        date = lmdutils.get_date_ymd(date)\n        lookup = self.get_config(\"days_lookup\", 7)\n        start_date = date - relativedelta(days=lookup)\n        end_date = date + relativedelta(days=1)\n\n        return start_date, end_date\n\n    def get_extra_for_template(self):\n        \"\"\"Get extra data to put in the template\"\"\"\n        return {}\n\n    def get_extra_for_needinfo_template(self):\n        \"\"\"Get extra data to put in the needinfo template\"\"\"\n        return {}\n\n    def get_config(self, entry, default=None):\n        return utils.get_config(self.name(), entry, default=default)\n\n    def get_bz_params(self, date):\n        \"\"\"Get the Bugzilla parameters for the search query\"\"\"\n        return {}\n\n    def get_data(self):\n        \"\"\"Get the data structure to use in the bughandler\"\"\"\n        return {}\n\n    def get_summary(self, bug):\n        return \"...\" if bug[\"groups\"] else bug[\"summary\"]\n\n    def has_default_products(self):\n        return True\n\n    def has_product_component(self):\n        return False\n\n    def get_product_component(self):\n        return self.prod_comp\n\n    def get_max_years(self):\n        return self.get_config(\"max-years\", -1)\n\n    def has_access_to_sec_bugs(self):\n        return self.get_config(\"sec\", True)\n\n    def handle_bug(self, bug, data):\n        \"\"\"Implement this function to get all the bugs from the query\"\"\"\n        return bug\n\n    def get_db_extra(self):\n        \"\"\"Get extra information required for db insertion\"\"\"\n        return {\n            bugid: ni_mail\n            for ni_mail, v in self.auto_needinfo.items()\n            for bugid in v[\"bugids\"]\n        }\n\n    def get_auto_ni_skiplist(self):\n        \"\"\"Return a set of email addresses that should never be needinfoed\"\"\"\n        return set(self.get_config(\"needinfo_skiplist\", default=[]))\n\n    def add_auto_ni(self, bugid, data):\n        if not data:\n            return False\n\n        ni_mail = data[\"mail\"]\n        if ni_mail in self.get_auto_ni_skiplist() or utils.is_no_assignee(ni_mail):\n            return False\n        if ni_mail in self.auto_needinfo:\n            max_ni = self.get_max_ni()\n            info = self.auto_needinfo[ni_mail]\n            if max_ni > 0 and len(info[\"bugids\"]) >= max_ni:\n                return False\n            info[\"bugids\"].append(str(bugid))\n        else:\n            self.auto_needinfo[ni_mail] = {\n                \"nickname\": data[\"nickname\"],\n                \"bugids\": [str(bugid)],\n            }\n        return True\n\n    def add_prioritized_action(self, bug, quota_name, needinfo=None, autofix=None):\n        \"\"\"\n        - `quota_name` is the key used to apply the limits, e.g., triage owner, team, or component\n        \"\"\"\n        assert needinfo or autofix\n\n        # Avoid having more than one ni from our bot\n        if needinfo and self.has_bot_set_ni(bug):\n            needinfo = autofix = None\n\n        action = {\n            \"bug\": bug,\n            \"needinfo\": needinfo,\n            \"autofix\": autofix,\n        }\n\n        self.quota_actions[quota_name].append(action)\n\n    def get_bug_sort_key(self, bug):\n        return None\n\n    def _populate_prioritized_actions(self, bugs):\n        max_actions = self.get_max_actions()\n        max_ni = self.get_max_ni()\n        exclude_no_action_bugs = (\n            len(self.quota_actions) > 0 and self.exclude_no_action_bugs()\n        )\n        bugs_with_action = set()\n\n        for actions in self.quota_actions.values():\n            if len(actions) > max_ni or len(actions) > max_actions:\n                actions.sort(\n                    key=lambda action: (\n                        not action[\"needinfo\"],\n                        self.get_bug_sort_key(action[\"bug\"]),\n                    )\n                )\n\n            ni_count = 0\n            actions_count = 0\n            for action in actions:\n                bugid = str(action[\"bug\"][\"id\"])\n                if max_actions > 0 and actions_count >= max_actions:\n                    break\n\n                if action[\"needinfo\"]:\n                    if max_ni > 0 and ni_count >= max_ni:\n                        continue\n\n                    ok = self.add_auto_ni(bugid, action[\"needinfo\"])\n                    if not ok:\n                        # If we can't needinfo, we do not add the autofix\n                        continue\n\n                    if \"extra\" in action[\"needinfo\"]:\n                        self.extra_ni[bugid] = action[\"needinfo\"][\"extra\"]\n\n                    bugs_with_action.add(bugid)\n                    ni_count += 1\n\n                if action[\"autofix\"]:\n                    assert bugid not in self.autofix_changes\n                    self.autofix_changes[bugid] = action[\"autofix\"]\n                    bugs_with_action.add(bugid)\n\n                if action[\"autofix\"] or action[\"needinfo\"]:\n                    actions_count += 1\n\n        if exclude_no_action_bugs:\n            bugs = {id: bug for id, bug in bugs.items() if id in bugs_with_action}\n\n        return bugs\n\n    def bughandler(self, bug, data):\n        \"\"\"bug handler for the Bugzilla query\"\"\"\n        if bug[\"id\"] in self.cache:\n            return\n\n        if self.handle_bug(bug, data) is None:\n            return\n\n        bugid = str(bug[\"id\"])\n        res = {\"id\": bugid}\n\n        auto_ni = self.get_mail_to_auto_ni(bug)\n        self.add_auto_ni(bugid, auto_ni)\n\n        res[\"summary\"] = self.get_summary(bug)\n\n        if self.has_assignee():\n            res[\"assignee\"] = utils.get_name_from_user_detail(bug[\"assigned_to_detail\"])\n\n        if self.has_needinfo():\n            s = set()\n            for flag in utils.get_needinfo(bug):\n                s.add(flag[\"requestee\"])\n            res[\"needinfos\"] = sorted(s)\n\n        if self.has_product_component():\n            for k in [\"product\", \"component\"]:\n                res[k] = bug[k]\n\n        if isinstance(self, Nag):\n            bug = self.set_people_to_nag(bug, res)\n            if not bug:\n                return\n\n        if bugid in data:\n            data[bugid].update(res)\n        else:\n            data[bugid] = res\n\n    def get_products(self):\n        return self.get_config(\"products\") + self.get_config(\"additional_products\", [])\n", "contexts_below": "    def get_bugs(self, date=\"today\", bug_ids=[], chunk_size=None):\n         \"\"\"Get the bugs\"\"\"\n         bugs = self.get_data()\n         params = self.get_bz_params(date)\n         self.amend_bzparams(params, bug_ids)\n         self.query_url = utils.get_bz_search_url(params)\n \n         if isinstance(self, Nag):\n             self.query_params: dict = params\n \n         old_CHUNK_SIZE = Bugzilla.BUGZILLA_CHUNK_SIZE\n         try:\n             if chunk_size:\n                 Bugzilla.BUGZILLA_CHUNK_SIZE = chunk_size\n \n             Bugzilla(\n                 params,\n                 bughandler=self.bughandler,\n                 bugdata=bugs,\n                 timeout=self.get_config(\"bz_query_timeout\"),\n             ).get_data().wait()\n         finally:\n             Bugzilla.BUGZILLA_CHUNK_SIZE = old_CHUNK_SIZE\n \n         self.get_comments(bugs)\n \n         return bugs\n \n     def commenthandler(self, bug, bugid, data):\n         return\n \n     def _commenthandler(self, bug, bugid, data):\n         comments = bug[\"comments\"]\n         bugid = str(bugid)\n         if self.has_last_comment_time():\n             if comments:\n                 data[bugid][\"last_comment\"] = utils.get_human_lag(comments[-1][\"time\"])\n             else:\n                 data[bugid][\"last_comment\"] = \"\"\n \n         self.commenthandler(bug, bugid, data)\n \n     def get_comments(self, bugs):\n         \"\"\"Get the bugs comments\"\"\"\n         if self.has_last_comment_time():\n             bugids = self.get_list_bugs(bugs)\n             Bugzilla(\n                 bugids=bugids, commenthandler=self._commenthandler, commentdata=bugs\n             ).get_data().wait()\n         return bugs\n \n     def has_last_comment_time(self):\n         return False\n \n     def get_list_bugs(self, bugs):\n         return [x[\"id\"] for x in bugs.values()]\n \n     def get_documentation(self):\n         return \"For more information, please visit [auto_nag documentation](https://wiki.mozilla.org/Release_Management/autonag#{}).\".format(\n             self.get_tool_path().replace(\"/\", \".2F\")\n         )\n \n     def has_bot_set_ni(self, bug):\n         if not self.has_flags:\n             raise Exception\n         return utils.has_bot_set_ni(bug)\n \n     def set_needinfo(self):\n         if not self.auto_needinfo:\n             return {}\n \n         template_name = self.needinfo_template()\n         assert bool(template_name)\n         env = Environment(loader=FileSystemLoader(\"templates\"))\n         template = env.get_template(template_name)\n         res = {}\n \n         doc = self.get_documentation()\n \n         for ni_mail, info in self.auto_needinfo.items():\n             nick = info[\"nickname\"]\n             for bugid in info[\"bugids\"]:\n                 data = {\n                     \"comment\": {\"body\": \"\"},\n                     \"flags\": [\n                         {\n                             \"name\": \"needinfo\",\n                             \"requestee\": ni_mail,\n                             \"status\": \"?\",\n                             \"new\": \"true\",\n                         }\n                     ],\n                 }\n \n                 comment = None\n                 if nick:\n                     comment = template.render(\n                         nickname=nick,\n                         extra=self.get_extra_for_needinfo_template(),\n                         plural=utils.plural,\n                         bugid=bugid,\n                         documentation=doc,\n                     )\n                     comment = comment.strip() + \"\\n\"\n                     data[\"comment\"][\"body\"] = comment\n \n                 if bugid not in res:\n                     res[bugid] = data\n                 else:\n                     res[bugid][\"flags\"] += data[\"flags\"]\n                     if comment:\n                         res[bugid][\"comment\"][\"body\"] = comment\n \n         return res\n \n     def has_individual_autofix(self, changes):\n         # check if we have a dictionary with bug numbers as keys\n         # return True if all the keys are bug number\n         # (which means that each bug has its own autofix)\n         return changes and all(\n             isinstance(bugid, int) or bugid.isdigit() for bugid in changes\n         )\n \n     def get_autofix_change(self):\n         \"\"\"Get the change to do to autofix the bugs\"\"\"\n         return self.autofix_changes\n \n     def autofix(self, bugs):\n         \"\"\"Autofix the bugs according to what is returned by get_autofix_change\"\"\"\n         ni_changes = self.set_needinfo()\n         change = self.get_autofix_change()\n \n         if not ni_changes and not change:\n             return bugs\n \n         self.has_autofix = True\n         new_changes = {}\n         if not self.has_individual_autofix(change):\n             bugids = self.get_list_bugs(bugs)\n             for bugid in bugids:\n                 new_changes[bugid] = utils.merge_bz_changes(\n                     change, ni_changes.get(bugid, {})\n                 )\n         else:\n             change = {str(k): v for k, v in change.items()}\n             bugids = set(change.keys()) | set(ni_changes.keys())\n             for bugid in bugids:\n                 mrg = utils.merge_bz_changes(\n                     change.get(bugid, {}), ni_changes.get(bugid, {})\n                 )\n                 if mrg:\n                     new_changes[bugid] = mrg\n \n         if self.dryrun or self.test_mode:\n             for bugid, ch in new_changes.items():\n                 logger.info(\n                     \"The bugs: {}\\n will be autofixed with:\\n{}\".format(bugid, ch)\n                 )\n         else:\n             extra = self.get_db_extra()\n             max_retries = utils.get_config(\"common\", \"bugzilla_max_retries\", 3)\n             for bugid, ch in new_changes.items():\n                 added = False\n                 for _ in range(max_retries):\n                     failures = Bugzilla([str(bugid)]).put(ch)\n                     if failures:\n                         time.sleep(1)\n                     else:\n                         added = True\n                         db.BugChange.add(self.name(), bugid, extra=extra.get(bugid, \"\"))\n                         break\n                 if not added:\n                     self.failure_callback(bugid)\n                     logger.error(\n                         \"{}: Cannot put data for bug {} (change => {}).\".format(\n                             self.name(), bugid, ch\n                         )\n                     )\n \n         return bugs\n \n     def failure_callback(self, bugid):\n         \"\"\"Called on Bugzilla.put failures\"\"\"\n         return\n \n     def terminate(self):\n         \"\"\"Called when everything is done\"\"\"\n         return\n \n     def organize(self, bugs):\n         return utils.organize(bugs, self.columns(), key=self.sort_columns())\n \n     def add_to_cache(self, bugs):\n         \"\"\"Add the bug keys to cache\"\"\"\n         if isinstance(bugs, dict):\n             self.cache.add(bugs.keys())\n         else:\n             self.cache.add(bugs)\n \n     def get_email_data(self, date, bug_ids):\n         bugs = self.get_bugs(date=date, bug_ids=bug_ids)\n         bugs = self._populate_prioritized_actions(bugs)\n         bugs = self.autofix(bugs)\n         self.add_to_cache(bugs)\n         if bugs:\n             return self.organize(bugs)\n \n     def get_email(self, date, bug_ids=[]):\n         \"\"\"Get title and body for the email\"\"\"\n         data = self.get_email_data(date, bug_ids)\n         if data:\n             extra = self.get_extra_for_template()\n             env = Environment(loader=FileSystemLoader(\"templates\"))\n             template = env.get_template(self.template())\n             message = template.render(\n                 date=date,\n                 data=data,\n                 extra=extra,\n                 str=str,\n                 enumerate=enumerate,\n                 plural=utils.plural,\n                 no_manager=self.no_manager,\n                 table_attrs=self.get_config(\"table_attrs\"),\n                 preamble=self.preamble(),\n             )\n             common = env.get_template(\"common.html\")\n             body = common.render(\n                 message=message, query_url=utils.shorten_long_bz_url(self.query_url)\n             )\n             return self.get_email_subject(date), body\n         return None, None\n \n     def send_email(self, date=\"today\"):\n         \"\"\"Send the email\"\"\"\n         if date:\n             date = lmdutils.get_date(date)\n             d = lmdutils.get_date_ymd(date)\n             if isinstance(self, Nag):\n                 self.nag_date: datetime = d\n \n             if not self.must_run(d):\n                 return\n \n         if not self.has_enough_data():\n             logger.info(\"The tool {} hasn't enough data to run\".format(self.name()))\n             return\n \n         login_info = utils.get_login_info()\n         title, body = self.get_email(date)\n         if title:\n             receivers = utils.get_receivers(self.name())\n             status = \"Success\"\n             try:\n                 mail.send(\n                     login_info[\"ldap_username\"],\n                     receivers,\n                     title,\n                     body,\n                     html=True,\n                     login=login_info,\n                     dryrun=self.dryrun,\n                 )\n             except Exception:\n                 logger.exception(\"Tool {}\".format(self.name()))\n                 status = \"Failure\"\n \n             db.Email.add(self.name(), receivers, \"global\", status)\n             if isinstance(self, Nag):\n                 self.send_mails(title, dryrun=self.dryrun)\n         else:\n             name = self.name().upper()\n             if date:\n                 logger.info(\"{}: No data for {}\".format(name, date))\n             else:\n                 logger.info(\"{}: No data\".format(name))\n             logger.info(\"Query: {}\".format(self.query_url))\n \n     def add_custom_arguments(self, parser):\n         pass\n \n     def parse_custom_arguments(self, args):\n         pass\n \n     def get_args_parser(self):\n         \"\"\"Get the argumends from the command line\"\"\"\n         parser = argparse.ArgumentParser(description=self.description())\n         parser.add_argument(\n             \"--production\",\n             dest=\"dryrun\",\n             action=\"store_false\",\n             help=\"If the flag is not passed, just do the query, and print emails to console without emailing anyone\",\n         )\n \n         if not self.ignore_date():\n             parser.add_argument(\n                 \"-D\",\n                 \"--date\",\n                 dest=\"date\",\n                 action=\"store\",\n                 default=\"today\",\n                 help=\"Date for the query\",\n             )\n \n         self.add_custom_arguments(parser)\n \n         return parser\n \n     def run(self):\n         \"\"\"Run the tool\"\"\"\n         args = self.get_args_parser().parse_args()\n         self.parse_custom_arguments(args)\n         date = \"\" if self.ignore_date() else args.date\n         self.dryrun = args.dryrun\n         self.cache.set_dry_run(self.dryrun)\n         try:\n             self.send_email(date=date)\n             self.terminate()\n             logger.info(\"Tool {} has finished.\".format(self.get_tool_path()))\n         except Exception:\n             logger.exception(\"Tool {}\".format(self.name()))\n ", "input_code": "def amend_bzparams(self, params, bug_ids):\n\"\"\"\nAmend the Bugzilla params\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def amend_bzparams(self, params, bug_ids):\n        \"\"\"Amend the Bugzilla params\"\"\"\n        if not self.all_include_fields():\n            if \"include_fields\" in params:\n                fields = params[\"include_fields\"]\n                if isinstance(fields, list):\n                    if \"id\" not in fields:\n                        fields.append(\"id\")\n                elif isinstance(fields, str):\n                    if fields != \"id\":\n                        params[\"include_fields\"] = [fields, \"id\"]\n                else:\n                    params[\"include_fields\"] = [fields, \"id\"]\n            else:\n                params[\"include_fields\"] = [\"id\"]\n\n            params[\"include_fields\"] += [\"summary\", \"groups\"]\n\n            if self.has_assignee() and \"assigned_to\" not in params[\"include_fields\"]:\n                params[\"include_fields\"].append(\"assigned_to\")\n\n            if self.has_product_component():\n                if \"product\" not in params[\"include_fields\"]:\n                    params[\"include_fields\"].append(\"product\")\n                if \"component\" not in params[\"include_fields\"]:\n                    params[\"include_fields\"].append(\"component\")\n\n            if self.has_needinfo() and \"flags\" not in params[\"include_fields\"]:\n                params[\"include_fields\"].append(\"flags\")\n\n        if bug_ids:\n            params[\"bug_id\"] = bug_ids\n\n        if self.filter_no_nag_keyword():\n            n = utils.get_last_field_num(params)\n            params.update(\n                {\n                    \"f\" + n: \"status_whiteboard\",\n                    \"o\" + n: \"notsubstring\",\n                    \"v\" + n: \"[no-nag]\",\n                }\n            )\n\n        if self.ignore_meta():\n            n = utils.get_last_field_num(params)\n            params.update({\"f\" + n: \"keywords\", \"o\" + n: \"nowords\", \"v\" + n: \"meta\"})\n\n        # Limit the checkers to X years. Unlimited if max_years = -1\n        max_years = self.get_max_years()\n        if max_years > 0:\n            n = utils.get_last_field_num(params)\n            params.update(\n                {\n                    f\"f{n}\": \"creation_ts\",\n                    f\"o{n}\": \"greaterthan\",\n                    f\"v{n}\": f\"-{max_years}y\",\n                }\n            )\n\n        if self.has_default_products():\n            params[\"product\"] = self.get_products()\n\n        if not self.has_access_to_sec_bugs():\n            n = utils.get_last_field_num(params)\n            params.update({\"f\" + n: \"bug_group\", \"o\" + n: \"isempty\"})\n\n        self.has_flags = \"flags\" in params.get(\"include_fields\", [])", "signature": "def amend_bzparams(self, params, bug_ids):", "completion_path": "auto_nag/bzcleaner.py"}
{"ce_id": "62b4567ed7d32e5b55cc83d9", "namespace": "62b4567ed7d32e5b55cc83d9", "namespace_real": "borgmatic.config.load.deep_merge_nodes", "real_proj_path": "witten---atticmatic/", "type": "function", "class_name": null, "function_name": "deep_merge_nodes", "contexts_above": "import logging\nimport os\n\nimport ruamel.yaml\n\nlogger = logging.getLogger(__name__)\n\n\nclass Yaml_with_loader_stream(ruamel.yaml.YAML):\n    '''\n    A derived class of ruamel.yaml.YAML that simply tacks the loaded stream (file object) onto the\n    loader class so that it's available anywhere that's passed a loader (in this case,\n    include_configuration() below).\n    '''\n\n    def get_constructor_parser(self, stream):\n        constructor, parser = super(Yaml_with_loader_stream, self).get_constructor_parser(stream)\n        constructor.loader.stream = stream\n        return constructor, parser\n\n\ndef load_configuration(filename):\n    '''\n    Load the given configuration file and return its contents as a data structure of nested dicts\n    and lists.\n\n    Raise ruamel.yaml.error.YAMLError if something goes wrong parsing the YAML, or RecursionError\n    if there are too many recursive includes.\n    '''\n    yaml = Yaml_with_loader_stream(typ='safe')\n    yaml.Constructor = Include_constructor\n\n    return yaml.load(open(filename))\n\n\ndef include_configuration(loader, filename_node):\n    '''\n    Load the given YAML filename (ignoring the given loader so we can use our own) and return its\n    contents as a data structure of nested dicts and lists. If the filename is relative, probe for\n    it within 1. the current working directory and 2. the directory containing the YAML file doing\n    the including.\n\n    Raise FileNotFoundError if an included file was not found.\n    '''\n    include_directories = [os.getcwd(), os.path.abspath(os.path.dirname(loader.stream.name))]\n    include_filename = os.path.expanduser(filename_node.value)\n\n    if not os.path.isabs(include_filename):\n        candidate_filenames = [\n            os.path.join(directory, include_filename) for directory in include_directories\n        ]\n\n        for candidate_filename in candidate_filenames:\n            if os.path.exists(candidate_filename):\n                include_filename = candidate_filename\n                break\n        else:\n            raise FileNotFoundError(\n                f'Could not find include {filename_node.value} at {\" or \".join(candidate_filenames)}'\n            )\n\n    return load_configuration(include_filename)\n\n\nDELETED_NODE = object()\n\n", "contexts_below": "\n class Include_constructor(ruamel.yaml.SafeConstructor):\n     '''\n     A YAML \"constructor\" (a ruamel.yaml concept) that supports a custom \"!include\" tag for including\n     separate YAML configuration files. Example syntax: `retention: !include common.yaml`\n     '''\n \n     def __init__(self, preserve_quotes=None, loader=None):\n         super(Include_constructor, self).__init__(preserve_quotes, loader)\n         self.add_constructor('!include', include_configuration)\n \n     def flatten_mapping(self, node):\n         '''\n         Support the special case of deep merging included configuration into an existing mapping\n         using the YAML '<<' merge key. Example syntax:\n \n         ```\n         retention:\n             keep_daily: 1\n \n         <<: !include common.yaml\n         ```\n \n         These includes are deep merged into the current configuration file. For instance, in this\n         example, any \"retention\" options in common.yaml will get merged into the \"retention\" section\n         in the example configuration file.\n         '''\n         representer = ruamel.yaml.representer.SafeRepresenter()\n \n         for index, (key_node, value_node) in enumerate(node.value):\n             if key_node.tag == u'tag:yaml.org,2002:merge' and value_node.tag == '!include':\n                 included_value = representer.represent_data(self.construct_object(value_node))\n                 node.value[index] = (key_node, included_value)\n \n         super(Include_constructor, self).flatten_mapping(node)\n \n         node.value = deep_merge_nodes(node.value)\n ", "input_code": "def deep_merge_nodes(nodes):\n\"\"\"\nGiven a nested borgmatic configuration data structure as a list of tuples in the form of:\n\n    (\n        ruamel.yaml.nodes.ScalarNode as a key,\n        ruamel.yaml.nodes.MappingNode or other Node as a value,\n    ),\n\n... deep merge any node values corresponding to duplicate keys and return the result. If\nthere are colliding keys with non-MappingNode values (e.g., integers or strings), the last\nof the values wins.\n\nFor instance, given node values of:\n\n    [\n        (\n            ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n            MappingNode(tag='tag:yaml.org,2002:map', value=[\n                (\n                    ScalarNode(tag='tag:yaml.org,2002:str', value='keep_hourly'),\n                    ScalarNode(tag='tag:yaml.org,2002:int', value='24')\n                ),\n                (\n                    ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                    ScalarNode(tag='tag:yaml.org,2002:int', value='7')\n                ),\n            ]),\n        ),\n        (\n            ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n            MappingNode(tag='tag:yaml.org,2002:map', value=[\n                (\n                    ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                    ScalarNode(tag='tag:yaml.org,2002:int', value='5')\n                ),\n            ]),\n        ),\n    ]\n\n... the returned result would be:\n\n    [\n        (\n            ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n            MappingNode(tag='tag:yaml.org,2002:map', value=[\n                (\n                    ScalarNode(tag='tag:yaml.org,2002:str', value='keep_hourly'),\n                    ScalarNode(tag='tag:yaml.org,2002:int', value='24')\n                ),\n                (\n                    ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                    ScalarNode(tag='tag:yaml.org,2002:int', value='5')\n                ),\n            ]),\n        ),\n    ]\n\nThe purpose of deep merging like this is to support, for instance, merging one borgmatic\nconfiguration file into another for reuse, such that a configuration section (\"retention\",\netc.) does not completely replace the corresponding section in a merged file.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def deep_merge_nodes(nodes):\n    '''\n    Given a nested borgmatic configuration data structure as a list of tuples in the form of:\n\n        (\n            ruamel.yaml.nodes.ScalarNode as a key,\n            ruamel.yaml.nodes.MappingNode or other Node as a value,\n        ),\n\n    ... deep merge any node values corresponding to duplicate keys and return the result. If\n    there are colliding keys with non-MappingNode values (e.g., integers or strings), the last\n    of the values wins.\n\n    For instance, given node values of:\n\n        [\n            (\n                ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n                MappingNode(tag='tag:yaml.org,2002:map', value=[\n                    (\n                        ScalarNode(tag='tag:yaml.org,2002:str', value='keep_hourly'),\n                        ScalarNode(tag='tag:yaml.org,2002:int', value='24')\n                    ),\n                    (\n                        ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                        ScalarNode(tag='tag:yaml.org,2002:int', value='7')\n                    ),\n                ]),\n            ),\n            (\n                ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n                MappingNode(tag='tag:yaml.org,2002:map', value=[\n                    (\n                        ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                        ScalarNode(tag='tag:yaml.org,2002:int', value='5')\n                    ),\n                ]),\n            ),\n        ]\n\n    ... the returned result would be:\n\n        [\n            (\n                ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n                MappingNode(tag='tag:yaml.org,2002:map', value=[\n                    (\n                        ScalarNode(tag='tag:yaml.org,2002:str', value='keep_hourly'),\n                        ScalarNode(tag='tag:yaml.org,2002:int', value='24')\n                    ),\n                    (\n                        ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                        ScalarNode(tag='tag:yaml.org,2002:int', value='5')\n                    ),\n                ]),\n            ),\n        ]\n\n    The purpose of deep merging like this is to support, for instance, merging one borgmatic\n    configuration file into another for reuse, such that a configuration section (\"retention\",\n    etc.) does not completely replace the corresponding section in a merged file.\n    '''\n    # Map from original node key/value to the replacement merged node. DELETED_NODE as a replacement\n    # node indications deletion.\n    replaced_nodes = {}\n\n    # To find nodes that require merging, compare each node with each other node.\n    for a_key, a_value in nodes:\n        for b_key, b_value in nodes:\n            # If we've already considered one of the nodes for merging, skip it.\n            if (a_key, a_value) in replaced_nodes or (b_key, b_value) in replaced_nodes:\n                continue\n\n            # If the keys match and the values are different, we need to merge these two A and B nodes.\n            if a_key.tag == b_key.tag and a_key.value == b_key.value and a_value != b_value:\n                # Since we're merging into the B node, consider the A node a duplicate and remove it.\n                replaced_nodes[(a_key, a_value)] = DELETED_NODE\n\n                # If we're dealing with MappingNodes, recurse and merge its values as well.\n                if isinstance(b_value, ruamel.yaml.nodes.MappingNode):\n                    replaced_nodes[(b_key, b_value)] = (\n                        b_key,\n                        ruamel.yaml.nodes.MappingNode(\n                            tag=b_value.tag,\n                            value=deep_merge_nodes(a_value.value + b_value.value),\n                            start_mark=b_value.start_mark,\n                            end_mark=b_value.end_mark,\n                            flow_style=b_value.flow_style,\n                            comment=b_value.comment,\n                            anchor=b_value.anchor,\n                        ),\n                    )\n                # If we're dealing with SequenceNodes, merge by appending one sequence to the other.\n                elif isinstance(b_value, ruamel.yaml.nodes.SequenceNode):\n                    replaced_nodes[(b_key, b_value)] = (\n                        b_key,\n                        ruamel.yaml.nodes.SequenceNode(\n                            tag=b_value.tag,\n                            value=a_value.value + b_value.value,\n                            start_mark=b_value.start_mark,\n                            end_mark=b_value.end_mark,\n                            flow_style=b_value.flow_style,\n                            comment=b_value.comment,\n                            anchor=b_value.anchor,\n                        ),\n                    )\n\n    return [\n        replaced_nodes.get(node, node) for node in nodes if replaced_nodes.get(node) != DELETED_NODE\n    ]", "signature": "def deep_merge_nodes(nodes):", "completion_path": "borgmatic/config/load.py"}
{"ce_id": "62b4567ad7d32e5b55cc83af", "namespace": "62b4567ad7d32e5b55cc83af", "namespace_real": "borgmatic.commands.generate_config.parse_arguments", "real_proj_path": "witten---atticmatic/", "type": "function", "class_name": null, "function_name": "parse_arguments", "contexts_above": "import sys\nfrom argparse import ArgumentParser\n\nfrom borgmatic.config import generate, validate\n\nDEFAULT_DESTINATION_CONFIG_FILENAME = '/etc/borgmatic/config.yaml'\n\n", "contexts_below": "\n def main():  # pragma: no cover\n     try:\n         args = parse_arguments(*sys.argv[1:])\n \n         generate.generate_sample_configuration(\n             args.source_filename,\n             args.destination_filename,\n             validate.schema_filename(),\n             overwrite=args.overwrite,\n         )\n \n         print('Generated a sample configuration file at {}.'.format(args.destination_filename))\n         print()\n         if args.source_filename:\n             print(\n                 'Merged in the contents of configuration file at {}.'.format(args.source_filename)\n             )\n             print('To review the changes made, run:')\n             print()\n             print(\n                 '    diff --unified {} {}'.format(args.source_filename, args.destination_filename)\n             )\n             print()\n         print('Please edit the file to suit your needs. The values are representative.')\n         print('All fields are optional except where indicated.')\n         print()\n         print('If you ever need help: https://torsion.org/borgmatic/#issues')\n     except (ValueError, OSError) as error:\n         print(error, file=sys.stderr)\n         sys.exit(1)\n ", "input_code": "def parse_arguments(*arguments):\n\"\"\"\nGiven command-line arguments with which this script was invoked, parse the arguments and return\nthem as an ArgumentParser instance.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def parse_arguments(*arguments):\n    '''\n    Given command-line arguments with which this script was invoked, parse the arguments and return\n    them as an ArgumentParser instance.\n    '''\n    parser = ArgumentParser(description='Generate a sample borgmatic YAML configuration file.')\n    parser.add_argument(\n        '-s',\n        '--source',\n        dest='source_filename',\n        help='Optional YAML configuration file to merge into the generated configuration, useful for upgrading your configuration',\n    )\n    parser.add_argument(\n        '-d',\n        '--destination',\n        dest='destination_filename',\n        default=DEFAULT_DESTINATION_CONFIG_FILENAME,\n        help='Destination YAML configuration file, default: {}'.format(\n            DEFAULT_DESTINATION_CONFIG_FILENAME\n        ),\n    )\n    parser.add_argument(\n        '--overwrite',\n        default=False,\n        action='store_true',\n        help='Whether to overwrite any existing destination file, defaults to false',\n    )\n\n    return parser.parse_args(arguments)", "signature": "def parse_arguments(*arguments):", "completion_path": "borgmatic/commands/generate_config.py"}
{"ce_id": "62b45679d7d32e5b55cc83a9", "namespace": "62b45679d7d32e5b55cc83a9", "namespace_real": "borgmatic.commands.completion.parser_flags", "real_proj_path": "witten---atticmatic/", "type": "function", "class_name": null, "function_name": "parser_flags", "contexts_above": "from borgmatic.commands import arguments\n\nUPGRADE_MESSAGE = '''\nYour bash completions script is from a different version of borgmatic than is\ncurrently installed. Please upgrade your script so your completions match the\ncommand-line flags in your installed borgmatic! Try this to upgrade:\n\n    sudo sh -c \"borgmatic --bash-completion > $BASH_SOURCE\"\n    source $BASH_SOURCE\n'''\n\n", "contexts_below": "\n def bash_completion():\n     '''\n     Return a bash completion script for the borgmatic command. Produce this by introspecting\n     borgmatic's command-line argument parsers.\n     '''\n     top_level_parser, subparsers = arguments.make_parsers()\n     global_flags = parser_flags(top_level_parser)\n     actions = ' '.join(subparsers.choices.keys())\n \n     # Avert your eyes.\n     return '\\n'.join(\n         (\n             'check_version() {',\n             '    local this_script=\"$(cat \"$BASH_SOURCE\" 2> /dev/null)\"',\n             '    local installed_script=\"$(borgmatic --bash-completion 2> /dev/null)\"',\n             '    if [ \"$this_script\" != \"$installed_script\" ] && [ \"$installed_script\" != \"\" ];'\n             '        then cat << EOF\\n%s\\nEOF' % UPGRADE_MESSAGE,\n             '    fi',\n             '}',\n             'complete_borgmatic() {',\n         )\n         + tuple(\n             '''    if [[ \" ${COMP_WORDS[*]} \" =~ \" %s \" ]]; then\n         COMPREPLY=($(compgen -W \"%s %s %s\" -- \"${COMP_WORDS[COMP_CWORD]}\"))\n         return 0\n     fi'''\n             % (action, parser_flags(subparser), actions, global_flags)\n             for action, subparser in subparsers.choices.items()\n         )\n         + (\n             '    COMPREPLY=($(compgen -W \"%s %s\" -- \"${COMP_WORDS[COMP_CWORD]}\"))'\n             % (actions, global_flags),\n             '    (check_version &)',\n             '}',\n             '\\ncomplete -o bashdefault -o default -F complete_borgmatic borgmatic',\n         )\n     )\n ", "input_code": "def parser_flags(parser):\n\"\"\"\nGiven an argparse.ArgumentParser instance, return its argument flags in a space-separated\nstring.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def parser_flags(parser):\n    '''\n    Given an argparse.ArgumentParser instance, return its argument flags in a space-separated\n    string.\n    '''\n    return ' '.join(option for action in parser._actions for option in action.option_strings)", "signature": "def parser_flags(parser):", "completion_path": "borgmatic/commands/completion.py"}
{"ce_id": "62b45665d7d32e5b55cc8365", "namespace": "62b45665d7d32e5b55cc8365", "namespace_real": "borgmatic.commands.arguments.parse_arguments", "real_proj_path": "witten---atticmatic/", "type": "function", "class_name": null, "function_name": "parse_arguments", "contexts_above": "import collections\nfrom argparse import Action, ArgumentParser\n\nfrom borgmatic.config import collect\n\nSUBPARSER_ALIASES = {\n    'init': ['--init', '-I'],\n    'prune': ['--prune', '-p'],\n    'compact': [],\n    'create': ['--create', '-C'],\n    'check': ['--check', '-k'],\n    'extract': ['--extract', '-x'],\n    'export-tar': ['--export-tar'],\n    'mount': ['--mount', '-m'],\n    'umount': ['--umount', '-u'],\n    'restore': ['--restore', '-r'],\n    'list': ['--list', '-l'],\n    'info': ['--info', '-i'],\n    'borg': [],\n}\n\n\ndef parse_subparser_arguments(unparsed_arguments, subparsers):\n    '''\n    Given a sequence of arguments and a dict from subparser name to argparse.ArgumentParser\n    instance, give each requested action's subparser a shot at parsing all arguments. This allows\n    common arguments like \"--repository\" to be shared across multiple subparsers.\n\n    Return the result as a tuple of (a dict mapping from subparser name to a parsed namespace of\n    arguments, a list of remaining arguments not claimed by any subparser).\n    '''\n    arguments = collections.OrderedDict()\n    remaining_arguments = list(unparsed_arguments)\n    alias_to_subparser_name = {\n        alias: subparser_name\n        for subparser_name, aliases in SUBPARSER_ALIASES.items()\n        for alias in aliases\n    }\n\n    # If the \"borg\" action is used, skip all other subparsers. This avoids confusion like\n    # \"borg list\" triggering borgmatic's own list action.\n    if 'borg' in unparsed_arguments:\n        subparsers = {'borg': subparsers['borg']}\n\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name not in remaining_arguments:\n            continue\n\n        canonical_name = alias_to_subparser_name.get(subparser_name, subparser_name)\n\n        # If a parsed value happens to be the same as the name of a subparser, remove it from the\n        # remaining arguments. This prevents, for instance, \"check --only extract\" from triggering\n        # the \"extract\" subparser.\n        parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)\n        for value in vars(parsed).values():\n            if isinstance(value, str):\n                if value in subparsers:\n                    remaining_arguments.remove(value)\n            elif isinstance(value, list):\n                for item in value:\n                    if item in subparsers:\n                        remaining_arguments.remove(item)\n\n        arguments[canonical_name] = parsed\n\n    # If no actions are explicitly requested, assume defaults: prune, compact, create, and check.\n    if not arguments and '--help' not in unparsed_arguments and '-h' not in unparsed_arguments:\n        for subparser_name in ('prune', 'compact', 'create', 'check'):\n            subparser = subparsers[subparser_name]\n            parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)\n            arguments[subparser_name] = parsed\n\n    remaining_arguments = list(unparsed_arguments)\n\n    # Now ask each subparser, one by one, to greedily consume arguments.\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name not in arguments.keys():\n            continue\n\n        subparser = subparsers[subparser_name]\n        unused_parsed, remaining_arguments = subparser.parse_known_args(remaining_arguments)\n\n    # Special case: If \"borg\" is present in the arguments, consume all arguments after (+1) the\n    # \"borg\" action.\n    if 'borg' in arguments:\n        borg_options_index = remaining_arguments.index('borg') + 1\n        arguments['borg'].options = remaining_arguments[borg_options_index:]\n        remaining_arguments = remaining_arguments[:borg_options_index]\n\n    # Remove the subparser names themselves.\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name in remaining_arguments:\n            remaining_arguments.remove(subparser_name)\n\n    return (arguments, remaining_arguments)\n\n\nclass Extend_action(Action):\n    '''\n    An argparse action to support Python 3.8's \"extend\" action in older versions of Python.\n    '''\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        items = getattr(namespace, self.dest, None)\n\n        if items:\n            items.extend(values)\n        else:\n            setattr(namespace, self.dest, list(values))\n\n\ndef make_parsers():\n    '''\n    Build a top-level parser and its subparsers and return them as a tuple.\n    '''\n    config_paths = collect.get_default_config_paths(expand_home=True)\n    unexpanded_config_paths = collect.get_default_config_paths(expand_home=False)\n\n    global_parser = ArgumentParser(add_help=False)\n    global_parser.register('action', 'extend', Extend_action)\n    global_group = global_parser.add_argument_group('global arguments')\n\n    global_group.add_argument(\n        '-c',\n        '--config',\n        nargs='*',\n        dest='config_paths',\n        default=config_paths,\n        help='Configuration filenames or directories, defaults to: {}'.format(\n            ' '.join(unexpanded_config_paths)\n        ),\n    )\n    global_group.add_argument(\n        '--excludes',\n        dest='excludes_filename',\n        help='Deprecated in favor of exclude_patterns within configuration',\n    )\n    global_group.add_argument(\n        '-n',\n        '--dry-run',\n        dest='dry_run',\n        action='store_true',\n        help='Go through the motions, but do not actually write to any repositories',\n    )\n    global_group.add_argument(\n        '-nc', '--no-color', dest='no_color', action='store_true', help='Disable colored output'\n    )\n    global_group.add_argument(\n        '-v',\n        '--verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Display verbose progress to the console (from only errors to very verbose: -1, 0, 1, or 2)',\n    )\n    global_group.add_argument(\n        '--syslog-verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Log verbose progress to syslog (from only errors to very verbose: -1, 0, 1, or 2). Ignored when console is interactive or --log-file is given',\n    )\n    global_group.add_argument(\n        '--log-file-verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Log verbose progress to log file (from only errors to very verbose: -1, 0, 1, or 2). Only used when --log-file is given',\n    )\n    global_group.add_argument(\n        '--monitoring-verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Log verbose progress to monitoring integrations that support logging (from only errors to very verbose: -1, 0, 1, or 2)',\n    )\n    global_group.add_argument(\n        '--log-file',\n        type=str,\n        default=None,\n        help='Write log messages to this file instead of syslog',\n    )\n    global_group.add_argument(\n        '--override',\n        metavar='SECTION.OPTION=VALUE',\n        nargs='+',\n        dest='overrides',\n        action='extend',\n        help='One or more configuration file options to override with specified values',\n    )\n    global_group.add_argument(\n        '--no-environment-interpolation',\n        dest='resolve_env',\n        action='store_false',\n        help='Do not resolve environment variables in configuration file',\n    )\n    global_group.add_argument(\n        '--bash-completion',\n        default=False,\n        action='store_true',\n        help='Show bash completion script and exit',\n    )\n    global_group.add_argument(\n        '--version',\n        dest='version',\n        default=False,\n        action='store_true',\n        help='Display installed version number of borgmatic and exit',\n    )\n\n    top_level_parser = ArgumentParser(\n        description='''\n            Simple, configuration-driven backup software for servers and workstations. If none of\n            the action options are given, then borgmatic defaults to: prune, compact, create, and\n            check.\n            ''',\n        parents=[global_parser],\n    )\n\n    subparsers = top_level_parser.add_subparsers(\n        title='actions',\n        metavar='',\n        help='Specify zero or more actions. Defaults to prune, compact, create, and check. Use --help with action for details:',\n    )\n    init_parser = subparsers.add_parser(\n        'init',\n        aliases=SUBPARSER_ALIASES['init'],\n        help='Initialize an empty Borg repository',\n        description='Initialize an empty Borg repository',\n        add_help=False,\n    )\n    init_group = init_parser.add_argument_group('init arguments')\n    init_group.add_argument(\n        '-e',\n        '--encryption',\n        dest='encryption_mode',\n        help='Borg repository encryption mode',\n        required=True,\n    )\n    init_group.add_argument(\n        '--append-only',\n        dest='append_only',\n        action='store_true',\n        help='Create an append-only repository',\n    )\n    init_group.add_argument(\n        '--storage-quota',\n        dest='storage_quota',\n        help='Create a repository with a fixed storage quota',\n    )\n    init_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    prune_parser = subparsers.add_parser(\n        'prune',\n        aliases=SUBPARSER_ALIASES['prune'],\n        help='Prune archives according to the retention policy (with Borg 1.2+, run compact afterwards to actually free space)',\n        description='Prune archives according to the retention policy (with Borg 1.2+, run compact afterwards to actually free space)',\n        add_help=False,\n    )\n    prune_group = prune_parser.add_argument_group('prune arguments')\n    prune_group.add_argument(\n        '--stats',\n        dest='stats',\n        default=False,\n        action='store_true',\n        help='Display statistics of archive',\n    )\n    prune_group.add_argument(\n        '--files', dest='files', default=False, action='store_true', help='Show per-file details'\n    )\n    prune_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    compact_parser = subparsers.add_parser(\n        'compact',\n        aliases=SUBPARSER_ALIASES['compact'],\n        help='Compact segments to free space (Borg 1.2+ only)',\n        description='Compact segments to free space (Borg 1.2+ only)',\n        add_help=False,\n    )\n    compact_group = compact_parser.add_argument_group('compact arguments')\n    compact_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress as each segment is compacted',\n    )\n    compact_group.add_argument(\n        '--cleanup-commits',\n        dest='cleanup_commits',\n        default=False,\n        action='store_true',\n        help='Cleanup commit-only 17-byte segment files left behind by Borg 1.1',\n    )\n    compact_group.add_argument(\n        '--threshold',\n        type=int,\n        dest='threshold',\n        help='Minimum saved space percentage threshold for compacting a segment, defaults to 10',\n    )\n    compact_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    create_parser = subparsers.add_parser(\n        'create',\n        aliases=SUBPARSER_ALIASES['create'],\n        help='Create archives (actually perform backups)',\n        description='Create archives (actually perform backups)',\n        add_help=False,\n    )\n    create_group = create_parser.add_argument_group('create arguments')\n    create_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress for each file as it is backed up',\n    )\n    create_group.add_argument(\n        '--stats',\n        dest='stats',\n        default=False,\n        action='store_true',\n        help='Display statistics of archive',\n    )\n    create_group.add_argument(\n        '--files', dest='files', default=False, action='store_true', help='Show per-file details'\n    )\n    create_group.add_argument(\n        '--json', dest='json', default=False, action='store_true', help='Output results as JSON'\n    )\n    create_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    check_parser = subparsers.add_parser(\n        'check',\n        aliases=SUBPARSER_ALIASES['check'],\n        help='Check archives for consistency',\n        description='Check archives for consistency',\n        add_help=False,\n    )\n    check_group = check_parser.add_argument_group('check arguments')\n    check_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress for each file as it is checked',\n    )\n    check_group.add_argument(\n        '--repair',\n        dest='repair',\n        default=False,\n        action='store_true',\n        help='Attempt to repair any inconsistencies found (for interactive use)',\n    )\n    check_group.add_argument(\n        '--only',\n        metavar='CHECK',\n        choices=('repository', 'archives', 'data', 'extract'),\n        dest='only',\n        action='append',\n        help='Run a particular consistency check (repository, archives, data, or extract) instead of configured checks (subject to configured frequency, can specify flag multiple times)',\n    )\n    check_group.add_argument(\n        '--force',\n        default=False,\n        action='store_true',\n        help='Ignore configured check frequencies and run checks unconditionally',\n    )\n    check_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    extract_parser = subparsers.add_parser(\n        'extract',\n        aliases=SUBPARSER_ALIASES['extract'],\n        help='Extract files from a named archive to the current directory',\n        description='Extract a named archive to the current directory',\n        add_help=False,\n    )\n    extract_group = extract_parser.add_argument_group('extract arguments')\n    extract_group.add_argument(\n        '--repository',\n        help='Path of repository to extract, defaults to the configured repository if there is only one',\n    )\n    extract_group.add_argument(\n        '--archive', help='Name of archive to extract (or \"latest\")', required=True\n    )\n    extract_group.add_argument(\n        '--path',\n        '--restore-path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths to extract from archive, defaults to the entire archive',\n    )\n    extract_group.add_argument(\n        '--destination',\n        metavar='PATH',\n        dest='destination',\n        help='Directory to extract files into, defaults to the current directory',\n    )\n    extract_group.add_argument(\n        '--strip-components',\n        type=int,\n        metavar='NUMBER',\n        dest='strip_components',\n        help='Number of leading path components to remove from each extracted path. Skip paths with fewer elements',\n    )\n    extract_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress for each file as it is extracted',\n    )\n    extract_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    export_tar_parser = subparsers.add_parser(\n        'export-tar',\n        aliases=SUBPARSER_ALIASES['export-tar'],\n        help='Export an archive to a tar-formatted file or stream',\n        description='Export an archive to a tar-formatted file or stream',\n        add_help=False,\n    )\n    export_tar_group = export_tar_parser.add_argument_group('export-tar arguments')\n    export_tar_group.add_argument(\n        '--repository',\n        help='Path of repository to export from, defaults to the configured repository if there is only one',\n    )\n    export_tar_group.add_argument(\n        '--archive', help='Name of archive to export (or \"latest\")', required=True\n    )\n    export_tar_group.add_argument(\n        '--path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths to export from archive, defaults to the entire archive',\n    )\n    export_tar_group.add_argument(\n        '--destination',\n        metavar='PATH',\n        dest='destination',\n        help='Path to destination export tar file, or \"-\" for stdout (but be careful about dirtying output with --verbosity or --files)',\n        required=True,\n    )\n    export_tar_group.add_argument(\n        '--tar-filter', help='Name of filter program to pipe data through'\n    )\n    export_tar_group.add_argument(\n        '--files', default=False, action='store_true', help='Show per-file details'\n    )\n    export_tar_group.add_argument(\n        '--strip-components',\n        type=int,\n        metavar='NUMBER',\n        dest='strip_components',\n        help='Number of leading path components to remove from each exported path. Skip paths with fewer elements',\n    )\n    export_tar_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    mount_parser = subparsers.add_parser(\n        'mount',\n        aliases=SUBPARSER_ALIASES['mount'],\n        help='Mount files from a named archive as a FUSE filesystem',\n        description='Mount a named archive as a FUSE filesystem',\n        add_help=False,\n    )\n    mount_group = mount_parser.add_argument_group('mount arguments')\n    mount_group.add_argument(\n        '--repository',\n        help='Path of repository to use, defaults to the configured repository if there is only one',\n    )\n    mount_group.add_argument('--archive', help='Name of archive to mount (or \"latest\")')\n    mount_group.add_argument(\n        '--mount-point',\n        metavar='PATH',\n        dest='mount_point',\n        help='Path where filesystem is to be mounted',\n        required=True,\n    )\n    mount_group.add_argument(\n        '--path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths to mount from archive, defaults to the entire archive',\n    )\n    mount_group.add_argument(\n        '--foreground',\n        dest='foreground',\n        default=False,\n        action='store_true',\n        help='Stay in foreground until ctrl-C is pressed',\n    )\n    mount_group.add_argument('--options', dest='options', help='Extra Borg mount options')\n    mount_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    umount_parser = subparsers.add_parser(\n        'umount',\n        aliases=SUBPARSER_ALIASES['umount'],\n        help='Unmount a FUSE filesystem that was mounted with \"borgmatic mount\"',\n        description='Unmount a mounted FUSE filesystem',\n        add_help=False,\n    )\n    umount_group = umount_parser.add_argument_group('umount arguments')\n    umount_group.add_argument(\n        '--mount-point',\n        metavar='PATH',\n        dest='mount_point',\n        help='Path of filesystem to unmount',\n        required=True,\n    )\n    umount_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    restore_parser = subparsers.add_parser(\n        'restore',\n        aliases=SUBPARSER_ALIASES['restore'],\n        help='Restore database dumps from a named archive',\n        description='Restore database dumps from a named archive. (To extract files instead, use \"borgmatic extract\".)',\n        add_help=False,\n    )\n    restore_group = restore_parser.add_argument_group('restore arguments')\n    restore_group.add_argument(\n        '--repository',\n        help='Path of repository to restore from, defaults to the configured repository if there is only one',\n    )\n    restore_group.add_argument(\n        '--archive', help='Name of archive to restore from (or \"latest\")', required=True\n    )\n    restore_group.add_argument(\n        '--database',\n        metavar='NAME',\n        nargs='+',\n        dest='databases',\n        help='Names of databases to restore from archive, defaults to all databases. Note that any databases to restore must be defined in borgmatic\\'s configuration',\n    )\n    restore_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    list_parser = subparsers.add_parser(\n        'list',\n        aliases=SUBPARSER_ALIASES['list'],\n        help='List archives',\n        description='List archives or the contents of an archive',\n        add_help=False,\n    )\n    list_group = list_parser.add_argument_group('list arguments')\n    list_group.add_argument(\n        '--repository', help='Path of repository to list, defaults to the configured repositories',\n    )\n    list_group.add_argument('--archive', help='Name of archive to list (or \"latest\")')\n    list_group.add_argument(\n        '--path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths or patterns to list from a single selected archive (via \"--archive\"), defaults to listing the entire archive',\n    )\n    list_group.add_argument(\n        '--find',\n        metavar='PATH',\n        nargs='+',\n        dest='find_paths',\n        help='Partial paths or patterns to search for and list across multiple archives',\n    )\n    list_group.add_argument(\n        '--short', default=False, action='store_true', help='Output only archive or path names'\n    )\n    list_group.add_argument('--format', help='Format for file listing')\n    list_group.add_argument(\n        '--json', default=False, action='store_true', help='Output results as JSON'\n    )\n    list_group.add_argument(\n        '-P', '--prefix', help='Only list archive names starting with this prefix'\n    )\n    list_group.add_argument(\n        '-a', '--glob-archives', metavar='GLOB', help='Only list archive names matching this glob'\n    )\n    list_group.add_argument(\n        '--successful',\n        default=True,\n        action='store_true',\n        help='Deprecated in favor of listing successful (non-checkpoint) backups by default in newer versions of Borg',\n    )\n    list_group.add_argument(\n        '--sort-by', metavar='KEYS', help='Comma-separated list of sorting keys'\n    )\n    list_group.add_argument(\n        '--first', metavar='N', help='List first N archives after other filters are applied'\n    )\n    list_group.add_argument(\n        '--last', metavar='N', help='List last N archives after other filters are applied'\n    )\n    list_group.add_argument(\n        '-e', '--exclude', metavar='PATTERN', help='Exclude paths matching the pattern'\n    )\n    list_group.add_argument(\n        '--exclude-from', metavar='FILENAME', help='Exclude paths from exclude file, one per line'\n    )\n    list_group.add_argument('--pattern', help='Include or exclude paths matching a pattern')\n    list_group.add_argument(\n        '--patterns-from',\n        metavar='FILENAME',\n        help='Include or exclude paths matching patterns from pattern file, one per line',\n    )\n    list_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    info_parser = subparsers.add_parser(\n        'info',\n        aliases=SUBPARSER_ALIASES['info'],\n        help='Display summary information on archives',\n        description='Display summary information on archives',\n        add_help=False,\n    )\n    info_group = info_parser.add_argument_group('info arguments')\n    info_group.add_argument(\n        '--repository',\n        help='Path of repository to show info for, defaults to the configured repository if there is only one',\n    )\n    info_group.add_argument('--archive', help='Name of archive to show info for (or \"latest\")')\n    info_group.add_argument(\n        '--json', dest='json', default=False, action='store_true', help='Output results as JSON'\n    )\n    info_group.add_argument(\n        '-P', '--prefix', help='Only show info for archive names starting with this prefix'\n    )\n    info_group.add_argument(\n        '-a',\n        '--glob-archives',\n        metavar='GLOB',\n        help='Only show info for archive names matching this glob',\n    )\n    info_group.add_argument(\n        '--sort-by', metavar='KEYS', help='Comma-separated list of sorting keys'\n    )\n    info_group.add_argument(\n        '--first',\n        metavar='N',\n        help='Show info for first N archives after other filters are applied',\n    )\n    info_group.add_argument(\n        '--last', metavar='N', help='Show info for last N archives after other filters are applied'\n    )\n    info_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    borg_parser = subparsers.add_parser(\n        'borg',\n        aliases=SUBPARSER_ALIASES['borg'],\n        help='Run an arbitrary Borg command',\n        description='Run an arbitrary Borg command based on borgmatic\\'s configuration',\n        add_help=False,\n    )\n    borg_group = borg_parser.add_argument_group('borg arguments')\n    borg_group.add_argument(\n        '--repository',\n        help='Path of repository to pass to Borg, defaults to the configured repositories',\n    )\n    borg_group.add_argument('--archive', help='Name of archive to pass to Borg (or \"latest\")')\n    borg_group.add_argument(\n        '--',\n        metavar='OPTION',\n        dest='options',\n        nargs='+',\n        help='Options to pass to Borg, command first (\"create\", \"list\", etc). \"--\" is optional. To specify the repository or the archive, you must use --repository or --archive instead of providing them here.',\n    )\n    borg_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    return top_level_parser, subparsers\n\n", "contexts_below": "", "input_code": "def parse_arguments(*unparsed_arguments):\n\"\"\"\nGiven command-line arguments with which this script was invoked, parse the arguments and return\nthem as a dict mapping from subparser name (or \"global\") to an argparse.Namespace instance.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def parse_arguments(*unparsed_arguments):\n    '''\n    Given command-line arguments with which this script was invoked, parse the arguments and return\n    them as a dict mapping from subparser name (or \"global\") to an argparse.Namespace instance.\n    '''\n    top_level_parser, subparsers = make_parsers()\n\n    arguments, remaining_arguments = parse_subparser_arguments(\n        unparsed_arguments, subparsers.choices\n    )\n    arguments['global'] = top_level_parser.parse_args(remaining_arguments)\n\n    if arguments['global'].excludes_filename:\n        raise ValueError(\n            'The --excludes option has been replaced with exclude_patterns in configuration'\n        )\n\n    if 'init' in arguments and arguments['global'].dry_run:\n        raise ValueError('The init action cannot be used with the --dry-run option')\n\n    if (\n        'list' in arguments\n        and 'info' in arguments\n        and arguments['list'].json\n        and arguments['info'].json\n    ):\n        raise ValueError('With the --json option, list and info actions cannot be used together')\n\n    return arguments", "signature": "def parse_arguments(*unparsed_arguments):", "completion_path": "borgmatic/commands/arguments.py"}
{"ce_id": "62b45665d7d32e5b55cc8364", "namespace": "62b45665d7d32e5b55cc8364", "namespace_real": "borgmatic.commands.arguments.parse_subparser_arguments", "real_proj_path": "witten---atticmatic/", "type": "function", "class_name": null, "function_name": "parse_subparser_arguments", "contexts_above": "import collections\nfrom argparse import Action, ArgumentParser\n\nfrom borgmatic.config import collect\n\nSUBPARSER_ALIASES = {\n    'init': ['--init', '-I'],\n    'prune': ['--prune', '-p'],\n    'compact': [],\n    'create': ['--create', '-C'],\n    'check': ['--check', '-k'],\n    'extract': ['--extract', '-x'],\n    'export-tar': ['--export-tar'],\n    'mount': ['--mount', '-m'],\n    'umount': ['--umount', '-u'],\n    'restore': ['--restore', '-r'],\n    'list': ['--list', '-l'],\n    'info': ['--info', '-i'],\n    'borg': [],\n}\n\n", "contexts_below": "\n class Extend_action(Action):\n     '''\n     An argparse action to support Python 3.8's \"extend\" action in older versions of Python.\n     '''\n \n     def __call__(self, parser, namespace, values, option_string=None):\n         items = getattr(namespace, self.dest, None)\n \n         if items:\n             items.extend(values)\n         else:\n             setattr(namespace, self.dest, list(values))\n \n \n def make_parsers():\n     '''\n     Build a top-level parser and its subparsers and return them as a tuple.\n     '''\n     config_paths = collect.get_default_config_paths(expand_home=True)\n     unexpanded_config_paths = collect.get_default_config_paths(expand_home=False)\n \n     global_parser = ArgumentParser(add_help=False)\n     global_parser.register('action', 'extend', Extend_action)\n     global_group = global_parser.add_argument_group('global arguments')\n \n     global_group.add_argument(\n         '-c',\n         '--config',\n         nargs='*',\n         dest='config_paths',\n         default=config_paths,\n         help='Configuration filenames or directories, defaults to: {}'.format(\n             ' '.join(unexpanded_config_paths)\n         ),\n     )\n     global_group.add_argument(\n         '--excludes',\n         dest='excludes_filename',\n         help='Deprecated in favor of exclude_patterns within configuration',\n     )\n     global_group.add_argument(\n         '-n',\n         '--dry-run',\n         dest='dry_run',\n         action='store_true',\n         help='Go through the motions, but do not actually write to any repositories',\n     )\n     global_group.add_argument(\n         '-nc', '--no-color', dest='no_color', action='store_true', help='Disable colored output'\n     )\n     global_group.add_argument(\n         '-v',\n         '--verbosity',\n         type=int,\n         choices=range(-1, 3),\n         default=0,\n         help='Display verbose progress to the console (from only errors to very verbose: -1, 0, 1, or 2)',\n     )\n     global_group.add_argument(\n         '--syslog-verbosity',\n         type=int,\n         choices=range(-1, 3),\n         default=0,\n         help='Log verbose progress to syslog (from only errors to very verbose: -1, 0, 1, or 2). Ignored when console is interactive or --log-file is given',\n     )\n     global_group.add_argument(\n         '--log-file-verbosity',\n         type=int,\n         choices=range(-1, 3),\n         default=0,\n         help='Log verbose progress to log file (from only errors to very verbose: -1, 0, 1, or 2). Only used when --log-file is given',\n     )\n     global_group.add_argument(\n         '--monitoring-verbosity',\n         type=int,\n         choices=range(-1, 3),\n         default=0,\n         help='Log verbose progress to monitoring integrations that support logging (from only errors to very verbose: -1, 0, 1, or 2)',\n     )\n     global_group.add_argument(\n         '--log-file',\n         type=str,\n         default=None,\n         help='Write log messages to this file instead of syslog',\n     )\n     global_group.add_argument(\n         '--override',\n         metavar='SECTION.OPTION=VALUE',\n         nargs='+',\n         dest='overrides',\n         action='extend',\n         help='One or more configuration file options to override with specified values',\n     )\n     global_group.add_argument(\n         '--no-environment-interpolation',\n         dest='resolve_env',\n         action='store_false',\n         help='Do not resolve environment variables in configuration file',\n     )\n     global_group.add_argument(\n         '--bash-completion',\n         default=False,\n         action='store_true',\n         help='Show bash completion script and exit',\n     )\n     global_group.add_argument(\n         '--version',\n         dest='version',\n         default=False,\n         action='store_true',\n         help='Display installed version number of borgmatic and exit',\n     )\n \n     top_level_parser = ArgumentParser(\n         description='''\n             Simple, configuration-driven backup software for servers and workstations. If none of\n             the action options are given, then borgmatic defaults to: prune, compact, create, and\n             check.\n             ''',\n         parents=[global_parser],\n     )\n \n     subparsers = top_level_parser.add_subparsers(\n         title='actions',\n         metavar='',\n         help='Specify zero or more actions. Defaults to prune, compact, create, and check. Use --help with action for details:',\n     )\n     init_parser = subparsers.add_parser(\n         'init',\n         aliases=SUBPARSER_ALIASES['init'],\n         help='Initialize an empty Borg repository',\n         description='Initialize an empty Borg repository',\n         add_help=False,\n     )\n     init_group = init_parser.add_argument_group('init arguments')\n     init_group.add_argument(\n         '-e',\n         '--encryption',\n         dest='encryption_mode',\n         help='Borg repository encryption mode',\n         required=True,\n     )\n     init_group.add_argument(\n         '--append-only',\n         dest='append_only',\n         action='store_true',\n         help='Create an append-only repository',\n     )\n     init_group.add_argument(\n         '--storage-quota',\n         dest='storage_quota',\n         help='Create a repository with a fixed storage quota',\n     )\n     init_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     prune_parser = subparsers.add_parser(\n         'prune',\n         aliases=SUBPARSER_ALIASES['prune'],\n         help='Prune archives according to the retention policy (with Borg 1.2+, run compact afterwards to actually free space)',\n         description='Prune archives according to the retention policy (with Borg 1.2+, run compact afterwards to actually free space)',\n         add_help=False,\n     )\n     prune_group = prune_parser.add_argument_group('prune arguments')\n     prune_group.add_argument(\n         '--stats',\n         dest='stats',\n         default=False,\n         action='store_true',\n         help='Display statistics of archive',\n     )\n     prune_group.add_argument(\n         '--files', dest='files', default=False, action='store_true', help='Show per-file details'\n     )\n     prune_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     compact_parser = subparsers.add_parser(\n         'compact',\n         aliases=SUBPARSER_ALIASES['compact'],\n         help='Compact segments to free space (Borg 1.2+ only)',\n         description='Compact segments to free space (Borg 1.2+ only)',\n         add_help=False,\n     )\n     compact_group = compact_parser.add_argument_group('compact arguments')\n     compact_group.add_argument(\n         '--progress',\n         dest='progress',\n         default=False,\n         action='store_true',\n         help='Display progress as each segment is compacted',\n     )\n     compact_group.add_argument(\n         '--cleanup-commits',\n         dest='cleanup_commits',\n         default=False,\n         action='store_true',\n         help='Cleanup commit-only 17-byte segment files left behind by Borg 1.1',\n     )\n     compact_group.add_argument(\n         '--threshold',\n         type=int,\n         dest='threshold',\n         help='Minimum saved space percentage threshold for compacting a segment, defaults to 10',\n     )\n     compact_group.add_argument(\n         '-h', '--help', action='help', help='Show this help message and exit'\n     )\n \n     create_parser = subparsers.add_parser(\n         'create',\n         aliases=SUBPARSER_ALIASES['create'],\n         help='Create archives (actually perform backups)',\n         description='Create archives (actually perform backups)',\n         add_help=False,\n     )\n     create_group = create_parser.add_argument_group('create arguments')\n     create_group.add_argument(\n         '--progress',\n         dest='progress',\n         default=False,\n         action='store_true',\n         help='Display progress for each file as it is backed up',\n     )\n     create_group.add_argument(\n         '--stats',\n         dest='stats',\n         default=False,\n         action='store_true',\n         help='Display statistics of archive',\n     )\n     create_group.add_argument(\n         '--files', dest='files', default=False, action='store_true', help='Show per-file details'\n     )\n     create_group.add_argument(\n         '--json', dest='json', default=False, action='store_true', help='Output results as JSON'\n     )\n     create_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     check_parser = subparsers.add_parser(\n         'check',\n         aliases=SUBPARSER_ALIASES['check'],\n         help='Check archives for consistency',\n         description='Check archives for consistency',\n         add_help=False,\n     )\n     check_group = check_parser.add_argument_group('check arguments')\n     check_group.add_argument(\n         '--progress',\n         dest='progress',\n         default=False,\n         action='store_true',\n         help='Display progress for each file as it is checked',\n     )\n     check_group.add_argument(\n         '--repair',\n         dest='repair',\n         default=False,\n         action='store_true',\n         help='Attempt to repair any inconsistencies found (for interactive use)',\n     )\n     check_group.add_argument(\n         '--only',\n         metavar='CHECK',\n         choices=('repository', 'archives', 'data', 'extract'),\n         dest='only',\n         action='append',\n         help='Run a particular consistency check (repository, archives, data, or extract) instead of configured checks (subject to configured frequency, can specify flag multiple times)',\n     )\n     check_group.add_argument(\n         '--force',\n         default=False,\n         action='store_true',\n         help='Ignore configured check frequencies and run checks unconditionally',\n     )\n     check_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     extract_parser = subparsers.add_parser(\n         'extract',\n         aliases=SUBPARSER_ALIASES['extract'],\n         help='Extract files from a named archive to the current directory',\n         description='Extract a named archive to the current directory',\n         add_help=False,\n     )\n     extract_group = extract_parser.add_argument_group('extract arguments')\n     extract_group.add_argument(\n         '--repository',\n         help='Path of repository to extract, defaults to the configured repository if there is only one',\n     )\n     extract_group.add_argument(\n         '--archive', help='Name of archive to extract (or \"latest\")', required=True\n     )\n     extract_group.add_argument(\n         '--path',\n         '--restore-path',\n         metavar='PATH',\n         nargs='+',\n         dest='paths',\n         help='Paths to extract from archive, defaults to the entire archive',\n     )\n     extract_group.add_argument(\n         '--destination',\n         metavar='PATH',\n         dest='destination',\n         help='Directory to extract files into, defaults to the current directory',\n     )\n     extract_group.add_argument(\n         '--strip-components',\n         type=int,\n         metavar='NUMBER',\n         dest='strip_components',\n         help='Number of leading path components to remove from each extracted path. Skip paths with fewer elements',\n     )\n     extract_group.add_argument(\n         '--progress',\n         dest='progress',\n         default=False,\n         action='store_true',\n         help='Display progress for each file as it is extracted',\n     )\n     extract_group.add_argument(\n         '-h', '--help', action='help', help='Show this help message and exit'\n     )\n \n     export_tar_parser = subparsers.add_parser(\n         'export-tar',\n         aliases=SUBPARSER_ALIASES['export-tar'],\n         help='Export an archive to a tar-formatted file or stream',\n         description='Export an archive to a tar-formatted file or stream',\n         add_help=False,\n     )\n     export_tar_group = export_tar_parser.add_argument_group('export-tar arguments')\n     export_tar_group.add_argument(\n         '--repository',\n         help='Path of repository to export from, defaults to the configured repository if there is only one',\n     )\n     export_tar_group.add_argument(\n         '--archive', help='Name of archive to export (or \"latest\")', required=True\n     )\n     export_tar_group.add_argument(\n         '--path',\n         metavar='PATH',\n         nargs='+',\n         dest='paths',\n         help='Paths to export from archive, defaults to the entire archive',\n     )\n     export_tar_group.add_argument(\n         '--destination',\n         metavar='PATH',\n         dest='destination',\n         help='Path to destination export tar file, or \"-\" for stdout (but be careful about dirtying output with --verbosity or --files)',\n         required=True,\n     )\n     export_tar_group.add_argument(\n         '--tar-filter', help='Name of filter program to pipe data through'\n     )\n     export_tar_group.add_argument(\n         '--files', default=False, action='store_true', help='Show per-file details'\n     )\n     export_tar_group.add_argument(\n         '--strip-components',\n         type=int,\n         metavar='NUMBER',\n         dest='strip_components',\n         help='Number of leading path components to remove from each exported path. Skip paths with fewer elements',\n     )\n     export_tar_group.add_argument(\n         '-h', '--help', action='help', help='Show this help message and exit'\n     )\n \n     mount_parser = subparsers.add_parser(\n         'mount',\n         aliases=SUBPARSER_ALIASES['mount'],\n         help='Mount files from a named archive as a FUSE filesystem',\n         description='Mount a named archive as a FUSE filesystem',\n         add_help=False,\n     )\n     mount_group = mount_parser.add_argument_group('mount arguments')\n     mount_group.add_argument(\n         '--repository',\n         help='Path of repository to use, defaults to the configured repository if there is only one',\n     )\n     mount_group.add_argument('--archive', help='Name of archive to mount (or \"latest\")')\n     mount_group.add_argument(\n         '--mount-point',\n         metavar='PATH',\n         dest='mount_point',\n         help='Path where filesystem is to be mounted',\n         required=True,\n     )\n     mount_group.add_argument(\n         '--path',\n         metavar='PATH',\n         nargs='+',\n         dest='paths',\n         help='Paths to mount from archive, defaults to the entire archive',\n     )\n     mount_group.add_argument(\n         '--foreground',\n         dest='foreground',\n         default=False,\n         action='store_true',\n         help='Stay in foreground until ctrl-C is pressed',\n     )\n     mount_group.add_argument('--options', dest='options', help='Extra Borg mount options')\n     mount_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     umount_parser = subparsers.add_parser(\n         'umount',\n         aliases=SUBPARSER_ALIASES['umount'],\n         help='Unmount a FUSE filesystem that was mounted with \"borgmatic mount\"',\n         description='Unmount a mounted FUSE filesystem',\n         add_help=False,\n     )\n     umount_group = umount_parser.add_argument_group('umount arguments')\n     umount_group.add_argument(\n         '--mount-point',\n         metavar='PATH',\n         dest='mount_point',\n         help='Path of filesystem to unmount',\n         required=True,\n     )\n     umount_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     restore_parser = subparsers.add_parser(\n         'restore',\n         aliases=SUBPARSER_ALIASES['restore'],\n         help='Restore database dumps from a named archive',\n         description='Restore database dumps from a named archive. (To extract files instead, use \"borgmatic extract\".)',\n         add_help=False,\n     )\n     restore_group = restore_parser.add_argument_group('restore arguments')\n     restore_group.add_argument(\n         '--repository',\n         help='Path of repository to restore from, defaults to the configured repository if there is only one',\n     )\n     restore_group.add_argument(\n         '--archive', help='Name of archive to restore from (or \"latest\")', required=True\n     )\n     restore_group.add_argument(\n         '--database',\n         metavar='NAME',\n         nargs='+',\n         dest='databases',\n         help='Names of databases to restore from archive, defaults to all databases. Note that any databases to restore must be defined in borgmatic\\'s configuration',\n     )\n     restore_group.add_argument(\n         '-h', '--help', action='help', help='Show this help message and exit'\n     )\n \n     list_parser = subparsers.add_parser(\n         'list',\n         aliases=SUBPARSER_ALIASES['list'],\n         help='List archives',\n         description='List archives or the contents of an archive',\n         add_help=False,\n     )\n     list_group = list_parser.add_argument_group('list arguments')\n     list_group.add_argument(\n         '--repository', help='Path of repository to list, defaults to the configured repositories',\n     )\n     list_group.add_argument('--archive', help='Name of archive to list (or \"latest\")')\n     list_group.add_argument(\n         '--path',\n         metavar='PATH',\n         nargs='+',\n         dest='paths',\n         help='Paths or patterns to list from a single selected archive (via \"--archive\"), defaults to listing the entire archive',\n     )\n     list_group.add_argument(\n         '--find',\n         metavar='PATH',\n         nargs='+',\n         dest='find_paths',\n         help='Partial paths or patterns to search for and list across multiple archives',\n     )\n     list_group.add_argument(\n         '--short', default=False, action='store_true', help='Output only archive or path names'\n     )\n     list_group.add_argument('--format', help='Format for file listing')\n     list_group.add_argument(\n         '--json', default=False, action='store_true', help='Output results as JSON'\n     )\n     list_group.add_argument(\n         '-P', '--prefix', help='Only list archive names starting with this prefix'\n     )\n     list_group.add_argument(\n         '-a', '--glob-archives', metavar='GLOB', help='Only list archive names matching this glob'\n     )\n     list_group.add_argument(\n         '--successful',\n         default=True,\n         action='store_true',\n         help='Deprecated in favor of listing successful (non-checkpoint) backups by default in newer versions of Borg',\n     )\n     list_group.add_argument(\n         '--sort-by', metavar='KEYS', help='Comma-separated list of sorting keys'\n     )\n     list_group.add_argument(\n         '--first', metavar='N', help='List first N archives after other filters are applied'\n     )\n     list_group.add_argument(\n         '--last', metavar='N', help='List last N archives after other filters are applied'\n     )\n     list_group.add_argument(\n         '-e', '--exclude', metavar='PATTERN', help='Exclude paths matching the pattern'\n     )\n     list_group.add_argument(\n         '--exclude-from', metavar='FILENAME', help='Exclude paths from exclude file, one per line'\n     )\n     list_group.add_argument('--pattern', help='Include or exclude paths matching a pattern')\n     list_group.add_argument(\n         '--patterns-from',\n         metavar='FILENAME',\n         help='Include or exclude paths matching patterns from pattern file, one per line',\n     )\n     list_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     info_parser = subparsers.add_parser(\n         'info',\n         aliases=SUBPARSER_ALIASES['info'],\n         help='Display summary information on archives',\n         description='Display summary information on archives',\n         add_help=False,\n     )\n     info_group = info_parser.add_argument_group('info arguments')\n     info_group.add_argument(\n         '--repository',\n         help='Path of repository to show info for, defaults to the configured repository if there is only one',\n     )\n     info_group.add_argument('--archive', help='Name of archive to show info for (or \"latest\")')\n     info_group.add_argument(\n         '--json', dest='json', default=False, action='store_true', help='Output results as JSON'\n     )\n     info_group.add_argument(\n         '-P', '--prefix', help='Only show info for archive names starting with this prefix'\n     )\n     info_group.add_argument(\n         '-a',\n         '--glob-archives',\n         metavar='GLOB',\n         help='Only show info for archive names matching this glob',\n     )\n     info_group.add_argument(\n         '--sort-by', metavar='KEYS', help='Comma-separated list of sorting keys'\n     )\n     info_group.add_argument(\n         '--first',\n         metavar='N',\n         help='Show info for first N archives after other filters are applied',\n     )\n     info_group.add_argument(\n         '--last', metavar='N', help='Show info for last N archives after other filters are applied'\n     )\n     info_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     borg_parser = subparsers.add_parser(\n         'borg',\n         aliases=SUBPARSER_ALIASES['borg'],\n         help='Run an arbitrary Borg command',\n         description='Run an arbitrary Borg command based on borgmatic\\'s configuration',\n         add_help=False,\n     )\n     borg_group = borg_parser.add_argument_group('borg arguments')\n     borg_group.add_argument(\n         '--repository',\n         help='Path of repository to pass to Borg, defaults to the configured repositories',\n     )\n     borg_group.add_argument('--archive', help='Name of archive to pass to Borg (or \"latest\")')\n     borg_group.add_argument(\n         '--',\n         metavar='OPTION',\n         dest='options',\n         nargs='+',\n         help='Options to pass to Borg, command first (\"create\", \"list\", etc). \"--\" is optional. To specify the repository or the archive, you must use --repository or --archive instead of providing them here.',\n     )\n     borg_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     return top_level_parser, subparsers\n \n \n def parse_arguments(*unparsed_arguments):\n     '''\n     Given command-line arguments with which this script was invoked, parse the arguments and return\n     them as a dict mapping from subparser name (or \"global\") to an argparse.Namespace instance.\n     '''\n     top_level_parser, subparsers = make_parsers()\n \n     arguments, remaining_arguments = parse_subparser_arguments(\n         unparsed_arguments, subparsers.choices\n     )\n     arguments['global'] = top_level_parser.parse_args(remaining_arguments)\n \n     if arguments['global'].excludes_filename:\n         raise ValueError(\n             'The --excludes option has been replaced with exclude_patterns in configuration'\n         )\n \n     if 'init' in arguments and arguments['global'].dry_run:\n         raise ValueError('The init action cannot be used with the --dry-run option')\n \n     if (\n         'list' in arguments\n         and 'info' in arguments\n         and arguments['list'].json\n         and arguments['info'].json\n     ):\n         raise ValueError('With the --json option, list and info actions cannot be used together')\n \n     return arguments\n ", "input_code": "def parse_subparser_arguments(unparsed_arguments, subparsers):\n\"\"\"\nGiven a sequence of arguments and a dict from subparser name to argparse.ArgumentParser\ninstance, give each requested action's subparser a shot at parsing all arguments. This allows\ncommon arguments like \"--repository\" to be shared across multiple subparsers.\n\nReturn the result as a tuple of (a dict mapping from subparser name to a parsed namespace of\narguments, a list of remaining arguments not claimed by any subparser).\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def parse_subparser_arguments(unparsed_arguments, subparsers):\n    '''\n    Given a sequence of arguments and a dict from subparser name to argparse.ArgumentParser\n    instance, give each requested action's subparser a shot at parsing all arguments. This allows\n    common arguments like \"--repository\" to be shared across multiple subparsers.\n\n    Return the result as a tuple of (a dict mapping from subparser name to a parsed namespace of\n    arguments, a list of remaining arguments not claimed by any subparser).\n    '''\n    arguments = collections.OrderedDict()\n    remaining_arguments = list(unparsed_arguments)\n    alias_to_subparser_name = {\n        alias: subparser_name\n        for subparser_name, aliases in SUBPARSER_ALIASES.items()\n        for alias in aliases\n    }\n\n    # If the \"borg\" action is used, skip all other subparsers. This avoids confusion like\n    # \"borg list\" triggering borgmatic's own list action.\n    if 'borg' in unparsed_arguments:\n        subparsers = {'borg': subparsers['borg']}\n\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name not in remaining_arguments:\n            continue\n\n        canonical_name = alias_to_subparser_name.get(subparser_name, subparser_name)\n\n        # If a parsed value happens to be the same as the name of a subparser, remove it from the\n        # remaining arguments. This prevents, for instance, \"check --only extract\" from triggering\n        # the \"extract\" subparser.\n        parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)\n        for value in vars(parsed).values():\n            if isinstance(value, str):\n                if value in subparsers:\n                    remaining_arguments.remove(value)\n            elif isinstance(value, list):\n                for item in value:\n                    if item in subparsers:\n                        remaining_arguments.remove(item)\n\n        arguments[canonical_name] = parsed\n\n    # If no actions are explicitly requested, assume defaults: prune, compact, create, and check.\n    if not arguments and '--help' not in unparsed_arguments and '-h' not in unparsed_arguments:\n        for subparser_name in ('prune', 'compact', 'create', 'check'):\n            subparser = subparsers[subparser_name]\n            parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)\n            arguments[subparser_name] = parsed\n\n    remaining_arguments = list(unparsed_arguments)\n\n    # Now ask each subparser, one by one, to greedily consume arguments.\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name not in arguments.keys():\n            continue\n\n        subparser = subparsers[subparser_name]\n        unused_parsed, remaining_arguments = subparser.parse_known_args(remaining_arguments)\n\n    # Special case: If \"borg\" is present in the arguments, consume all arguments after (+1) the\n    # \"borg\" action.\n    if 'borg' in arguments:\n        borg_options_index = remaining_arguments.index('borg') + 1\n        arguments['borg'].options = remaining_arguments[borg_options_index:]\n        remaining_arguments = remaining_arguments[:borg_options_index]\n\n    # Remove the subparser names themselves.\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name in remaining_arguments:\n            remaining_arguments.remove(subparser_name)\n\n    return (arguments, remaining_arguments)", "signature": "def parse_subparser_arguments(unparsed_arguments, subparsers):", "completion_path": "borgmatic/commands/arguments.py"}
{"ce_id": "62b45665d7d32e5b55cc8363", "namespace": "62b45665d7d32e5b55cc8363", "namespace_real": "borgmatic.commands.arguments.make_parsers", "real_proj_path": "witten---atticmatic/", "type": "function", "class_name": null, "function_name": "make_parsers", "contexts_above": "import collections\nfrom argparse import Action, ArgumentParser\n\nfrom borgmatic.config import collect\n\nSUBPARSER_ALIASES = {\n    'init': ['--init', '-I'],\n    'prune': ['--prune', '-p'],\n    'compact': [],\n    'create': ['--create', '-C'],\n    'check': ['--check', '-k'],\n    'extract': ['--extract', '-x'],\n    'export-tar': ['--export-tar'],\n    'mount': ['--mount', '-m'],\n    'umount': ['--umount', '-u'],\n    'restore': ['--restore', '-r'],\n    'list': ['--list', '-l'],\n    'info': ['--info', '-i'],\n    'borg': [],\n}\n\n\ndef parse_subparser_arguments(unparsed_arguments, subparsers):\n    '''\n    Given a sequence of arguments and a dict from subparser name to argparse.ArgumentParser\n    instance, give each requested action's subparser a shot at parsing all arguments. This allows\n    common arguments like \"--repository\" to be shared across multiple subparsers.\n\n    Return the result as a tuple of (a dict mapping from subparser name to a parsed namespace of\n    arguments, a list of remaining arguments not claimed by any subparser).\n    '''\n    arguments = collections.OrderedDict()\n    remaining_arguments = list(unparsed_arguments)\n    alias_to_subparser_name = {\n        alias: subparser_name\n        for subparser_name, aliases in SUBPARSER_ALIASES.items()\n        for alias in aliases\n    }\n\n    # If the \"borg\" action is used, skip all other subparsers. This avoids confusion like\n    # \"borg list\" triggering borgmatic's own list action.\n    if 'borg' in unparsed_arguments:\n        subparsers = {'borg': subparsers['borg']}\n\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name not in remaining_arguments:\n            continue\n\n        canonical_name = alias_to_subparser_name.get(subparser_name, subparser_name)\n\n        # If a parsed value happens to be the same as the name of a subparser, remove it from the\n        # remaining arguments. This prevents, for instance, \"check --only extract\" from triggering\n        # the \"extract\" subparser.\n        parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)\n        for value in vars(parsed).values():\n            if isinstance(value, str):\n                if value in subparsers:\n                    remaining_arguments.remove(value)\n            elif isinstance(value, list):\n                for item in value:\n                    if item in subparsers:\n                        remaining_arguments.remove(item)\n\n        arguments[canonical_name] = parsed\n\n    # If no actions are explicitly requested, assume defaults: prune, compact, create, and check.\n    if not arguments and '--help' not in unparsed_arguments and '-h' not in unparsed_arguments:\n        for subparser_name in ('prune', 'compact', 'create', 'check'):\n            subparser = subparsers[subparser_name]\n            parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)\n            arguments[subparser_name] = parsed\n\n    remaining_arguments = list(unparsed_arguments)\n\n    # Now ask each subparser, one by one, to greedily consume arguments.\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name not in arguments.keys():\n            continue\n\n        subparser = subparsers[subparser_name]\n        unused_parsed, remaining_arguments = subparser.parse_known_args(remaining_arguments)\n\n    # Special case: If \"borg\" is present in the arguments, consume all arguments after (+1) the\n    # \"borg\" action.\n    if 'borg' in arguments:\n        borg_options_index = remaining_arguments.index('borg') + 1\n        arguments['borg'].options = remaining_arguments[borg_options_index:]\n        remaining_arguments = remaining_arguments[:borg_options_index]\n\n    # Remove the subparser names themselves.\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name in remaining_arguments:\n            remaining_arguments.remove(subparser_name)\n\n    return (arguments, remaining_arguments)\n\n\nclass Extend_action(Action):\n    '''\n    An argparse action to support Python 3.8's \"extend\" action in older versions of Python.\n    '''\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        items = getattr(namespace, self.dest, None)\n\n        if items:\n            items.extend(values)\n        else:\n            setattr(namespace, self.dest, list(values))\n\n", "contexts_below": "\n def parse_arguments(*unparsed_arguments):\n     '''\n     Given command-line arguments with which this script was invoked, parse the arguments and return\n     them as a dict mapping from subparser name (or \"global\") to an argparse.Namespace instance.\n     '''\n     top_level_parser, subparsers = make_parsers()\n \n     arguments, remaining_arguments = parse_subparser_arguments(\n         unparsed_arguments, subparsers.choices\n     )\n     arguments['global'] = top_level_parser.parse_args(remaining_arguments)\n \n     if arguments['global'].excludes_filename:\n         raise ValueError(\n             'The --excludes option has been replaced with exclude_patterns in configuration'\n         )\n \n     if 'init' in arguments and arguments['global'].dry_run:\n         raise ValueError('The init action cannot be used with the --dry-run option')\n \n     if (\n         'list' in arguments\n         and 'info' in arguments\n         and arguments['list'].json\n         and arguments['info'].json\n     ):\n         raise ValueError('With the --json option, list and info actions cannot be used together')\n \n     return arguments\n ", "input_code": "def make_parsers():\n\"\"\"\nBuild a top-level parser and its subparsers and return them as a tuple.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def make_parsers():\n    '''\n    Build a top-level parser and its subparsers and return them as a tuple.\n    '''\n    config_paths = collect.get_default_config_paths(expand_home=True)\n    unexpanded_config_paths = collect.get_default_config_paths(expand_home=False)\n\n    global_parser = ArgumentParser(add_help=False)\n    global_parser.register('action', 'extend', Extend_action)\n    global_group = global_parser.add_argument_group('global arguments')\n\n    global_group.add_argument(\n        '-c',\n        '--config',\n        nargs='*',\n        dest='config_paths',\n        default=config_paths,\n        help='Configuration filenames or directories, defaults to: {}'.format(\n            ' '.join(unexpanded_config_paths)\n        ),\n    )\n    global_group.add_argument(\n        '--excludes',\n        dest='excludes_filename',\n        help='Deprecated in favor of exclude_patterns within configuration',\n    )\n    global_group.add_argument(\n        '-n',\n        '--dry-run',\n        dest='dry_run',\n        action='store_true',\n        help='Go through the motions, but do not actually write to any repositories',\n    )\n    global_group.add_argument(\n        '-nc', '--no-color', dest='no_color', action='store_true', help='Disable colored output'\n    )\n    global_group.add_argument(\n        '-v',\n        '--verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Display verbose progress to the console (from only errors to very verbose: -1, 0, 1, or 2)',\n    )\n    global_group.add_argument(\n        '--syslog-verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Log verbose progress to syslog (from only errors to very verbose: -1, 0, 1, or 2). Ignored when console is interactive or --log-file is given',\n    )\n    global_group.add_argument(\n        '--log-file-verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Log verbose progress to log file (from only errors to very verbose: -1, 0, 1, or 2). Only used when --log-file is given',\n    )\n    global_group.add_argument(\n        '--monitoring-verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Log verbose progress to monitoring integrations that support logging (from only errors to very verbose: -1, 0, 1, or 2)',\n    )\n    global_group.add_argument(\n        '--log-file',\n        type=str,\n        default=None,\n        help='Write log messages to this file instead of syslog',\n    )\n    global_group.add_argument(\n        '--override',\n        metavar='SECTION.OPTION=VALUE',\n        nargs='+',\n        dest='overrides',\n        action='extend',\n        help='One or more configuration file options to override with specified values',\n    )\n    global_group.add_argument(\n        '--no-environment-interpolation',\n        dest='resolve_env',\n        action='store_false',\n        help='Do not resolve environment variables in configuration file',\n    )\n    global_group.add_argument(\n        '--bash-completion',\n        default=False,\n        action='store_true',\n        help='Show bash completion script and exit',\n    )\n    global_group.add_argument(\n        '--version',\n        dest='version',\n        default=False,\n        action='store_true',\n        help='Display installed version number of borgmatic and exit',\n    )\n\n    top_level_parser = ArgumentParser(\n        description='''\n            Simple, configuration-driven backup software for servers and workstations. If none of\n            the action options are given, then borgmatic defaults to: prune, compact, create, and\n            check.\n            ''',\n        parents=[global_parser],\n    )\n\n    subparsers = top_level_parser.add_subparsers(\n        title='actions',\n        metavar='',\n        help='Specify zero or more actions. Defaults to prune, compact, create, and check. Use --help with action for details:',\n    )\n    init_parser = subparsers.add_parser(\n        'init',\n        aliases=SUBPARSER_ALIASES['init'],\n        help='Initialize an empty Borg repository',\n        description='Initialize an empty Borg repository',\n        add_help=False,\n    )\n    init_group = init_parser.add_argument_group('init arguments')\n    init_group.add_argument(\n        '-e',\n        '--encryption',\n        dest='encryption_mode',\n        help='Borg repository encryption mode',\n        required=True,\n    )\n    init_group.add_argument(\n        '--append-only',\n        dest='append_only',\n        action='store_true',\n        help='Create an append-only repository',\n    )\n    init_group.add_argument(\n        '--storage-quota',\n        dest='storage_quota',\n        help='Create a repository with a fixed storage quota',\n    )\n    init_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    prune_parser = subparsers.add_parser(\n        'prune',\n        aliases=SUBPARSER_ALIASES['prune'],\n        help='Prune archives according to the retention policy (with Borg 1.2+, run compact afterwards to actually free space)',\n        description='Prune archives according to the retention policy (with Borg 1.2+, run compact afterwards to actually free space)',\n        add_help=False,\n    )\n    prune_group = prune_parser.add_argument_group('prune arguments')\n    prune_group.add_argument(\n        '--stats',\n        dest='stats',\n        default=False,\n        action='store_true',\n        help='Display statistics of archive',\n    )\n    prune_group.add_argument(\n        '--files', dest='files', default=False, action='store_true', help='Show per-file details'\n    )\n    prune_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    compact_parser = subparsers.add_parser(\n        'compact',\n        aliases=SUBPARSER_ALIASES['compact'],\n        help='Compact segments to free space (Borg 1.2+ only)',\n        description='Compact segments to free space (Borg 1.2+ only)',\n        add_help=False,\n    )\n    compact_group = compact_parser.add_argument_group('compact arguments')\n    compact_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress as each segment is compacted',\n    )\n    compact_group.add_argument(\n        '--cleanup-commits',\n        dest='cleanup_commits',\n        default=False,\n        action='store_true',\n        help='Cleanup commit-only 17-byte segment files left behind by Borg 1.1',\n    )\n    compact_group.add_argument(\n        '--threshold',\n        type=int,\n        dest='threshold',\n        help='Minimum saved space percentage threshold for compacting a segment, defaults to 10',\n    )\n    compact_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    create_parser = subparsers.add_parser(\n        'create',\n        aliases=SUBPARSER_ALIASES['create'],\n        help='Create archives (actually perform backups)',\n        description='Create archives (actually perform backups)',\n        add_help=False,\n    )\n    create_group = create_parser.add_argument_group('create arguments')\n    create_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress for each file as it is backed up',\n    )\n    create_group.add_argument(\n        '--stats',\n        dest='stats',\n        default=False,\n        action='store_true',\n        help='Display statistics of archive',\n    )\n    create_group.add_argument(\n        '--files', dest='files', default=False, action='store_true', help='Show per-file details'\n    )\n    create_group.add_argument(\n        '--json', dest='json', default=False, action='store_true', help='Output results as JSON'\n    )\n    create_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    check_parser = subparsers.add_parser(\n        'check',\n        aliases=SUBPARSER_ALIASES['check'],\n        help='Check archives for consistency',\n        description='Check archives for consistency',\n        add_help=False,\n    )\n    check_group = check_parser.add_argument_group('check arguments')\n    check_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress for each file as it is checked',\n    )\n    check_group.add_argument(\n        '--repair',\n        dest='repair',\n        default=False,\n        action='store_true',\n        help='Attempt to repair any inconsistencies found (for interactive use)',\n    )\n    check_group.add_argument(\n        '--only',\n        metavar='CHECK',\n        choices=('repository', 'archives', 'data', 'extract'),\n        dest='only',\n        action='append',\n        help='Run a particular consistency check (repository, archives, data, or extract) instead of configured checks (subject to configured frequency, can specify flag multiple times)',\n    )\n    check_group.add_argument(\n        '--force',\n        default=False,\n        action='store_true',\n        help='Ignore configured check frequencies and run checks unconditionally',\n    )\n    check_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    extract_parser = subparsers.add_parser(\n        'extract',\n        aliases=SUBPARSER_ALIASES['extract'],\n        help='Extract files from a named archive to the current directory',\n        description='Extract a named archive to the current directory',\n        add_help=False,\n    )\n    extract_group = extract_parser.add_argument_group('extract arguments')\n    extract_group.add_argument(\n        '--repository',\n        help='Path of repository to extract, defaults to the configured repository if there is only one',\n    )\n    extract_group.add_argument(\n        '--archive', help='Name of archive to extract (or \"latest\")', required=True\n    )\n    extract_group.add_argument(\n        '--path',\n        '--restore-path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths to extract from archive, defaults to the entire archive',\n    )\n    extract_group.add_argument(\n        '--destination',\n        metavar='PATH',\n        dest='destination',\n        help='Directory to extract files into, defaults to the current directory',\n    )\n    extract_group.add_argument(\n        '--strip-components',\n        type=int,\n        metavar='NUMBER',\n        dest='strip_components',\n        help='Number of leading path components to remove from each extracted path. Skip paths with fewer elements',\n    )\n    extract_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress for each file as it is extracted',\n    )\n    extract_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    export_tar_parser = subparsers.add_parser(\n        'export-tar',\n        aliases=SUBPARSER_ALIASES['export-tar'],\n        help='Export an archive to a tar-formatted file or stream',\n        description='Export an archive to a tar-formatted file or stream',\n        add_help=False,\n    )\n    export_tar_group = export_tar_parser.add_argument_group('export-tar arguments')\n    export_tar_group.add_argument(\n        '--repository',\n        help='Path of repository to export from, defaults to the configured repository if there is only one',\n    )\n    export_tar_group.add_argument(\n        '--archive', help='Name of archive to export (or \"latest\")', required=True\n    )\n    export_tar_group.add_argument(\n        '--path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths to export from archive, defaults to the entire archive',\n    )\n    export_tar_group.add_argument(\n        '--destination',\n        metavar='PATH',\n        dest='destination',\n        help='Path to destination export tar file, or \"-\" for stdout (but be careful about dirtying output with --verbosity or --files)',\n        required=True,\n    )\n    export_tar_group.add_argument(\n        '--tar-filter', help='Name of filter program to pipe data through'\n    )\n    export_tar_group.add_argument(\n        '--files', default=False, action='store_true', help='Show per-file details'\n    )\n    export_tar_group.add_argument(\n        '--strip-components',\n        type=int,\n        metavar='NUMBER',\n        dest='strip_components',\n        help='Number of leading path components to remove from each exported path. Skip paths with fewer elements',\n    )\n    export_tar_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    mount_parser = subparsers.add_parser(\n        'mount',\n        aliases=SUBPARSER_ALIASES['mount'],\n        help='Mount files from a named archive as a FUSE filesystem',\n        description='Mount a named archive as a FUSE filesystem',\n        add_help=False,\n    )\n    mount_group = mount_parser.add_argument_group('mount arguments')\n    mount_group.add_argument(\n        '--repository',\n        help='Path of repository to use, defaults to the configured repository if there is only one',\n    )\n    mount_group.add_argument('--archive', help='Name of archive to mount (or \"latest\")')\n    mount_group.add_argument(\n        '--mount-point',\n        metavar='PATH',\n        dest='mount_point',\n        help='Path where filesystem is to be mounted',\n        required=True,\n    )\n    mount_group.add_argument(\n        '--path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths to mount from archive, defaults to the entire archive',\n    )\n    mount_group.add_argument(\n        '--foreground',\n        dest='foreground',\n        default=False,\n        action='store_true',\n        help='Stay in foreground until ctrl-C is pressed',\n    )\n    mount_group.add_argument('--options', dest='options', help='Extra Borg mount options')\n    mount_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    umount_parser = subparsers.add_parser(\n        'umount',\n        aliases=SUBPARSER_ALIASES['umount'],\n        help='Unmount a FUSE filesystem that was mounted with \"borgmatic mount\"',\n        description='Unmount a mounted FUSE filesystem',\n        add_help=False,\n    )\n    umount_group = umount_parser.add_argument_group('umount arguments')\n    umount_group.add_argument(\n        '--mount-point',\n        metavar='PATH',\n        dest='mount_point',\n        help='Path of filesystem to unmount',\n        required=True,\n    )\n    umount_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    restore_parser = subparsers.add_parser(\n        'restore',\n        aliases=SUBPARSER_ALIASES['restore'],\n        help='Restore database dumps from a named archive',\n        description='Restore database dumps from a named archive. (To extract files instead, use \"borgmatic extract\".)',\n        add_help=False,\n    )\n    restore_group = restore_parser.add_argument_group('restore arguments')\n    restore_group.add_argument(\n        '--repository',\n        help='Path of repository to restore from, defaults to the configured repository if there is only one',\n    )\n    restore_group.add_argument(\n        '--archive', help='Name of archive to restore from (or \"latest\")', required=True\n    )\n    restore_group.add_argument(\n        '--database',\n        metavar='NAME',\n        nargs='+',\n        dest='databases',\n        help='Names of databases to restore from archive, defaults to all databases. Note that any databases to restore must be defined in borgmatic\\'s configuration',\n    )\n    restore_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    list_parser = subparsers.add_parser(\n        'list',\n        aliases=SUBPARSER_ALIASES['list'],\n        help='List archives',\n        description='List archives or the contents of an archive',\n        add_help=False,\n    )\n    list_group = list_parser.add_argument_group('list arguments')\n    list_group.add_argument(\n        '--repository', help='Path of repository to list, defaults to the configured repositories',\n    )\n    list_group.add_argument('--archive', help='Name of archive to list (or \"latest\")')\n    list_group.add_argument(\n        '--path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths or patterns to list from a single selected archive (via \"--archive\"), defaults to listing the entire archive',\n    )\n    list_group.add_argument(\n        '--find',\n        metavar='PATH',\n        nargs='+',\n        dest='find_paths',\n        help='Partial paths or patterns to search for and list across multiple archives',\n    )\n    list_group.add_argument(\n        '--short', default=False, action='store_true', help='Output only archive or path names'\n    )\n    list_group.add_argument('--format', help='Format for file listing')\n    list_group.add_argument(\n        '--json', default=False, action='store_true', help='Output results as JSON'\n    )\n    list_group.add_argument(\n        '-P', '--prefix', help='Only list archive names starting with this prefix'\n    )\n    list_group.add_argument(\n        '-a', '--glob-archives', metavar='GLOB', help='Only list archive names matching this glob'\n    )\n    list_group.add_argument(\n        '--successful',\n        default=True,\n        action='store_true',\n        help='Deprecated in favor of listing successful (non-checkpoint) backups by default in newer versions of Borg',\n    )\n    list_group.add_argument(\n        '--sort-by', metavar='KEYS', help='Comma-separated list of sorting keys'\n    )\n    list_group.add_argument(\n        '--first', metavar='N', help='List first N archives after other filters are applied'\n    )\n    list_group.add_argument(\n        '--last', metavar='N', help='List last N archives after other filters are applied'\n    )\n    list_group.add_argument(\n        '-e', '--exclude', metavar='PATTERN', help='Exclude paths matching the pattern'\n    )\n    list_group.add_argument(\n        '--exclude-from', metavar='FILENAME', help='Exclude paths from exclude file, one per line'\n    )\n    list_group.add_argument('--pattern', help='Include or exclude paths matching a pattern')\n    list_group.add_argument(\n        '--patterns-from',\n        metavar='FILENAME',\n        help='Include or exclude paths matching patterns from pattern file, one per line',\n    )\n    list_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    info_parser = subparsers.add_parser(\n        'info',\n        aliases=SUBPARSER_ALIASES['info'],\n        help='Display summary information on archives',\n        description='Display summary information on archives',\n        add_help=False,\n    )\n    info_group = info_parser.add_argument_group('info arguments')\n    info_group.add_argument(\n        '--repository',\n        help='Path of repository to show info for, defaults to the configured repository if there is only one',\n    )\n    info_group.add_argument('--archive', help='Name of archive to show info for (or \"latest\")')\n    info_group.add_argument(\n        '--json', dest='json', default=False, action='store_true', help='Output results as JSON'\n    )\n    info_group.add_argument(\n        '-P', '--prefix', help='Only show info for archive names starting with this prefix'\n    )\n    info_group.add_argument(\n        '-a',\n        '--glob-archives',\n        metavar='GLOB',\n        help='Only show info for archive names matching this glob',\n    )\n    info_group.add_argument(\n        '--sort-by', metavar='KEYS', help='Comma-separated list of sorting keys'\n    )\n    info_group.add_argument(\n        '--first',\n        metavar='N',\n        help='Show info for first N archives after other filters are applied',\n    )\n    info_group.add_argument(\n        '--last', metavar='N', help='Show info for last N archives after other filters are applied'\n    )\n    info_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    borg_parser = subparsers.add_parser(\n        'borg',\n        aliases=SUBPARSER_ALIASES['borg'],\n        help='Run an arbitrary Borg command',\n        description='Run an arbitrary Borg command based on borgmatic\\'s configuration',\n        add_help=False,\n    )\n    borg_group = borg_parser.add_argument_group('borg arguments')\n    borg_group.add_argument(\n        '--repository',\n        help='Path of repository to pass to Borg, defaults to the configured repositories',\n    )\n    borg_group.add_argument('--archive', help='Name of archive to pass to Borg (or \"latest\")')\n    borg_group.add_argument(\n        '--',\n        metavar='OPTION',\n        dest='options',\n        nargs='+',\n        help='Options to pass to Borg, command first (\"create\", \"list\", etc). \"--\" is optional. To specify the repository or the archive, you must use --repository or --archive instead of providing them here.',\n    )\n    borg_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    return top_level_parser, subparsers", "signature": "def make_parsers():", "completion_path": "borgmatic/commands/arguments.py"}
{"ce_id": "62b438ba66fea644fe22cca2", "namespace": "62b438ba66fea644fe22cca2", "namespace_real": "borgmatic.config.load.deep_merge_nodes", "real_proj_path": "witten---borgmatic/", "type": "function", "class_name": null, "function_name": "deep_merge_nodes", "contexts_above": "import logging\nimport os\n\nimport ruamel.yaml\n\nlogger = logging.getLogger(__name__)\n\n\nclass Yaml_with_loader_stream(ruamel.yaml.YAML):\n    '''\n    A derived class of ruamel.yaml.YAML that simply tacks the loaded stream (file object) onto the\n    loader class so that it's available anywhere that's passed a loader (in this case,\n    include_configuration() below).\n    '''\n\n    def get_constructor_parser(self, stream):\n        constructor, parser = super(Yaml_with_loader_stream, self).get_constructor_parser(stream)\n        constructor.loader.stream = stream\n        return constructor, parser\n\n\ndef load_configuration(filename):\n    '''\n    Load the given configuration file and return its contents as a data structure of nested dicts\n    and lists.\n\n    Raise ruamel.yaml.error.YAMLError if something goes wrong parsing the YAML, or RecursionError\n    if there are too many recursive includes.\n    '''\n    yaml = Yaml_with_loader_stream(typ='safe')\n    yaml.Constructor = Include_constructor\n\n    return yaml.load(open(filename))\n\n\ndef include_configuration(loader, filename_node):\n    '''\n    Load the given YAML filename (ignoring the given loader so we can use our own) and return its\n    contents as a data structure of nested dicts and lists. If the filename is relative, probe for\n    it within 1. the current working directory and 2. the directory containing the YAML file doing\n    the including.\n\n    Raise FileNotFoundError if an included file was not found.\n    '''\n    include_directories = [os.getcwd(), os.path.abspath(os.path.dirname(loader.stream.name))]\n    include_filename = os.path.expanduser(filename_node.value)\n\n    if not os.path.isabs(include_filename):\n        candidate_filenames = [\n            os.path.join(directory, include_filename) for directory in include_directories\n        ]\n\n        for candidate_filename in candidate_filenames:\n            if os.path.exists(candidate_filename):\n                include_filename = candidate_filename\n                break\n        else:\n            raise FileNotFoundError(\n                f'Could not find include {filename_node.value} at {\" or \".join(candidate_filenames)}'\n            )\n\n    return load_configuration(include_filename)\n\n\nDELETED_NODE = object()\n\n", "contexts_below": "\n class Include_constructor(ruamel.yaml.SafeConstructor):\n     '''\n     A YAML \"constructor\" (a ruamel.yaml concept) that supports a custom \"!include\" tag for including\n     separate YAML configuration files. Example syntax: `retention: !include common.yaml`\n     '''\n \n     def __init__(self, preserve_quotes=None, loader=None):\n         super(Include_constructor, self).__init__(preserve_quotes, loader)\n         self.add_constructor('!include', include_configuration)\n \n     def flatten_mapping(self, node):\n         '''\n         Support the special case of deep merging included configuration into an existing mapping\n         using the YAML '<<' merge key. Example syntax:\n \n         ```\n         retention:\n             keep_daily: 1\n \n         <<: !include common.yaml\n         ```\n \n         These includes are deep merged into the current configuration file. For instance, in this\n         example, any \"retention\" options in common.yaml will get merged into the \"retention\" section\n         in the example configuration file.\n         '''\n         representer = ruamel.yaml.representer.SafeRepresenter()\n \n         for index, (key_node, value_node) in enumerate(node.value):\n             if key_node.tag == u'tag:yaml.org,2002:merge' and value_node.tag == '!include':\n                 included_value = representer.represent_data(self.construct_object(value_node))\n                 node.value[index] = (key_node, included_value)\n \n         super(Include_constructor, self).flatten_mapping(node)\n \n         node.value = deep_merge_nodes(node.value)\n ", "input_code": "def deep_merge_nodes(nodes):\n\"\"\"\nGiven a nested borgmatic configuration data structure as a list of tuples in the form of:\n\n    (\n        ruamel.yaml.nodes.ScalarNode as a key,\n        ruamel.yaml.nodes.MappingNode or other Node as a value,\n    ),\n\n... deep merge any node values corresponding to duplicate keys and return the result. If\nthere are colliding keys with non-MappingNode values (e.g., integers or strings), the last\nof the values wins.\n\nFor instance, given node values of:\n\n    [\n        (\n            ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n            MappingNode(tag='tag:yaml.org,2002:map', value=[\n                (\n                    ScalarNode(tag='tag:yaml.org,2002:str', value='keep_hourly'),\n                    ScalarNode(tag='tag:yaml.org,2002:int', value='24')\n                ),\n                (\n                    ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                    ScalarNode(tag='tag:yaml.org,2002:int', value='7')\n                ),\n            ]),\n        ),\n        (\n            ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n            MappingNode(tag='tag:yaml.org,2002:map', value=[\n                (\n                    ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                    ScalarNode(tag='tag:yaml.org,2002:int', value='5')\n                ),\n            ]),\n        ),\n    ]\n\n... the returned result would be:\n\n    [\n        (\n            ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n            MappingNode(tag='tag:yaml.org,2002:map', value=[\n                (\n                    ScalarNode(tag='tag:yaml.org,2002:str', value='keep_hourly'),\n                    ScalarNode(tag='tag:yaml.org,2002:int', value='24')\n                ),\n                (\n                    ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                    ScalarNode(tag='tag:yaml.org,2002:int', value='5')\n                ),\n            ]),\n        ),\n    ]\n\nThe purpose of deep merging like this is to support, for instance, merging one borgmatic\nconfiguration file into another for reuse, such that a configuration section (\"retention\",\netc.) does not completely replace the corresponding section in a merged file.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def deep_merge_nodes(nodes):\n    '''\n    Given a nested borgmatic configuration data structure as a list of tuples in the form of:\n\n        (\n            ruamel.yaml.nodes.ScalarNode as a key,\n            ruamel.yaml.nodes.MappingNode or other Node as a value,\n        ),\n\n    ... deep merge any node values corresponding to duplicate keys and return the result. If\n    there are colliding keys with non-MappingNode values (e.g., integers or strings), the last\n    of the values wins.\n\n    For instance, given node values of:\n\n        [\n            (\n                ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n                MappingNode(tag='tag:yaml.org,2002:map', value=[\n                    (\n                        ScalarNode(tag='tag:yaml.org,2002:str', value='keep_hourly'),\n                        ScalarNode(tag='tag:yaml.org,2002:int', value='24')\n                    ),\n                    (\n                        ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                        ScalarNode(tag='tag:yaml.org,2002:int', value='7')\n                    ),\n                ]),\n            ),\n            (\n                ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n                MappingNode(tag='tag:yaml.org,2002:map', value=[\n                    (\n                        ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                        ScalarNode(tag='tag:yaml.org,2002:int', value='5')\n                    ),\n                ]),\n            ),\n        ]\n\n    ... the returned result would be:\n\n        [\n            (\n                ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n                MappingNode(tag='tag:yaml.org,2002:map', value=[\n                    (\n                        ScalarNode(tag='tag:yaml.org,2002:str', value='keep_hourly'),\n                        ScalarNode(tag='tag:yaml.org,2002:int', value='24')\n                    ),\n                    (\n                        ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                        ScalarNode(tag='tag:yaml.org,2002:int', value='5')\n                    ),\n                ]),\n            ),\n        ]\n\n    The purpose of deep merging like this is to support, for instance, merging one borgmatic\n    configuration file into another for reuse, such that a configuration section (\"retention\",\n    etc.) does not completely replace the corresponding section in a merged file.\n    '''\n    # Map from original node key/value to the replacement merged node. DELETED_NODE as a replacement\n    # node indications deletion.\n    replaced_nodes = {}\n\n    # To find nodes that require merging, compare each node with each other node.\n    for a_key, a_value in nodes:\n        for b_key, b_value in nodes:\n            # If we've already considered one of the nodes for merging, skip it.\n            if (a_key, a_value) in replaced_nodes or (b_key, b_value) in replaced_nodes:\n                continue\n\n            # If the keys match and the values are different, we need to merge these two A and B nodes.\n            if a_key.tag == b_key.tag and a_key.value == b_key.value and a_value != b_value:\n                # Since we're merging into the B node, consider the A node a duplicate and remove it.\n                replaced_nodes[(a_key, a_value)] = DELETED_NODE\n\n                # If we're dealing with MappingNodes, recurse and merge its values as well.\n                if isinstance(b_value, ruamel.yaml.nodes.MappingNode):\n                    replaced_nodes[(b_key, b_value)] = (\n                        b_key,\n                        ruamel.yaml.nodes.MappingNode(\n                            tag=b_value.tag,\n                            value=deep_merge_nodes(a_value.value + b_value.value),\n                            start_mark=b_value.start_mark,\n                            end_mark=b_value.end_mark,\n                            flow_style=b_value.flow_style,\n                            comment=b_value.comment,\n                            anchor=b_value.anchor,\n                        ),\n                    )\n                # If we're dealing with SequenceNodes, merge by appending one sequence to the other.\n                elif isinstance(b_value, ruamel.yaml.nodes.SequenceNode):\n                    replaced_nodes[(b_key, b_value)] = (\n                        b_key,\n                        ruamel.yaml.nodes.SequenceNode(\n                            tag=b_value.tag,\n                            value=a_value.value + b_value.value,\n                            start_mark=b_value.start_mark,\n                            end_mark=b_value.end_mark,\n                            flow_style=b_value.flow_style,\n                            comment=b_value.comment,\n                            anchor=b_value.anchor,\n                        ),\n                    )\n\n    return [\n        replaced_nodes.get(node, node) for node in nodes if replaced_nodes.get(node) != DELETED_NODE\n    ]", "signature": "def deep_merge_nodes(nodes):", "completion_path": "borgmatic/config/load.py"}
{"ce_id": "62b438b666fea644fe22cc78", "namespace": "62b438b666fea644fe22cc78", "namespace_real": "borgmatic.commands.generate_config.parse_arguments", "real_proj_path": "witten---borgmatic/", "type": "function", "class_name": null, "function_name": "parse_arguments", "contexts_above": "import sys\nfrom argparse import ArgumentParser\n\nfrom borgmatic.config import generate, validate\n\nDEFAULT_DESTINATION_CONFIG_FILENAME = '/etc/borgmatic/config.yaml'\n\n", "contexts_below": "\n def main():  # pragma: no cover\n     try:\n         args = parse_arguments(*sys.argv[1:])\n \n         generate.generate_sample_configuration(\n             args.source_filename,\n             args.destination_filename,\n             validate.schema_filename(),\n             overwrite=args.overwrite,\n         )\n \n         print('Generated a sample configuration file at {}.'.format(args.destination_filename))\n         print()\n         if args.source_filename:\n             print(\n                 'Merged in the contents of configuration file at {}.'.format(args.source_filename)\n             )\n             print('To review the changes made, run:')\n             print()\n             print(\n                 '    diff --unified {} {}'.format(args.source_filename, args.destination_filename)\n             )\n             print()\n         print('Please edit the file to suit your needs. The values are representative.')\n         print('All fields are optional except where indicated.')\n         print()\n         print('If you ever need help: https://torsion.org/borgmatic/#issues')\n     except (ValueError, OSError) as error:\n         print(error, file=sys.stderr)\n         sys.exit(1)\n ", "input_code": "def parse_arguments(*arguments):\n\"\"\"\nGiven command-line arguments with which this script was invoked, parse the arguments and return\nthem as an ArgumentParser instance.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def parse_arguments(*arguments):\n    '''\n    Given command-line arguments with which this script was invoked, parse the arguments and return\n    them as an ArgumentParser instance.\n    '''\n    parser = ArgumentParser(description='Generate a sample borgmatic YAML configuration file.')\n    parser.add_argument(\n        '-s',\n        '--source',\n        dest='source_filename',\n        help='Optional YAML configuration file to merge into the generated configuration, useful for upgrading your configuration',\n    )\n    parser.add_argument(\n        '-d',\n        '--destination',\n        dest='destination_filename',\n        default=DEFAULT_DESTINATION_CONFIG_FILENAME,\n        help='Destination YAML configuration file, default: {}'.format(\n            DEFAULT_DESTINATION_CONFIG_FILENAME\n        ),\n    )\n    parser.add_argument(\n        '--overwrite',\n        default=False,\n        action='store_true',\n        help='Whether to overwrite any existing destination file, defaults to false',\n    )\n\n    return parser.parse_args(arguments)", "signature": "def parse_arguments(*arguments):", "completion_path": "borgmatic/commands/generate_config.py"}
{"ce_id": "62b438b666fea644fe22cc72", "namespace": "62b438b666fea644fe22cc72", "namespace_real": "borgmatic.commands.completion.parser_flags", "real_proj_path": "witten---borgmatic/", "type": "function", "class_name": null, "function_name": "parser_flags", "contexts_above": "from borgmatic.commands import arguments\n\nUPGRADE_MESSAGE = '''\nYour bash completions script is from a different version of borgmatic than is\ncurrently installed. Please upgrade your script so your completions match the\ncommand-line flags in your installed borgmatic! Try this to upgrade:\n\n    sudo sh -c \"borgmatic --bash-completion > $BASH_SOURCE\"\n    source $BASH_SOURCE\n'''\n\n", "contexts_below": "\n def bash_completion():\n     '''\n     Return a bash completion script for the borgmatic command. Produce this by introspecting\n     borgmatic's command-line argument parsers.\n     '''\n     top_level_parser, subparsers = arguments.make_parsers()\n     global_flags = parser_flags(top_level_parser)\n     actions = ' '.join(subparsers.choices.keys())\n \n     # Avert your eyes.\n     return '\\n'.join(\n         (\n             'check_version() {',\n             '    local this_script=\"$(cat \"$BASH_SOURCE\" 2> /dev/null)\"',\n             '    local installed_script=\"$(borgmatic --bash-completion 2> /dev/null)\"',\n             '    if [ \"$this_script\" != \"$installed_script\" ] && [ \"$installed_script\" != \"\" ];'\n             '        then cat << EOF\\n%s\\nEOF' % UPGRADE_MESSAGE,\n             '    fi',\n             '}',\n             'complete_borgmatic() {',\n         )\n         + tuple(\n             '''    if [[ \" ${COMP_WORDS[*]} \" =~ \" %s \" ]]; then\n         COMPREPLY=($(compgen -W \"%s %s %s\" -- \"${COMP_WORDS[COMP_CWORD]}\"))\n         return 0\n     fi'''\n             % (action, parser_flags(subparser), actions, global_flags)\n             for action, subparser in subparsers.choices.items()\n         )\n         + (\n             '    COMPREPLY=($(compgen -W \"%s %s\" -- \"${COMP_WORDS[COMP_CWORD]}\"))'\n             % (actions, global_flags),\n             '    (check_version &)',\n             '}',\n             '\\ncomplete -o bashdefault -o default -F complete_borgmatic borgmatic',\n         )\n     )\n ", "input_code": "def parser_flags(parser):\n\"\"\"\nGiven an argparse.ArgumentParser instance, return its argument flags in a space-separated\nstring.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def parser_flags(parser):\n    '''\n    Given an argparse.ArgumentParser instance, return its argument flags in a space-separated\n    string.\n    '''\n    return ' '.join(option for action in parser._actions for option in action.option_strings)", "signature": "def parser_flags(parser):", "completion_path": "borgmatic/commands/completion.py"}
{"ce_id": "62b438b566fea644fe22cc70", "namespace": "62b438b566fea644fe22cc70", "namespace_real": "borgmatic.commands.completion.bash_completion", "real_proj_path": "witten---borgmatic/", "type": "function", "class_name": null, "function_name": "bash_completion", "contexts_above": "from borgmatic.commands import arguments\n\nUPGRADE_MESSAGE = '''\nYour bash completions script is from a different version of borgmatic than is\ncurrently installed. Please upgrade your script so your completions match the\ncommand-line flags in your installed borgmatic! Try this to upgrade:\n\n    sudo sh -c \"borgmatic --bash-completion > $BASH_SOURCE\"\n    source $BASH_SOURCE\n'''\n\n\ndef parser_flags(parser):\n    '''\n    Given an argparse.ArgumentParser instance, return its argument flags in a space-separated\n    string.\n    '''\n    return ' '.join(option for action in parser._actions for option in action.option_strings)\n\n", "contexts_below": "", "input_code": "def bash_completion():\n\"\"\"\nReturn a bash completion script for the borgmatic command. Produce this by introspecting\nborgmatic's command-line argument parsers.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def bash_completion():\n    '''\n    Return a bash completion script for the borgmatic command. Produce this by introspecting\n    borgmatic's command-line argument parsers.\n    '''\n    top_level_parser, subparsers = arguments.make_parsers()\n    global_flags = parser_flags(top_level_parser)\n    actions = ' '.join(subparsers.choices.keys())\n\n    # Avert your eyes.\n    return '\\n'.join(\n        (\n            'check_version() {',\n            '    local this_script=\"$(cat \"$BASH_SOURCE\" 2> /dev/null)\"',\n            '    local installed_script=\"$(borgmatic --bash-completion 2> /dev/null)\"',\n            '    if [ \"$this_script\" != \"$installed_script\" ] && [ \"$installed_script\" != \"\" ];'\n            '        then cat << EOF\\n%s\\nEOF' % UPGRADE_MESSAGE,\n            '    fi',\n            '}',\n            'complete_borgmatic() {',\n        )\n        + tuple(\n            '''    if [[ \" ${COMP_WORDS[*]} \" =~ \" %s \" ]]; then\n        COMPREPLY=($(compgen -W \"%s %s %s\" -- \"${COMP_WORDS[COMP_CWORD]}\"))\n        return 0\n    fi'''\n            % (action, parser_flags(subparser), actions, global_flags)\n            for action, subparser in subparsers.choices.items()\n        )\n        + (\n            '    COMPREPLY=($(compgen -W \"%s %s\" -- \"${COMP_WORDS[COMP_CWORD]}\"))'\n            % (actions, global_flags),\n            '    (check_version &)',\n            '}',\n            '\\ncomplete -o bashdefault -o default -F complete_borgmatic borgmatic',\n        )\n    )", "signature": "def bash_completion():", "completion_path": "borgmatic/commands/completion.py"}
{"ce_id": "62b438a266fea644fe22cc2e", "namespace": "62b438a266fea644fe22cc2e", "namespace_real": "borgmatic.commands.arguments.parse_arguments", "real_proj_path": "witten---borgmatic/", "type": "function", "class_name": null, "function_name": "parse_arguments", "contexts_above": "import collections\nfrom argparse import Action, ArgumentParser\n\nfrom borgmatic.config import collect\n\nSUBPARSER_ALIASES = {\n    'init': ['--init', '-I'],\n    'prune': ['--prune', '-p'],\n    'compact': [],\n    'create': ['--create', '-C'],\n    'check': ['--check', '-k'],\n    'extract': ['--extract', '-x'],\n    'export-tar': ['--export-tar'],\n    'mount': ['--mount', '-m'],\n    'umount': ['--umount', '-u'],\n    'restore': ['--restore', '-r'],\n    'list': ['--list', '-l'],\n    'info': ['--info', '-i'],\n    'borg': [],\n}\n\n\ndef parse_subparser_arguments(unparsed_arguments, subparsers):\n    '''\n    Given a sequence of arguments and a dict from subparser name to argparse.ArgumentParser\n    instance, give each requested action's subparser a shot at parsing all arguments. This allows\n    common arguments like \"--repository\" to be shared across multiple subparsers.\n\n    Return the result as a tuple of (a dict mapping from subparser name to a parsed namespace of\n    arguments, a list of remaining arguments not claimed by any subparser).\n    '''\n    arguments = collections.OrderedDict()\n    remaining_arguments = list(unparsed_arguments)\n    alias_to_subparser_name = {\n        alias: subparser_name\n        for subparser_name, aliases in SUBPARSER_ALIASES.items()\n        for alias in aliases\n    }\n\n    # If the \"borg\" action is used, skip all other subparsers. This avoids confusion like\n    # \"borg list\" triggering borgmatic's own list action.\n    if 'borg' in unparsed_arguments:\n        subparsers = {'borg': subparsers['borg']}\n\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name not in remaining_arguments:\n            continue\n\n        canonical_name = alias_to_subparser_name.get(subparser_name, subparser_name)\n\n        # If a parsed value happens to be the same as the name of a subparser, remove it from the\n        # remaining arguments. This prevents, for instance, \"check --only extract\" from triggering\n        # the \"extract\" subparser.\n        parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)\n        for value in vars(parsed).values():\n            if isinstance(value, str):\n                if value in subparsers:\n                    remaining_arguments.remove(value)\n            elif isinstance(value, list):\n                for item in value:\n                    if item in subparsers:\n                        remaining_arguments.remove(item)\n\n        arguments[canonical_name] = parsed\n\n    # If no actions are explicitly requested, assume defaults: prune, compact, create, and check.\n    if not arguments and '--help' not in unparsed_arguments and '-h' not in unparsed_arguments:\n        for subparser_name in ('prune', 'compact', 'create', 'check'):\n            subparser = subparsers[subparser_name]\n            parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)\n            arguments[subparser_name] = parsed\n\n    remaining_arguments = list(unparsed_arguments)\n\n    # Now ask each subparser, one by one, to greedily consume arguments.\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name not in arguments.keys():\n            continue\n\n        subparser = subparsers[subparser_name]\n        unused_parsed, remaining_arguments = subparser.parse_known_args(remaining_arguments)\n\n    # Special case: If \"borg\" is present in the arguments, consume all arguments after (+1) the\n    # \"borg\" action.\n    if 'borg' in arguments:\n        borg_options_index = remaining_arguments.index('borg') + 1\n        arguments['borg'].options = remaining_arguments[borg_options_index:]\n        remaining_arguments = remaining_arguments[:borg_options_index]\n\n    # Remove the subparser names themselves.\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name in remaining_arguments:\n            remaining_arguments.remove(subparser_name)\n\n    return (arguments, remaining_arguments)\n\n\nclass Extend_action(Action):\n    '''\n    An argparse action to support Python 3.8's \"extend\" action in older versions of Python.\n    '''\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        items = getattr(namespace, self.dest, None)\n\n        if items:\n            items.extend(values)\n        else:\n            setattr(namespace, self.dest, list(values))\n\n\ndef make_parsers():\n    '''\n    Build a top-level parser and its subparsers and return them as a tuple.\n    '''\n    config_paths = collect.get_default_config_paths(expand_home=True)\n    unexpanded_config_paths = collect.get_default_config_paths(expand_home=False)\n\n    global_parser = ArgumentParser(add_help=False)\n    global_parser.register('action', 'extend', Extend_action)\n    global_group = global_parser.add_argument_group('global arguments')\n\n    global_group.add_argument(\n        '-c',\n        '--config',\n        nargs='*',\n        dest='config_paths',\n        default=config_paths,\n        help='Configuration filenames or directories, defaults to: {}'.format(\n            ' '.join(unexpanded_config_paths)\n        ),\n    )\n    global_group.add_argument(\n        '--excludes',\n        dest='excludes_filename',\n        help='Deprecated in favor of exclude_patterns within configuration',\n    )\n    global_group.add_argument(\n        '-n',\n        '--dry-run',\n        dest='dry_run',\n        action='store_true',\n        help='Go through the motions, but do not actually write to any repositories',\n    )\n    global_group.add_argument(\n        '-nc', '--no-color', dest='no_color', action='store_true', help='Disable colored output'\n    )\n    global_group.add_argument(\n        '-v',\n        '--verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Display verbose progress to the console (from only errors to very verbose: -1, 0, 1, or 2)',\n    )\n    global_group.add_argument(\n        '--syslog-verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Log verbose progress to syslog (from only errors to very verbose: -1, 0, 1, or 2). Ignored when console is interactive or --log-file is given',\n    )\n    global_group.add_argument(\n        '--log-file-verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Log verbose progress to log file (from only errors to very verbose: -1, 0, 1, or 2). Only used when --log-file is given',\n    )\n    global_group.add_argument(\n        '--monitoring-verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Log verbose progress to monitoring integrations that support logging (from only errors to very verbose: -1, 0, 1, or 2)',\n    )\n    global_group.add_argument(\n        '--log-file',\n        type=str,\n        default=None,\n        help='Write log messages to this file instead of syslog',\n    )\n    global_group.add_argument(\n        '--override',\n        metavar='SECTION.OPTION=VALUE',\n        nargs='+',\n        dest='overrides',\n        action='extend',\n        help='One or more configuration file options to override with specified values',\n    )\n    global_group.add_argument(\n        '--no-environment-interpolation',\n        dest='resolve_env',\n        action='store_false',\n        help='Do not resolve environment variables in configuration file',\n    )\n    global_group.add_argument(\n        '--bash-completion',\n        default=False,\n        action='store_true',\n        help='Show bash completion script and exit',\n    )\n    global_group.add_argument(\n        '--version',\n        dest='version',\n        default=False,\n        action='store_true',\n        help='Display installed version number of borgmatic and exit',\n    )\n\n    top_level_parser = ArgumentParser(\n        description='''\n            Simple, configuration-driven backup software for servers and workstations. If none of\n            the action options are given, then borgmatic defaults to: prune, compact, create, and\n            check.\n            ''',\n        parents=[global_parser],\n    )\n\n    subparsers = top_level_parser.add_subparsers(\n        title='actions',\n        metavar='',\n        help='Specify zero or more actions. Defaults to prune, compact, create, and check. Use --help with action for details:',\n    )\n    init_parser = subparsers.add_parser(\n        'init',\n        aliases=SUBPARSER_ALIASES['init'],\n        help='Initialize an empty Borg repository',\n        description='Initialize an empty Borg repository',\n        add_help=False,\n    )\n    init_group = init_parser.add_argument_group('init arguments')\n    init_group.add_argument(\n        '-e',\n        '--encryption',\n        dest='encryption_mode',\n        help='Borg repository encryption mode',\n        required=True,\n    )\n    init_group.add_argument(\n        '--append-only',\n        dest='append_only',\n        action='store_true',\n        help='Create an append-only repository',\n    )\n    init_group.add_argument(\n        '--storage-quota',\n        dest='storage_quota',\n        help='Create a repository with a fixed storage quota',\n    )\n    init_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    prune_parser = subparsers.add_parser(\n        'prune',\n        aliases=SUBPARSER_ALIASES['prune'],\n        help='Prune archives according to the retention policy (with Borg 1.2+, run compact afterwards to actually free space)',\n        description='Prune archives according to the retention policy (with Borg 1.2+, run compact afterwards to actually free space)',\n        add_help=False,\n    )\n    prune_group = prune_parser.add_argument_group('prune arguments')\n    prune_group.add_argument(\n        '--stats',\n        dest='stats',\n        default=False,\n        action='store_true',\n        help='Display statistics of archive',\n    )\n    prune_group.add_argument(\n        '--files', dest='files', default=False, action='store_true', help='Show per-file details'\n    )\n    prune_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    compact_parser = subparsers.add_parser(\n        'compact',\n        aliases=SUBPARSER_ALIASES['compact'],\n        help='Compact segments to free space (Borg 1.2+ only)',\n        description='Compact segments to free space (Borg 1.2+ only)',\n        add_help=False,\n    )\n    compact_group = compact_parser.add_argument_group('compact arguments')\n    compact_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress as each segment is compacted',\n    )\n    compact_group.add_argument(\n        '--cleanup-commits',\n        dest='cleanup_commits',\n        default=False,\n        action='store_true',\n        help='Cleanup commit-only 17-byte segment files left behind by Borg 1.1',\n    )\n    compact_group.add_argument(\n        '--threshold',\n        type=int,\n        dest='threshold',\n        help='Minimum saved space percentage threshold for compacting a segment, defaults to 10',\n    )\n    compact_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    create_parser = subparsers.add_parser(\n        'create',\n        aliases=SUBPARSER_ALIASES['create'],\n        help='Create archives (actually perform backups)',\n        description='Create archives (actually perform backups)',\n        add_help=False,\n    )\n    create_group = create_parser.add_argument_group('create arguments')\n    create_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress for each file as it is backed up',\n    )\n    create_group.add_argument(\n        '--stats',\n        dest='stats',\n        default=False,\n        action='store_true',\n        help='Display statistics of archive',\n    )\n    create_group.add_argument(\n        '--files', dest='files', default=False, action='store_true', help='Show per-file details'\n    )\n    create_group.add_argument(\n        '--json', dest='json', default=False, action='store_true', help='Output results as JSON'\n    )\n    create_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    check_parser = subparsers.add_parser(\n        'check',\n        aliases=SUBPARSER_ALIASES['check'],\n        help='Check archives for consistency',\n        description='Check archives for consistency',\n        add_help=False,\n    )\n    check_group = check_parser.add_argument_group('check arguments')\n    check_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress for each file as it is checked',\n    )\n    check_group.add_argument(\n        '--repair',\n        dest='repair',\n        default=False,\n        action='store_true',\n        help='Attempt to repair any inconsistencies found (for interactive use)',\n    )\n    check_group.add_argument(\n        '--only',\n        metavar='CHECK',\n        choices=('repository', 'archives', 'data', 'extract'),\n        dest='only',\n        action='append',\n        help='Run a particular consistency check (repository, archives, data, or extract) instead of configured checks (subject to configured frequency, can specify flag multiple times)',\n    )\n    check_group.add_argument(\n        '--force',\n        default=False,\n        action='store_true',\n        help='Ignore configured check frequencies and run checks unconditionally',\n    )\n    check_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    extract_parser = subparsers.add_parser(\n        'extract',\n        aliases=SUBPARSER_ALIASES['extract'],\n        help='Extract files from a named archive to the current directory',\n        description='Extract a named archive to the current directory',\n        add_help=False,\n    )\n    extract_group = extract_parser.add_argument_group('extract arguments')\n    extract_group.add_argument(\n        '--repository',\n        help='Path of repository to extract, defaults to the configured repository if there is only one',\n    )\n    extract_group.add_argument(\n        '--archive', help='Name of archive to extract (or \"latest\")', required=True\n    )\n    extract_group.add_argument(\n        '--path',\n        '--restore-path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths to extract from archive, defaults to the entire archive',\n    )\n    extract_group.add_argument(\n        '--destination',\n        metavar='PATH',\n        dest='destination',\n        help='Directory to extract files into, defaults to the current directory',\n    )\n    extract_group.add_argument(\n        '--strip-components',\n        type=int,\n        metavar='NUMBER',\n        dest='strip_components',\n        help='Number of leading path components to remove from each extracted path. Skip paths with fewer elements',\n    )\n    extract_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress for each file as it is extracted',\n    )\n    extract_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    export_tar_parser = subparsers.add_parser(\n        'export-tar',\n        aliases=SUBPARSER_ALIASES['export-tar'],\n        help='Export an archive to a tar-formatted file or stream',\n        description='Export an archive to a tar-formatted file or stream',\n        add_help=False,\n    )\n    export_tar_group = export_tar_parser.add_argument_group('export-tar arguments')\n    export_tar_group.add_argument(\n        '--repository',\n        help='Path of repository to export from, defaults to the configured repository if there is only one',\n    )\n    export_tar_group.add_argument(\n        '--archive', help='Name of archive to export (or \"latest\")', required=True\n    )\n    export_tar_group.add_argument(\n        '--path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths to export from archive, defaults to the entire archive',\n    )\n    export_tar_group.add_argument(\n        '--destination',\n        metavar='PATH',\n        dest='destination',\n        help='Path to destination export tar file, or \"-\" for stdout (but be careful about dirtying output with --verbosity or --files)',\n        required=True,\n    )\n    export_tar_group.add_argument(\n        '--tar-filter', help='Name of filter program to pipe data through'\n    )\n    export_tar_group.add_argument(\n        '--files', default=False, action='store_true', help='Show per-file details'\n    )\n    export_tar_group.add_argument(\n        '--strip-components',\n        type=int,\n        metavar='NUMBER',\n        dest='strip_components',\n        help='Number of leading path components to remove from each exported path. Skip paths with fewer elements',\n    )\n    export_tar_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    mount_parser = subparsers.add_parser(\n        'mount',\n        aliases=SUBPARSER_ALIASES['mount'],\n        help='Mount files from a named archive as a FUSE filesystem',\n        description='Mount a named archive as a FUSE filesystem',\n        add_help=False,\n    )\n    mount_group = mount_parser.add_argument_group('mount arguments')\n    mount_group.add_argument(\n        '--repository',\n        help='Path of repository to use, defaults to the configured repository if there is only one',\n    )\n    mount_group.add_argument('--archive', help='Name of archive to mount (or \"latest\")')\n    mount_group.add_argument(\n        '--mount-point',\n        metavar='PATH',\n        dest='mount_point',\n        help='Path where filesystem is to be mounted',\n        required=True,\n    )\n    mount_group.add_argument(\n        '--path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths to mount from archive, defaults to the entire archive',\n    )\n    mount_group.add_argument(\n        '--foreground',\n        dest='foreground',\n        default=False,\n        action='store_true',\n        help='Stay in foreground until ctrl-C is pressed',\n    )\n    mount_group.add_argument('--options', dest='options', help='Extra Borg mount options')\n    mount_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    umount_parser = subparsers.add_parser(\n        'umount',\n        aliases=SUBPARSER_ALIASES['umount'],\n        help='Unmount a FUSE filesystem that was mounted with \"borgmatic mount\"',\n        description='Unmount a mounted FUSE filesystem',\n        add_help=False,\n    )\n    umount_group = umount_parser.add_argument_group('umount arguments')\n    umount_group.add_argument(\n        '--mount-point',\n        metavar='PATH',\n        dest='mount_point',\n        help='Path of filesystem to unmount',\n        required=True,\n    )\n    umount_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    restore_parser = subparsers.add_parser(\n        'restore',\n        aliases=SUBPARSER_ALIASES['restore'],\n        help='Restore database dumps from a named archive',\n        description='Restore database dumps from a named archive. (To extract files instead, use \"borgmatic extract\".)',\n        add_help=False,\n    )\n    restore_group = restore_parser.add_argument_group('restore arguments')\n    restore_group.add_argument(\n        '--repository',\n        help='Path of repository to restore from, defaults to the configured repository if there is only one',\n    )\n    restore_group.add_argument(\n        '--archive', help='Name of archive to restore from (or \"latest\")', required=True\n    )\n    restore_group.add_argument(\n        '--database',\n        metavar='NAME',\n        nargs='+',\n        dest='databases',\n        help='Names of databases to restore from archive, defaults to all databases. Note that any databases to restore must be defined in borgmatic\\'s configuration',\n    )\n    restore_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    list_parser = subparsers.add_parser(\n        'list',\n        aliases=SUBPARSER_ALIASES['list'],\n        help='List archives',\n        description='List archives or the contents of an archive',\n        add_help=False,\n    )\n    list_group = list_parser.add_argument_group('list arguments')\n    list_group.add_argument(\n        '--repository', help='Path of repository to list, defaults to the configured repositories',\n    )\n    list_group.add_argument('--archive', help='Name of archive to list (or \"latest\")')\n    list_group.add_argument(\n        '--path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths or patterns to list from a single selected archive (via \"--archive\"), defaults to listing the entire archive',\n    )\n    list_group.add_argument(\n        '--find',\n        metavar='PATH',\n        nargs='+',\n        dest='find_paths',\n        help='Partial paths or patterns to search for and list across multiple archives',\n    )\n    list_group.add_argument(\n        '--short', default=False, action='store_true', help='Output only archive or path names'\n    )\n    list_group.add_argument('--format', help='Format for file listing')\n    list_group.add_argument(\n        '--json', default=False, action='store_true', help='Output results as JSON'\n    )\n    list_group.add_argument(\n        '-P', '--prefix', help='Only list archive names starting with this prefix'\n    )\n    list_group.add_argument(\n        '-a', '--glob-archives', metavar='GLOB', help='Only list archive names matching this glob'\n    )\n    list_group.add_argument(\n        '--successful',\n        default=True,\n        action='store_true',\n        help='Deprecated in favor of listing successful (non-checkpoint) backups by default in newer versions of Borg',\n    )\n    list_group.add_argument(\n        '--sort-by', metavar='KEYS', help='Comma-separated list of sorting keys'\n    )\n    list_group.add_argument(\n        '--first', metavar='N', help='List first N archives after other filters are applied'\n    )\n    list_group.add_argument(\n        '--last', metavar='N', help='List last N archives after other filters are applied'\n    )\n    list_group.add_argument(\n        '-e', '--exclude', metavar='PATTERN', help='Exclude paths matching the pattern'\n    )\n    list_group.add_argument(\n        '--exclude-from', metavar='FILENAME', help='Exclude paths from exclude file, one per line'\n    )\n    list_group.add_argument('--pattern', help='Include or exclude paths matching a pattern')\n    list_group.add_argument(\n        '--patterns-from',\n        metavar='FILENAME',\n        help='Include or exclude paths matching patterns from pattern file, one per line',\n    )\n    list_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    info_parser = subparsers.add_parser(\n        'info',\n        aliases=SUBPARSER_ALIASES['info'],\n        help='Display summary information on archives',\n        description='Display summary information on archives',\n        add_help=False,\n    )\n    info_group = info_parser.add_argument_group('info arguments')\n    info_group.add_argument(\n        '--repository',\n        help='Path of repository to show info for, defaults to the configured repository if there is only one',\n    )\n    info_group.add_argument('--archive', help='Name of archive to show info for (or \"latest\")')\n    info_group.add_argument(\n        '--json', dest='json', default=False, action='store_true', help='Output results as JSON'\n    )\n    info_group.add_argument(\n        '-P', '--prefix', help='Only show info for archive names starting with this prefix'\n    )\n    info_group.add_argument(\n        '-a',\n        '--glob-archives',\n        metavar='GLOB',\n        help='Only show info for archive names matching this glob',\n    )\n    info_group.add_argument(\n        '--sort-by', metavar='KEYS', help='Comma-separated list of sorting keys'\n    )\n    info_group.add_argument(\n        '--first',\n        metavar='N',\n        help='Show info for first N archives after other filters are applied',\n    )\n    info_group.add_argument(\n        '--last', metavar='N', help='Show info for last N archives after other filters are applied'\n    )\n    info_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    borg_parser = subparsers.add_parser(\n        'borg',\n        aliases=SUBPARSER_ALIASES['borg'],\n        help='Run an arbitrary Borg command',\n        description='Run an arbitrary Borg command based on borgmatic\\'s configuration',\n        add_help=False,\n    )\n    borg_group = borg_parser.add_argument_group('borg arguments')\n    borg_group.add_argument(\n        '--repository',\n        help='Path of repository to pass to Borg, defaults to the configured repositories',\n    )\n    borg_group.add_argument('--archive', help='Name of archive to pass to Borg (or \"latest\")')\n    borg_group.add_argument(\n        '--',\n        metavar='OPTION',\n        dest='options',\n        nargs='+',\n        help='Options to pass to Borg, command first (\"create\", \"list\", etc). \"--\" is optional. To specify the repository or the archive, you must use --repository or --archive instead of providing them here.',\n    )\n    borg_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    return top_level_parser, subparsers\n\n", "contexts_below": "", "input_code": "def parse_arguments(*unparsed_arguments):\n\"\"\"\nGiven command-line arguments with which this script was invoked, parse the arguments and return\nthem as a dict mapping from subparser name (or \"global\") to an argparse.Namespace instance.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def parse_arguments(*unparsed_arguments):\n    '''\n    Given command-line arguments with which this script was invoked, parse the arguments and return\n    them as a dict mapping from subparser name (or \"global\") to an argparse.Namespace instance.\n    '''\n    top_level_parser, subparsers = make_parsers()\n\n    arguments, remaining_arguments = parse_subparser_arguments(\n        unparsed_arguments, subparsers.choices\n    )\n    arguments['global'] = top_level_parser.parse_args(remaining_arguments)\n\n    if arguments['global'].excludes_filename:\n        raise ValueError(\n            'The --excludes option has been replaced with exclude_patterns in configuration'\n        )\n\n    if 'init' in arguments and arguments['global'].dry_run:\n        raise ValueError('The init action cannot be used with the --dry-run option')\n\n    if (\n        'list' in arguments\n        and 'info' in arguments\n        and arguments['list'].json\n        and arguments['info'].json\n    ):\n        raise ValueError('With the --json option, list and info actions cannot be used together')\n\n    return arguments", "signature": "def parse_arguments(*unparsed_arguments):", "completion_path": "borgmatic/commands/arguments.py"}
{"ce_id": "62b438a266fea644fe22cc2d", "namespace": "62b438a266fea644fe22cc2d", "namespace_real": "borgmatic.commands.arguments.parse_subparser_arguments", "real_proj_path": "witten---borgmatic/", "type": "function", "class_name": null, "function_name": "parse_subparser_arguments", "contexts_above": "import collections\nfrom argparse import Action, ArgumentParser\n\nfrom borgmatic.config import collect\n\nSUBPARSER_ALIASES = {\n    'init': ['--init', '-I'],\n    'prune': ['--prune', '-p'],\n    'compact': [],\n    'create': ['--create', '-C'],\n    'check': ['--check', '-k'],\n    'extract': ['--extract', '-x'],\n    'export-tar': ['--export-tar'],\n    'mount': ['--mount', '-m'],\n    'umount': ['--umount', '-u'],\n    'restore': ['--restore', '-r'],\n    'list': ['--list', '-l'],\n    'info': ['--info', '-i'],\n    'borg': [],\n}\n\n", "contexts_below": "\n class Extend_action(Action):\n     '''\n     An argparse action to support Python 3.8's \"extend\" action in older versions of Python.\n     '''\n \n     def __call__(self, parser, namespace, values, option_string=None):\n         items = getattr(namespace, self.dest, None)\n \n         if items:\n             items.extend(values)\n         else:\n             setattr(namespace, self.dest, list(values))\n \n \n def make_parsers():\n     '''\n     Build a top-level parser and its subparsers and return them as a tuple.\n     '''\n     config_paths = collect.get_default_config_paths(expand_home=True)\n     unexpanded_config_paths = collect.get_default_config_paths(expand_home=False)\n \n     global_parser = ArgumentParser(add_help=False)\n     global_parser.register('action', 'extend', Extend_action)\n     global_group = global_parser.add_argument_group('global arguments')\n \n     global_group.add_argument(\n         '-c',\n         '--config',\n         nargs='*',\n         dest='config_paths',\n         default=config_paths,\n         help='Configuration filenames or directories, defaults to: {}'.format(\n             ' '.join(unexpanded_config_paths)\n         ),\n     )\n     global_group.add_argument(\n         '--excludes',\n         dest='excludes_filename',\n         help='Deprecated in favor of exclude_patterns within configuration',\n     )\n     global_group.add_argument(\n         '-n',\n         '--dry-run',\n         dest='dry_run',\n         action='store_true',\n         help='Go through the motions, but do not actually write to any repositories',\n     )\n     global_group.add_argument(\n         '-nc', '--no-color', dest='no_color', action='store_true', help='Disable colored output'\n     )\n     global_group.add_argument(\n         '-v',\n         '--verbosity',\n         type=int,\n         choices=range(-1, 3),\n         default=0,\n         help='Display verbose progress to the console (from only errors to very verbose: -1, 0, 1, or 2)',\n     )\n     global_group.add_argument(\n         '--syslog-verbosity',\n         type=int,\n         choices=range(-1, 3),\n         default=0,\n         help='Log verbose progress to syslog (from only errors to very verbose: -1, 0, 1, or 2). Ignored when console is interactive or --log-file is given',\n     )\n     global_group.add_argument(\n         '--log-file-verbosity',\n         type=int,\n         choices=range(-1, 3),\n         default=0,\n         help='Log verbose progress to log file (from only errors to very verbose: -1, 0, 1, or 2). Only used when --log-file is given',\n     )\n     global_group.add_argument(\n         '--monitoring-verbosity',\n         type=int,\n         choices=range(-1, 3),\n         default=0,\n         help='Log verbose progress to monitoring integrations that support logging (from only errors to very verbose: -1, 0, 1, or 2)',\n     )\n     global_group.add_argument(\n         '--log-file',\n         type=str,\n         default=None,\n         help='Write log messages to this file instead of syslog',\n     )\n     global_group.add_argument(\n         '--override',\n         metavar='SECTION.OPTION=VALUE',\n         nargs='+',\n         dest='overrides',\n         action='extend',\n         help='One or more configuration file options to override with specified values',\n     )\n     global_group.add_argument(\n         '--no-environment-interpolation',\n         dest='resolve_env',\n         action='store_false',\n         help='Do not resolve environment variables in configuration file',\n     )\n     global_group.add_argument(\n         '--bash-completion',\n         default=False,\n         action='store_true',\n         help='Show bash completion script and exit',\n     )\n     global_group.add_argument(\n         '--version',\n         dest='version',\n         default=False,\n         action='store_true',\n         help='Display installed version number of borgmatic and exit',\n     )\n \n     top_level_parser = ArgumentParser(\n         description='''\n             Simple, configuration-driven backup software for servers and workstations. If none of\n             the action options are given, then borgmatic defaults to: prune, compact, create, and\n             check.\n             ''',\n         parents=[global_parser],\n     )\n \n     subparsers = top_level_parser.add_subparsers(\n         title='actions',\n         metavar='',\n         help='Specify zero or more actions. Defaults to prune, compact, create, and check. Use --help with action for details:',\n     )\n     init_parser = subparsers.add_parser(\n         'init',\n         aliases=SUBPARSER_ALIASES['init'],\n         help='Initialize an empty Borg repository',\n         description='Initialize an empty Borg repository',\n         add_help=False,\n     )\n     init_group = init_parser.add_argument_group('init arguments')\n     init_group.add_argument(\n         '-e',\n         '--encryption',\n         dest='encryption_mode',\n         help='Borg repository encryption mode',\n         required=True,\n     )\n     init_group.add_argument(\n         '--append-only',\n         dest='append_only',\n         action='store_true',\n         help='Create an append-only repository',\n     )\n     init_group.add_argument(\n         '--storage-quota',\n         dest='storage_quota',\n         help='Create a repository with a fixed storage quota',\n     )\n     init_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     prune_parser = subparsers.add_parser(\n         'prune',\n         aliases=SUBPARSER_ALIASES['prune'],\n         help='Prune archives according to the retention policy (with Borg 1.2+, run compact afterwards to actually free space)',\n         description='Prune archives according to the retention policy (with Borg 1.2+, run compact afterwards to actually free space)',\n         add_help=False,\n     )\n     prune_group = prune_parser.add_argument_group('prune arguments')\n     prune_group.add_argument(\n         '--stats',\n         dest='stats',\n         default=False,\n         action='store_true',\n         help='Display statistics of archive',\n     )\n     prune_group.add_argument(\n         '--files', dest='files', default=False, action='store_true', help='Show per-file details'\n     )\n     prune_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     compact_parser = subparsers.add_parser(\n         'compact',\n         aliases=SUBPARSER_ALIASES['compact'],\n         help='Compact segments to free space (Borg 1.2+ only)',\n         description='Compact segments to free space (Borg 1.2+ only)',\n         add_help=False,\n     )\n     compact_group = compact_parser.add_argument_group('compact arguments')\n     compact_group.add_argument(\n         '--progress',\n         dest='progress',\n         default=False,\n         action='store_true',\n         help='Display progress as each segment is compacted',\n     )\n     compact_group.add_argument(\n         '--cleanup-commits',\n         dest='cleanup_commits',\n         default=False,\n         action='store_true',\n         help='Cleanup commit-only 17-byte segment files left behind by Borg 1.1',\n     )\n     compact_group.add_argument(\n         '--threshold',\n         type=int,\n         dest='threshold',\n         help='Minimum saved space percentage threshold for compacting a segment, defaults to 10',\n     )\n     compact_group.add_argument(\n         '-h', '--help', action='help', help='Show this help message and exit'\n     )\n \n     create_parser = subparsers.add_parser(\n         'create',\n         aliases=SUBPARSER_ALIASES['create'],\n         help='Create archives (actually perform backups)',\n         description='Create archives (actually perform backups)',\n         add_help=False,\n     )\n     create_group = create_parser.add_argument_group('create arguments')\n     create_group.add_argument(\n         '--progress',\n         dest='progress',\n         default=False,\n         action='store_true',\n         help='Display progress for each file as it is backed up',\n     )\n     create_group.add_argument(\n         '--stats',\n         dest='stats',\n         default=False,\n         action='store_true',\n         help='Display statistics of archive',\n     )\n     create_group.add_argument(\n         '--files', dest='files', default=False, action='store_true', help='Show per-file details'\n     )\n     create_group.add_argument(\n         '--json', dest='json', default=False, action='store_true', help='Output results as JSON'\n     )\n     create_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     check_parser = subparsers.add_parser(\n         'check',\n         aliases=SUBPARSER_ALIASES['check'],\n         help='Check archives for consistency',\n         description='Check archives for consistency',\n         add_help=False,\n     )\n     check_group = check_parser.add_argument_group('check arguments')\n     check_group.add_argument(\n         '--progress',\n         dest='progress',\n         default=False,\n         action='store_true',\n         help='Display progress for each file as it is checked',\n     )\n     check_group.add_argument(\n         '--repair',\n         dest='repair',\n         default=False,\n         action='store_true',\n         help='Attempt to repair any inconsistencies found (for interactive use)',\n     )\n     check_group.add_argument(\n         '--only',\n         metavar='CHECK',\n         choices=('repository', 'archives', 'data', 'extract'),\n         dest='only',\n         action='append',\n         help='Run a particular consistency check (repository, archives, data, or extract) instead of configured checks (subject to configured frequency, can specify flag multiple times)',\n     )\n     check_group.add_argument(\n         '--force',\n         default=False,\n         action='store_true',\n         help='Ignore configured check frequencies and run checks unconditionally',\n     )\n     check_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     extract_parser = subparsers.add_parser(\n         'extract',\n         aliases=SUBPARSER_ALIASES['extract'],\n         help='Extract files from a named archive to the current directory',\n         description='Extract a named archive to the current directory',\n         add_help=False,\n     )\n     extract_group = extract_parser.add_argument_group('extract arguments')\n     extract_group.add_argument(\n         '--repository',\n         help='Path of repository to extract, defaults to the configured repository if there is only one',\n     )\n     extract_group.add_argument(\n         '--archive', help='Name of archive to extract (or \"latest\")', required=True\n     )\n     extract_group.add_argument(\n         '--path',\n         '--restore-path',\n         metavar='PATH',\n         nargs='+',\n         dest='paths',\n         help='Paths to extract from archive, defaults to the entire archive',\n     )\n     extract_group.add_argument(\n         '--destination',\n         metavar='PATH',\n         dest='destination',\n         help='Directory to extract files into, defaults to the current directory',\n     )\n     extract_group.add_argument(\n         '--strip-components',\n         type=int,\n         metavar='NUMBER',\n         dest='strip_components',\n         help='Number of leading path components to remove from each extracted path. Skip paths with fewer elements',\n     )\n     extract_group.add_argument(\n         '--progress',\n         dest='progress',\n         default=False,\n         action='store_true',\n         help='Display progress for each file as it is extracted',\n     )\n     extract_group.add_argument(\n         '-h', '--help', action='help', help='Show this help message and exit'\n     )\n \n     export_tar_parser = subparsers.add_parser(\n         'export-tar',\n         aliases=SUBPARSER_ALIASES['export-tar'],\n         help='Export an archive to a tar-formatted file or stream',\n         description='Export an archive to a tar-formatted file or stream',\n         add_help=False,\n     )\n     export_tar_group = export_tar_parser.add_argument_group('export-tar arguments')\n     export_tar_group.add_argument(\n         '--repository',\n         help='Path of repository to export from, defaults to the configured repository if there is only one',\n     )\n     export_tar_group.add_argument(\n         '--archive', help='Name of archive to export (or \"latest\")', required=True\n     )\n     export_tar_group.add_argument(\n         '--path',\n         metavar='PATH',\n         nargs='+',\n         dest='paths',\n         help='Paths to export from archive, defaults to the entire archive',\n     )\n     export_tar_group.add_argument(\n         '--destination',\n         metavar='PATH',\n         dest='destination',\n         help='Path to destination export tar file, or \"-\" for stdout (but be careful about dirtying output with --verbosity or --files)',\n         required=True,\n     )\n     export_tar_group.add_argument(\n         '--tar-filter', help='Name of filter program to pipe data through'\n     )\n     export_tar_group.add_argument(\n         '--files', default=False, action='store_true', help='Show per-file details'\n     )\n     export_tar_group.add_argument(\n         '--strip-components',\n         type=int,\n         metavar='NUMBER',\n         dest='strip_components',\n         help='Number of leading path components to remove from each exported path. Skip paths with fewer elements',\n     )\n     export_tar_group.add_argument(\n         '-h', '--help', action='help', help='Show this help message and exit'\n     )\n \n     mount_parser = subparsers.add_parser(\n         'mount',\n         aliases=SUBPARSER_ALIASES['mount'],\n         help='Mount files from a named archive as a FUSE filesystem',\n         description='Mount a named archive as a FUSE filesystem',\n         add_help=False,\n     )\n     mount_group = mount_parser.add_argument_group('mount arguments')\n     mount_group.add_argument(\n         '--repository',\n         help='Path of repository to use, defaults to the configured repository if there is only one',\n     )\n     mount_group.add_argument('--archive', help='Name of archive to mount (or \"latest\")')\n     mount_group.add_argument(\n         '--mount-point',\n         metavar='PATH',\n         dest='mount_point',\n         help='Path where filesystem is to be mounted',\n         required=True,\n     )\n     mount_group.add_argument(\n         '--path',\n         metavar='PATH',\n         nargs='+',\n         dest='paths',\n         help='Paths to mount from archive, defaults to the entire archive',\n     )\n     mount_group.add_argument(\n         '--foreground',\n         dest='foreground',\n         default=False,\n         action='store_true',\n         help='Stay in foreground until ctrl-C is pressed',\n     )\n     mount_group.add_argument('--options', dest='options', help='Extra Borg mount options')\n     mount_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     umount_parser = subparsers.add_parser(\n         'umount',\n         aliases=SUBPARSER_ALIASES['umount'],\n         help='Unmount a FUSE filesystem that was mounted with \"borgmatic mount\"',\n         description='Unmount a mounted FUSE filesystem',\n         add_help=False,\n     )\n     umount_group = umount_parser.add_argument_group('umount arguments')\n     umount_group.add_argument(\n         '--mount-point',\n         metavar='PATH',\n         dest='mount_point',\n         help='Path of filesystem to unmount',\n         required=True,\n     )\n     umount_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     restore_parser = subparsers.add_parser(\n         'restore',\n         aliases=SUBPARSER_ALIASES['restore'],\n         help='Restore database dumps from a named archive',\n         description='Restore database dumps from a named archive. (To extract files instead, use \"borgmatic extract\".)',\n         add_help=False,\n     )\n     restore_group = restore_parser.add_argument_group('restore arguments')\n     restore_group.add_argument(\n         '--repository',\n         help='Path of repository to restore from, defaults to the configured repository if there is only one',\n     )\n     restore_group.add_argument(\n         '--archive', help='Name of archive to restore from (or \"latest\")', required=True\n     )\n     restore_group.add_argument(\n         '--database',\n         metavar='NAME',\n         nargs='+',\n         dest='databases',\n         help='Names of databases to restore from archive, defaults to all databases. Note that any databases to restore must be defined in borgmatic\\'s configuration',\n     )\n     restore_group.add_argument(\n         '-h', '--help', action='help', help='Show this help message and exit'\n     )\n \n     list_parser = subparsers.add_parser(\n         'list',\n         aliases=SUBPARSER_ALIASES['list'],\n         help='List archives',\n         description='List archives or the contents of an archive',\n         add_help=False,\n     )\n     list_group = list_parser.add_argument_group('list arguments')\n     list_group.add_argument(\n         '--repository', help='Path of repository to list, defaults to the configured repositories',\n     )\n     list_group.add_argument('--archive', help='Name of archive to list (or \"latest\")')\n     list_group.add_argument(\n         '--path',\n         metavar='PATH',\n         nargs='+',\n         dest='paths',\n         help='Paths or patterns to list from a single selected archive (via \"--archive\"), defaults to listing the entire archive',\n     )\n     list_group.add_argument(\n         '--find',\n         metavar='PATH',\n         nargs='+',\n         dest='find_paths',\n         help='Partial paths or patterns to search for and list across multiple archives',\n     )\n     list_group.add_argument(\n         '--short', default=False, action='store_true', help='Output only archive or path names'\n     )\n     list_group.add_argument('--format', help='Format for file listing')\n     list_group.add_argument(\n         '--json', default=False, action='store_true', help='Output results as JSON'\n     )\n     list_group.add_argument(\n         '-P', '--prefix', help='Only list archive names starting with this prefix'\n     )\n     list_group.add_argument(\n         '-a', '--glob-archives', metavar='GLOB', help='Only list archive names matching this glob'\n     )\n     list_group.add_argument(\n         '--successful',\n         default=True,\n         action='store_true',\n         help='Deprecated in favor of listing successful (non-checkpoint) backups by default in newer versions of Borg',\n     )\n     list_group.add_argument(\n         '--sort-by', metavar='KEYS', help='Comma-separated list of sorting keys'\n     )\n     list_group.add_argument(\n         '--first', metavar='N', help='List first N archives after other filters are applied'\n     )\n     list_group.add_argument(\n         '--last', metavar='N', help='List last N archives after other filters are applied'\n     )\n     list_group.add_argument(\n         '-e', '--exclude', metavar='PATTERN', help='Exclude paths matching the pattern'\n     )\n     list_group.add_argument(\n         '--exclude-from', metavar='FILENAME', help='Exclude paths from exclude file, one per line'\n     )\n     list_group.add_argument('--pattern', help='Include or exclude paths matching a pattern')\n     list_group.add_argument(\n         '--patterns-from',\n         metavar='FILENAME',\n         help='Include or exclude paths matching patterns from pattern file, one per line',\n     )\n     list_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     info_parser = subparsers.add_parser(\n         'info',\n         aliases=SUBPARSER_ALIASES['info'],\n         help='Display summary information on archives',\n         description='Display summary information on archives',\n         add_help=False,\n     )\n     info_group = info_parser.add_argument_group('info arguments')\n     info_group.add_argument(\n         '--repository',\n         help='Path of repository to show info for, defaults to the configured repository if there is only one',\n     )\n     info_group.add_argument('--archive', help='Name of archive to show info for (or \"latest\")')\n     info_group.add_argument(\n         '--json', dest='json', default=False, action='store_true', help='Output results as JSON'\n     )\n     info_group.add_argument(\n         '-P', '--prefix', help='Only show info for archive names starting with this prefix'\n     )\n     info_group.add_argument(\n         '-a',\n         '--glob-archives',\n         metavar='GLOB',\n         help='Only show info for archive names matching this glob',\n     )\n     info_group.add_argument(\n         '--sort-by', metavar='KEYS', help='Comma-separated list of sorting keys'\n     )\n     info_group.add_argument(\n         '--first',\n         metavar='N',\n         help='Show info for first N archives after other filters are applied',\n     )\n     info_group.add_argument(\n         '--last', metavar='N', help='Show info for last N archives after other filters are applied'\n     )\n     info_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     borg_parser = subparsers.add_parser(\n         'borg',\n         aliases=SUBPARSER_ALIASES['borg'],\n         help='Run an arbitrary Borg command',\n         description='Run an arbitrary Borg command based on borgmatic\\'s configuration',\n         add_help=False,\n     )\n     borg_group = borg_parser.add_argument_group('borg arguments')\n     borg_group.add_argument(\n         '--repository',\n         help='Path of repository to pass to Borg, defaults to the configured repositories',\n     )\n     borg_group.add_argument('--archive', help='Name of archive to pass to Borg (or \"latest\")')\n     borg_group.add_argument(\n         '--',\n         metavar='OPTION',\n         dest='options',\n         nargs='+',\n         help='Options to pass to Borg, command first (\"create\", \"list\", etc). \"--\" is optional. To specify the repository or the archive, you must use --repository or --archive instead of providing them here.',\n     )\n     borg_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n \n     return top_level_parser, subparsers\n \n \n def parse_arguments(*unparsed_arguments):\n     '''\n     Given command-line arguments with which this script was invoked, parse the arguments and return\n     them as a dict mapping from subparser name (or \"global\") to an argparse.Namespace instance.\n     '''\n     top_level_parser, subparsers = make_parsers()\n \n     arguments, remaining_arguments = parse_subparser_arguments(\n         unparsed_arguments, subparsers.choices\n     )\n     arguments['global'] = top_level_parser.parse_args(remaining_arguments)\n \n     if arguments['global'].excludes_filename:\n         raise ValueError(\n             'The --excludes option has been replaced with exclude_patterns in configuration'\n         )\n \n     if 'init' in arguments and arguments['global'].dry_run:\n         raise ValueError('The init action cannot be used with the --dry-run option')\n \n     if (\n         'list' in arguments\n         and 'info' in arguments\n         and arguments['list'].json\n         and arguments['info'].json\n     ):\n         raise ValueError('With the --json option, list and info actions cannot be used together')\n \n     return arguments\n ", "input_code": "def parse_subparser_arguments(unparsed_arguments, subparsers):\n\"\"\"\nGiven a sequence of arguments and a dict from subparser name to argparse.ArgumentParser\ninstance, give each requested action's subparser a shot at parsing all arguments. This allows\ncommon arguments like \"--repository\" to be shared across multiple subparsers.\n\nReturn the result as a tuple of (a dict mapping from subparser name to a parsed namespace of\narguments, a list of remaining arguments not claimed by any subparser).\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def parse_subparser_arguments(unparsed_arguments, subparsers):\n    '''\n    Given a sequence of arguments and a dict from subparser name to argparse.ArgumentParser\n    instance, give each requested action's subparser a shot at parsing all arguments. This allows\n    common arguments like \"--repository\" to be shared across multiple subparsers.\n\n    Return the result as a tuple of (a dict mapping from subparser name to a parsed namespace of\n    arguments, a list of remaining arguments not claimed by any subparser).\n    '''\n    arguments = collections.OrderedDict()\n    remaining_arguments = list(unparsed_arguments)\n    alias_to_subparser_name = {\n        alias: subparser_name\n        for subparser_name, aliases in SUBPARSER_ALIASES.items()\n        for alias in aliases\n    }\n\n    # If the \"borg\" action is used, skip all other subparsers. This avoids confusion like\n    # \"borg list\" triggering borgmatic's own list action.\n    if 'borg' in unparsed_arguments:\n        subparsers = {'borg': subparsers['borg']}\n\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name not in remaining_arguments:\n            continue\n\n        canonical_name = alias_to_subparser_name.get(subparser_name, subparser_name)\n\n        # If a parsed value happens to be the same as the name of a subparser, remove it from the\n        # remaining arguments. This prevents, for instance, \"check --only extract\" from triggering\n        # the \"extract\" subparser.\n        parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)\n        for value in vars(parsed).values():\n            if isinstance(value, str):\n                if value in subparsers:\n                    remaining_arguments.remove(value)\n            elif isinstance(value, list):\n                for item in value:\n                    if item in subparsers:\n                        remaining_arguments.remove(item)\n\n        arguments[canonical_name] = parsed\n\n    # If no actions are explicitly requested, assume defaults: prune, compact, create, and check.\n    if not arguments and '--help' not in unparsed_arguments and '-h' not in unparsed_arguments:\n        for subparser_name in ('prune', 'compact', 'create', 'check'):\n            subparser = subparsers[subparser_name]\n            parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)\n            arguments[subparser_name] = parsed\n\n    remaining_arguments = list(unparsed_arguments)\n\n    # Now ask each subparser, one by one, to greedily consume arguments.\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name not in arguments.keys():\n            continue\n\n        subparser = subparsers[subparser_name]\n        unused_parsed, remaining_arguments = subparser.parse_known_args(remaining_arguments)\n\n    # Special case: If \"borg\" is present in the arguments, consume all arguments after (+1) the\n    # \"borg\" action.\n    if 'borg' in arguments:\n        borg_options_index = remaining_arguments.index('borg') + 1\n        arguments['borg'].options = remaining_arguments[borg_options_index:]\n        remaining_arguments = remaining_arguments[:borg_options_index]\n\n    # Remove the subparser names themselves.\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name in remaining_arguments:\n            remaining_arguments.remove(subparser_name)\n\n    return (arguments, remaining_arguments)", "signature": "def parse_subparser_arguments(unparsed_arguments, subparsers):", "completion_path": "borgmatic/commands/arguments.py"}
{"ce_id": "62b438a266fea644fe22cc2c", "namespace": "62b438a266fea644fe22cc2c", "namespace_real": "borgmatic.commands.arguments.make_parsers", "real_proj_path": "witten---borgmatic/", "type": "function", "class_name": null, "function_name": "make_parsers", "contexts_above": "import collections\nfrom argparse import Action, ArgumentParser\n\nfrom borgmatic.config import collect\n\nSUBPARSER_ALIASES = {\n    'init': ['--init', '-I'],\n    'prune': ['--prune', '-p'],\n    'compact': [],\n    'create': ['--create', '-C'],\n    'check': ['--check', '-k'],\n    'extract': ['--extract', '-x'],\n    'export-tar': ['--export-tar'],\n    'mount': ['--mount', '-m'],\n    'umount': ['--umount', '-u'],\n    'restore': ['--restore', '-r'],\n    'list': ['--list', '-l'],\n    'info': ['--info', '-i'],\n    'borg': [],\n}\n\n\ndef parse_subparser_arguments(unparsed_arguments, subparsers):\n    '''\n    Given a sequence of arguments and a dict from subparser name to argparse.ArgumentParser\n    instance, give each requested action's subparser a shot at parsing all arguments. This allows\n    common arguments like \"--repository\" to be shared across multiple subparsers.\n\n    Return the result as a tuple of (a dict mapping from subparser name to a parsed namespace of\n    arguments, a list of remaining arguments not claimed by any subparser).\n    '''\n    arguments = collections.OrderedDict()\n    remaining_arguments = list(unparsed_arguments)\n    alias_to_subparser_name = {\n        alias: subparser_name\n        for subparser_name, aliases in SUBPARSER_ALIASES.items()\n        for alias in aliases\n    }\n\n    # If the \"borg\" action is used, skip all other subparsers. This avoids confusion like\n    # \"borg list\" triggering borgmatic's own list action.\n    if 'borg' in unparsed_arguments:\n        subparsers = {'borg': subparsers['borg']}\n\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name not in remaining_arguments:\n            continue\n\n        canonical_name = alias_to_subparser_name.get(subparser_name, subparser_name)\n\n        # If a parsed value happens to be the same as the name of a subparser, remove it from the\n        # remaining arguments. This prevents, for instance, \"check --only extract\" from triggering\n        # the \"extract\" subparser.\n        parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)\n        for value in vars(parsed).values():\n            if isinstance(value, str):\n                if value in subparsers:\n                    remaining_arguments.remove(value)\n            elif isinstance(value, list):\n                for item in value:\n                    if item in subparsers:\n                        remaining_arguments.remove(item)\n\n        arguments[canonical_name] = parsed\n\n    # If no actions are explicitly requested, assume defaults: prune, compact, create, and check.\n    if not arguments and '--help' not in unparsed_arguments and '-h' not in unparsed_arguments:\n        for subparser_name in ('prune', 'compact', 'create', 'check'):\n            subparser = subparsers[subparser_name]\n            parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)\n            arguments[subparser_name] = parsed\n\n    remaining_arguments = list(unparsed_arguments)\n\n    # Now ask each subparser, one by one, to greedily consume arguments.\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name not in arguments.keys():\n            continue\n\n        subparser = subparsers[subparser_name]\n        unused_parsed, remaining_arguments = subparser.parse_known_args(remaining_arguments)\n\n    # Special case: If \"borg\" is present in the arguments, consume all arguments after (+1) the\n    # \"borg\" action.\n    if 'borg' in arguments:\n        borg_options_index = remaining_arguments.index('borg') + 1\n        arguments['borg'].options = remaining_arguments[borg_options_index:]\n        remaining_arguments = remaining_arguments[:borg_options_index]\n\n    # Remove the subparser names themselves.\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name in remaining_arguments:\n            remaining_arguments.remove(subparser_name)\n\n    return (arguments, remaining_arguments)\n\n\nclass Extend_action(Action):\n    '''\n    An argparse action to support Python 3.8's \"extend\" action in older versions of Python.\n    '''\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        items = getattr(namespace, self.dest, None)\n\n        if items:\n            items.extend(values)\n        else:\n            setattr(namespace, self.dest, list(values))\n\n", "contexts_below": "\n def parse_arguments(*unparsed_arguments):\n     '''\n     Given command-line arguments with which this script was invoked, parse the arguments and return\n     them as a dict mapping from subparser name (or \"global\") to an argparse.Namespace instance.\n     '''\n     top_level_parser, subparsers = make_parsers()\n \n     arguments, remaining_arguments = parse_subparser_arguments(\n         unparsed_arguments, subparsers.choices\n     )\n     arguments['global'] = top_level_parser.parse_args(remaining_arguments)\n \n     if arguments['global'].excludes_filename:\n         raise ValueError(\n             'The --excludes option has been replaced with exclude_patterns in configuration'\n         )\n \n     if 'init' in arguments and arguments['global'].dry_run:\n         raise ValueError('The init action cannot be used with the --dry-run option')\n \n     if (\n         'list' in arguments\n         and 'info' in arguments\n         and arguments['list'].json\n         and arguments['info'].json\n     ):\n         raise ValueError('With the --json option, list and info actions cannot be used together')\n \n     return arguments\n ", "input_code": "def make_parsers():\n\"\"\"\nBuild a top-level parser and its subparsers and return them as a tuple.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def make_parsers():\n    '''\n    Build a top-level parser and its subparsers and return them as a tuple.\n    '''\n    config_paths = collect.get_default_config_paths(expand_home=True)\n    unexpanded_config_paths = collect.get_default_config_paths(expand_home=False)\n\n    global_parser = ArgumentParser(add_help=False)\n    global_parser.register('action', 'extend', Extend_action)\n    global_group = global_parser.add_argument_group('global arguments')\n\n    global_group.add_argument(\n        '-c',\n        '--config',\n        nargs='*',\n        dest='config_paths',\n        default=config_paths,\n        help='Configuration filenames or directories, defaults to: {}'.format(\n            ' '.join(unexpanded_config_paths)\n        ),\n    )\n    global_group.add_argument(\n        '--excludes',\n        dest='excludes_filename',\n        help='Deprecated in favor of exclude_patterns within configuration',\n    )\n    global_group.add_argument(\n        '-n',\n        '--dry-run',\n        dest='dry_run',\n        action='store_true',\n        help='Go through the motions, but do not actually write to any repositories',\n    )\n    global_group.add_argument(\n        '-nc', '--no-color', dest='no_color', action='store_true', help='Disable colored output'\n    )\n    global_group.add_argument(\n        '-v',\n        '--verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Display verbose progress to the console (from only errors to very verbose: -1, 0, 1, or 2)',\n    )\n    global_group.add_argument(\n        '--syslog-verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Log verbose progress to syslog (from only errors to very verbose: -1, 0, 1, or 2). Ignored when console is interactive or --log-file is given',\n    )\n    global_group.add_argument(\n        '--log-file-verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Log verbose progress to log file (from only errors to very verbose: -1, 0, 1, or 2). Only used when --log-file is given',\n    )\n    global_group.add_argument(\n        '--monitoring-verbosity',\n        type=int,\n        choices=range(-1, 3),\n        default=0,\n        help='Log verbose progress to monitoring integrations that support logging (from only errors to very verbose: -1, 0, 1, or 2)',\n    )\n    global_group.add_argument(\n        '--log-file',\n        type=str,\n        default=None,\n        help='Write log messages to this file instead of syslog',\n    )\n    global_group.add_argument(\n        '--override',\n        metavar='SECTION.OPTION=VALUE',\n        nargs='+',\n        dest='overrides',\n        action='extend',\n        help='One or more configuration file options to override with specified values',\n    )\n    global_group.add_argument(\n        '--no-environment-interpolation',\n        dest='resolve_env',\n        action='store_false',\n        help='Do not resolve environment variables in configuration file',\n    )\n    global_group.add_argument(\n        '--bash-completion',\n        default=False,\n        action='store_true',\n        help='Show bash completion script and exit',\n    )\n    global_group.add_argument(\n        '--version',\n        dest='version',\n        default=False,\n        action='store_true',\n        help='Display installed version number of borgmatic and exit',\n    )\n\n    top_level_parser = ArgumentParser(\n        description='''\n            Simple, configuration-driven backup software for servers and workstations. If none of\n            the action options are given, then borgmatic defaults to: prune, compact, create, and\n            check.\n            ''',\n        parents=[global_parser],\n    )\n\n    subparsers = top_level_parser.add_subparsers(\n        title='actions',\n        metavar='',\n        help='Specify zero or more actions. Defaults to prune, compact, create, and check. Use --help with action for details:',\n    )\n    init_parser = subparsers.add_parser(\n        'init',\n        aliases=SUBPARSER_ALIASES['init'],\n        help='Initialize an empty Borg repository',\n        description='Initialize an empty Borg repository',\n        add_help=False,\n    )\n    init_group = init_parser.add_argument_group('init arguments')\n    init_group.add_argument(\n        '-e',\n        '--encryption',\n        dest='encryption_mode',\n        help='Borg repository encryption mode',\n        required=True,\n    )\n    init_group.add_argument(\n        '--append-only',\n        dest='append_only',\n        action='store_true',\n        help='Create an append-only repository',\n    )\n    init_group.add_argument(\n        '--storage-quota',\n        dest='storage_quota',\n        help='Create a repository with a fixed storage quota',\n    )\n    init_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    prune_parser = subparsers.add_parser(\n        'prune',\n        aliases=SUBPARSER_ALIASES['prune'],\n        help='Prune archives according to the retention policy (with Borg 1.2+, run compact afterwards to actually free space)',\n        description='Prune archives according to the retention policy (with Borg 1.2+, run compact afterwards to actually free space)',\n        add_help=False,\n    )\n    prune_group = prune_parser.add_argument_group('prune arguments')\n    prune_group.add_argument(\n        '--stats',\n        dest='stats',\n        default=False,\n        action='store_true',\n        help='Display statistics of archive',\n    )\n    prune_group.add_argument(\n        '--files', dest='files', default=False, action='store_true', help='Show per-file details'\n    )\n    prune_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    compact_parser = subparsers.add_parser(\n        'compact',\n        aliases=SUBPARSER_ALIASES['compact'],\n        help='Compact segments to free space (Borg 1.2+ only)',\n        description='Compact segments to free space (Borg 1.2+ only)',\n        add_help=False,\n    )\n    compact_group = compact_parser.add_argument_group('compact arguments')\n    compact_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress as each segment is compacted',\n    )\n    compact_group.add_argument(\n        '--cleanup-commits',\n        dest='cleanup_commits',\n        default=False,\n        action='store_true',\n        help='Cleanup commit-only 17-byte segment files left behind by Borg 1.1',\n    )\n    compact_group.add_argument(\n        '--threshold',\n        type=int,\n        dest='threshold',\n        help='Minimum saved space percentage threshold for compacting a segment, defaults to 10',\n    )\n    compact_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    create_parser = subparsers.add_parser(\n        'create',\n        aliases=SUBPARSER_ALIASES['create'],\n        help='Create archives (actually perform backups)',\n        description='Create archives (actually perform backups)',\n        add_help=False,\n    )\n    create_group = create_parser.add_argument_group('create arguments')\n    create_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress for each file as it is backed up',\n    )\n    create_group.add_argument(\n        '--stats',\n        dest='stats',\n        default=False,\n        action='store_true',\n        help='Display statistics of archive',\n    )\n    create_group.add_argument(\n        '--files', dest='files', default=False, action='store_true', help='Show per-file details'\n    )\n    create_group.add_argument(\n        '--json', dest='json', default=False, action='store_true', help='Output results as JSON'\n    )\n    create_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    check_parser = subparsers.add_parser(\n        'check',\n        aliases=SUBPARSER_ALIASES['check'],\n        help='Check archives for consistency',\n        description='Check archives for consistency',\n        add_help=False,\n    )\n    check_group = check_parser.add_argument_group('check arguments')\n    check_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress for each file as it is checked',\n    )\n    check_group.add_argument(\n        '--repair',\n        dest='repair',\n        default=False,\n        action='store_true',\n        help='Attempt to repair any inconsistencies found (for interactive use)',\n    )\n    check_group.add_argument(\n        '--only',\n        metavar='CHECK',\n        choices=('repository', 'archives', 'data', 'extract'),\n        dest='only',\n        action='append',\n        help='Run a particular consistency check (repository, archives, data, or extract) instead of configured checks (subject to configured frequency, can specify flag multiple times)',\n    )\n    check_group.add_argument(\n        '--force',\n        default=False,\n        action='store_true',\n        help='Ignore configured check frequencies and run checks unconditionally',\n    )\n    check_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    extract_parser = subparsers.add_parser(\n        'extract',\n        aliases=SUBPARSER_ALIASES['extract'],\n        help='Extract files from a named archive to the current directory',\n        description='Extract a named archive to the current directory',\n        add_help=False,\n    )\n    extract_group = extract_parser.add_argument_group('extract arguments')\n    extract_group.add_argument(\n        '--repository',\n        help='Path of repository to extract, defaults to the configured repository if there is only one',\n    )\n    extract_group.add_argument(\n        '--archive', help='Name of archive to extract (or \"latest\")', required=True\n    )\n    extract_group.add_argument(\n        '--path',\n        '--restore-path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths to extract from archive, defaults to the entire archive',\n    )\n    extract_group.add_argument(\n        '--destination',\n        metavar='PATH',\n        dest='destination',\n        help='Directory to extract files into, defaults to the current directory',\n    )\n    extract_group.add_argument(\n        '--strip-components',\n        type=int,\n        metavar='NUMBER',\n        dest='strip_components',\n        help='Number of leading path components to remove from each extracted path. Skip paths with fewer elements',\n    )\n    extract_group.add_argument(\n        '--progress',\n        dest='progress',\n        default=False,\n        action='store_true',\n        help='Display progress for each file as it is extracted',\n    )\n    extract_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    export_tar_parser = subparsers.add_parser(\n        'export-tar',\n        aliases=SUBPARSER_ALIASES['export-tar'],\n        help='Export an archive to a tar-formatted file or stream',\n        description='Export an archive to a tar-formatted file or stream',\n        add_help=False,\n    )\n    export_tar_group = export_tar_parser.add_argument_group('export-tar arguments')\n    export_tar_group.add_argument(\n        '--repository',\n        help='Path of repository to export from, defaults to the configured repository if there is only one',\n    )\n    export_tar_group.add_argument(\n        '--archive', help='Name of archive to export (or \"latest\")', required=True\n    )\n    export_tar_group.add_argument(\n        '--path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths to export from archive, defaults to the entire archive',\n    )\n    export_tar_group.add_argument(\n        '--destination',\n        metavar='PATH',\n        dest='destination',\n        help='Path to destination export tar file, or \"-\" for stdout (but be careful about dirtying output with --verbosity or --files)',\n        required=True,\n    )\n    export_tar_group.add_argument(\n        '--tar-filter', help='Name of filter program to pipe data through'\n    )\n    export_tar_group.add_argument(\n        '--files', default=False, action='store_true', help='Show per-file details'\n    )\n    export_tar_group.add_argument(\n        '--strip-components',\n        type=int,\n        metavar='NUMBER',\n        dest='strip_components',\n        help='Number of leading path components to remove from each exported path. Skip paths with fewer elements',\n    )\n    export_tar_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    mount_parser = subparsers.add_parser(\n        'mount',\n        aliases=SUBPARSER_ALIASES['mount'],\n        help='Mount files from a named archive as a FUSE filesystem',\n        description='Mount a named archive as a FUSE filesystem',\n        add_help=False,\n    )\n    mount_group = mount_parser.add_argument_group('mount arguments')\n    mount_group.add_argument(\n        '--repository',\n        help='Path of repository to use, defaults to the configured repository if there is only one',\n    )\n    mount_group.add_argument('--archive', help='Name of archive to mount (or \"latest\")')\n    mount_group.add_argument(\n        '--mount-point',\n        metavar='PATH',\n        dest='mount_point',\n        help='Path where filesystem is to be mounted',\n        required=True,\n    )\n    mount_group.add_argument(\n        '--path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths to mount from archive, defaults to the entire archive',\n    )\n    mount_group.add_argument(\n        '--foreground',\n        dest='foreground',\n        default=False,\n        action='store_true',\n        help='Stay in foreground until ctrl-C is pressed',\n    )\n    mount_group.add_argument('--options', dest='options', help='Extra Borg mount options')\n    mount_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    umount_parser = subparsers.add_parser(\n        'umount',\n        aliases=SUBPARSER_ALIASES['umount'],\n        help='Unmount a FUSE filesystem that was mounted with \"borgmatic mount\"',\n        description='Unmount a mounted FUSE filesystem',\n        add_help=False,\n    )\n    umount_group = umount_parser.add_argument_group('umount arguments')\n    umount_group.add_argument(\n        '--mount-point',\n        metavar='PATH',\n        dest='mount_point',\n        help='Path of filesystem to unmount',\n        required=True,\n    )\n    umount_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    restore_parser = subparsers.add_parser(\n        'restore',\n        aliases=SUBPARSER_ALIASES['restore'],\n        help='Restore database dumps from a named archive',\n        description='Restore database dumps from a named archive. (To extract files instead, use \"borgmatic extract\".)',\n        add_help=False,\n    )\n    restore_group = restore_parser.add_argument_group('restore arguments')\n    restore_group.add_argument(\n        '--repository',\n        help='Path of repository to restore from, defaults to the configured repository if there is only one',\n    )\n    restore_group.add_argument(\n        '--archive', help='Name of archive to restore from (or \"latest\")', required=True\n    )\n    restore_group.add_argument(\n        '--database',\n        metavar='NAME',\n        nargs='+',\n        dest='databases',\n        help='Names of databases to restore from archive, defaults to all databases. Note that any databases to restore must be defined in borgmatic\\'s configuration',\n    )\n    restore_group.add_argument(\n        '-h', '--help', action='help', help='Show this help message and exit'\n    )\n\n    list_parser = subparsers.add_parser(\n        'list',\n        aliases=SUBPARSER_ALIASES['list'],\n        help='List archives',\n        description='List archives or the contents of an archive',\n        add_help=False,\n    )\n    list_group = list_parser.add_argument_group('list arguments')\n    list_group.add_argument(\n        '--repository', help='Path of repository to list, defaults to the configured repositories',\n    )\n    list_group.add_argument('--archive', help='Name of archive to list (or \"latest\")')\n    list_group.add_argument(\n        '--path',\n        metavar='PATH',\n        nargs='+',\n        dest='paths',\n        help='Paths or patterns to list from a single selected archive (via \"--archive\"), defaults to listing the entire archive',\n    )\n    list_group.add_argument(\n        '--find',\n        metavar='PATH',\n        nargs='+',\n        dest='find_paths',\n        help='Partial paths or patterns to search for and list across multiple archives',\n    )\n    list_group.add_argument(\n        '--short', default=False, action='store_true', help='Output only archive or path names'\n    )\n    list_group.add_argument('--format', help='Format for file listing')\n    list_group.add_argument(\n        '--json', default=False, action='store_true', help='Output results as JSON'\n    )\n    list_group.add_argument(\n        '-P', '--prefix', help='Only list archive names starting with this prefix'\n    )\n    list_group.add_argument(\n        '-a', '--glob-archives', metavar='GLOB', help='Only list archive names matching this glob'\n    )\n    list_group.add_argument(\n        '--successful',\n        default=True,\n        action='store_true',\n        help='Deprecated in favor of listing successful (non-checkpoint) backups by default in newer versions of Borg',\n    )\n    list_group.add_argument(\n        '--sort-by', metavar='KEYS', help='Comma-separated list of sorting keys'\n    )\n    list_group.add_argument(\n        '--first', metavar='N', help='List first N archives after other filters are applied'\n    )\n    list_group.add_argument(\n        '--last', metavar='N', help='List last N archives after other filters are applied'\n    )\n    list_group.add_argument(\n        '-e', '--exclude', metavar='PATTERN', help='Exclude paths matching the pattern'\n    )\n    list_group.add_argument(\n        '--exclude-from', metavar='FILENAME', help='Exclude paths from exclude file, one per line'\n    )\n    list_group.add_argument('--pattern', help='Include or exclude paths matching a pattern')\n    list_group.add_argument(\n        '--patterns-from',\n        metavar='FILENAME',\n        help='Include or exclude paths matching patterns from pattern file, one per line',\n    )\n    list_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    info_parser = subparsers.add_parser(\n        'info',\n        aliases=SUBPARSER_ALIASES['info'],\n        help='Display summary information on archives',\n        description='Display summary information on archives',\n        add_help=False,\n    )\n    info_group = info_parser.add_argument_group('info arguments')\n    info_group.add_argument(\n        '--repository',\n        help='Path of repository to show info for, defaults to the configured repository if there is only one',\n    )\n    info_group.add_argument('--archive', help='Name of archive to show info for (or \"latest\")')\n    info_group.add_argument(\n        '--json', dest='json', default=False, action='store_true', help='Output results as JSON'\n    )\n    info_group.add_argument(\n        '-P', '--prefix', help='Only show info for archive names starting with this prefix'\n    )\n    info_group.add_argument(\n        '-a',\n        '--glob-archives',\n        metavar='GLOB',\n        help='Only show info for archive names matching this glob',\n    )\n    info_group.add_argument(\n        '--sort-by', metavar='KEYS', help='Comma-separated list of sorting keys'\n    )\n    info_group.add_argument(\n        '--first',\n        metavar='N',\n        help='Show info for first N archives after other filters are applied',\n    )\n    info_group.add_argument(\n        '--last', metavar='N', help='Show info for last N archives after other filters are applied'\n    )\n    info_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    borg_parser = subparsers.add_parser(\n        'borg',\n        aliases=SUBPARSER_ALIASES['borg'],\n        help='Run an arbitrary Borg command',\n        description='Run an arbitrary Borg command based on borgmatic\\'s configuration',\n        add_help=False,\n    )\n    borg_group = borg_parser.add_argument_group('borg arguments')\n    borg_group.add_argument(\n        '--repository',\n        help='Path of repository to pass to Borg, defaults to the configured repositories',\n    )\n    borg_group.add_argument('--archive', help='Name of archive to pass to Borg (or \"latest\")')\n    borg_group.add_argument(\n        '--',\n        metavar='OPTION',\n        dest='options',\n        nargs='+',\n        help='Options to pass to Borg, command first (\"create\", \"list\", etc). \"--\" is optional. To specify the repository or the archive, you must use --repository or --archive instead of providing them here.',\n    )\n    borg_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n    return top_level_parser, subparsers", "signature": "def make_parsers():", "completion_path": "borgmatic/commands/arguments.py"}
{"ce_id": "62ece4982e6aefcf4aabbd5f", "namespace": "62ece4982e6aefcf4aabbd5f", "namespace_real": "infoblox_client.utils.paging", "real_proj_path": "infobloxopen---infoblox-client/", "type": "function", "class_name": null, "function_name": "paging", "contexts_above": "# Copyright 2015 OpenStack LLC.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport netaddr\nimport six\n\ntry:\n    from oslo_log import log as logging\nexcept ImportError:  # pragma: no cover\n    import logging\n\ntry:\n    from oslo_serialization import jsonutils\nexcept ImportError:  # pragma: no cover\n    import json as jsonutils\n\nLOG = logging.getLogger(__name__)\n\n\ndef is_valid_ip(ip):\n    try:\n        netaddr.IPAddress(ip)\n    except netaddr.core.AddrFormatError:\n        return False\n    return True\n\n\ndef generate_duid(mac):\n    \"\"\"DUID is consisted of 10 hex numbers.\n\n    0x00 + mac with last 3 hex + mac with 6 hex\n    \"\"\"\n    valid = mac and isinstance(mac, six.string_types)\n    if not valid:\n        raise ValueError(\"Invalid argument was passed\")\n    return \"00:\" + mac[9:] + \":\" + mac\n\n\ndef determine_ip_version(ip_in):\n    ip_ver = 4\n    if isinstance(ip_in, (list, tuple)):\n        ip_in = ip_in[0]\n    if ip_in:\n        if isinstance(ip_in, int):\n            if ip_in == 6:\n                ip_ver = 6\n            else:\n                ip_ver = 4\n        elif hasattr(ip_in, 'ip_version'):\n            return ip_in.ip_version\n        else:\n            if type(ip_in) is dict:\n                addr = ip_in['ip_address']\n            else:\n                addr = ip_in\n            try:\n                ip = netaddr.IPAddress(addr)\n            except ValueError:\n                ip = netaddr.IPNetwork(addr)\n\n            ip_ver = ip.version\n    return ip_ver\n\n\ndef safe_json_load(data):\n    try:\n        return jsonutils.loads(data)\n    except ValueError:\n        LOG.warning(\"Could not decode reply into json: %s\", data)\n\n\ndef try_value_to_bool(value, strict_mode=True):\n    \"\"\"Tries to convert value into boolean.\n\n    Args:\n        value       (str): Value that should be converted into boolean.\n\n        strict_mode (bool):\n            - If strict_mode is True, Only string representation of str(True)\n              and str(False) are converted into booleans;\n            - If strict_mode is False, anything that looks like True or False\n              is converted into booleans:\n\n              - Values accepted as True are: 'true', 'on', 'yes' (case\n                independent)\n              - Values accepted as False are: 'false', 'off', 'no' (case\n                independent)\n\n    Returns:\n        True, False, or original value in case of failed conversion.\n    \"\"\"\n    if strict_mode:\n        true_list = ('True',)\n        false_list = ('False',)\n        val = value\n    else:\n        true_list = ('true', 'on', 'yes')\n        false_list = ('false', 'off', 'no')\n        val = str(value).lower()\n\n    if val in true_list:\n        return True\n    elif val in false_list:\n        return False\n    return value\n\n", "contexts_below": "", "input_code": "def paging(response, max_results):\n\"\"\"\nReturns WAPI response page by page\n\nArgs:\n    response (list): WAPI response.\n    max_results (int): Maximum number of objects to be returned in one page.\nReturns:\n    Generator object with WAPI response split page by page.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def paging(response, max_results):\n    \"\"\"Returns WAPI response page by page\n\n    Args:\n        response (list): WAPI response.\n        max_results (int): Maximum number of objects to be returned in one page.\n    Returns:\n        Generator object with WAPI response split page by page.\n    \"\"\"\n    i = 0\n    while i < len(response):\n        yield response[i:i + max_results]\n        i = i + max_results", "signature": "def paging(response, max_results):", "completion_path": "infoblox_client/utils.py"}
{"ce_id": "62ece4982e6aefcf4aabbd60", "namespace": "62ece4982e6aefcf4aabbd60", "namespace_real": "swh.lister.arch.lister.size_to_bytes", "real_proj_path": "SoftwareHeritage---swh-lister/", "type": "function", "class_name": null, "function_name": "size_to_bytes", "contexts_above": "# Copyright (C) 2022  The Software Heritage developers\n# See the AUTHORS file at the top-level directory of this distribution\n# License: GNU General Public License version 3, or any later version\n# See top-level LICENSE file for more information\nimport datetime\nimport logging\nfrom pathlib import Path\nimport re\nimport tarfile\nfrom typing import Any, Dict, Iterator, List, Optional\nfrom urllib.parse import unquote, urljoin\n\nfrom bs4 import BeautifulSoup\nimport requests\n\nfrom swh.model.hashutil import hash_to_hex\nfrom swh.scheduler.interface import SchedulerInterface\nfrom swh.scheduler.model import ListedOrigin\n\nfrom ..pattern import CredentialsType, StatelessLister\n\nlogger = logging.getLogger(__name__)\n\n# Aliasing the page results returned by `get_pages` method from the lister.\nArchListerPage = List[Dict[str, Any]]\n\n", "contexts_below": "\n class ArchLister(StatelessLister[ArchListerPage]):\n     \"\"\"List Arch linux origins from 'core', 'extra', and 'community' repositories\n \n     For 'official' Arch Linux it downloads core.tar.gz, extra.tar.gz and community.tar.gz\n     from https://archive.archlinux.org/repos/last/ extract to a temp directory and\n     then walks through each 'desc' files.\n \n     Each 'desc' file describe the latest released version of a package and helps\n     to build an origin url from where scrapping artifacts metadata.\n \n     For 'arm' Arch Linux it follow the same discovery process parsing 'desc' files.\n     The main difference is that we can't get existing versions of an arm package\n     because https://archlinuxarm.org does not have an 'archive' website or api.\n     \"\"\"\n \n     LISTER_NAME = \"arch\"\n     VISIT_TYPE = \"arch\"\n     INSTANCE = \"arch\"\n \n     DESTINATION_PATH = Path(\"/tmp/archlinux_archive\")\n \n     ARCH_PACKAGE_URL_PATTERN = \"{base_url}/packages/{repo}/{arch}/{pkgname}\"\n     ARCH_PACKAGE_VERSIONS_URL_PATTERN = \"{base_url}/packages/{pkgname[0]}/{pkgname}\"\n     ARCH_PACKAGE_DOWNLOAD_URL_PATTERN = (\n         \"{base_url}/packages/{pkgname[0]}/{pkgname}/{filename}\"\n     )\n     ARCH_API_URL_PATTERN = \"{base_url}/packages/{repo}/{arch}/{pkgname}/json\"\n \n     ARM_PACKAGE_URL_PATTERN = \"{base_url}/packages/{arch}/{pkgname}\"\n     ARM_PACKAGE_DOWNLOAD_URL_PATTERN = \"{base_url}/{arch}/{repo}/{filename}\"\n \n     def __init__(\n         self,\n         scheduler: SchedulerInterface,\n         credentials: Optional[CredentialsType] = None,\n         flavours: Dict[str, Any] = {\n             \"official\": {\n                 \"archs\": [\"x86_64\"],\n                 \"repos\": [\"core\", \"extra\", \"community\"],\n                 \"base_info_url\": \"https://archlinux.org\",\n                 \"base_archive_url\": \"https://archive.archlinux.org\",\n                 \"base_mirror_url\": \"\",\n                 \"base_api_url\": \"https://archlinux.org\",\n             },\n             \"arm\": {\n                 \"archs\": [\"armv7h\", \"aarch64\"],\n                 \"repos\": [\"core\", \"extra\", \"community\"],\n                 \"base_info_url\": \"https://archlinuxarm.org\",\n                 \"base_archive_url\": \"\",\n                 \"base_mirror_url\": \"https://uk.mirror.archlinuxarm.org\",\n                 \"base_api_url\": \"\",\n             },\n         },\n     ):\n         super().__init__(\n             scheduler=scheduler,\n             credentials=credentials,\n             url=flavours[\"official\"][\"base_info_url\"],\n             instance=self.INSTANCE,\n         )\n \n         self.flavours = flavours\n \n     def scrap_package_versions(\n         self, name: str, repo: str, base_url: str\n     ) -> List[Dict[str, Any]]:\n         \"\"\"Given a package 'name' and 'repo', make an http call to origin url and parse its content\n         to get package versions artifacts data.\n         That method is suitable only for 'official' Arch Linux, not 'arm'.\n \n         Args:\n             name: Package name\n             repo: The repository the package belongs to (one of self.repos)\n \n         Returns:\n             A list of dict of version\n \n             Example::\n \n                 [\n                     {\"url\": \"https://archive.archlinux.org/packages/d/dialog/dialog-1:1.3_20190211-1-x86_64.pkg.tar.xz\",  # noqa: B950\n                     \"arch\": \"x86_64\",\n                     \"repo\": \"core\",\n                     \"name\": \"dialog\",\n                     \"version\": \"1:1.3_20190211-1\",\n                     \"length\": 180000,\n                     \"filename\": \"dialog-1:1.3_20190211-1-x86_64.pkg.tar.xz\",\n                     \"last_modified\": \"2019-02-13T08:36:00\"},\n                 ]\n         \"\"\"\n         url = self.ARCH_PACKAGE_VERSIONS_URL_PATTERN.format(\n             pkgname=name, base_url=base_url\n         )\n         soup = BeautifulSoup(requests.get(url).text, \"html.parser\")\n         links = soup.find_all(\"a\", href=True)\n \n         # drop the first line (used to go to up directory)\n         if links[0].attrs[\"href\"] == \"../\":\n             links.pop(0)\n \n         versions = []\n \n         for link in links:\n             # filename displayed can be cropped if name is too long, get it from href instead\n             filename = unquote(link.attrs[\"href\"])\n \n             if filename.endswith((\".tar.xz\", \".tar.zst\")):\n                 # Extract arch from filename\n                 arch_rex = re.compile(\n                     rf\"^{re.escape(name)}-(?P<version>.*)-(?P<arch>any|i686|x86_64)\"\n                     rf\"(.pkg.tar.(?:zst|xz))$\"\n                 )\n                 m = arch_rex.match(filename)\n                 if m is None:\n                     logger.error(\n                         \"Can not find a match for architecture in %(filename)s\"\n                         % dict(filename=filename)\n                     )\n                 else:\n                     arch = m.group(\"arch\")\n                     version = m.group(\"version\")\n \n                 # Extract last_modified and an approximate file size\n                 raw_text = link.next_sibling\n                 raw_text_rex = re.compile(\n                     r\"^(?P<last_modified>\\d+-\\w+-\\d+ \\d\\d:\\d\\d)\\s+(?P<size>\\w+)$\"\n                 )\n                 s = raw_text_rex.search(raw_text.strip())\n                 if s is None:\n                     logger.error(\n                         \"Can not find a match for 'last_modified' and/or \"\n                         \"'size' in '%(raw_text)s'\" % dict(raw_text=raw_text)\n                     )\n                 else:\n                     assert s.groups()\n                     assert len(s.groups()) == 2\n                     last_modified_str, size = s.groups()\n \n                 # format as expected\n                 last_modified = datetime.datetime.strptime(\n                     last_modified_str, \"%d-%b-%Y %H:%M\"\n                 ).isoformat()\n \n                 length = size_to_bytes(size)  # we want bytes\n \n                 # link url is relative, format a canonical one\n                 url = self.ARCH_PACKAGE_DOWNLOAD_URL_PATTERN.format(\n                     base_url=base_url, pkgname=name, filename=filename\n                 )\n                 versions.append(\n                     dict(\n                         name=name,\n                         version=version,\n                         repo=repo,\n                         arch=arch,\n                         filename=filename,\n                         url=url,\n                         last_modified=last_modified,\n                         length=length,\n                     )\n                 )\n         return versions\n \n     def get_repo_archive(self, url: str, destination_path: Path) -> Path:\n         \"\"\"Given an url and a destination path, retrieve and extract .tar.gz archive\n         which contains 'desc' file for each package.\n         Each .tar.gz archive corresponds to an Arch Linux repo ('core', 'extra', 'community').\n \n         Args:\n             url: url of the .tar.gz archive to download\n             destination_path: the path on disk where to extract archive\n \n         Returns:\n             a directory Path where the archive has been extracted to.\n         \"\"\"\n         res = requests.get(url)\n         destination_path.parent.mkdir(parents=True, exist_ok=True)\n         destination_path.write_bytes(res.content)\n \n         extract_to = Path(str(destination_path).split(\".tar.gz\")[0])\n         tar = tarfile.open(destination_path)\n         tar.extractall(path=extract_to)\n         tar.close()\n \n         return extract_to\n \n     def parse_desc_file(\n         self,\n         path: Path,\n         repo: str,\n         base_url: str,\n         dl_url_fmt: str,\n     ) -> Dict[str, Any]:\n         \"\"\"Extract package information from a 'desc' file.\n         There are subtle differences between parsing 'official' and 'arm' des files\n \n         Args:\n             path: A path to a 'desc' file on disk\n             repo: The repo the package belongs to\n \n         Returns:\n             A dict of metadata\n \n             Example::\n \n                 {'api_url': 'https://archlinux.org/packages/core/x86_64/dialog/json',\n                  'arch': 'x86_64',\n                  'base': 'dialog',\n                  'builddate': '1650081535',\n                  'csize': '203028',\n                  'desc': 'A tool to display dialog boxes from shell scripts',\n                  'filename': 'dialog-1:1.3_20220414-1-x86_64.pkg.tar.zst',\n                  'isize': '483988',\n                  'license': 'LGPL2.1',\n                  'md5sum': '06407c0cb11c50d7bf83d600f2e8107c',\n                  'name': 'dialog',\n                  'packager': 'Evangelos Foutras <foutrelis@archlinux.org>',\n                  'pgpsig': 'pgpsig content xxx',\n                  'project_url': 'https://invisible-island.net/dialog/',\n                  'provides': 'libdialog.so=15-64',\n                  'repo': 'core',\n                  'sha256sum': 'ef8c8971f591de7db0f455970ef5d81d5aced1ddf139f963f16f6730b1851fa7',\n                  'url': 'https://archive.archlinux.org/packages/.all/dialog-1:1.3_20220414-1-x86_64.pkg.tar.zst',  # noqa: B950\n                  'version': '1:1.3_20220414-1'}\n         \"\"\"\n         rex = re.compile(r\"^\\%(?P<k>\\w+)\\%\\n(?P<v>.*)\\n$\", re.M)\n         with path.open(\"rb\") as content:\n             parsed = rex.findall(content.read().decode())\n             data = {entry[0].lower(): entry[1] for entry in parsed}\n \n             if \"url\" in data.keys():\n                 data[\"project_url\"] = data[\"url\"]\n \n             assert data[\"name\"]\n             assert data[\"filename\"]\n             assert data[\"arch\"]\n \n             data[\"repo\"] = repo\n             data[\"url\"] = urljoin(\n                 base_url,\n                 dl_url_fmt.format(\n                     base_url=base_url,\n                     pkgname=data[\"name\"],\n                     filename=data[\"filename\"],\n                     arch=data[\"arch\"],\n                     repo=repo,\n                 ),\n             )\n \n             assert data[\"md5sum\"]\n             assert data[\"sha256sum\"]\n             data[\"checksums\"] = {\n                 \"md5sum\": hash_to_hex(data[\"md5sum\"]),\n                 \"sha256sum\": hash_to_hex(data[\"sha256sum\"]),\n             }\n         return data\n \n     def get_pages(self) -> Iterator[ArchListerPage]:\n         \"\"\"Yield an iterator sorted by name in ascending order of pages.\n \n         Each page is a list of package belonging to a flavour ('official', 'arm'),\n         and a repo ('core', 'extra', 'community')\n         \"\"\"\n \n         for name, flavour in self.flavours.items():\n             for arch in flavour[\"archs\"]:\n                 for repo in flavour[\"repos\"]:\n                     page = []\n                     if name == \"official\":\n                         prefix = urljoin(flavour[\"base_archive_url\"], \"/repos/last/\")\n                         filename = f\"{repo}.files.tar.gz\"\n                         archive_url = urljoin(prefix, f\"{repo}/os/{arch}/{filename}\")\n                         destination_path = Path(self.DESTINATION_PATH, arch, filename)\n                         base_url = flavour[\"base_archive_url\"]\n                         dl_url_fmt = self.ARCH_PACKAGE_DOWNLOAD_URL_PATTERN\n                         base_info_url = flavour[\"base_info_url\"]\n                         info_url_fmt = self.ARCH_PACKAGE_URL_PATTERN\n                     elif name == \"arm\":\n                         filename = f\"{repo}.files.tar.gz\"\n                         archive_url = urljoin(\n                             flavour[\"base_mirror_url\"], f\"{arch}/{repo}/{filename}\"\n                         )\n                         destination_path = Path(self.DESTINATION_PATH, arch, filename)\n                         base_url = flavour[\"base_mirror_url\"]\n                         dl_url_fmt = self.ARM_PACKAGE_DOWNLOAD_URL_PATTERN\n                         base_info_url = flavour[\"base_info_url\"]\n                         info_url_fmt = self.ARM_PACKAGE_URL_PATTERN\n \n                     archive = self.get_repo_archive(\n                         url=archive_url, destination_path=destination_path\n                     )\n \n                     assert archive\n \n                     packages_desc = list(archive.glob(\"**/desc\"))\n                     logger.debug(\n                         \"Processing %(instance)s source packages info from \"\n                         \"%(flavour)s %(arch)s %(repo)s repository, \"\n                         \"(%(qty)s packages).\"\n                         % dict(\n                             instance=self.instance,\n                             flavour=name,\n                             arch=arch,\n                             repo=repo,\n                             qty=len(packages_desc),\n                         )\n                     )\n \n                     for package_desc in packages_desc:\n                         data = self.parse_desc_file(\n                             path=package_desc,\n                             repo=repo,\n                             base_url=base_url,\n                             dl_url_fmt=dl_url_fmt,\n                         )\n \n                         assert data[\"builddate\"]\n                         last_modified = datetime.datetime.fromtimestamp(\n                             float(data[\"builddate\"]), tz=datetime.timezone.utc\n                         )\n \n                         assert data[\"name\"]\n                         assert data[\"filename\"]\n                         assert data[\"arch\"]\n                         url = info_url_fmt.format(\n                             base_url=base_info_url,\n                             pkgname=data[\"name\"],\n                             filename=data[\"filename\"],\n                             repo=repo,\n                             arch=data[\"arch\"],\n                         )\n \n                         assert data[\"version\"]\n                         if name == \"official\":\n                             # find all versions of a package scrapping archive\n                             versions = self.scrap_package_versions(\n                                 name=data[\"name\"],\n                                 repo=repo,\n                                 base_url=base_url,\n                             )\n                         elif name == \"arm\":\n                             # There is no way to get related versions of a package,\n                             # but 'data' represents the latest released version,\n                             # use it in this case\n                             assert data[\"builddate\"]\n                             assert data[\"csize\"]\n                             assert data[\"url\"]\n                             versions = [\n                                 dict(\n                                     name=data[\"name\"],\n                                     version=data[\"version\"],\n                                     repo=repo,\n                                     arch=data[\"arch\"],\n                                     filename=data[\"filename\"],\n                                     url=data[\"url\"],\n                                     last_modified=last_modified.replace(\n                                         tzinfo=None\n                                     ).isoformat(timespec=\"seconds\"),\n                                     length=int(data[\"csize\"]),\n                                 )\n                             ]\n \n                         package = {\n                             \"name\": data[\"name\"],\n                             \"version\": data[\"version\"],\n                             \"last_modified\": last_modified,\n                             \"url\": url,\n                             \"versions\": versions,\n                             \"data\": data,\n                         }\n                         page.append(package)\n                     yield page\n \n     def get_origins_from_page(self, page: ArchListerPage) -> Iterator[ListedOrigin]:\n         \"\"\"Iterate on all arch pages and yield ListedOrigin instances.\"\"\"\n         assert self.lister_obj.id is not None\n         for origin in page:\n             yield ListedOrigin(\n                 lister_id=self.lister_obj.id,\n                 visit_type=self.VISIT_TYPE,\n                 url=origin[\"url\"],\n                 last_update=origin[\"last_modified\"],\n                 extra_loader_arguments={\n                     \"artifacts\": origin[\"versions\"],\n                 },\n             )\n ", "input_code": "def size_to_bytes(size: str) -> int:\n\"\"\"\nConvert human readable file size to bytes.\n\nResulting value is an approximation as input value is in most case rounded.\n\nArgs:\n    size: A string representing a human readable file size (eg: '500K')\n\nReturns:\n    A decimal representation of file size\n\n    Examples::\n\n        >>> size_to_bytes(\"500\")\n        500\n        >>> size_to_bytes(\"1K\")\n        1000\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def size_to_bytes(size: str) -> int:\n    \"\"\"Convert human readable file size to bytes.\n\n    Resulting value is an approximation as input value is in most case rounded.\n\n    Args:\n        size: A string representing a human readable file size (eg: '500K')\n\n    Returns:\n        A decimal representation of file size\n\n        Examples::\n\n            >>> size_to_bytes(\"500\")\n            500\n            >>> size_to_bytes(\"1K\")\n            1000\n    \"\"\"\n    units = {\n        \"K\": 1000,\n        \"M\": 1000**2,\n        \"G\": 1000**3,\n        \"T\": 1000**4,\n        \"P\": 1000**5,\n        \"E\": 1000**6,\n        \"Z\": 1000**7,\n        \"Y\": 1000**8,\n    }\n    if size.endswith(tuple(units)):\n        v, u = (size[:-1], size[-1])\n        return int(v) * units[u]\n    else:\n        return int(size)", "signature": "def size_to_bytes(size: str) -> int:", "completion_path": "swh/lister/arch/lister.py"}
{"ce_id": "62ece4982e6aefcf4aabbd61", "namespace": "62ece4982e6aefcf4aabbd61", "namespace_real": "contrib.planb-swiftsync._dictsum", "real_proj_path": "ossobv---planb/", "type": "function", "class_name": null, "function_name": "_dictsum", "contexts_above": "#!/usr/bin/env python3\nimport logging\nimport os\nimport re\nimport signal\nimport sys\nimport threading\nimport traceback\nimport warnings\n\nfrom argparse import ArgumentParser\nfrom collections import OrderedDict\nfrom configparser import RawConfigParser, SectionProxy\nfrom datetime import datetime, timezone\nfrom hashlib import md5\nfrom tempfile import NamedTemporaryFile\nfrom time import time\nfrom unittest import TestCase\n\ntry:\n    from swiftclient import Connection\nexcept ImportError:\n    warnings.warn('No swiftclient? You probably need to {!r}'.format(\n        'apt-get install python3-swiftclient --no-install-recommends'))\nelse:\n    from swiftclient.exceptions import ClientException\n\n# TODO: when stopping mid-add, we get lots of \"ValueError: early abort\"\n# backtraces polluting the log; should do without error\n\nSAMPLE_INIFILE = r\"\"\"\\\n[acme_swift_v1_config]\n\n; Use rclonse(1) to see the containers: `rclone lsd acme_swift_v1_config:`\ntype = swift\nuser = NAMESPACE:USER\nkey = KEY\nauth = https://AUTHSERVER/auth/v1.0\n\n; You can use one or more 'planb_translate' or use 'planb_translate_<N>'\n; to define filename translation rules. They may be needed to circumvent\n; local filesystem limits (like not allowing trailing / in a filename).\n\n; GUID-style (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx) to \"ID/GU/FULLGUID\".\nplanb_translate_0 = document=\n    ^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{8}([0-9a-f]{2})([0-9a-f]{2}))$=\n    \\4/\\3/\\1\n; BEWARE ^^ remove excess linefeeds and indentation from this example  ^^\n\n; Translate in the 'wsdl' container all paths that start with \"YYYYMMDD\"\n; to \"YYYY/MM/DD/\"\nplanb_translate_1 = wsdl=^(\\d{4})(\\d{2})(\\d{2})/=\\1/\\2/\\3/\n\n; Translate in all containers all paths (files) that end with a slash to %2F.\n; (This will conflict with files actually having a %2F there, but that\n; is not likely to happen.)\nplanb_translate_2 = *=/$=%2F\n\n\n[acme_swift_v3_config]\n\ntype = swift\ndomain = USER_DOMAIN\nuser = USER\nkey = KEY\nauth = https://AUTHSERVER/v3/\ntenant = PROJECT\ntenant_domain = PROJECT_DOMAIN\nauth_version = 3\n\n; Set this to always to skip autodetection of DLO segment support: not all DLO\n; segments are stored in a separate <container>_segments container.\n; (You may need to clear the planb-swiftsync.new cache after setting this.)\nplanb_container_has_segments = always\n\"\"\"\n\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format=(\n        '%(asctime)s [planb-swiftsync:%(threadName)-10.10s] '\n        '[%(levelname)-3.3s] %(message)s'),\n    handlers=[logging.StreamHandler()])\nlog = logging.getLogger()\n\n\ndef _signal_handler(signo, _stack_frame):\n    global _MT_ABORT, _MT_HAS_THREADS\n    _MT_ABORT = signo\n    log.info('Got signal %d', signo)\n    if not _MT_HAS_THREADS:\n        # If we have no threads, we can abort immediately.\n        log.info('Killing self because of signal %d', signo)\n        sys.exit(128 + signo)  # raises SystemExit()\n_MT_ABORT = 0                   # noqa -- aborting?\n_MT_HAS_THREADS = False         # do we have threads at all?\n\nsignal.signal(signal.SIGHUP, _signal_handler)\nsignal.signal(signal.SIGINT, _signal_handler)\nsignal.signal(signal.SIGTERM, _signal_handler)\nsignal.signal(signal.SIGQUIT, _signal_handler)\n\n\nclass PathTranslator:\n    \"\"\"\n    Translates path from remote_path to local_path.\n\n    When single_container=True, the container name is not added into the\n    local_path.\n\n    Test using:\n\n        planb_storage_destination=$(pwd)/data \\\n        ./planb-swiftsync -c planb-swiftsync.conf SECTION \\\n            --test-path-translate CONTAINERNAME\n\n        (provide remote paths on stdin)\n    \"\"\"\n    def __init__(self, data_path, container, translations, single_container):\n        assert '/' not in container, container\n        assert isinstance(single_container, bool)\n        self.data_path = data_path\n        self.container = container\n        self.single_container = single_container\n        self.replacements = []\n        for translation in translations:\n            container_match, needle, replacement = translation.split('=')\n            if container == container_match or container_match == '*':\n                self.replacements.append((\n                    re.compile(needle), replacement))\n\n    def __call__(self, remote_path):\n        for needle, replacement in self.replacements:\n            local_path = needle.sub(replacement, remote_path)\n            if local_path != remote_path:\n                break\n        else:\n            local_path = remote_path\n\n        # Single container: LOCAL_BASE + TRANSLATED_REMOTE_PATH\n        if self.single_container:\n            return os.path.join(self.data_path, local_path)\n\n        # Multiple containers: LOCAL_BASE + CONTAINER + TRANSLATED_REMOTE_PATH\n        return os.path.join(self.data_path, self.container, local_path)\n\n\nclass ConfigParserMultiValues(OrderedDict):\n    \"\"\"\n    Accept duplicate keys in the RawConfigParser.\n    \"\"\"\n    def __setitem__(self, key, value):\n        # The RawConfigParser does a second pass. First lists are passed.\n        # Secondly concatenated strings are passed.\n        assert isinstance(value, (\n            ConfigParserMultiValues, SectionProxy, list, str)), (\n                key, value, type(value))\n\n        # For the second pass, we could do an optional split by LF. But that\n        # makes it harder to notice when this breaks. Instead, just skip the\n        # str-setting.\n        if isinstance(value, str):  # and '\\n' in value:\n            # super().__setitem__(key, value.split('\\n'))\n            return\n\n        if key in self and isinstance(value, list):\n            self[key].extend(value)\n        else:\n            super().__setitem__(key, value)\n\n\nclass SwiftSyncConfig:\n    def __init__(self, inifile, section):\n        self.read_inifile(inifile, section)\n        self.read_environment()\n\n    def read_inifile(self, inifile, section):\n        configparser = RawConfigParser(\n            strict=False, empty_lines_in_values=False,\n            dict_type=ConfigParserMultiValues)\n        configparser.read([inifile])\n        try:\n            config = configparser[section]\n        except KeyError:\n            raise ValueError(\n                'no section {!r} found in {!r}'.format(section, inifile))\n\n        type_ = config.get('type', None)\n        assert type_ == ['swift'], type_\n        self.swift_authver = config.get('auth_version', ['1'])[-1]\n        self.swift_auth = config['auth'][-1]   # authurl\n        self.swift_user = config['user'][-1]\n        self.swift_key = config['key'][-1]\n        # auth_version v3:\n        self.swift_project = config.get('tenant', [None])[-1]  # project\n        self.swift_pdomain = (\n            config.get('tenant_domain', [None])[-1])    # project-domain\n        self.swift_udomain = (\n            config.get('domain', [None])[-1])           # user-domain\n        self.swift_containers = []\n\n        # Accept multiple planb_translate keys. But also accept\n        # planb_translate_<id> keys. If you use the rclone config tool,\n        # rewriting the file would destroy duplicate keys, so using a\n        # suffix is preferred.\n        self.planb_translations = []\n        for key in sorted(config.keys()):\n            if key == 'planb_translate' or key.startswith('planb_translate_'):\n                self.planb_translations.extend(config[key])\n\n        # Sometimes segment autodetection can fail, resulting in:\n        # > Filesize mismatch for '...': 0 != 9515\n        # This is probably because the object has X-Object-Manifest and is a\n        # Dynamic Large Object (DLO).\n        self.all_containers_have_segments = (\n            config.get('planb_container_has_segments', [''])[-1] == 'always')\n\n    def read_environment(self):\n        # /tank/customer-friendly_name/data\n        storage = os.environ['planb_storage_destination']\n        # friendly_name = os.environ['planb_fileset_friendly_name']\n        # fileset_id = os.environ['planb_fileset_id']\n\n        if not storage.endswith('/data'):\n            raise ValueError(\n                'expected storage path to end in /data, got {!r}'.format(\n                    storage))\n        if not os.path.exists(storage):\n            raise ValueError(\n                'data_path does not exist: {!r}'.format(storage))\n\n        self.data_path = storage\n        self.metadata_path = storage.rsplit('/', 1)[0]\n        assert self.metadata_path.startswith('/'), self.metadata_path\n\n    def get_swift(self):\n        if self.swift_authver == '3':\n            os_options = {\n                'project_name': self.swift_project,\n                'project_domain_name': self.swift_pdomain,\n                'user_domain_name': self.swift_udomain,\n            }\n            connection = Connection(\n                auth_version='3', authurl=self.swift_auth,\n                user=self.swift_user, key=self.swift_key,\n                os_options=os_options)\n\n        elif self.swift_authver == '1':\n            connection = Connection(\n                auth_version='1', authurl=self.swift_auth,\n                user=self.swift_user, key=self.swift_key,\n                tenant_name='UNUSED')\n\n        else:\n            raise NotImplementedError(\n                'auth_version? {!r}'.format(self.swift_authver))\n\n        return connection\n\n    def get_translator(self, container, single_container):\n        return PathTranslator(\n            self.data_path, container, self.planb_translations,\n            single_container)\n\n\nclass SwiftSyncConfigPathTranslators(dict):\n    def __init__(self, config, single_container):\n        assert isinstance(single_container, bool)\n        super().__init__()\n        self._config = config\n        self._single_container = single_container\n\n    def get(self, *args, **kwargs):\n        raise NotImplementedError()\n\n    def __getitem__(self, container):\n        try:\n            translator = super().__getitem__(container)\n        except KeyError:\n            translator = self._config.get_translator(\n                container, single_container=self._single_container)\n            super().__setitem__(container, translator)\n        return translator\n\n\nclass SwiftContainer(str):\n    # The OpenStack Swift canonical method for handling large objects,\n    # is using Dynamic Large Objects (DLO) or Static Large Objects\n    # (SLO).\n    #\n    # In both (DLO and SLO) cases, the CONTAINER file segments are\n    # uploaded to a separate container called CONTAINER_segments.\n    # When doing a listing over CONTAINER, the segmented files are\n    # reported as having 0 size. When that happens, we have to do a HEAD\n    # on those files to retreive the actual concatenated file size.\n    #\n    # This boolean allows us to skip those expensive lookups for all\n    # containers X that do not have an X_segments helper container.\n    has_segments = False\n\n\nclass SwiftLine:\n    def __init__(self, obj):\n        # {'bytes': 107713,\n        #  'last_modified': '2018-05-25T15:11:14.501890',\n        #  'hash': '89602749f508fc9820ef575a52cbfaba',\n        #  'name': '20170101/mr/administrative',\n        #  'content_type': 'text/xml'}]\n        self.obj = obj\n        self.size = obj['bytes']\n        assert len(obj['last_modified']) == 26, obj\n        assert obj['last_modified'][10] == 'T', obj\n        self.modified = obj['last_modified']\n        self.path = obj['name']\n        assert not self.path.startswith(('\\\\', '/', './', '../')), self.path\n        assert '/../' not in self.path, self.path  # disallow harmful path\n        assert '/./' not in self.path, self.path   # disallow awkward path\n\n\nclass ListLine:\n    # >>> escaped_re.findall('containerx|file||name|0|1234\\n')\n    # ['containerx', '|', 'file||name', '|', '0', '|', '1234\\n']\n    escaped_re = re.compile(r'(?P<part>(?:[^|]|(?:[|][|]))+|[|])')\n\n    @classmethod\n    def from_swift_head(cls, container, path, head_dict):\n        \"\"\"\n        {'server': 'nginx', 'date': 'Fri, 02 Jul 2021 13:04:35 GMT',\n         'content-type': 'image/jpg', 'content-length': '241190',\n         'etag': '7bc4ca634783b4c83cf506188cd7176b',\n         'x-object-meta-mtime': '1581604242',\n         'last-modified': 'Tue, 08 Jun 2021 07:03:34 GMT',\n         'x-timestamp': '1623135813.04310', 'accept-ranges': 'bytes',\n         'x-trans-id': 'txcxxx-xxx', 'x-openstack-request-id': 'txcxxx-xxx'}\n        \"\"\"\n        size = head_dict.get('content-length')\n        assert size.isdigit(), head_dict\n        assert all(i in '0123456789.' for i in head_dict['x-timestamp']), (\n            head_dict)\n        tm = datetime.utcfromtimestamp(float(head_dict['x-timestamp']))\n        tms = tm.strftime('%Y-%m-%dT%H:%M:%S.%f')\n\n        if container:\n            assert '|' not in container, (\n                'unescaping can only cope with pipe in path: {!r} + {!r}'\n                .format(container, path))\n            return cls('{}|{}|{}|{}\\n'.format(\n                container, path.replace('|', '||'),\n                tms, size))\n\n        return cls('{}|{}|{}\\n'.format(path.replace('|', '||'), tms, size))\n\n    def __init__(self, line):\n        # Line looks like: [container|]path|modified|size<LF>\n        # But path may contain double pipes.\n\n        if '||' not in line:\n            # Simple matching.\n            self.path, self._modified, self._size = line.rsplit('|', 2)\n            if '|' in self.path:\n                self.container, self.path = self.path.split('|', 1)\n            else:\n                self.container = None\n            assert '|' not in self.path, 'bad line: {!r}'.format(line)\n        else:\n            # Complicated regex matching. Path may include double pipes.\n            matches = self.escaped_re.findall(line)\n            assert ''.join(matches) == line, (line, matches)\n            if len(matches) == 7:\n                path = ''.join(matches[0:3])  # move pipes to path\n                self.container, path = path.split('|', 1)\n                self._modified = matches[4]\n                self._size = matches[6]\n            elif len(matches) == 5:\n                path = matches[0]\n                self.container = None\n                self._modified = matches[2]\n                self._size = matches[4]\n            else:\n                assert False, 'bad line: {!r}'.format(line)\n            self.path = path.replace('||', '|')\n\n        assert self.container is None or self.container, (\n            'bad container in line: {!r}'.format(line))\n        self.line = line\n        self.container_path = (self.container, self.path)\n\n    @property\n    def size(self):\n        # NOTE: _size has a trailing LF, but int() silently eats it for us.\n        return int(self._size)\n\n    @property\n    def modified(self):\n        # The time is zone agnostic, so let's assume UTC.\n        if not hasattr(self, '_modified_cache'):\n            dates, us = self._modified.split('.', 1)\n            dates = int(\n                datetime.strptime(dates, '%Y-%m-%dT%H:%M:%S')\n                .replace(tzinfo=timezone.utc).timestamp())\n            assert len(us) == 6\n            self._modified_cache = 1000000000 * dates + 1000 * int(us)\n        return self._modified_cache\n\n    def __eq__(self, other):\n        return (self.size == other.size\n                and self.container == other.container\n                and self.container_path == other.container_path\n                and self.path == other.path)\n\n\nclass SwiftSync:\n    def __init__(self, config, container=None):\n        self.config = config\n        self.container = container\n\n        # Init translators. They're done lazily, so we don't need to know which\n        # containers exist yet.\n        self._translators = SwiftSyncConfigPathTranslators(\n            self.config, single_container=bool(container))\n\n        # Get data path. Chdir into it so no unmounting can take place.\n        data_path = config.data_path\n        os.chdir(data_path)\n\n        # Get metadata path where we store listings.\n        metadata_path = config.metadata_path\n        self._filelock = os.path.join(metadata_path, 'planb-swiftsync.lock')\n        self._path_cur = os.path.join(metadata_path, 'planb-swiftsync.cur')\n        # ^-- this contains the local truth\n        self._path_new = os.path.join(metadata_path, 'planb-swiftsync.new')\n        # ^-- the unreached goal\n        self._path_del = os.path.join(metadata_path, 'planb-swiftsync.del')\n        self._path_add = os.path.join(metadata_path, 'planb-swiftsync.add')\n        self._path_utime = os.path.join(metadata_path, 'planb-swiftsync.utime')\n        # ^-- the work we have to do to reach the goal\n        # NOTE: For changed files, we get an entry in both del and add.\n        # Sometimes however, only the mtime is changed. For that case we\n        # use the utime list, where we check the hash before\n        # downloading/overwriting.\n\n    def get_containers(self):\n        if not hasattr(self, '_get_containers'):\n            resp_headers, containers = (\n                self.config.get_swift().get_account())\n            # containers == [\n            #   {'count': 350182, 'bytes': 78285833087,\n            #    'name': 'containerA'}]\n            container_names = set(i['name'] for i in containers)\n\n            force_segments = self.config.all_containers_have_segments\n\n            # Translate container set into containers with and without\n            # segments. For example:\n            # - containerA (has_segments=False)\n            # - containerB (has_segments=True)\n            # - containerB_segments (skipped, belongs with containerB)\n            # - containerC_segments (has_segments=False)\n            selected_containers = []\n            for name in sorted(container_names):\n                # We're looking for a specific container. Only check whether a\n                # X_segments exists. (Because of DLO/SLO we must do the\n                # get_accounts() lookup even though we already know\n                # which container to process.)\n                if self.container:\n                    if self.container == name:\n                        new = SwiftContainer(name)\n                        if force_segments or (\n                                '{}_segments'.format(name) in container_names):\n                            new.has_segments = True\n                        selected_containers.append(new)\n                        break\n\n                # We're getting all containers. Check if X_segments exists for\n                # it. And only add X_segments containers if there is no X\n                # container.\n                else:\n                    if (name.endswith('_segments')\n                            and name.rsplit('_', 1)[0] in container_names):\n                        # Don't add X_segments, because X exists.\n                        pass\n                    else:\n                        new = SwiftContainer(name)\n                        if force_segments or (\n                                '{}_segments'.format(name) in container_names):\n                            new.has_segments = True\n                        selected_containers.append(new)\n\n            # It's already sorted because we sort the container_names\n            # before inserting.\n            self._get_containers = selected_containers\n        return self._get_containers\n\n    def get_translators(self):\n        return self._translators\n\n    def sync(self):\n        lock_fd = None\n        try:\n            # Get lock.\n            lock_fd = os.open(\n                self._filelock, os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o600)\n        except FileExistsError:\n            # Failed to get lock.\n            log.error('Failed to get %r lock', self._filelock)\n            sys.exit(1)\n        else:\n            # Do work.\n            self.make_lists()\n            failures = 0\n            failures += self.delete_from_list()\n            failures += self.add_from_list()\n            failures += self.update_from_list()\n\n            # If we bailed out with failures, but without an exception, we'll\n            # still clear out the list. Perhaps the list was bad and we simply\n            # need to fetch a clean new one (on the next run, that is).\n            self.clean_lists()\n\n            if failures:\n                raise SystemExit(1)\n        finally:\n            if lock_fd is not None:\n                os.close(lock_fd)\n                os.unlink(self._filelock)\n\n    def make_lists(self):\n        \"\"\"\n        Build planb-swiftsync.add, planb-swiftsync.del, planb-swiftsync.utime.\n        \"\"\"\n        log.info('Building lists')\n\n        # Only create new list if it didn't exist yet (because we completed\n        # successfully the last time) or if it's rather old.\n        try:\n            last_modified = os.path.getmtime(self._path_new)\n        except FileNotFoundError:\n            last_modified = 0\n        if not last_modified or (time() - last_modified) > (18 * 3600.0):\n            self._make_new_list()\n\n        # Make the add/del/utime lists based off cur/new.\n        #\n        # * The add/del lists are obvious. Changed files get an entry in\n        #   both del and add.\n        #\n        # * The utime list is for cases when only the mtime has changed:\n        #   To avoid rewriting (duplicating) the file on COW storage (ZFS),\n        #   we'll want to check the file hash to avoid rewriting it if it's\n        #   the same. (Useful when the source files have been moved/copied\n        #   and the X-Timestamps have thus been renewed.)\n        #\n        self._make_diff_lists()\n\n    def delete_from_list(self):\n        \"\"\"\n        Delete from planb-swiftsync.del.\n        \"\"\"\n        if os.path.getsize(self._path_del):\n            log.info('Removing old files (SwiftSyncDeleter)')\n            deleter = SwiftSyncDeleter(self, self._path_del)\n            deleter.work()\n\n        # NOTE: We don't expect any failures here, ever. This concerns\n        # only local file deletions. If they fail, then something is\n        # really wrong (bad filesystem, or datalist out of sync).\n        return 0  # no (recoverable) failures\n\n    def add_from_list(self):\n        \"\"\"\n        Add from planb-swiftsync.add.\n        \"\"\"\n        if os.path.getsize(self._path_add):\n            log.info('Adding new files (SwiftSyncAdder)')\n            adder = SwiftSyncAdder(self, self._path_add)\n            adder.work()\n            return adder.failures  # (possibly recoverable) failure count\n\n        return 0  # no (recoverable) failures\n\n    def update_from_list(self):\n        \"\"\"\n        Check/update from planb-swiftsync.utime.\n        \"\"\"\n        if os.path.getsize(self._path_utime):\n            log.info('Updating timestamp for updated files (SwiftSyncUpdater)')\n            updater = SwiftSyncUpdater(self, self._path_utime)\n            updater.work()\n            return updater.failures  # (possibly recoverable) failure count\n\n        return 0  # no (recoverable) failures\n\n    def clean_lists(self):\n        \"\"\"\n        Remove planb-swiftsync.new so we'll fetch a fresh one on the next run.\n        \"\"\"\n        os.unlink(self._path_new)\n        # Also remove add/del/utime files; we don't need them anymore, and they\n        # take up space.\n        os.unlink(self._path_add)\n        os.unlink(self._path_del)\n        os.unlink(self._path_utime)\n        log.info('Sync done')\n\n    def _make_new_list(self):\n        \"\"\"\n        Create planb-swiftsync.new with the files we want to have.\n\n        This can be slow as we may need to fetch many lines from swift.\n        \"\"\"\n        path_tmp = '{}.tmp'.format(self._path_new)\n        swiftconn = self.config.get_swift()\n        with open(path_tmp, 'w') as dest:\n            os.chmod(path_tmp, 0o600)\n            for container in self.get_containers():\n                assert '|' not in container, container\n                assert '{' not in container, container\n                if self.container:  # only one container\n                    fmt = '{}|{}|{}\\n'\n                else:  # multiple containers\n                    fmt = '{}|{{}}|{{}}|{{}}\\n'.format(container)\n                log.info('Fetching new list for %r', container)\n                # full_listing:\n                #     if True, return a full listing, else returns a max of\n                #     10000 listings; but that will eat memory, which we don't\n                #     want.\n                marker = ''  # \"start _after_ marker\"\n                prev_marker = 'anything_except_the_empty_string'\n                limit = 10000\n                while True:\n                    assert marker != prev_marker, marker  # loop trap\n                    resp_headers, lines = swiftconn.get_container(\n                        container, full_listing=False, limit=limit,\n                        marker=marker)\n                    for idx, line in enumerate(lines):\n                        self._make_new_list_add_line(\n                            dest, fmt, swiftconn, container, line)\n                    if not lines or (idx + 1 < limit):\n                        break\n                    marker, prev_marker = line['name'], marker\n        os.rename(path_tmp, self._path_new)\n\n    def _make_new_list_add_line(self, dest, fmt, swiftconn, container, line):\n        record = SwiftLine(line)\n\n        if record.size == 0 and container.has_segments:\n            # Do a head to get DLO/SLO stats. This is\n            # only needed if this container has segments,\n            # and if the apparent file size is 0.\n            try:\n                obj_stat = swiftconn.head_object(container, line['name'])\n                # If this is still 0, then it's an empty file\n                # anyway.\n                record.size = int(obj_stat['content-length'])\n            except ClientException as e:\n                # 404?\n                log.warning(\n                    'File %r %r disappeared from under us '\n                    'when doing a HEAD (%s)',\n                    container, line['name'], e)\n                # Skip record.\n                return\n\n        dest.write(fmt.format(\n            record.path.replace('|', '||'),\n            record.modified,\n            record.size))\n\n    def _make_diff_lists(self):\n        \"\"\"\n        Create planb-swiftsync.add, planb-swiftsync.del and\n        planb-swiftsync.utime based on planb-swiftsync.new and\n        planb-swiftsync.cur.\n\n        planb-swiftsync.del:   Files that can be removed immediately.\n        planb-swiftsync.add:   Files that can be added immediately.\n        planb-swiftsync.utime: Files that have the same name and filesize, but\n                               different timestamp.\n        \"\"\"\n        try:\n            cur_fp = open(self._path_cur, 'r')\n        except FileNotFoundError:\n            with open(self._path_cur, 'w'):\n                os.chmod(self._path_cur, 0o600)\n            cur_fp = open(self._path_cur, 'r')\n\n        try:\n            with open(self._path_new, 'r') as new_fp, \\\n                    open(self._path_del, 'w') as del_fp, \\\n                    open(self._path_add, 'w') as add_fp, \\\n                    open(self._path_utime, 'w') as utime_fp:\n                os.chmod(self._path_del, 0o600)\n                os.chmod(self._path_add, 0o600)\n                os.chmod(self._path_utime, 0o600)\n\n                llc = _ListLineComm(cur_fp, new_fp)\n                llc.act(\n                    # We already have it if in both:\n                    both=(lambda line: None),\n                    # We have it in both, but only the timestamp differs:\n                    difftime=(lambda leftline, rightline: (\n                        utime_fp.write(rightline))),\n                    # Remove when only in cur_fp:\n                    leftonly=(lambda line: del_fp.write(line)),\n                    # Add when only in new_fp:\n                    rightonly=(lambda line: add_fp.write(line)))\n        finally:\n            cur_fp.close()\n\n    def update_cur_list_from_added(self, added_fp):\n        \"\"\"\n        Update planb-swiftsync.cur by adding all from added_fp.\n        \"\"\"\n        path_tmp = '{}.tmp'.format(self._path_cur)\n        with open(self._path_cur, 'r') as cur_fp, \\\n                open(path_tmp, 'w') as tmp_fp:\n            os.chmod(path_tmp, 0o600)\n            llc = _ListLineComm(cur_fp, added_fp)\n            llc.act(\n                # Keep it if we already had it:\n                leftonly=(lambda line: tmp_fp.write(line)),\n                # Keep it if we added it now:\n                rightonly=(lambda line: tmp_fp.write(line)),\n                # This should not happen:\n                both=None,      # existed _and_ added?\n                difftime=None)  # existed _and_ changed?\n        os.rename(path_tmp, self._path_cur)\n\n    def update_cur_list_from_deleted(self, deleted_fp):\n        \"\"\"\n        Update planb-swiftsync.cur by removing all from deleted_fp.\n        \"\"\"\n        path_tmp = '{}.tmp'.format(self._path_cur)\n        with open(self._path_cur, 'r') as cur_fp, \\\n                open(path_tmp, 'w') as tmp_fp:\n            os.chmod(path_tmp, 0o600)\n            llc = _ListLineComm(cur_fp, deleted_fp)\n            llc.act(\n                # Drop it if in both (we deleted it now):\n                both=(lambda line: None),\n                # Keep it if we didn't touch it:\n                leftonly=(lambda line: tmp_fp.write(line)),\n                # This should not happen:\n                difftime=None,   # existed _and_ added?\n                rightonly=None)  # deleted something which didn't exist?\n        os.rename(path_tmp, self._path_cur)\n\n    def update_cur_list_from_updated(self, updated_fp):\n        \"\"\"\n        Update planb-swiftsync.cur by updating all from updated_fp.\n        \"\"\"\n        path_tmp = '{}.tmp'.format(self._path_cur)\n        with open(self._path_cur, 'r') as cur_fp, \\\n                open(path_tmp, 'w') as tmp_fp:\n            os.chmod(path_tmp, 0o600)\n            llc = _ListLineComm(cur_fp, updated_fp)\n            llc.act(\n                # Replace it if we updated it:\n                difftime=(lambda leftline, rightline: (\n                    tmp_fp.write(rightline))),\n                # Keep it if we didn't touch it:\n                leftonly=(lambda line: tmp_fp.write(line)),\n                # This should not happen:\n                both=None,\n                rightonly=None)\n        os.rename(path_tmp, self._path_cur)\n\n\nclass SwiftSyncDeleter:\n    def __init__(self, swiftsync, source):\n        self._swiftsync = swiftsync\n        self._source = source\n\n    def work(self):\n        with NamedTemporaryFile(delete=True, mode='w+') as success_fp:\n            try:\n                self._delete_old(success_fp)\n            finally:\n                success_fp.flush()\n                success_fp.seek(0)\n                self._swiftsync.update_cur_list_from_deleted(success_fp)\n\n    def _delete_old(self, success_fp):\n        \"\"\"\n        Delete old files (from planb-swiftsync.del) and store which files we\n        deleted in the success_fp.\n        \"\"\"\n        translators = self._swiftsync.get_translators()\n        only_container = self._swiftsync.container\n\n        with open(self._source, 'r') as del_fp:\n            for record in _comm_lineiter(del_fp):\n                # record.container is None for single_container syncs.\n                container = record.container or only_container\n\n                # Locate local path and remove.\n                path = translators[container](record.path)\n                os.unlink(path)\n                # FIXME: should also try to delete unused directories?\n\n                success_fp.write(record.line)\n\n\nclass SwiftSyncMultiWorkerBase(threading.Thread):\n    \"\"\"\n    Multithreaded SwiftSyncWorkerBase class.\n    \"\"\"\n    class ProcessRecordFailure(Exception):\n        pass\n\n    def __init__(self, swiftsync, source, offset=0, threads=0):\n        super().__init__()\n        self._swiftsync = swiftsync\n        self._source = source\n        self._offset = offset\n        self._threads = threads\n\n        self._success_fp = None\n\n        # If there were one or more failures, store them so they can be used by\n        # the caller.\n        self.failures = 0\n\n    def run(self):\n        log.info('%s: Started thread', self.__class__.__name__)\n        self._success_fp = NamedTemporaryFile(delete=True, mode='w+')\n        try:\n            self._process_source_list()\n        finally:\n            self._success_fp.flush()\n            log.info('%s: Stopping thread', self.__class__.__name__)\n\n    def take_success_file(self):\n        \"\"\"\n        You're allowed to take ownership of the file... once.\n        \"\"\"\n        ret, self._success_fp = self._success_fp, None\n        return ret\n\n    def process_record(self, record, container, dst_path):\n        raise NotImplementedError()\n\n    def process_record_success(self, record):\n        \"\"\"\n        Store success in the success list.\n        \"\"\"\n        self._success_fp.write(record.line)\n\n    def _process_source_list(self):\n        \"\"\"\n        Process the source list, calling process_record() for each file.\n        \"\"\"\n        # Create this swift connection first in this thread on purpose. That\n        # should minimise swiftclient library MT issues.\n        self._swiftconn = self._swiftsync.config.get_swift()\n\n        ProcessRecordFailure = self.ProcessRecordFailure\n        translators = self._swiftsync.get_translators()\n        only_container = self._swiftsync.container\n        offset = self._offset\n        threads = self._threads\n\n        # Loop over the planb-swiftsync.add file, but only do our own files.\n        with open(self._source, 'r') as add_fp:\n            for idx, record in enumerate(_comm_lineiter(add_fp)):\n                # When running with multiple threads, we don't use a\n                # queue, but simply divide the files over all threads\n                # fairly.\n                if (idx % threads) != offset:\n                    continue\n\n                # Make multi-thread ready.\n                if _MT_ABORT:\n                    raise ValueError('early abort')\n\n                # record.container is None for single_container syncs.\n                container = record.container or only_container\n                dst_path = translators[container](record.path)\n                if dst_path.endswith('/'):\n                    log.warning(\n                        ('Skipping record %r (from %r) because of trailing '\n                         'slash'), dst_path, record.container_path)\n                    self.failures += 1\n                    continue\n\n                # Download the file into the appropriate directory.\n                try:\n                    self.process_record(record, container, dst_path)\n                except ProcessRecordFailure:\n                    self.failures += 1\n                else:\n                    self.process_record_success(record)\n\n        if self.failures:\n            log.warning('At list EOF, got %d failures', self.failures)\n\n    def _add_new_record_dir(self, path):\n        try:\n            os.makedirs(os.path.dirname(path), 0o700)\n        except FileExistsError:\n            pass\n\n    def _add_new_record_download(self, record, container, path):\n        try:\n            with open(path, 'wb') as out_fp:\n                # resp_chunk_size - if defined, chunk size of data to read.\n                # > If you specify a resp_chunk_size you must fully read\n                # > the object's contents before making another request.\n                resp_headers, obj = self._swiftconn.get_object(\n                    container, record.path, resp_chunk_size=(16 * 1024 * 1024))\n                if record.size == 0 and 'X-Object-Manifest' in resp_headers:\n                    raise NotImplementedError(\n                        '0-sized files with X-Object-Manifest? '\n                        'cont={!r}, path={!r}, size={!r}, hdrs={!r}'.format(\n                            container, record.path, record.size, resp_headers))\n\n                for data in obj:\n                    if _MT_ABORT:\n                        raise ValueError('early abort during {}'.format(\n                            record.container_path))\n                    out_fp.write(data)\n        except Exception as e:\n            log.warning(\n                'Download failure for %r (from %r): %s',\n                path, record.container_path, e)\n            if isinstance(e, IsADirectoryError):\n                pass\n            else:\n                try:\n                    # FIXME: also remove directories we just created?\n                    os.unlink(path)\n                except FileNotFoundError:\n                    pass\n            raise self.ProcessRecordFailure()\n\n    def _add_new_record_valid(self, record, path):\n        os.utime(path, ns=(record.modified, record.modified))\n        local_size = os.stat(path).st_size\n        if local_size != record.size:\n            log.error(\n                'Filesize mismatch for %r (from %r): %d != %d',\n                path, record.container_path, record.size, local_size)\n            try:\n                # FIXME: also remove directories we just created?\n                os.unlink(path)\n            except FileNotFoundError:\n                pass\n            raise self.ProcessRecordFailure()\n\n\nclass SwiftSyncMultiAdder(SwiftSyncMultiWorkerBase):\n    def process_record(self, record, container, dst_path):\n        \"\"\"\n        Process a single record: download it.\n\n        If there was an error, it cleans up after itself and raises a\n        ProcessRecordFailure.\n        \"\"\"\n        self._add_new_record_dir(dst_path)\n        self._add_new_record_download(record, container, dst_path)\n        self._add_new_record_valid(record, dst_path)\n\n\nclass SwiftSyncMultiUpdater(SwiftSyncMultiWorkerBase):\n    \"\"\"\n    Multithreaded SwiftSyncUpdater.\n    \"\"\"\n    def process_record(self, record, container, dst_path):\n        \"\"\"\n        Process a single record: download it.\n\n        Raises ProcessRecordFailure on error.\n        \"\"\"\n        try:\n            obj_stat = self._swiftconn.head_object(container, record.path)\n        except ClientException as e:\n            log.warning(\n                'File %r %r disappeared from under us when doing a HEAD (%s)',\n                container, record.path, e)\n            raise self.ProcessRecordFailure()\n\n        etag = str(obj_stat.get('etag'))\n        if len(etag) != 32 or any(i not in '0123456789abcdef' for i in etag):\n            log.warning(\n                'File %r %r presented bad etag: %r', container, record.path,\n                obj_stat)\n            raise self.ProcessRecordFailure()\n\n        # Note that guard against odd races, we must also check the record\n        # against this new head. This also asserts that the file size is still\n        # the same.\n        new_record = ListLine.from_swift_head(\n            record.container, record.path, obj_stat)\n        if new_record.line != record.line:\n            log.warning(\n                'File was updated in the mean time? %r != %r',\n                record.line, new_record.line)\n            raise self.ProcessRecordFailure()\n\n        # Nice, we have an etag, and we were lured here with the prospect that\n        # the file was equal to what we already had.\n        md5digest = self._md5sum(dst_path)  # should exist and succeed\n\n        # If the hash is equal, then all is awesome.\n        if md5digest == etag:\n            return\n\n        # If not, then we need to download a new file and overwrite it.\n        # XXX: if this fails, we have invalid state! the file could be\n        # removed while our lists will not have it. This needs fixing.\n        self._add_new_record_download(record, container, dst_path)\n        self._add_new_record_valid(record, dst_path)\n\n    def _md5sum(self, path):\n        m = md5()\n        with open(path, 'rb') as fp:\n            while True:\n                buf = fp.read(128 * 1024)  # larger is generally better\n                if not buf:\n                    break\n                m.update(buf)\n\n        hexdigest = m.hexdigest()\n        assert (\n            len(hexdigest) == 32\n            and all(i in '0123456789abcdef' for i in hexdigest)), hexdigest\n\n        return hexdigest\n\n\nclass SwiftSyncBase:\n    worker_class = NotImplemented\n\n    def __init__(self, swiftsync, source):\n        self._swiftsync = swiftsync\n        self._source = source\n        self._thread_count = 7\n\n    def work(self):\n        global _MT_ABORT, _MT_HAS_THREADS\n\n        log.info(\n            '%s: Starting %d %s downloader threads', self.__class__.__name__,\n            self._thread_count, self.worker_class.__name__)\n\n        threads = [\n            self.worker_class(\n                swiftsync=self._swiftsync, source=self._source,\n                offset=idx, threads=self._thread_count)\n            for idx in range(self._thread_count)]\n\n        if self._thread_count == 1:\n            try:\n                threads[0].run()\n            finally:\n                self.merge_success(threads[0].take_success_file())\n        else:\n            _MT_HAS_THREADS = True\n            for thread in threads:\n                thread.start()\n            for thread in threads:\n                thread.join()\n            _MT_HAS_THREADS = False\n\n            success_fps = [th.take_success_file() for th in threads]\n            success_fps = [fp for fp in success_fps if fp is not None]\n            self._merge_multi_success(success_fps)\n            del success_fps\n\n        if _MT_ABORT:\n            raise SystemExit(_MT_ABORT)\n\n        # Collect and sum failure count to signify when not everything is fine,\n        # even though we did our best. If we're here, all threads ended\n        # successfully, so they all have a valid failures count.\n        self.failures = sum(th.failures for th in threads)\n\n    def merge_success(self, success_fp):\n        raise NotImplementedError()\n\n    def _merge_multi_success(self, success_fps):\n        \"\"\"\n        Merge all success_fps into cur.\n\n        This is useful because we oftentimes download only a handful of files.\n        First merge those, before we merge them into the big .cur list.\n\n        NOTE: _merge_multi_success will close all success_fps.\n        \"\"\"\n        try:\n            success_fp = self._create_combined_success(success_fps)\n            self.merge_success(success_fp)\n        finally:\n            for fp in success_fps:\n                fp.close()\n\n    def _create_combined_success(self, success_fps):\n        \"\"\"\n        Merge all success_fps into a single success_fp.\n\n        Returns a new success_fp.\n        \"\"\"\n        combined_fp = prev_fp = None\n        combined_fp = NamedTemporaryFile(delete=True, mode='w+')\n        try:\n            prev_fp = NamedTemporaryFile(delete=True, mode='w+')  # start blank\n\n            # Add all success_fps into combined_fp. Update prev_fp to\n            # hold combined_fp.\n            for added_fp in success_fps:\n                if added_fp is None:\n                    continue\n\n                added_size = added_fp.tell()\n                added_fp.seek(0)\n                if added_size:\n                    prev_size = prev_fp.tell()\n                    prev_fp.seek(0)\n                    log.info(\n                        '%s: Merging success lists (%d into %d)',\n                        self.__class__.__name__, added_size, prev_size)\n                    llc = _ListLineComm(prev_fp, added_fp)\n                    llc.act(\n                        # Die if we encounter a file twice:\n                        both=None,\n                        difftime=None,\n                        # Keep it if we already had it:\n                        leftonly=(lambda line: combined_fp.write(line)),\n                        # Keep it if we added it now:\n                        rightonly=(lambda line: combined_fp.write(line)))\n                    combined_fp.flush()\n\n                    # We don't need left anymore. Make combined the new left.\n                    # Create new combined where we merge the next success_fp.\n                    prev_fp.close()\n                    prev_fp, combined_fp = combined_fp, None\n                    combined_fp = NamedTemporaryFile(delete=True, mode='w+')\n\n            # We want combined_fp at this point, but it's currently in\n            # prev_fp. Note that the new combined_fp is at EOF (unseeked).\n            combined_fp.close()\n            combined_fp, prev_fp = prev_fp, None\n        except Exception:\n            if prev_fp:\n                prev_fp.close()\n            if combined_fp:\n                combined_fp.close()\n            raise\n\n        return combined_fp\n\n\nclass SwiftSyncAdder(SwiftSyncBase):\n    worker_class = SwiftSyncMultiAdder\n\n    def merge_success(self, success_fp):\n        \"\"\"\n        Merge \"add\" success_fp into (the big) .cur list.\n\n        NOTE: merge_success will close success_fp.\n        \"\"\"\n        if success_fp is None:\n            return\n        try:\n            size = success_fp.tell()\n            success_fp.seek(0)\n            if size:\n                log.info(\n                    '%s: Merging %d bytes of added files into current',\n                    self.__class__.__name__, size)\n                success_fp.seek(0)\n                self._swiftsync.update_cur_list_from_added(success_fp)\n        finally:\n            success_fp.close()\n\n\nclass SwiftSyncUpdater(SwiftSyncBase):\n    worker_class = SwiftSyncMultiUpdater\n\n    def merge_success(self, success_fp):\n        \"\"\"\n        Merge \"update\" success_fp into (the big) .cur list.\n\n        NOTE: merge_success will close success_fp.\n        \"\"\"\n        if success_fp is None:\n            return\n        try:\n            size = success_fp.tell()\n            success_fp.seek(0)\n            if size:\n                log.info(\n                    '%s: Merging %d bytes of updated files into current',\n                    self.__class__.__name__, size)\n                success_fp.seek(0)\n                self._swiftsync.update_cur_list_from_updated(success_fp)\n        finally:\n            success_fp.close()\n\n", "contexts_below": "\n def _comm_lineiter(fp):\n     \"\"\"\n     Line iterator for _comm. Yields ListLine instances.\n     \"\"\"\n     it = iter(fp)\n \n     # Do one manually, so we get prev_path.\n     try:\n         line = next(it)\n     except StopIteration:\n         return\n     record = ListLine(line)\n     yield record\n     prev_record = record\n \n     # Do the rest through normal iteration.\n     for line in it:\n         record = ListLine(line)\n         if prev_record.container_path >= record.container_path:\n             raise ValueError('data (sorting?) error: {!r} vs. {!r}'.format(\n                 prev_record.container_path, record.container_path))\n         yield record\n         prev_record = record\n \n \n class _ListLineComm:\n     \"\"\"\n     Like comm(1) - compare two sorted files line by line - using the\n     _comm_lineiter iterator.\n \n     Usage::\n \n         llc = _ListLineComm(cur_fp, new_fp)\n         llc.act(\n             # We already have it if in both:\n             both=(lambda line: None),\n             # Both, but the mtime is different:\n             difftime=(lambda leftline, rightline: utime_fp.write(rightline)),\n             # Remove when only in cur_fp:\n             leftonly=(lambda line: del_fp.write(line)),\n             # Add when only in new_fp:\n             rightonly=(lambda line: add_fp.write(line)))\n     \"\"\"\n     def __init__(self, left, right):\n         self._left_src = left\n         self._right_src = right\n \n     def act(self, both, difftime, leftonly, rightonly):\n         self._act_both = both\n         self._act_difftime = difftime\n         self._act_leftonly = leftonly\n         self._act_rightonly = rightonly\n \n         self._process_main()\n         self._process_tail()\n \n     def _setup(self, source):\n         it = _comm_lineiter(source)\n         try:\n             elem = next(it)\n         except StopIteration:\n             elem = it = None\n         return it, elem\n \n     def _process_main(self):\n         # Make local\n         act_both, act_difftime, act_leftonly, act_rightonly = (\n             self._act_both, self._act_difftime,\n             self._act_leftonly, self._act_rightonly)\n \n         left_iter, left = self._setup(self._left_src)\n         right_iter, right = self._setup(self._right_src)\n \n         while left_iter and right_iter:\n             if left.container_path < right.container_path:\n                 # Current is lower, remove and seek current.\n                 act_leftonly(left.line)\n                 try:\n                     left = next(left_iter)\n                 except StopIteration:\n                     left = left_iter = None\n             elif right.container_path < left.container_path:\n                 # New is lower, add and seek right.\n                 act_rightonly(right.line)\n                 try:\n                     right = next(right_iter)\n                 except StopIteration:\n                     right = right_iter = None\n             else:  # filename and container are equal\n                 if left.line == right.line:\n                     # 100% equal?\n                     act_both(right.line)\n                 elif left.size == right.size:\n                     # Size is equal. Then mtime must be unequal.\n                     assert left.modified != right.modified, (left, right)\n                     act_difftime(left.line, right.line)\n                 else:\n                     # Size is different, mtime is irrelevant.\n                     act_leftonly(left.line)\n                     act_rightonly(right.line)\n \n                 # Seek both to get to the next filename.\n                 try:\n                     left = next(left_iter)\n                 except StopIteration:\n                     left = left_iter = None\n                 try:\n                     right = next(right_iter)\n                 except StopIteration:\n                     right = right_iter = None\n \n         # Store\n         self._left_iter, self._left = left_iter, left\n         self._right_iter, self._right = right_iter, right\n \n     def _process_tail(self):\n         if self._left_iter:\n             act_leftonly = self._act_leftonly\n             act_leftonly(self._left.line)\n             for left in self._left_iter:\n                 act_leftonly(left.line)\n \n         if self._right_iter:\n             act_rightonly = self._act_rightonly\n             act_rightonly(self._right.line)\n             for right in self._right_iter:\n                 act_rightonly(right.line)\n \n \n class _ListLineTest(TestCase):\n     def _eq(self, line, cont, path, mod, size):\n         ll = ListLine(line)\n         self.assertEqual(ll.container, cont)\n         self.assertEqual(ll.container_path, (cont, path))\n         self.assertEqual(ll.path, path)\n         self.assertEqual(ll.modified, mod)\n         self.assertEqual(ll.size, size)\n \n     def test_pipe_in_path(self):\n         self._eq(\n             'containerx|path/to||esc|2021-02-03T12:34:56.654321|1234',\n             'containerx', 'path/to|esc', 1612355696654321000, 1234)\n         self._eq(\n             'path/to||esc|2021-02-03T12:34:56.654321|1234',\n             None, 'path/to|esc', 1612355696654321000, 1234)\n         self._eq(\n             '||path/with/starting/pipe|2021-02-03T12:34:56.654321|1234',\n             None, '|path/with/starting/pipe', 1612355696654321000, 1234)\n         self._eq(\n             'path/with/ending/pipe|||2021-02-03T12:34:56.654321|1234',\n             None, 'path/with/ending/pipe|', 1612355696654321000, 1234)\n         self._eq(\n             '||path/with/both|||2021-02-03T12:34:56.654321|1234',\n             None, '|path/with/both|', 1612355696654321000, 1234)\n         self._eq(\n             'container|||||pipefest|||2021-02-03T12:34:56.654321|1234',\n             'container', '||pipefest|', 1612355696654321000, 1234)\n         self.assertRaises(\n             Exception,\n             ListLine, 'too|few')\n         self.assertRaises(\n             AssertionError,\n             ListLine, 'lots|of|unescaped|2021-02-03T12:34:56.654321|1234')\n         self.assertRaises(\n             AssertionError,\n             ListLine, 'lots|of|one||escaped|2021-02-03T12:34:56.654321|1234')\n         self.assertRaises(\n             AssertionError,\n             ListLine, '|emptycontainer|2021-02-03T12:34:56.654321|1234')\n \n     def test_with_container(self):\n         ll = ListLine(\n             'contx|path/to/somewhere|2021-02-03T12:34:56.654321|1234')\n         self.assertEqual(ll.container, 'contx')\n         self.assertEqual(ll.container_path, ('contx', 'path/to/somewhere'))\n         self.assertEqual(ll.path, 'path/to/somewhere')\n         self.assertEqual(ll.modified, 1612355696654321000)\n         self.assertEqual(ll.size, 1234)\n \n     def test_no_container(self):\n         ll = ListLine(\n             'nocontainer/to/somewhere|2021-02-03T12:34:57.654321|12345')\n         self.assertEqual(ll.container, None)\n         self.assertEqual(ll.container_path, (None, 'nocontainer/to/somewhere'))\n         self.assertEqual(ll.path, 'nocontainer/to/somewhere')\n         self.assertEqual(ll.modified, 1612355697654321000)\n         self.assertEqual(ll.size, 12345)\n \n     def test_comm_lineiter_good(self):\n         a = '''\\\n contx|a|2021-02-03T12:34:56.654321|1234\n contx|ab|2021-02-03T12:34:56.654321|1234\n contx|b|2021-02-03T12:34:56.654321|1234\n conty|a|2021-02-03T12:34:56.654321|1234'''.split('\\n')\n         it = _comm_lineiter(a)\n         values = [i for i in it]\n         self.assertEqual(values, [\n             ListLine('contx|a|2021-02-03T12:34:56.654321|1234'),\n             ListLine('contx|ab|2021-02-03T12:34:56.654321|1234'),\n             ListLine('contx|b|2021-02-03T12:34:56.654321|1234'),\n             ListLine('conty|a|2021-02-03T12:34:56.654321|1234')])\n \n     def test_comm_lineiter_error(self):\n         a = '''\\\n contx|a|2021-02-03T12:34:56.654321|1234\n contx|c|2021-02-03T12:34:56.654321|1234\n contx|b|2021-02-03T12:34:56.654321|1234'''.split('\\n')\n         it = _comm_lineiter(a)\n         self.assertRaises(ValueError, list, it)\n \n \n class _ListLineCommTest(TestCase):\n     def test_mixed(self):\n         a = '''\\\n a|2021-02-03T12:34:56.654321|1234\n b|2021-02-03T12:34:56.654321|1234\n c|2021-02-03T12:34:56.654321|1234'''.split('\\n')\n         b = '''\\\n a|2021-02-03T12:34:56.654321|1234\n b2|2021-02-03T12:34:56.654321|1234\n b3|2021-02-03T12:34:56.654321|1234\n c|2021-02-03T12:34:56.654321|1234\n c2|2021-02-03T12:34:56.654321|1234'''.split('\\n')\n         act_both, act_left, act_right = [], [], []\n         llc = _ListLineComm(a, b)\n         llc.act(\n             both=(lambda line: act_both.append(line)),\n             difftime=None,\n             leftonly=(lambda line: act_left.append(line)),\n             rightonly=(lambda line: act_right.append(line)))\n         self.assertEqual(act_both, [\n             'a|2021-02-03T12:34:56.654321|1234',\n             'c|2021-02-03T12:34:56.654321|1234'])\n         self.assertEqual(act_left, [\n             'b|2021-02-03T12:34:56.654321|1234'])\n         self.assertEqual(act_right, [\n             'b2|2021-02-03T12:34:56.654321|1234',\n             'b3|2021-02-03T12:34:56.654321|1234',\n             'c2|2021-02-03T12:34:56.654321|1234'])\n \n     def test_oneonly(self):\n         a = '''\\\n a|2021-02-03T12:34:56.654321|1234\n b|2021-02-03T12:34:56.654321|1234\n c|2021-02-03T12:34:56.654321|1234'''.split('\\n')\n \n         act_both, act_left, act_right = [], [], []\n         llc = _ListLineComm(a, [])\n         llc.act(\n             both=(lambda line: act_both.append(line)),\n             difftime=None,\n             leftonly=(lambda line: act_left.append(line)),\n             rightonly=(lambda line: act_right.append(line)))\n         self.assertEqual((act_both, act_left, act_right), ([], a, []))\n \n         act_both, act_left, act_right = [], [], []\n         llc = _ListLineComm([], a)\n         llc.act(\n             both=(lambda line: act_both.append(line)),\n             difftime=None,\n             leftonly=(lambda line: act_left.append(line)),\n             rightonly=(lambda line: act_right.append(line)))\n         self.assertEqual((act_both, act_left, act_right), ([], [], a))\n \n     def test_difftime(self):\n         a = '''\\\n a|2021-02-03T12:34:56.654321|1234\n b|2021-02-03T12:34:56.654321|1234\n c|2021-02-03T12:34:56.654321|1234'''.split('\\n')\n         b = '''\\\n a|2021-02-03T12:34:56.654322|1234\n b2|2021-02-03T12:34:56.654321|1234\n b3|2021-02-03T12:34:56.654321|1234\n c|2021-02-03T12:34:56.654322|1234\n c2|2021-02-03T12:34:56.654321|1234'''.split('\\n')\n         act_both, act_difftime, act_left, act_right = [], [], [], []\n         llc = _ListLineComm(a, b)\n         llc.act(\n             both=(lambda line: act_both.append(line)),\n             difftime=(lambda leftline, rightline: (\n                 act_difftime.append((leftline, rightline)))),\n             leftonly=(lambda line: act_left.append(line)),\n             rightonly=(lambda line: act_right.append(line)))\n         self.assertEqual(act_both, [])\n         self.assertEqual(act_difftime, [\n             ('a|2021-02-03T12:34:56.654321|1234',\n              'a|2021-02-03T12:34:56.654322|1234'),\n             ('c|2021-02-03T12:34:56.654321|1234',\n              'c|2021-02-03T12:34:56.654322|1234')])\n         self.assertEqual(act_left, [\n             'b|2021-02-03T12:34:56.654321|1234'])\n         self.assertEqual(act_right, [\n             'b2|2021-02-03T12:34:56.654321|1234',\n             'b3|2021-02-03T12:34:56.654321|1234',\n             'c2|2021-02-03T12:34:56.654321|1234'])\n \n \n class Cli:\n     def __init__(self):\n         parser = ArgumentParser()\n         parser.add_argument(\n             '-c', '--config', metavar='configpath', default='~/.rclone.conf',\n             help='inifile location')\n         parser.add_argument('inisection')\n         parser.add_argument(\n             '--test-path-translate', metavar='testcontainer',\n             help='test path translation with paths from stdin')\n         parser.add_argument('container', nargs='?')\n         parser.add_argument('--all-containers', action='store_true')\n         self.args = parser.parse_args()\n \n         if not self.args.test_path_translate:\n             if not (bool(self.args.container)\n                     ^ bool(self.args.all_containers)):\n                 parser.error('either specify a container or --all-containers')\n \n     @property\n     def config(self):\n         if not hasattr(self, '_config'):\n             self._config = SwiftSyncConfig(\n                 os.path.expanduser(self.args.config),\n                 self.args.inisection)\n         return self._config\n \n     def execute(self):\n         if self.args.test_path_translate:\n             self.test_path_translate(self.args.test_path_translate)\n         elif self.args.container:\n             self.sync_container(self.args.container)\n         elif self.args.all_containers:\n             self.sync_all_containers()\n         else:\n             raise NotImplementedError()\n \n     def sync_container(self, container_name):\n         swiftsync = SwiftSync(self.config, container_name)\n         swiftsync.sync()\n \n     def sync_all_containers(self):\n         swiftsync = SwiftSync(self.config)\n         swiftsync.sync()\n \n     def test_path_translate(self, container):\n         translator = self.config.get_translator(container)\n         try:\n             while True:\n                 rpath = input()\n                 lpath = translator(rpath)\n                 print('{!r} => {!r}'.format(rpath, lpath))\n         except EOFError:\n             pass\n \n \n if __name__ == '__main__':\n     # Test using: python3 -m unittest contrib/planb-swiftsync.py\n     cli = Cli()\n     try:\n         cli.execute()\n     except SystemExit as e:\n         # When it is not handled, the Python interpreter exits; no stack\n         # traceback is printed. Print it ourselves.\n         if e.code != 0:\n             traceback.print_exc()\n         sys.exit(e.code)\n ", "input_code": "def _dictsum(dicts):\n\"\"\"\nCombine values of the dictionaries supplied by iterable dicts.\n\n>>> _dictsum([{'a': 1, 'b': 2}, {'a': 5, 'b': 0}])\n{'a': 6, 'b': 2}\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _dictsum(dicts):\n    \"\"\"\n    Combine values of the dictionaries supplied by iterable dicts.\n\n    >>> _dictsum([{'a': 1, 'b': 2}, {'a': 5, 'b': 0}])\n    {'a': 6, 'b': 2}\n    \"\"\"\n    it = iter(dicts)\n    first = next(it).copy()\n    for d in it:\n        for k, v in d.items():\n            first[k] += v\n    return first", "signature": "def _dictsum(dicts):", "completion_path": "contrib/planb-swiftsync.py"}
{"ce_id": "62ece4982e6aefcf4aabbd62", "namespace": "62ece4982e6aefcf4aabbd62", "namespace_real": "pyseed.apibase._replace_url_args", "real_proj_path": "SEED-platform---py-seed/", "type": "function", "class_name": null, "function_name": "_replace_url_args", "contexts_above": "#!/usr/bin/env python\n\"\"\"\ncopyright (c) 2016 Earth Advantage. All rights reserved.\n..codeauthor::Paul Munday <paul@paulmunday.net>\n\nFunctionality for calls to external API's\"\"\"\n\n# Imports from Standard Library\nimport re\n\n# Imports from Third Party Modules\n# Imports from External Modules\nimport requests\n\n# Local Imports\n# Public Functions and Classes\n# Helper functions for use by BaseAPI subclasses\nfrom pyseed.exceptions import APIClientError\n\n\ndef add_pk(url, pk, required=True, slash=False):\n    \"\"\"Add id/primary key to url\"\"\"\n    if required and not pk:\n        raise APIClientError('id/pk must be supplied')\n    if pk:\n        if isinstance(pk, str) and not pk.isdigit():\n            raise TypeError('id/pk must be a positive integer')\n        elif not isinstance(pk, (int, str)) or int(pk) < 0:\n            raise TypeError('id/pk must be a positive integer')\n        if not url.endswith('/'):\n            url = \"{}/{}\".format(url, pk)\n        else:\n            url = \"{}{}\".format(url, pk)\n    if slash:\n        # Only add the trailing slash if it's not already there\n        if not url.endswith('/'):\n            url = \"{}/\".format(url)\n    return url\n\n", "contexts_below": "class BaseAPI(object):\n     \"\"\"\n     Base class for API Calls\n     \"\"\"\n     # pylint: disable=too-few-public-methods, too-many-instance-attributes\n \n     def __init__(self, url=None, use_ssl=True, timeout=None, use_json=False,\n                  use_auth=False, auth=None, **kwargs):\n         # pylint: disable=too-many-arguments\n         \"\"\"Set url,api key, auth usage, ssl usage, timeout etc.\n \n         :param url: url to use, http(s)://can be omitted, an error will\n                    will be used if it is supplied and dose not match use_ssl\n         :param: use_ssl: connect over https, defaults to true\n         :param use_auth: use authentication\n \n         ..Note:\n             if use_auth is True the default is to use http basic\n             authentication if self.auth is not set. (You will need to\n             to this by overriding __init__ and setting this before\n             calling super.\n \n             This requires username and password to be supplied as\n             keyword arguments. N.B. api keys using basic auth e.g. SEED\n             should be supplied as password.\n \n             To use Digest Authentication set auth_method='digest'\n \n             If use_ssl is False and the url you supply starts with https\n             an error will be thrown.\n         \"\"\"\n         self.timeout = timeout\n         self.use_ssl = use_ssl\n         self.use_json = use_json\n         self.use_auth = use_auth\n         self.auth = auth\n         self.url = None\n         self.url = self._construct_url(url) if url else None\n         for key, val in kwargs.items():\n             setattr(self, key, val)\n \n     def _construct_payload(self, params):\n         \"\"\"Construct parameters for an api call.\n .\n         :param params: An dictionary of key-value pairs to include\n             in the request.\n         :return: A dictionary of k-v pairs to send to the server\n             in the request.\n         \"\"\"\n         compulsory = getattr(self, 'compulsory_params', [])\n         for param in compulsory:\n             if param not in params:\n                 try:\n                     params[param] = getattr(self, param)\n                 except AttributeError:\n                     msg = \"{} is a compulsory field\".format(param)\n                     raise APIClientError(msg)\n         return params\n \n     def _construct_url(self, urlstring, use_ssl=None):\n         \"\"\"Construct url\"\"\"\n         # self.use_ssl takes priority to enforce ssl use\n         use_ssl = self.use_ssl if self.use_ssl is not None else use_ssl\n         if not urlstring and not self.url:\n             raise APIClientError('No url set')\n         elif not urlstring:\n             url = self.url\n         else:\n             if urlstring.startswith('https://') and not use_ssl:\n                 # We strip off url prefix\n                 # raise an error if https is used  in url without use_ssl\n                 raise APIClientError(\n                     'use_ssl is false but url starts with https'\n                 )\n             elif urlstring.startswith('http://') and use_ssl:\n                 # We strip off url prefix\n                 # raise an error if http is used in url with use_ssl\n                 raise APIClientError(\n                     'use_ssl is true but url does not starts with https'\n                 )\n             else:\n                 # strip http(s):// off url\n                 regex = re.compile('^https?://')\n                 urlstring = regex.sub('', urlstring)\n                 if use_ssl:\n                     start = 'https://'\n                 else:\n                     start = 'http://'\n                 url = \"{}{}\".format(start, urlstring)\n         return url\n \n     def check_call_success(self, response):\n         \"\"\"Return true if api call was successful.\"\"\"\n         # pylint: disable=no-self-use, no-member\n         return response.status_code == requests.codes.ok\n \n     def _get(self, url=None, use_ssl=None, **kwargs):\n         \"\"\"Internal method to make api calls using GET.\"\"\"\n         url = self._construct_url(url, use_ssl=use_ssl)\n         params = self._construct_payload(kwargs)\n         payload = {\n             'timeout': self.timeout,\n             'headers': params.pop('headers', None)\n         }\n         if params:\n             payload['params'] = params\n         if self.auth:                                       # pragma: no cover\n             payload['auth'] = self.auth\n         api_call = requests.get(url, **payload)\n         return api_call\n \n     def _post(self, url=None, use_ssl=None, params=None, files=None, **kwargs):\n         \"\"\"Internal method to make api calls using POST.\"\"\"\n         url = self._construct_url(url, use_ssl=use_ssl)\n         if not params:\n             params = {}\n         params = self._construct_payload(params)\n         payload = {\n             'timeout': self.timeout,\n             'headers': params.pop('headers', None)\n         }\n         if params:\n             payload['params'] = params\n         if files:\n             payload['files'] = files\n         if self.auth:                                       # pragma: no cover\n             payload['auth'] = self.auth\n         if self.use_json:\n             data = kwargs.pop('json', None)\n             if data:\n                 payload['json'] = data\n             else:\n                 # just put the remaining kwargs into the json field\n                 payload['json'] = kwargs\n         else:\n             data = kwargs.pop('data', None)\n             if data:\n                 payload['data'] = data\n             else:\n                 # just put the remaining kwargs into the data field\n                 payload['data'] = kwargs\n \n         # if there are any remaining kwargs, then put them into the params\n         if 'params' not in payload:\n             payload['params'] = {}\n         payload['params'].update(**kwargs)\n \n         # now do the actual call to post!\n         api_call = requests.post(url, **payload)\n         return api_call\n \n     def _put(self, url=None, use_ssl=None, params=None, files=None,\n              **kwargs):\n         \"\"\"Internal method to make api calls using PUT.\"\"\"\n         url = self._construct_url(url, use_ssl=use_ssl)\n         if not params:\n             params = {}\n         params = self._construct_payload(params)\n         payload = {\n             'timeout': self.timeout,\n             'headers': params.pop('headers', None)\n         }\n         if params:\n             payload['params'] = params\n         if files:                                           # pragma: no cover\n             payload['files'] = files\n         if self.auth:                                       # pragma: no cover\n             payload['auth'] = self.auth\n         if self.use_json:\n             data = kwargs.pop('json', None)\n             if data:\n                 payload['json'] = data\n             else:\n                 # just put the remaining kwargs into the json field\n                 payload['json'] = kwargs\n         else:\n             data = kwargs.pop('data', None)\n             if data:\n                 payload['data'] = data\n             else:\n                 # just put the remaining kwargs into the data field\n                 payload['data'] = kwargs\n \n         # if there are any remaining kwargs, then put them into the params\n         if 'params' not in payload:\n             payload['params'] = {}\n         payload['params'].update(**kwargs)\n \n         api_call = requests.put(url, **payload)\n         return api_call\n \n     def _patch(self, url=None, use_ssl=None, params=None, files=None,\n                **kwargs):\n         \"\"\"Internal method to make api calls using PATCH.\"\"\"\n         url = self._construct_url(url, use_ssl=use_ssl)\n         if not params:\n             params = {}\n         params = self._construct_payload(params)\n         payload = {\n             'timeout': self.timeout,\n             'headers': params.pop('headers', None)\n         }\n         if params:\n             payload['params'] = params\n         if files:\n             payload['files'] = files\n         if self.auth:                                        # pragma: no cover\n             payload['auth'] = self.auth\n         if self.use_json:\n             data = kwargs.pop('json', None)\n             if data:\n                 payload['json'] = data\n             else:\n                 # just put the remaining kwargs into the json field\n                 payload['json'] = kwargs\n         else:\n             data = kwargs.pop('data', None)\n             if data:\n                 payload['data'] = data\n             else:\n                 # just put the remaining kwargs into the data field\n                 payload['data'] = kwargs\n \n         # if there are any remaining kwargs, then put them into the params\n         if 'params' not in payload:\n             payload['params'] = {}\n         payload['params'].update(**kwargs)\n         api_call = requests.patch(url, **payload)\n         return api_call\n \n     def _delete(self, url=None, use_ssl=None, **kwargs):\n         \"\"\"Internal method to make api calls using DELETE.\"\"\"\n         url = self._construct_url(url, use_ssl=use_ssl)\n         params = self._construct_payload(kwargs)\n         payload = {\n             'timeout': self.timeout,\n             'headers': params.pop('headers', None)\n         }\n         if params:\n             payload['params'] = params\n         if self.auth:                                        # pragma: no cover\n             payload['auth'] = self.auth\n         api_call = requests.delete(url, **payload)\n         return api_call\n \n \n class JSONAPI(BaseAPI):\n     \"\"\"\n     Base class for Json API Calls. See BaseAPI for documentation.\n     \"\"\"\n     # pylint: disable=too-few-public-methods, too-many-arguments\n \n     def __init__(self, url=None, use_ssl=True, timeout=None,\n                  use_auth=False, auth=None, **kwargs):\n         super(JSONAPI, self).__init__(\n             url=url, use_ssl=use_ssl, timeout=timeout, use_json=True,\n             use_auth=use_auth, auth=auth, **kwargs\n         )\n \n \n class UserAuthMixin(object):\n     \"\"\"\n     Mixin to provide basic or digest api client authentication via username\n     and password(or api_key).\"\"\"\n     # pylint:disable=too-few-public-methods\n \n     def _get_auth(self):\n         \"\"\"Get basic or digest auth by username/password\"\"\"\n         username = getattr(self, 'username', None)\n         password = getattr(self, 'password', None)\n         # support using api_key as password in basic auth\n         # as used by SEED (if supplied as api_key not password)\n         if not password:\n             password = getattr(self, 'api_key', None)\n         if getattr(self, 'auth_method', None) == 'digest':\n             auth = requests.auth.HTTPDigestAuth(username, password)\n         else:\n             auth = requests.auth.HTTPBasicAuth(username, password)\n         return auth\n \n     def _construct_payload(self, params):\n         \"\"\"Construct parameters for an api call.\n .\n         :param params: An dictionary of key-value pairs to include\n             in the request.\n         :return: A dictionary of k-v pairs to send to the server\n             in the request.\n         \"\"\"\n         if getattr(self, 'use_auth', None) and not getattr(self, 'auth', None):\n             self.auth = self._get_auth()\n         return super(UserAuthMixin, self)._construct_payload(params)\n \n \n class OAuthMixin(object):\n     \"\"\"\n     Mixin to provide api client authentication via OAuth access tokens based\n     on the JWTGrantClient found in jwt-oauth2lib.\n \n     see https://github.com/GreenBuildingRegistry/jwt_oauth2\n     \"\"\"\n \n     _token_type = \"Bearer\"\n     oauth_client = None\n \n     def _get_access_token(self):\n         \"\"\"Generate OAuth access token\"\"\"\n         private_key_file = getattr(self, 'private_key_location', None)\n         client_id = getattr(self, 'client_id', None)\n         username = getattr(self, 'username', None)\n         with open(private_key_file, 'r') as pk_file:\n             sig = pk_file.read()\n             oauth_client = self.oauth_client(\n                 sig, username, client_id,\n                 pvt_key_password=getattr(self, 'pvt_key_password', None)\n             )\n             return oauth_client.get_access_token()\n \n     def _construct_payload(self, params):\n         \"\"\"Construct parameters for an api call.\n .\n         :param params: An dictionary of key-value pairs to include\n             in the request.\n         :return: A dictionary of k-v pairs to send to the server\n             in the request.\n         \"\"\"\n         params = super(OAuthMixin, self)._construct_payload(params)\n         token = getattr(self, 'token', None) or self._get_access_token()\n         params['headers'] = {\n             'Authorization': '{} {}'.format(self._token_type, token)\n         }\n         return params\n ", "input_code": "def _replace_url_args(url, url_args):\n\"\"\"\nReplace any custom string URL items with values in args\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _replace_url_args(url, url_args):\n    \"\"\"Replace any custom string URL items with values in args\"\"\"\n    if url_args:\n        for key, value in url_args.items():\n            url = url.replace(f\"{key}/\", f\"{value}/\")\n    return url", "signature": "def _replace_url_args(url, url_args):", "completion_path": "pyseed/apibase.py"}
{"ce_id": "62ece4982e6aefcf4aabbd63", "namespace": "62ece4982e6aefcf4aabbd63", "namespace_real": "cinder.api.api_utils.is_none_string", "real_proj_path": "openstack---cinder/", "type": "function", "class_name": null, "function_name": "is_none_string", "contexts_above": "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nfrom __future__ import annotations\n\nimport typing\nfrom typing import Any, Generator, Iterable, Optional, Union  # noqa: H301\n\nfrom keystoneauth1 import exceptions as ks_exc\nfrom keystoneauth1 import identity\nfrom keystoneauth1 import loading as ka_loading\nfrom keystoneclient import client\nfrom oslo_config import cfg\nfrom oslo_log import log as logging\nfrom oslo_utils import strutils\nimport webob\nfrom webob import exc\n\nif typing.TYPE_CHECKING:\n    # conditional import to avoid a circular import problem from cinderlib\n    from cinder import context\nfrom cinder import exception\nfrom cinder.i18n import _\n\nCONF = cfg.CONF\nCONF.import_group('keystone_authtoken',\n                  'keystonemiddleware.auth_token.__init__')\n\nLOG = logging.getLogger(__name__)\n\n\ndef _parse_is_public(is_public: Optional[str]) -> Optional[bool]:\n    \"\"\"Parse is_public into something usable.\n\n    * True: List public volume types only\n    * False: List private volume types only\n    * None: List both public and private volume types\n    \"\"\"\n\n    if is_public is None:\n        # preserve default value of showing only public types\n        return True\n    elif is_none_string(is_public):\n        return None\n    else:\n        try:\n            return strutils.bool_from_string(is_public, strict=True)\n        except ValueError:\n            msg = _('Invalid is_public filter [%s]') % is_public\n            raise exc.HTTPBadRequest(explanation=msg)\n\n", "contexts_below": "\n def remove_invalid_filter_options(\n         context: 'context.RequestContext',\n         filters: dict,\n         allowed_search_options: Iterable[str]) -> None:\n     \"\"\"Remove search options that are not valid for non-admin API/context.\"\"\"\n \n     if context.is_admin:\n         # Allow all options\n         return\n     # Otherwise, strip out all unknown options\n     unknown_options = [opt for opt in filters\n                        if opt not in allowed_search_options]\n     bad_options = \", \".join(unknown_options)\n     LOG.debug(\"Removing options '%s' from query.\", bad_options)\n     for opt in unknown_options:\n         del filters[opt]\n \n \n _visible_admin_metadata_keys = ['readonly', 'attached_mode']\n \n \n def add_visible_admin_metadata(volume) -> None:\n     \"\"\"Add user-visible admin metadata to regular metadata.\n \n     Extracts the admin metadata keys that are to be made visible to\n     non-administrators, and adds them to the regular metadata structure for the\n     passed-in volume.\n     \"\"\"\n     visible_admin_meta = {}\n \n     if volume.get('volume_admin_metadata'):\n         if isinstance(volume['volume_admin_metadata'], dict):\n             volume_admin_metadata = volume['volume_admin_metadata']\n             for key in volume_admin_metadata:\n                 if key in _visible_admin_metadata_keys:\n                     visible_admin_meta[key] = volume_admin_metadata[key]\n         else:\n             for item in volume['volume_admin_metadata']:\n                 if item['key'] in _visible_admin_metadata_keys:\n                     visible_admin_meta[item['key']] = item['value']\n     # avoid circular ref when volume is a Volume instance\n     elif (volume.get('admin_metadata') and\n             isinstance(volume.get('admin_metadata'), dict)):\n         for key in _visible_admin_metadata_keys:\n             if key in volume['admin_metadata'].keys():\n                 visible_admin_meta[key] = volume['admin_metadata'][key]\n \n     if not visible_admin_meta:\n         return\n \n     # NOTE(zhiyan): update visible administration metadata to\n     # volume metadata, administration metadata will rewrite existing key.\n     if volume.get('volume_metadata'):\n         orig_meta = list(volume.get('volume_metadata'))\n         for item in orig_meta:\n             if item['key'] in visible_admin_meta.keys():\n                 item['value'] = visible_admin_meta.pop(item['key'])\n         for key, value in visible_admin_meta.items():\n             orig_meta.append({'key': key, 'value': value})\n         volume['volume_metadata'] = orig_meta\n     # avoid circular ref when vol is a Volume instance\n     elif (volume.get('metadata') and\n             isinstance(volume.get('metadata'), dict)):\n         volume['metadata'].update(visible_admin_meta)\n     else:\n         volume['metadata'] = visible_admin_meta\n \n \n def validate_integer(value: int, name: str,\n                      min_value: Optional[int] = None,\n                      max_value: Optional[int] = None) -> int:\n     \"\"\"Make sure that value is a valid integer, potentially within range.\n \n     :param value: the value of the integer\n     :param name: the name of the integer\n     :param min_value: the min value of the integer\n     :param max_value: the max value of the integer\n     :returns: integer\n     \"\"\"\n     try:\n         value = strutils.validate_integer(value, name, min_value, max_value)\n         return value\n     except ValueError as e:\n         raise webob.exc.HTTPBadRequest(explanation=str(e))\n \n \n def walk_class_hierarchy(clazz: type,\n                          encountered: Optional[list[type]] = None) -> \\\n         Generator[type, None, None]:\n     \"\"\"Walk class hierarchy, yielding most derived classes first.\"\"\"\n     if not encountered:\n         encountered = []\n     for subclass in clazz.__subclasses__():\n         if subclass not in encountered:\n             encountered.append(subclass)\n             # drill down to leaves first\n             for subsubclass in walk_class_hierarchy(subclass, encountered):\n                 yield subsubclass\n             yield subclass\n \n \n def _keystone_client(context: 'context.RequestContext',\n                      version: tuple[int, int] = (3, 0)) -> client.Client:\n     \"\"\"Creates and returns an instance of a generic keystone client.\n \n     :param context: The request context\n     :param version: version of Keystone to request\n     :return: keystoneclient.client.Client object\n     \"\"\"\n     if context.system_scope is not None:\n         auth_plugin = identity.Token(\n             auth_url=CONF.keystone_authtoken.auth_url,\n             token=context.auth_token,\n             system_scope=context.system_scope\n         )\n     elif context.domain_id is not None:\n         auth_plugin = identity.Token(\n             auth_url=CONF.keystone_authtoken.auth_url,\n             token=context.auth_token,\n             domain_id=context.domain_id\n         )\n     elif context.project_id is not None:\n         auth_plugin = identity.Token(\n             auth_url=CONF.keystone_authtoken.auth_url,\n             token=context.auth_token,\n             project_id=context.project_id\n         )\n     else:\n         # We're dealing with an unscoped token from keystone that doesn't\n         # carry any authoritative power outside of the user simplify proving\n         # they know their own password. This token isn't associated with any\n         # authorization target (e.g., system, domain, or project).\n         auth_plugin = context.get_auth_plugin()\n \n     client_session = ka_loading.session.Session().load_from_options(\n         auth=auth_plugin,\n         insecure=CONF.keystone_authtoken.insecure,\n         cacert=CONF.keystone_authtoken.cafile,\n         key=CONF.keystone_authtoken.keyfile,\n         cert=CONF.keystone_authtoken.certfile,\n         split_loggers=CONF.service_user.split_loggers)\n     return client.Client(auth_url=CONF.keystone_authtoken.auth_url,\n                          session=client_session, version=version)\n \n \n class GenericProjectInfo(object):\n     \"\"\"Abstraction layer for Keystone V2 and V3 project objects\"\"\"\n     def __init__(self,\n                  project_id: str,\n                  project_keystone_api_version: str,\n                  domain_id: Optional[str] = None,\n                  name: Optional[str] = None,\n                  description: Optional[str] = None):\n         self.id = project_id\n         self.keystone_api_version = project_keystone_api_version\n         self.domain_id = domain_id\n         self.name = name\n         self.description = description\n \n \n def get_project(context: 'context.RequestContext',\n                 project_id: str) -> GenericProjectInfo:\n     \"\"\"Method to verify project exists in keystone\"\"\"\n     keystone = _keystone_client(context)\n     generic_project = GenericProjectInfo(project_id, keystone.version)\n     project = keystone.projects.get(project_id)\n     generic_project.domain_id = project.domain_id\n     generic_project.name = project.name\n     generic_project.description = project.description\n     return generic_project\n \n \n def validate_project_and_authorize(context: 'context.RequestContext',\n                                    project_id: str,\n                                    policy_check: str,\n                                    validate_only: bool = False) -> None:\n     target_project: Union[GenericProjectInfo, dict]\n     try:\n         target_project = get_project(context, project_id)\n         if not validate_only:\n             target_project = {'project_id': target_project.id}\n             context.authorize(policy_check, target=target_project)\n     except ks_exc.http.NotFound:\n         explanation = _(\"Project with id %s not found.\" % project_id)\n         raise exc.HTTPNotFound(explanation=explanation)\n     except exception.NotAuthorized:\n         explanation = _(\"You are not authorized to perform this \"\n                         \"operation.\")\n         raise exc.HTTPForbidden(explanation=explanation)\n ", "input_code": "def is_none_string(val: Any) -> bool:\n\"\"\"\nCheck if a string represents a None value.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def is_none_string(val: Any) -> bool:\n    \"\"\"Check if a string represents a None value.\"\"\"\n    if not isinstance(val, str):\n        return False\n\n    return val.lower() == 'none'", "signature": "def is_none_string(val: Any) -> bool:", "completion_path": "cinder/api/api_utils.py"}
{"ce_id": "62ece4982e6aefcf4aabbd65", "namespace": "62ece4982e6aefcf4aabbd65", "namespace_real": "borgmatic.commands.completion.parser_flags", "real_proj_path": "witten---borgmatic/", "type": "function", "class_name": null, "function_name": "parser_flags", "contexts_above": "import pkg_resources\n\nfrom borgmatic.commands import arguments\n\nUPGRADE_MESSAGE = '''\nYour bash completions script is from a different version of borgmatic than is\ncurrently installed. Please upgrade your script so your completions match the\ncommand-line flags in your installed borgmatic! Try this to upgrade:\n\n    sudo sh -c \"borgmatic --bash-completions > $BASH_SOURCE\"\n    source $BASH_SOURCE\n'''\n\n", "contexts_below": "\n def bash_completion():\n     '''\n     Return a bash completion script for the borgmatic command. Produce this by introspecting\n     borgmatic's command-line argument parsers.\n     '''\n     top_level_parser, subparsers = arguments.make_parsers()\n     global_flags = parser_flags(top_level_parser)\n     actions = ' '.join(subparsers.choices.keys())\n     borgmatic_version = pkg_resources.require('borgmatic')[0].version\n \n     # Avert your eyes.\n     return '\\n'.join(\n         (\n             'check_version() {',\n             '    local installed_version=\"$(borgmatic --version 2> /dev/null)\"',\n             '    if [ \"$installed_version\" != \"%s\" ] && [ \"$installed_version\" != \"\" ];'\n             % borgmatic_version,\n             '        then cat << EOF\\n%s\\nEOF' % UPGRADE_MESSAGE,\n             '    fi',\n             '}',\n             'complete_borgmatic() {',\n         )\n         + tuple(\n             '''    if [[ \" ${COMP_WORDS[*]} \" =~ \" %s \" ]]; then\n         COMPREPLY=($(compgen -W \"%s %s %s\" -- \"${COMP_WORDS[COMP_CWORD]}\"))\n         return 0\n     fi'''\n             % (action, parser_flags(subparser), actions, global_flags)\n             for action, subparser in subparsers.choices.items()\n         )\n         + (\n             '    COMPREPLY=($(compgen -W \"%s %s\" -- \"${COMP_WORDS[COMP_CWORD]}\"))'\n             % (actions, global_flags),\n             '    (check_version &)',\n             '}',\n             '\\ncomplete -F complete_borgmatic borgmatic',\n         )\n     )\n ", "input_code": "def parser_flags(parser):\n\"\"\"\nGiven an argparse.ArgumentParser instance, return its argument flags in a space-separated\nstring.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def parser_flags(parser):\n    '''\n    Given an argparse.ArgumentParser instance, return its argument flags in a space-separated\n    string.\n    '''\n    return ' '.join(option for action in parser._actions for option in action.option_strings)", "signature": "def parser_flags(parser):", "completion_path": "borgmatic/commands/completion.py"}
{"ce_id": "62ece4982e6aefcf4aabbd66", "namespace": "62ece4982e6aefcf4aabbd66", "namespace_real": "makeprojects.util.was_processed", "real_proj_path": "burgerbecky---makeprojects/", "type": "function", "class_name": null, "function_name": "was_processed", "contexts_above": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nThe util module contains subroutines used everywhere.\n\n@package makeprojects.util\n\"\"\"\n\nfrom __future__ import absolute_import, print_function, unicode_literals\n\nimport os\nimport re\nimport fnmatch\nfrom burger import string_to_bool, is_string, import_py_script\nfrom .enums import FileTypes\nfrom .config import DEFAULT_BUILD_RULES\n\n# pylint: disable=consider-using-f-string\n\n########################################\n\n\ndef validate_enum_type(value, data_type):\n    \"\"\"\n    Verify a value is a specific data type.\n\n    Check if the value is either None or an instance of a\n    specfic data type. If so, return immediately. If the value is a string,\n    call the lookup() function of the data type for conversion.\n\n    Args:\n        value: Value to check.\n        data_type: Type instance of the class type to match.\n\n    Returns:\n        Value converted to data_type or None.\n\n    Raises:\n        TypeError\n\n    \"\"\"\n\n    if value is not None:\n        # Perform the lookup\n        new_value = data_type.lookup(value)\n        if new_value is None:\n            msg = '\"{}\" must be of type \"{}\".'.format(\n                value, data_type.__name__)\n            raise TypeError(msg)\n        # Save the converted type\n        value = new_value\n    return value\n\n########################################\n\n\ndef regex_dict(item):\n    \"\"\"\n    Convert *.cpp keys to regex keys\n\n    Given a dict where the keys are all filenames with wildcards, convert only\n    the keys into equivalent regexes and leave the values intact.\n\n    Examples:\n\n    rules = {\n        '*.cpp':\n            {'a': 'arf', 'b': 'bark', 'c': 'coo'},\n        '*.h':\n            {'h': 'help'}\n    }\n    regex_keys = regex_dict(rules)\n\n    Args:\n        item: dict to convert\n    Returns:\n        dict with keys converted to regexes\n    \"\"\"\n\n    output = {}\n    for key in item:\n        output[re.compile(fnmatch.translate(key)).match] = item[key]\n    return output\n\n########################################\n\n\ndef validate_boolean(value):\n    \"\"\"\n    Verify a value is a boolean.\n\n    Check if the value can be converted to a bool, if so, return the value as\n    bool. None is converted to False.\n\n    Args:\n        value: Value to check.\n\n    Returns:\n        Value converted to data_type or None.\n\n    Raises:\n        ValueError\n    \"\"\"\n\n    if value is not None:\n        # Convert to bool\n        value = string_to_bool(value)\n    return value\n\n########################################\n\n\ndef validate_string(value):\n    \"\"\"\n    Verify a value is a string.\n\n    Check if the value is a string, if so, return the value as is or None.\n\n    Args:\n        value: Value to check.\n\n    Returns:\n        Value is string or None.\n\n    Raises:\n        ValueError\n    \"\"\"\n\n    if value is not None:\n        # Convert to bool\n        if not is_string(value):\n            raise ValueError('\"{}\" must be a string.'.format(value))\n    return value\n\n########################################\n\n\ndef source_file_filter(file_list, file_type_list):\n    \"\"\"\n    Prune the file list for a specific type.\n\n    Note: file_type_list can either be a single enums.FileTypes enum or an\n        iterable list of enums.FileTypes\n\n    Args:\n        file_list: list of core.SourceFile entries.\n        file_type_list: enums.FileTypes to match.\n    Returns:\n        list of matching core.SourceFile entries.\n    \"\"\"\n\n    result_list = []\n\n    # If a single item was passed, use a simple loop\n    if isinstance(file_type_list, FileTypes):\n        for item in file_list:\n            if item.type is file_type_list:\n                result_list.append(item)\n    else:\n        # A list was passed, so test against the list\n        for item in file_list:\n            if item.type in file_type_list:\n                result_list.append(item)\n    return result_list\n\n########################################\n\n\ndef add_build_rules(build_rules_list, file_name, verbose, is_root, basename):\n    \"\"\"\n    Load in the file ``build_rules.py``\n\n    Load the build_rules.py file. If the variable ``*_GENERIC`` is ``True``\n    or if ``is_root`` is ``True``, append the module to ``build_rules_list``.\n    If the variable ``*_CONTINUE`` was found in the file, check if it is set\n    to ``True``. If so, return ``True`` to allow processing to continue. If\n    the file is not found, return ``True`` to allow processing the parent\n    folder.\n\n    Since this is called from ``buildme``, ``cleanme``, and ``makeprojects``,\n    the prefix needed for the tool is passed in ``basename``. An example is\n    \"CLEANME\".\n\n    Args:\n        build_rules_list: List to add ``build_rules.py`` instances.\n        file_name: Full path name of the build_rules.py to load.\n        verbose: True for verbose output.\n        is_root: True if *_GENERIC is ignored.\n        basename: Variable prefix to substitute * in *_GENERIC\n    Returns:\n        True if the parent folder should be checked, False if not.\n    \"\"\"\n\n    # Ensure the absolute path is used.\n    file_name = os.path.abspath(file_name)\n    build_rules = import_py_script(file_name)\n\n    # Not found? Continue parsing folders.\n    if not build_rules:\n        return True\n\n    if is_root or getattr(build_rules, basename + \"_GENERIC\",\n                          False) or getattr(build_rules, \"GENERIC\", False):\n        # Add to the list\n        build_rules_list.append(build_rules)\n\n    if verbose:\n        print('Using configuration file {}'.format(file_name))\n\n    # Test if this is considered the last one in the chain.\n    result = getattr(build_rules, basename + \"_CONTINUE\", None)\n\n    # Not found?\n    if result is None:\n        # Try the catch all version\n        result = getattr(build_rules, \"CONTINUE\", False)\n    return result\n\n########################################\n\n\ndef get_build_rules(working_directory, verbose, build_rules_name, basename):\n    \"\"\"\n    Find all ``build_rules.py`` files that apply to this directory.\n\n    If no files are found, return an empty list.\n\n    Args:\n        working_directory: Directory to scan for ``build_rules.py``\n        verbose: True if verbose output is desired\n        build_rules_name: ``build_rules.py`` or an override\n        basename: \"CLEANME\", \"BUILDME\", etc.\n    Returns:\n        List of loaded ``build_rules.py`` file modules\n    \"\"\"\n\n    # Test if there is a specific build rule\n    build_rules_list = []\n\n    # Load the configuration file at the current directory\n    temp_dir = os.path.abspath(working_directory)\n\n    # Is this the first pass?\n    is_root = True\n    while True:\n\n        # Attempt to load in the build rules.\n        if not add_build_rules(\n            build_rules_list, os.path.join(\n                temp_dir, build_rules_name), verbose, is_root, basename):\n            # Abort if *_CONTINUE = False\n            break\n\n        # Directory traversal is active, require CLEANME_GENERIC\n        is_root = False\n\n        # Pop a folder to check for higher level build_rules.py\n        temp_dir2 = os.path.dirname(temp_dir)\n\n        # Already at the top of the directory?\n        if temp_dir2 is None or temp_dir2 == temp_dir:\n            add_build_rules(\n                build_rules_list,\n                DEFAULT_BUILD_RULES,\n                verbose,\n                True,\n                basename)\n            break\n        # Use the new folder\n        temp_dir = temp_dir2\n    return build_rules_list\n\n########################################\n\n\ndef getattr_build_rules(build_rules_list, attributes, value):\n    \"\"\"\n    Find an attribute in a list of build rules.\n\n    Iterate over the build rules list until an entry has an attribute value.\n    It will return the first one found. If none are found, or there were no\n    entries in ``build_rules_list``, this function returns ``value``.\n\n    Args:\n        build_rules_list: List of ``build_rules.py`` instances.\n        attributes: Attribute name(s) to check for.\n        value: Value to return if the attribute was not found.\n\n    Returns:\n        Attribute value found in ``build_rules_list`` entry, or ``value``.\n    \"\"\"\n\n    # Ensure if it is a single string\n\n    if is_string(attributes):\n        for build_rules in build_rules_list:\n            # Does the entry have this attribute?\n            try:\n                return getattr(build_rules, attributes)\n            except AttributeError:\n                pass\n    else:\n        # Assume attributes is an iterable of strings\n        for build_rules in build_rules_list:\n            # Does the rules file have this attribute?\n            for attribute in attributes:\n                try:\n                    return getattr(build_rules, attribute)\n                except AttributeError:\n                    pass\n\n    # Return the default value\n    return value\n\n########################################\n\n\ndef remove_ending_os_sep(input_list):\n    \"\"\"\n    Iterate over a string list and remove trailing os seperator characters.\n\n    Each string is tested if its length is greater than one and if the last\n    character is the pathname seperator. If so, the pathname seperator character\n    is removed.\n\n    Args:\n        input_list: list of strings\n\n    Returns:\n        Processed list of strings\n\n    Raises:\n        TypeError\n    \"\"\"\n\n    # Input could be None, so test for that case\n    if input_list is None:\n        return []\n\n    return [item[:-1] if len(item) >= 2 and item.endswith(os.sep)\n            else item for item in input_list]\n\n########################################\n\n", "contexts_below": "", "input_code": "def was_processed(processed, path_name, verbose):\n\"\"\"\nCheck if a file or directory has already been processed.\n\nTo prevent recursion, expand the path name to an absolution path\ncall this function with a set that will store all the entries and\nthe entry to test. If the entry is already in the set, report the issue\nand return ``True``. Otherwise, add the entry to the set and return\n``False`` to allow the path to be processed.\n\nArgs:\n    processed: Set to store processed pathnames\n    path_name: Path to a directory or file\n    verbose: True if verbose output is requested\n\nReturns:\n    True if it's already in the set. False if not.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def was_processed(processed, path_name, verbose):\n    \"\"\"\n    Check if a file or directory has already been processed.\n\n    To prevent recursion, expand the path name to an absolution path\n    call this function with a set that will store all the entries and\n    the entry to test. If the entry is already in the set, report the issue\n    and return ``True``. Otherwise, add the entry to the set and return\n    ``False`` to allow the path to be processed.\n\n    Args:\n        processed: Set to store processed pathnames\n        path_name: Path to a directory or file\n        verbose: True if verbose output is requested\n\n    Returns:\n        True if it's already in the set. False if not.\n    \"\"\"\n\n    # Test for recursion\n    if path_name in processed:\n        if verbose:\n            print('{} has already been processed'.format(path_name))\n        return True\n\n    # Mark this list as \"processed\" to prevent recursion\n    if verbose:\n        print('Processing {}.'.format(path_name))\n    processed.add(path_name)\n    return False", "signature": "def was_processed(processed, path_name, verbose):", "completion_path": "makeprojects/util.py"}
{"ce_id": "62ece4982e6aefcf4aabbd67", "namespace": "62ece4982e6aefcf4aabbd67", "namespace_real": "eppy.geometry.surface.vertex3tuple", "real_proj_path": "santoshphilip---eppy/", "type": "function", "class_name": null, "function_name": "vertex3tuple", "contexts_above": "# Copyright (c) 2012 Tuan Tran\n# Copyright (c) 2020 Cheng Cui\n\n# This file is part of eppy.\n# =======================================================================\n#  Distributed under the MIT License.\n#  (See accompanying file LICENSE or copy at\n#  http://opensource.org/licenses/MIT)\n# =======================================================================\n\n\"\"\"This module is used for assisted calculations on E+ surfaces\"\"\"\n# Wrote by Tuan Tran trantuan@hawaii.edu / tranhuuanhtuan@gmail.com\n# School of Architecture, University of Hawaii at Manoa\n\n# The following code within the block\n# credited by ActiveState Code Recipes code.activestate.com\n## {{{ http://code.activestate.com/recipes/578276/ (r1)\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\ntry:\n    import numpy as np\n    from numpy import arccos as acos\nexcept ImportError as err:\n    from tinynumpy import tinynumpy as np\n    from tinynumpy import tinylinalg as linalg\n    from math import acos as acos\nimport math\n\n\ndef area(poly):\n    \"\"\"Area of a polygon poly\"\"\"\n    if len(poly) < 3:  # not a plane - no area\n        return 0\n    total = [0, 0, 0]\n    num = len(poly)\n    for i in range(num):\n        vi1 = poly[i]\n        vi2 = poly[(i + 1) % num]\n        prod = np.cross(vi1, vi2)\n        total[0] += prod[0]\n        total[1] += prod[1]\n        total[2] += prod[2]\n    if total == [0, 0, 0]:  # points are in a straight line - no area\n        return 0\n\n    try:\n        the_unitnormal = get_an_unit_normal(poly)\n    except ZeroDivisionError as e:\n        return 0 # all the points in the poly are in a straight line\n\n\n\n    result = np.dot(total, the_unitnormal)\n    # result = np.dot(total, unit_normal(poly[0], poly[1], poly[2]))\n    return abs(result / 2)\n", "contexts_below": "def get_an_unit_normal(poly):\n     \"\"\"try each vertex of the poly for a unit_normal. Return the unit_normal on sucess\"\"\"\n     for three_t in vertex3tuple(poly):\n         try:\n             return unit_normal(three_t[0], three_t[1], three_t[2])\n         except ZeroDivisionError as e:\n             continue # these 3 points are in a striaght line. try next three\n     raise ZeroDivisionError # all points are in a striaght line\n \n \n \n def unit_normal(pt_a, pt_b, pt_c):\n     \"\"\"unit normal vector of plane defined by points pt_a, pt_b, and pt_c\"\"\"\n     x_val = np.linalg.det(\n         [[1, pt_a[1], pt_a[2]], [1, pt_b[1], pt_b[2]], [1, pt_c[1], pt_c[2]]]\n     )\n     y_val = np.linalg.det(\n         [[pt_a[0], 1, pt_a[2]], [pt_b[0], 1, pt_b[2]], [pt_c[0], 1, pt_c[2]]]\n     )\n     z_val = np.linalg.det(\n         [[pt_a[0], pt_a[1], 1], [pt_b[0], pt_b[1], 1], [pt_c[0], pt_c[1], 1]]\n     )\n     magnitude = (x_val ** 2 + y_val ** 2 + z_val ** 2) ** 0.5\n     mag = (x_val / magnitude, y_val / magnitude, z_val / magnitude)\n     if magnitude < 0.00000001:\n         mag = (0, 0, 0)\n     return mag\n \n \n ## end of http://code.activestate.com/recipes/578276/ }}}\n \n # distance between two points\n def dist(pt1, pt2):\n     \"\"\"Distance between two points\"\"\"\n     return (\n         (pt2[0] - pt1[0]) ** 2 + (pt2[1] - pt1[1]) ** 2 + (pt2[2] - pt1[2]) ** 2\n     ) ** 0.5\n \n \n # width of a rectangular polygon\n def width(poly):\n     \"\"\"Width of a polygon poly\"\"\"\n     num = len(poly) - 1\n     if abs(poly[num][2] - poly[0][2]) < abs(poly[1][2] - poly[0][2]):\n         return dist(poly[num], poly[0])\n     elif abs(poly[num][2] - poly[0][2]) > abs(poly[1][2] - poly[0][2]):\n         return dist(poly[1], poly[0])\n     else:\n         return max(dist(poly[num], poly[0]), dist(poly[1], poly[0]))\n \n \n # height of a polygon poly\n def height(poly):\n     \"\"\"Height of a polygon poly\"\"\"\n     num = len(poly) - 1\n     if abs(poly[num][2] - poly[0][2]) > abs(poly[1][2] - poly[0][2]):\n         return dist(poly[num], poly[0])\n     elif abs(poly[num][2] - poly[0][2]) < abs(poly[1][2] - poly[0][2]):\n         return dist(poly[1], poly[0])\n     else:\n         return min(dist(poly[num], poly[0]), dist(poly[1], poly[0]))\n \n \n def angle2vecs(vec1, vec2):\n     \"\"\"angle between two vectors\"\"\"\n     # vector a * vector b = |a|*|b|* cos(angle between vector a and vector b)\n     dot = np.dot(vec1, vec2)\n     vec1_modulus = np.sqrt(np.multiply(vec1, vec1).sum())\n     vec2_modulus = np.sqrt(np.multiply(vec2, vec2).sum())\n     if (vec1_modulus * vec2_modulus) == 0:\n         cos_angle = 1\n     else:\n         cos_angle = dot / (vec1_modulus * vec2_modulus)\n     return math.degrees(acos(cos_angle))\n \n \n # orienation of a polygon poly\n def azimuth(poly):\n     \"\"\"Azimuth of a polygon poly\"\"\"\n     num = len(poly) - 1\n     vec = unit_normal(poly[0], poly[1], poly[num])\n     vec_azi = np.array([vec[0], vec[1], 0])\n     vec_n = np.array([0, 1, 0])\n     # update by Santosh\n     # angle2vecs gives the smallest angle between the vectors\n     # so for a west wall angle2vecs will give 90\n     # the following 'if' statement will make sure 270 is returned\n     x_vector = vec_azi[0]\n     if x_vector < 0:\n         return 360 - angle2vecs(vec_azi, vec_n)\n     else:\n         return angle2vecs(vec_azi, vec_n)\n \n \n def true_azimuth(bldg_north, zone_rel_north, surf_azimuth):\n     \"\"\"True azimuth of a building surface\"\"\"\n     bldg_north = 0 if bldg_north == \"\" else bldg_north\n     zone_rel_north = 0 if zone_rel_north == \"\" else zone_rel_north\n     return (bldg_north + zone_rel_north + surf_azimuth) % 360\n \n \n def tilt(poly):\n     \"\"\"Tilt of a polygon poly\"\"\"\n     num = len(poly) - 1\n     vec = unit_normal(poly[0], poly[1], poly[num])\n     vec_alt = np.array([vec[0], vec[1], vec[2]])\n     vec_z = np.array([0, 0, 1])\n     return angle2vecs(vec_alt, vec_z)\n ", "input_code": "def vertex3tuple(vertices):\n\"\"\"\nreturn 3 points for each vertex of the polygon. This will include the vertex and the 2 points on both sides of the vertex::\n\npolygon with vertices ABCD\nWill return\nDAB, ABC, BCD, CDA -> returns 3tuples\n#A    B    C    D  -> of vertices\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def vertex3tuple(vertices):\n    \"\"\"return 3 points for each vertex of the polygon. This will include the vertex and the 2 points on both sides of the vertex::\n\n        polygon with vertices ABCD\n        Will return\n        DAB, ABC, BCD, CDA -> returns 3tuples\n        #A    B    C    D  -> of vertices\n    \"\"\"\n    asvertex_list = []\n    for i in range(len(vertices)):\n        try:\n            asvertex_list.append((vertices[i-1], vertices[i], vertices[i+1]))\n        except IndexError as e:\n           asvertex_list.append((vertices[i-1], vertices[i], vertices[0]))\n    return asvertex_list", "signature": "def vertex3tuple(vertices):", "completion_path": "eppy/geometry/surface.py"}
{"ce_id": "62ece4982e6aefcf4aabbd68", "namespace": "62ece4982e6aefcf4aabbd68", "namespace_real": "shortuuid.main.int_to_string", "real_proj_path": "skorokithakis---shortuuid/", "type": "function", "class_name": null, "function_name": "int_to_string", "contexts_above": "\"\"\"Concise UUID generation.\"\"\"\nimport binascii\nimport math\nimport os\nimport uuid as _uu\n\nfrom typing import List, Optional\n\n", "contexts_below": "\n def string_to_int(string: str, alphabet: List[str]) -> int:\n     \"\"\"\n     Convert a string to a number, using the given alphabet.\n \n     The input is assumed to have the most significant digit first.\n     \"\"\"\n     number = 0\n     alpha_len = len(alphabet)\n     for char in string:\n         number = number * alpha_len + alphabet.index(char)\n     return number\n \n \n class ShortUUID(object):\n     def __init__(self, alphabet: Optional[List[str]] = None) -> None:\n         if alphabet is None:\n             alphabet = list(\n                 \"23456789ABCDEFGHJKLMNPQRSTUVWXYZ\" \"abcdefghijkmnopqrstuvwxyz\"\n             )\n \n         self.set_alphabet(alphabet)\n \n     @property\n     def _length(self) -> int:\n         \"\"\"Return the necessary length to fit the entire UUID given the current alphabet.\"\"\"\n         return int(math.ceil(math.log(2 ** 128, self._alpha_len)))\n \n     def encode(self, uuid: _uu.UUID, pad_length: Optional[int] = None) -> str:\n         \"\"\"\n         Encode a UUID into a string (LSB first) according to the alphabet.\n \n         If leftmost (MSB) bits are 0, the string might be shorter.\n         \"\"\"\n         if not isinstance(uuid, _uu.UUID):\n             raise ValueError(\"Input `uuid` must be a UUID object.\")\n         if pad_length is None:\n             pad_length = self._length\n         return int_to_string(uuid.int, self._alphabet, padding=pad_length)\n \n     def decode(self, string: str, legacy: bool = False) -> _uu.UUID:\n         \"\"\"\n         Decode a string according to the current alphabet into a UUID.\n \n         Raises ValueError when encountering illegal characters or a too-long string.\n \n         If string too short, fills leftmost (MSB) bits with 0.\n \n         Pass `legacy=True` if your UUID was encoded with a ShortUUID version prior to\n         1.0.0.\n         \"\"\"\n         if not isinstance(string, str):\n             raise ValueError(\"Input `string` must be a str.\")\n         if legacy:\n             string = string[::-1]\n         return _uu.UUID(int=string_to_int(string, self._alphabet))\n \n     def uuid(self, name: Optional[str] = None, pad_length: Optional[int] = None) -> str:\n         \"\"\"\n         Generate and return a UUID.\n \n         If the name parameter is provided, set the namespace to the provided\n         name and generate a UUID.\n         \"\"\"\n         if pad_length is None:\n             pad_length = self._length\n \n         # If no name is given, generate a random UUID.\n         if name is None:\n             u = _uu.uuid4()\n         elif name.lower().startswith((\"http://\", \"https://\")):\n             u = _uu.uuid5(_uu.NAMESPACE_URL, name)\n         else:\n             u = _uu.uuid5(_uu.NAMESPACE_DNS, name)\n         return self.encode(u, pad_length)\n \n     def random(self, length: Optional[int] = None) -> str:\n         \"\"\"Generate and return a cryptographically secure short random string of `length`.\"\"\"\n         if length is None:\n             length = self._length\n \n         random_num = int(binascii.b2a_hex(os.urandom(length)), 16)\n         return int_to_string(random_num, self._alphabet, padding=length)[:length]\n \n     def get_alphabet(self) -> str:\n         \"\"\"Return the current alphabet used for new UUIDs.\"\"\"\n         return \"\".join(self._alphabet)\n \n     def set_alphabet(self, alphabet: str) -> None:\n         \"\"\"Set the alphabet to be used for new UUIDs.\"\"\"\n         # Turn the alphabet into a set and sort it to prevent duplicates\n         # and ensure reproducibility.\n         new_alphabet = list(sorted(set(alphabet)))\n         if len(new_alphabet) > 1:\n             self._alphabet = new_alphabet\n             self._alpha_len = len(self._alphabet)\n         else:\n             raise ValueError(\"Alphabet with more than \" \"one unique symbols required.\")\n \n     def encoded_length(self, num_bytes: int = 16) -> int:\n         \"\"\"Return the string length of the shortened UUID.\"\"\"\n         factor = math.log(256) / math.log(self._alpha_len)\n         return int(math.ceil(factor * num_bytes))\n \n \n # For backwards compatibility\n _global_instance = ShortUUID()\n encode = _global_instance.encode\n decode = _global_instance.decode\n uuid = _global_instance.uuid\n random = _global_instance.random\n get_alphabet = _global_instance.get_alphabet\n set_alphabet = _global_instance.set_alphabet\n ", "input_code": "def int_to_string(number: int, alphabet: List[str], padding: Optional[int]=None) -> str:\n\"\"\"\nConvert a number to a string, using the given alphabet.\n\nThe output has the most significant digit first.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def int_to_string(number: int, alphabet: List[str], padding: Optional[int] = None) -> str:\n    \"\"\"\n    Convert a number to a string, using the given alphabet.\n\n    The output has the most significant digit first.\n    \"\"\"\n    output = \"\"\n    alpha_len = len(alphabet)\n    while number:\n        number, digit = divmod(number, alpha_len)\n        output += alphabet[digit]\n    if padding:\n        remainder = max(padding - len(output), 0)\n        output = output + alphabet[0] * remainder\n    return output[::-1]", "signature": "def int_to_string(number: int, alphabet: List[str], padding: Optional[int]=None) -> str:", "completion_path": "shortuuid/main.py"}
{"ce_id": "62ece4982e6aefcf4aabbd69", "namespace": "62ece4982e6aefcf4aabbd69", "namespace_real": "neutron_lib.agent.common.utils._replace_register", "real_proj_path": "openstack---neutron-lib/", "type": "function", "class_name": null, "function_name": "_replace_register", "contexts_above": "# Copyright 2022\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nfrom neutron_lib.agent.common import constants\n\n", "contexts_below": "\n def create_reg_numbers(flow_params):\n     \"\"\"Replace reg_(port|net) values with defined register numbers\"\"\"\n     _replace_register(flow_params, constants.REG_PORT, constants.PORT_REG_NAME)\n     _replace_register(flow_params, constants.REG_NET, constants.NET_REG_NAME)\n     _replace_register(flow_params,\n                       constants.REG_REMOTE_GROUP,\n                       constants.REMOTE_GROUP_REG_NAME)\n     _replace_register(flow_params,\n                       constants.REG_MIN_BW,\n                       constants.MIN_BW_REG_NAME)\n     _replace_register(flow_params,\n                       constants.REG_INGRESS_BW_LIMIT,\n                       constants.INGRESS_BW_LIMIT_REG_NAME)\n ", "input_code": "def _replace_register(flow_params, register_number, register_value):\n\"\"\"\nReplace value from flows to given register number\n\n'register_value' key in dictionary will be replaced by register number\ngiven by 'register_number'\n\n:param flow_params: Dictionary containing defined flows\n:param register_number: The number of register where value will be stored\n:param register_value: Key to be replaced by register number\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _replace_register(flow_params, register_number, register_value):\n    \"\"\"Replace value from flows to given register number\n\n    'register_value' key in dictionary will be replaced by register number\n    given by 'register_number'\n\n    :param flow_params: Dictionary containing defined flows\n    :param register_number: The number of register where value will be stored\n    :param register_value: Key to be replaced by register number\n\n    \"\"\"\n    try:\n        reg_port = flow_params[register_value]\n        del flow_params[register_value]\n        flow_params['reg{:d}'.format(register_number)] = reg_port\n    except KeyError:\n        pass", "signature": "def _replace_register(flow_params, register_number, register_value):", "completion_path": "neutron_lib/agent/common/utils.py"}
{"ce_id": "62ece4982e6aefcf4aabbd6a", "namespace": "62ece4982e6aefcf4aabbd6a", "namespace_real": "release_dashboard.templatetags.rd_extras.replace_dots", "real_proj_path": "sipwise---repoapi/", "type": "function", "class_name": null, "function_name": "replace_dots", "contexts_above": "# Copyright (C) 2022 The Sipwise Team - http://sipwise.com\n#\n# This program is free software: you can redistribute it and/or modify it\n# under the terms of the GNU General Public License as published by the Free\n# Software Foundation, either version 3 of the License, or (at your option)\n# any later version.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n# more details.\n#\n# You should have received a copy of the GNU General Public License along\n# with this program.  If not, see <http://www.gnu.org/licenses/>.\nfrom django import template\nfrom django.template.defaultfilters import stringfilter\n\nregister = template.Library()\n\n\n@register.filter\n@stringfilter", "contexts_below": "", "input_code": "@register.filter\n@stringfilter\ndef replace_dots(value, arg):\n\"\"\"\nReplaces all values of '.' to arg from the given string\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def replace_dots(value, arg):\n    \"\"\"Replaces all values of '.' to arg from the given string\"\"\"\n    return value.replace(\".\", arg)", "signature": "@register.filter\n@stringfilter\ndef replace_dots(value, arg):", "completion_path": "release_dashboard/templatetags/rd_extras.py"}
{"ce_id": "62ece4982e6aefcf4aabbd6b", "namespace": "62ece4982e6aefcf4aabbd6b", "namespace_real": "rows.utils.__init__.subclasses", "real_proj_path": "turicas---rows/", "type": "function", "class_name": null, "function_name": "subclasses", "contexts_above": "# coding: utf-8\n\n# Copyright 2014-2020 \u00c1lvaro Justen <https://github.com/turicas/rows/>\n\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU Lesser General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#    (at your option) any later version.\n\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU Lesser General Public License for more details.\n\n#    You should have received a copy of the GNU Lesser General Public License\n#    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import unicode_literals\n\nimport cgi\nimport csv\nimport gzip\nimport io\nimport mimetypes\nimport os\nimport re\nimport shlex\nimport sqlite3\nimport subprocess\nimport tempfile\nfrom collections import OrderedDict\nfrom dataclasses import dataclass\nfrom itertools import islice\nfrom pathlib import Path\nfrom textwrap import dedent\n\nimport six\n\ntry:\n    import requests\n    from requests.adapters import HTTPAdapter\n    from requests.packages.urllib3.util.retry import Retry\nexcept ImportError:\n    requests = None\ntry:\n    from tqdm import tqdm\nexcept ImportError:\n    tqdm = None\n\nimport rows\nfrom rows.plugins.utils import make_header\n\ntry:\n    import lzma\nexcept ImportError:\n    lzma = None\ntry:\n    import bz2\nexcept ImportError:\n    bz2 = None\n\ntry:\n    from urlparse import urlparse  # Python 2\nexcept ImportError:\n    from urllib.parse import urlparse  # Python 3\n\ntry:\n    import magic\nexcept (ImportError, TypeError):\n    magic = None\nelse:\n    if not hasattr(magic, \"detect_from_content\"):\n        # This is not the file-magic library\n        magic = None\n\nif requests:\n    chardet = requests.compat.chardet\n    try:\n        import urllib3\n    except ImportError:\n        from requests.packages import urllib3\n    else:\n        try:\n            urllib3.disable_warnings()\n        except AttributeError:\n            # old versions of urllib3 or requests\n            pass\nelse:\n    chardet = None\n\n\n# TODO: should get this information from the plugins\nCOMPRESSED_EXTENSIONS = (\"gz\", \"xz\", \"bz2\")\nTEXT_PLAIN = {\n    \"txt\": \"text/txt\",\n    \"text\": \"text/txt\",\n    \"csv\": \"text/csv\",\n    \"json\": \"application/json\",\n}\nOCTET_STREAM = {\n    \"microsoft ooxml\": \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n    \"par archive data\": \"application/parquet\",\n}\nFILE_EXTENSIONS = {\n    \"csv\": \"text/csv\",\n    \"db\": \"application/x-sqlite3\",\n    \"htm\": \"text/html\",\n    \"html\": \"text/html\",\n    \"json\": \"application/json\",\n    \"ods\": \"application/vnd.oasis.opendocument.spreadsheet\",\n    \"parquet\": \"application/parquet\",\n    \"sqlite\": \"application/x-sqlite3\",\n    \"text\": \"text/txt\",\n    \"tsv\": \"text/csv\",\n    \"txt\": \"text/txt\",\n    \"xls\": \"application/vnd.ms-excel\",\n    \"xlsx\": \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n    \"pdf\": \"application/pdf\",\n}\nMIME_TYPE_TO_PLUGIN_NAME = {\n    \"application/json\": \"json\",\n    \"application/parquet\": \"parquet\",\n    \"application/vnd.ms-excel\": \"xls\",\n    \"application/vnd.oasis.opendocument.spreadsheet\": \"ods\",\n    \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\": \"xlsx\",\n    \"application/x-sqlite3\": \"sqlite\",\n    \"text/csv\": \"csv\",\n    \"text/html\": \"html\",\n    \"text/txt\": \"txt\",\n    \"application/pdf\": \"pdf\",\n}\nregexp_sizes = re.compile(\"([0-9,.]+ [a-zA-Z]+B)\")\nMULTIPLIERS = {\"B\": 1, \"KiB\": 1024, \"MiB\": 1024 ** 2, \"GiB\": 1024 ** 3}\n\n", "contexts_below": "\n class ProgressBar:\n     def __init__(self, prefix, pre_prefix=\"\", total=None, unit=\" rows\"):\n         self.prefix = prefix\n         self.progress = tqdm(\n             desc=pre_prefix, total=total, unit=unit, unit_scale=True, dynamic_ncols=True\n         )\n         self.started = False\n \n     def __enter__(self):\n         return self\n \n     def __exit__(self, exc_type, exc_value, traceback):\n         self.close()\n \n     @property\n     def description(self):\n         return self.progress.desc\n \n     @description.setter\n     def description(self, value):\n         self.progress.desc = value\n         self.progress.refresh()\n \n     @property\n     def total(self):\n         return self.progress.total\n \n     @total.setter\n     def total(self, value):\n         self.progress.total = value\n         self.progress.refresh()\n \n     def update(self, last_done=1, total_done=None):\n         if not last_done and not total_done:\n             raise ValueError(\"Either last_done or total_done must be specified\")\n \n         if not self.started:\n             self.started = True\n             self.progress.desc = self.prefix\n             self.progress.unpause()\n \n         if last_done:\n             self.progress.n += last_done\n         else:\n             self.progress.n = total_done\n         self.progress.refresh()\n \n     def close(self):\n         self.progress.close()\n \n \n @dataclass\n class Source(object):\n     \"Define a source to import a `rows.Table`\"\n \n     uri: (str, Path)\n     plugin_name: str\n     encoding: str\n     fobj: object = None\n     compressed: bool = None\n     should_delete: bool = False\n     should_close: bool = False\n     is_file: bool = None\n     local: bool = None\n \n     @classmethod\n     def from_file(\n         cls,\n         filename_or_fobj,\n         plugin_name=None,\n         encoding=None,\n         mode=\"rb\",\n         compressed=None,\n         should_delete=False,\n         should_close=None,\n         is_file=True,\n         local=True,\n     ):\n         \"\"\"Create a `Source` from a filename or fobj\"\"\"\n \n         if isinstance(filename_or_fobj, Source):\n             return filename_or_fobj\n \n         elif isinstance(filename_or_fobj, (six.binary_type, six.text_type, Path)):\n             fobj = open_compressed(filename_or_fobj, mode=mode)\n             filename = filename_or_fobj\n             should_close = True if should_close is None else should_close\n \n         else:  # Don't know exactly what is, assume file-like object\n             fobj = filename_or_fobj\n             filename = getattr(fobj, \"name\", None)\n             if not isinstance(\n                 filename, (six.binary_type, six.text_type)\n             ):  # BytesIO object\n                 filename = None\n             should_close = False if should_close is None else should_close\n \n         if is_file and local and filename and not isinstance(filename, Path):\n             filename = Path(filename)\n \n         return Source(\n             compressed=compressed,\n             encoding=encoding,\n             fobj=fobj,\n             is_file=is_file,\n             local=local,\n             plugin_name=plugin_name,\n             should_close=should_close,\n             should_delete=should_delete,\n             uri=filename,\n         )\n \n \n def plugin_name_by_uri(uri):\n     \"Return the plugin name based on the URI\"\n \n     # TODO: parse URIs like 'sqlite://' also\n     # TODO: integrate this function with detect_source\n \n     parsed = urlparse(uri)\n     if parsed.scheme:\n         if parsed.scheme == \"sqlite\":\n             return \"sqlite\"\n         elif parsed.scheme == \"postgres\":\n             return \"postgresql\"\n \n     basename = os.path.basename(parsed.path)\n     if not basename.strip():\n         raise RuntimeError(\"Could not identify file format.\")\n \n     extension = basename.split(\".\")[-1].lower()\n     if extension in COMPRESSED_EXTENSIONS:\n         extension = basename.split(\".\")[-2].lower()\n \n     plugin_name = extension\n     if extension in FILE_EXTENSIONS:\n         plugin_name = MIME_TYPE_TO_PLUGIN_NAME[FILE_EXTENSIONS[plugin_name]]\n \n     return plugin_name\n \n \n def extension_by_source(source, mime_type):\n     \"Return the file extension used by this plugin\"\n \n     # TODO: should get this information from the plugin\n     extension = source.plugin_name\n     if extension:\n         return extension\n \n     if mime_type:\n         return mime_type.split(\"/\")[-1]\n \n \n def normalize_mime_type(mime_type, mime_name, file_extension):\n \n     file_extension = file_extension.lower() if file_extension else \"\"\n     mime_name = mime_name.lower() if mime_name else \"\"\n     mime_type = mime_type.lower() if mime_type else \"\"\n \n     if mime_type == \"text/plain\" and file_extension in TEXT_PLAIN:\n         return TEXT_PLAIN[file_extension]\n \n     elif mime_type == \"application/octet-stream\" and mime_name in OCTET_STREAM:\n         return OCTET_STREAM[mime_name]\n \n     elif file_extension in FILE_EXTENSIONS:\n         return FILE_EXTENSIONS[file_extension]\n \n     else:\n         return mime_type\n \n \n def plugin_name_by_mime_type(mime_type, mime_name, file_extension):\n     \"Return the plugin name based on the MIME type\"\n \n     return MIME_TYPE_TO_PLUGIN_NAME.get(\n         normalize_mime_type(mime_type, mime_name, file_extension), None\n     )\n \n \n def detect_local_source(path, content, mime_type=None, encoding=None):\n \n     # TODO: may add sample_size\n \n     filename = os.path.basename(path)\n     parts = filename.split(\".\")\n     extension = parts[-1].lower() if len(parts) > 1 else None\n     if extension in COMPRESSED_EXTENSIONS:\n         extension = parts[-2].lower() if len(parts) > 2 else None\n \n     if magic is not None:\n         detected = magic.detect_from_content(content)\n         encoding = detected.encoding or encoding\n         mime_name = detected.name\n         mime_type = detected.mime_type or mime_type\n \n     else:\n         if chardet and not encoding:\n             encoding = chardet.detect(content)[\"encoding\"] or encoding\n         mime_name = None\n         mime_type = mime_type or mimetypes.guess_type(filename)[0]\n \n     plugin_name = plugin_name_by_mime_type(mime_type, mime_name, extension)\n     if encoding == \"binary\":\n         encoding = None\n \n     return Source(uri=path, plugin_name=plugin_name, encoding=encoding)\n \n \n def local_file(path, sample_size=1048576):\n     # TODO: may change sample_size\n     if path.split(\".\")[-1].lower() in COMPRESSED_EXTENSIONS:\n         compressed = True\n         fobj = open_compressed(path, mode=\"rb\")\n         content = fobj.read(sample_size)\n         fobj.close()\n     else:\n         compressed = False\n         with open(path, \"rb\") as fobj:\n             content = fobj.read(sample_size)\n \n     source = detect_local_source(path, content, mime_type=None, encoding=None)\n \n     return Source(\n         uri=path,\n         plugin_name=source.plugin_name,\n         encoding=source.encoding,\n         compressed=compressed,\n         should_delete=False,\n         is_file=True,\n         local=True,\n     )\n \n \n def download_file(\n     uri,\n     filename=None,\n     verify_ssl=True,\n     timeout=5,\n     progress=False,\n     detect=False,\n     chunk_size=8192,\n     sample_size=1048576,\n     retries=3,\n     progress_pattern=\"Downloading file\",\n ):\n     # TODO: add ability to continue download\n \n     session = requests.Session()\n     retry_adapter = HTTPAdapter(max_retries=Retry(total=retries, backoff_factor=1))\n     session.mount(\"http://\", retry_adapter)\n     session.mount(\"https://\", retry_adapter)\n \n     response = session.get(\n         uri,\n         verify=verify_ssl,\n         timeout=timeout,\n         stream=True,\n         headers={\"user-agent\": \"rows-{}\".format(rows.__version__)},\n     )\n     if not response.ok:\n         raise RuntimeError(\"HTTP response: {}\".format(response.status_code))\n \n     # Get data from headers (if available) to help plugin + encoding detection\n     real_filename, encoding, mime_type = uri, None, None\n     headers = response.headers\n     if \"content-type\" in headers:\n         mime_type, options = cgi.parse_header(headers[\"content-type\"])\n         encoding = options.get(\"charset\", encoding)\n     if \"content-disposition\" in headers:\n         _, options = cgi.parse_header(headers[\"content-disposition\"])\n         real_filename = options.get(\"filename\", real_filename)\n \n     if filename is None:\n         tmp = tempfile.NamedTemporaryFile(delete=False)\n         fobj = open_compressed(tmp.name, mode=\"wb\")\n     else:\n         fobj = open_compressed(filename, mode=\"wb\")\n \n     if progress:\n         total = response.headers.get(\"content-length\", None)\n         total = int(total) if total else None\n         progress_bar = ProgressBar(\n             prefix=progress_pattern.format(\n                 uri=uri,\n                 filename=Path(fobj.name),\n                 mime_type=mime_type,\n                 encoding=encoding,\n             ),\n             total=total,\n             unit=\"bytes\",\n         )\n \n     sample_data = b\"\"\n     for data in response.iter_content(chunk_size=chunk_size):\n         fobj.write(data)\n         if detect and len(sample_data) <= sample_size:\n             sample_data += data\n         if progress:\n             progress_bar.update(len(data))\n     fobj.close()\n     if progress:\n         progress_bar.close()\n \n     # Detect file type and rename temporary file to have the correct extension\n     if detect:\n         # TODO: check if will work for compressed files\n         source = detect_local_source(real_filename, sample_data, mime_type, encoding)\n         extension = extension_by_source(source, mime_type)\n         plugin_name = source.plugin_name\n         encoding = source.encoding\n     else:\n         extension, plugin_name, encoding = None, None, None\n         if mime_type:\n             extension = mime_type.split(\"/\")[-1]\n \n     if filename is None:\n         filename = tmp.name\n         if extension:\n             filename += \".\" + extension\n         os.rename(tmp.name, filename)\n \n     return Source(\n         uri=filename,\n         plugin_name=plugin_name,\n         encoding=encoding,\n         should_delete=True,\n         is_file=True,\n         local=False,\n     )\n \n \n def detect_source(uri, verify_ssl, progress, timeout=5):\n     \"\"\"Return a `rows.Source` with information for a given URI\n \n     If URI starts with \"http\" or \"https\" the file will be downloaded.\n \n     This function should only be used if the URI already exists because it's\n     going to download/open the file to detect its encoding and MIME type.\n     \"\"\"\n \n     # TODO: should also supporte other schemes, like file://, sqlite:// etc.\n \n     if uri.lower().startswith(\"http://\") or uri.lower().startswith(\"https://\"):\n         return download_file(\n             uri, verify_ssl=verify_ssl, timeout=timeout, progress=progress, detect=True\n         )\n \n     elif uri.startswith(\"postgres://\"):\n         return Source(\n             should_delete=False,\n             encoding=None,\n             plugin_name=\"postgresql\",\n             uri=uri,\n             is_file=False,\n             local=None,\n         )\n     else:\n         return local_file(uri)\n \n \n def import_from_source(source, default_encoding, *args, **kwargs):\n     \"Import data described in a `rows.Source` into a `rows.Table`\"\n \n     # TODO: test open_compressed\n     plugin_name = source.plugin_name\n     kwargs[\"encoding\"] = (\n         kwargs.get(\"encoding\", None) or source.encoding or default_encoding\n     )\n \n     try:\n         import_function = getattr(rows, \"import_from_{}\".format(plugin_name))\n     except AttributeError:\n         raise ValueError('Plugin (import) \"{}\" not found'.format(plugin_name))\n \n     table = import_function(source.uri, *args, **kwargs)\n \n     return table\n \n \n def import_from_uri(\n     uri, default_encoding=\"utf-8\", verify_ssl=True, progress=False, *args, **kwargs\n ):\n     \"Given an URI, detects plugin and encoding and imports into a `rows.Table`\"\n \n     # TODO: support '-' also\n     # TODO: (optimization) if `kwargs.get('encoding', None) is not None` we can\n     #       skip encoding detection.\n     source = detect_source(uri, verify_ssl=verify_ssl, progress=progress)\n     return import_from_source(source, default_encoding, *args, **kwargs)\n \n \n def export_to_uri(table, uri, *args, **kwargs):\n     \"Given a `rows.Table` and an URI, detects plugin (from URI) and exports\"\n \n     # TODO: support '-' also\n     plugin_name = plugin_name_by_uri(uri)\n \n     try:\n         export_function = getattr(rows, \"export_to_{}\".format(plugin_name))\n     except AttributeError:\n         raise ValueError('Plugin (export) \"{}\" not found'.format(plugin_name))\n \n     return export_function(table, uri, *args, **kwargs)\n \n \n # TODO: check https://docs.python.org/3.7/library/fileinput.html\n def open_compressed(\n     filename,\n     mode=\"r\",\n     buffering=-1,\n     encoding=None,\n     errors=None,\n     newline=None,\n     closefd=True,\n     opener=None,\n ):\n     \"\"\"Return a text-based file object from a filename, even if compressed\n \n     NOTE: if the file is compressed, options like `buffering` are valid to the\n     compressed file-object (not the uncompressed file-object returned).\n     \"\"\"\n \n     binary_mode = \"b\" in mode\n     if not binary_mode and \"t\" not in mode:\n         # For some reason, passing only mode='r' to bzip2 is equivalent\n         # to 'rb', not 'rt', so we force it here.\n         mode += \"t\"\n     if binary_mode and encoding:\n         raise ValueError(\"encoding should not be specified in binary mode\")\n \n     extension = str(filename).split(\".\")[-1].lower()\n     mode_binary = mode.replace(\"t\", \"b\")\n     get_fobj_binary = lambda: open(\n         filename,\n         mode=mode_binary,\n         buffering=buffering,\n         errors=errors,\n         newline=newline,\n         closefd=closefd,\n         opener=opener,\n     )\n     get_fobj_text = lambda: open(\n         filename,\n         mode=mode,\n         buffering=buffering,\n         encoding=encoding,\n         errors=errors,\n         newline=newline,\n         closefd=closefd,\n         opener=opener,\n     )\n     known_extensions = (\"xz\", \"gz\", \"bz2\")\n \n     if extension not in known_extensions:  # No compression\n         if binary_mode:\n             return get_fobj_binary()\n         else:\n             return get_fobj_text()\n \n     elif extension == \"xz\":\n         if lzma is None:\n             raise ModuleNotFoundError(\"lzma support is not installed\")\n         fobj_binary = lzma.LZMAFile(get_fobj_binary(), mode=mode_binary)\n \n     elif extension == \"gz\":\n         fobj_binary = gzip.GzipFile(fileobj=get_fobj_binary(), mode=mode_binary)\n \n     elif extension == \"bz2\":\n         if bz2 is None:\n             raise ModuleNotFoundError(\"bzip2 support is not installed\")\n         fobj_binary = bz2.BZ2File(get_fobj_binary(), mode=mode_binary)\n \n     if binary_mode:\n         return fobj_binary\n     else:\n         return io.TextIOWrapper(fobj_binary, encoding=encoding)\n \n \n def csv_to_sqlite(\n     input_filename,\n     output_filename,\n     samples=None,\n     dialect=None,\n     batch_size=10000,\n     encoding=\"utf-8\",\n     callback=None,\n     force_types=None,\n     chunk_size=8388608,\n     table_name=\"table1\",\n     schema=None,\n ):\n     \"Export a CSV file to SQLite, based on field type detection from samples\"\n \n     # TODO: automatically detect encoding if encoding == `None`\n     # TODO: should be able to specify fields\n     # TODO: if schema is provided and the names are in uppercase, this function\n     #       will fail\n \n     if dialect is None:  # Get a sample to detect dialect\n         fobj = open_compressed(input_filename, mode=\"rb\")\n         sample = fobj.read(chunk_size)\n         fobj.close()\n         dialect = rows.plugins.csv.discover_dialect(sample, encoding=encoding)\n     elif isinstance(dialect, six.text_type):\n         dialect = csv.get_dialect(dialect)\n \n     if schema is None:  # Identify data types\n         fobj = open_compressed(input_filename, encoding=encoding)\n         data = list(islice(csv.DictReader(fobj, dialect=dialect), samples))\n         fobj.close()\n         schema = rows.import_from_dicts(data).fields\n         if force_types is not None:\n             schema.update(force_types)\n \n     # Create lazy table object to be converted\n     # TODO: this lazyness feature will be incorported into the library soon so\n     #       we can call here `rows.import_from_csv` instead of `csv.reader`.\n     fobj = open_compressed(input_filename, encoding=encoding)\n     csv_reader = csv.reader(fobj, dialect=dialect)\n     header = make_header(next(csv_reader))  # skip header\n     table = rows.Table(fields=OrderedDict([(field, schema[field]) for field in header]))\n     table._rows = csv_reader\n \n     # Export to SQLite\n     result = rows.export_to_sqlite(\n         table,\n         output_filename,\n         table_name=table_name,\n         batch_size=batch_size,\n         callback=callback,\n     )\n     fobj.close()\n     return result\n \n \n def sqlite_to_csv(\n     input_filename,\n     table_name,\n     output_filename,\n     dialect=csv.excel,\n     batch_size=10000,\n     encoding=\"utf-8\",\n     callback=None,\n     query=None,\n ):\n     \"\"\"Export a table inside a SQLite database to CSV\"\"\"\n \n     # TODO: should be able to specify fields\n     # TODO: should be able to specify custom query\n \n     if isinstance(dialect, six.text_type):\n         dialect = csv.get_dialect(dialect)\n \n     if query is None:\n         query = \"SELECT * FROM {}\".format(table_name)\n     connection = sqlite3.Connection(input_filename)\n     cursor = connection.cursor()\n     result = cursor.execute(query)\n     header = [item[0] for item in cursor.description]\n     fobj = open_compressed(output_filename, mode=\"w\", encoding=encoding)\n     writer = csv.writer(fobj, dialect=dialect)\n     writer.writerow(header)\n     total_written = 0\n     for batch in rows.plugins.utils.ipartition(result, batch_size):\n         writer.writerows(batch)\n         written = len(batch)\n         total_written += written\n         if callback:\n             callback(written, total_written)\n     fobj.close()\n \n \n class CsvLazyDictWriter:\n     \"\"\"Lazy CSV dict writer, with compressed output option\n \n     This class is almost the same as `csv.DictWriter` with the following\n     differences:\n \n     - You don't need to pass `fieldnames` (it's extracted on the first\n       `.writerow` call);\n     - You can pass either a filename or a fobj (like `sys.stdout`);\n     - If passing a filename, it can end with `.gz`, `.xz` or `.bz2` and the\n       output file will be automatically compressed.\n     \"\"\"\n \n     def __init__(self, filename_or_fobj, encoding=\"utf-8\", *args, **kwargs):\n         self.writer = None\n         self.filename_or_fobj = filename_or_fobj\n         self.encoding = encoding\n         self._fobj = None\n         self.writer_args = args\n         self.writer_kwargs = kwargs\n         self.writer_kwargs[\"lineterminator\"] = kwargs.get(\"lineterminator\", \"\\n\")\n         # TODO: check if it should be the same in other OSes\n \n     def __enter__(self):\n         return self\n \n     def __exit__(self, exc_type, exc_value, traceback):\n         self.close()\n \n     @property\n     def fobj(self):\n         if self._fobj is None:\n             if getattr(self.filename_or_fobj, \"read\", None) is not None:\n                 self._fobj = self.filename_or_fobj\n             else:\n                 self._fobj = open_compressed(\n                     self.filename_or_fobj, mode=\"w\", encoding=self.encoding\n                 )\n \n         return self._fobj\n \n     def writerow(self, row):\n         if self.writer is None:\n             self.writer = csv.DictWriter(\n                 self.fobj,\n                 fieldnames=list(row.keys()),\n                 *self.writer_args,\n                 **self.writer_kwargs\n             )\n             self.writer.writeheader()\n \n         self.writerow = self.writer.writerow\n         return self.writerow(row)\n \n     def __del__(self):\n         self.close()\n \n     def close(self):\n         if self._fobj and not self._fobj.closed:\n             self._fobj.close()\n \n \n def execute_command(command):\n     \"\"\"Execute a command and return its output\"\"\"\n \n     command = shlex.split(command)\n     try:\n         process = subprocess.Popen(\n             command,\n             stdin=subprocess.PIPE,\n             stdout=subprocess.PIPE,\n             stderr=subprocess.PIPE,\n         )\n     except FileNotFoundError:\n         raise RuntimeError(\"Command not found: {}\".format(repr(command)))\n     process.wait()\n     # TODO: may use another codec to decode\n     if process.returncode > 0:\n         stderr = process.stderr.read().decode(\"utf-8\")\n         raise ValueError(\"Error executing command: {}\".format(repr(stderr)))\n     data = process.stdout.read().decode(\"utf-8\")\n     process.stdin.close()\n     process.stdout.close()\n     process.stderr.close()\n     process.wait()\n     return data\n \n \n def uncompressed_size(filename):\n     \"\"\"Return the uncompressed size for a file by executing commands\n \n     Note: due to a limitation in gzip format, uncompressed files greather than\n     4GiB will have a wrong value.\n     \"\"\"\n \n     quoted_filename = shlex.quote(filename)\n \n     # TODO: get filetype from file-magic, if available\n     if str(filename).lower().endswith(\".xz\"):\n         output = execute_command('xz --list \"{}\"'.format(quoted_filename))\n         compressed, uncompressed = regexp_sizes.findall(output)\n         value, unit = uncompressed.split()\n         value = float(value.replace(\",\", \"\"))\n         return int(value * MULTIPLIERS[unit])\n \n     elif str(filename).lower().endswith(\".gz\"):\n         # XXX: gzip only uses 32 bits to store uncompressed size, so if the\n         # uncompressed size is greater than 4GiB, the value returned will be\n         # incorrect.\n         output = execute_command('gzip --list \"{}\"'.format(quoted_filename))\n         lines = [line.split() for line in output.splitlines()]\n         header, data = lines[0], lines[1]\n         gzip_data = dict(zip(header, data))\n         return int(gzip_data[\"uncompressed\"])\n \n     else:\n         raise ValueError('Unrecognized file type for \"{}\".'.format(filename))\n \n \n def generate_schema(table, export_fields, output_format):\n     \"\"\"Generate table schema for a specific output format and write\n \n     Current supported output formats: 'txt', 'sql' and 'django'.\n     The table name and all fields names pass for a slugifying process (table\n     name is taken from file name).\n     \"\"\"\n \n     if output_format in (\"csv\", \"txt\"):\n         from rows import plugins\n \n         data = [\n             {\n                 \"field_name\": fieldname,\n                 \"field_type\": fieldtype.__name__.replace(\"Field\", \"\").lower(),\n             }\n             for fieldname, fieldtype in table.fields.items()\n             if fieldname in export_fields\n         ]\n         table = plugins.dicts.import_from_dicts(\n             data, import_fields=[\"field_name\", \"field_type\"]\n         )\n         if output_format == \"txt\":\n             return plugins.txt.export_to_txt(table)\n         elif output_format == \"csv\":\n             return plugins.csv.export_to_csv(table).decode(\"utf-8\")\n \n     elif output_format == \"sql\":\n         # TODO: may use dict from rows.plugins.sqlite or postgresql\n         sql_fields = {\n             rows.fields.BinaryField: \"BLOB\",\n             rows.fields.BoolField: \"BOOL\",\n             rows.fields.IntegerField: \"INT\",\n             rows.fields.FloatField: \"FLOAT\",\n             rows.fields.PercentField: \"FLOAT\",\n             rows.fields.DateField: \"DATE\",\n             rows.fields.DatetimeField: \"DATETIME\",\n             rows.fields.TextField: \"TEXT\",\n             rows.fields.DecimalField: \"FLOAT\",\n             rows.fields.EmailField: \"TEXT\",\n             rows.fields.JSONField: \"TEXT\",\n         }\n         fields = [\n             \"    {} {}\".format(field_name, sql_fields[field_type])\n             for field_name, field_type in table.fields.items()\n             if field_name in export_fields\n         ]\n         sql = (\n             dedent(\n                 \"\"\"\n                 CREATE TABLE IF NOT EXISTS {name} (\n                 {fields}\n                 );\n                 \"\"\"\n             )\n             .strip()\n             .format(name=table.name, fields=\",\\n\".join(fields))\n             + \"\\n\"\n         )\n         return sql\n \n     elif output_format == \"django\":\n         django_fields = {\n             rows.fields.BinaryField: \"BinaryField\",\n             rows.fields.BoolField: \"BooleanField\",\n             rows.fields.IntegerField: \"IntegerField\",\n             rows.fields.FloatField: \"FloatField\",\n             rows.fields.PercentField: \"DecimalField\",\n             rows.fields.DateField: \"DateField\",\n             rows.fields.DatetimeField: \"DateTimeField\",\n             rows.fields.TextField: \"TextField\",\n             rows.fields.DecimalField: \"DecimalField\",\n             rows.fields.EmailField: \"EmailField\",\n             rows.fields.JSONField: \"JSONField\",\n         }\n         table_name = \"\".join(word.capitalize() for word in table.name.split(\"_\"))\n \n         lines = [\"from django.db import models\"]\n         if rows.fields.JSONField in [\n             table.fields[field_name] for field_name in export_fields\n         ]:\n             lines.append(\"from django.contrib.postgres.fields import JSONField\")\n         lines.append(\"\")\n \n         lines.append(\"class {}(models.Model):\".format(table_name))\n         for field_name, field_type in table.fields.items():\n             if field_name not in export_fields:\n                 continue\n \n             if field_type is not rows.fields.JSONField:\n                 django_type = \"models.{}()\".format(django_fields[field_type])\n             else:\n                 django_type = \"JSONField()\"\n             lines.append(\"    {} = {}\".format(field_name, django_type))\n \n         result = \"\\n\".join(lines) + \"\\n\"\n         return result\n \n \n def load_schema(filename, context=None):\n     \"\"\"Load schema from file in any of the supported formats\n \n     The table must have at least the fields `field_name` and `field_type`.\n     `context` is a `dict` with field_type as key pointing to field class, like:\n         {\"text\": rows.fields.TextField, \"value\": MyCustomField}\n     \"\"\"\n     # TODO: load_schema must support Path objects\n \n     table = import_from_uri(filename)\n     field_names = table.field_names\n     assert \"field_name\" in field_names\n     assert \"field_type\" in field_names\n \n     context = context or {\n         key.replace(\"Field\", \"\").lower(): getattr(rows.fields, key)\n         for key in dir(rows.fields)\n         if \"Field\" in key and key != \"Field\"\n     }\n     return OrderedDict([(row.field_name, context[row.field_type]) for row in table])\n \n \n def scale_number(n, divider=1000, suffix=None, multipliers=\"KMGTPEZ\", decimal_places=2):\n     suffix = suffix if suffix is not None else \"\"\n     count = -1\n     while n >= divider:\n         n /= divider\n         count += 1\n     multiplier = multipliers[count] if count > -1 else \"\"\n     if not multiplier:\n         return str(n) + suffix\n     else:\n         fmt_str = \"{{n:.{}f}}{{multiplier}}{{suffix}}\".format(decimal_places)\n         return fmt_str.format(n=n, multiplier=multiplier, suffix=suffix)\n \n \n class NotNullWrapper(io.BufferedReader):\n     \"\"\"BufferedReader which removes NUL (`\\x00`) from source stream\"\"\"\n \n     def read(self, n):\n         return super().read(n).replace(b\"\\x00\", b\"\")\n \n     def readline(self):\n         return super().readline().replace(b\"\\x00\", b\"\")\n \n \n # Shortcuts and legacy functions\n csv2sqlite = csv_to_sqlite\n sqlite2csv = sqlite_to_csv\n \n \n def pgimport(filename, *args, **kwargs):\n     # TODO: add warning (will remove this function from here in the future)\n     from rows.plugins.postgresql import pgimport as original_function\n \n     return original_function(filename_or_fobj=filename, *args, **kwargs)\n \n \n def pgexport(*args, **kwargs):\n     # TODO: add warning (will remove this function from here in the future)\n     from rows.plugins.postgresql import pgexport as original_function\n \n     return original_function(*args, **kwargs)\n \n \n def get_psql_command(*args, **kwargs):\n     # TODO: add warning (will remove this function from here in the future)\n     from rows.plugins.postgresql import get_psql_command as original_function\n \n     return original_function(*args, **kwargs)\n \n \n def get_psql_copy_command(*args, **kwargs):\n     # TODO: add warning (will remove this function from here in the future)\n     from rows.plugins.postgresql import get_psql_copy_command as original_function\n \n     return original_function(*args, **kwargs)\n \n \n def pg_create_table_sql(*args, **kwargs):\n     # TODO: add warning (will remove this function from here in the future)\n     from rows.plugins.postgresql import pg_create_table_sql as original_function\n \n     return original_function(*args, **kwargs)\n \n \n def pg_execute_sql(*args, **kwargs):\n     # TODO: add warning (will remove this function from here in the future)\n     from rows.plugins.postgresql import pg_execute_sql as original_function\n \n     return original_function(*args, **kwargs)\n ", "input_code": "def subclasses(cls):\n\"\"\"\nReturn all subclasses of a class, recursively\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def subclasses(cls):\n    \"\"\"Return all subclasses of a class, recursively\"\"\"\n    children = cls.__subclasses__()\n    return set(children).union(\n        set(grandchild for child in children for grandchild in subclasses(child))\n    )", "signature": "def subclasses(cls):", "completion_path": "rows/utils/__init__.py"}
{"ce_id": "62ece4982e6aefcf4aabbd6d", "namespace": "62ece4982e6aefcf4aabbd6d", "namespace_real": "shortuuid.main.string_to_int", "real_proj_path": "skorokithakis---shortuuid/", "type": "function", "class_name": null, "function_name": "string_to_int", "contexts_above": "\"\"\"Concise UUID generation.\"\"\"\nimport binascii\nimport math\nimport os\nimport uuid as _uu\n\nfrom typing import List, Optional\n\n\ndef int_to_string(number: int, alphabet: List[str], padding: Optional[int] = None) -> str:\n    \"\"\"\n    Convert a number to a string, using the given alphabet.\n\n    The output has the most significant digit first.\n    \"\"\"\n    output = \"\"\n    alpha_len = len(alphabet)\n    while number:\n        number, digit = divmod(number, alpha_len)\n        output += alphabet[digit]\n    if padding:\n        remainder = max(padding - len(output), 0)\n        output = output + alphabet[0] * remainder\n    return output[::-1]\n\n", "contexts_below": "\n class ShortUUID(object):\n     def __init__(self, alphabet: Optional[List[str]] = None) -> None:\n         if alphabet is None:\n             alphabet = list(\n                 \"23456789ABCDEFGHJKLMNPQRSTUVWXYZ\" \"abcdefghijkmnopqrstuvwxyz\"\n             )\n \n         self.set_alphabet(alphabet)\n \n     @property\n     def _length(self) -> int:\n         \"\"\"Return the necessary length to fit the entire UUID given the current alphabet.\"\"\"\n         return int(math.ceil(math.log(2 ** 128, self._alpha_len)))\n \n     def encode(self, uuid: _uu.UUID, pad_length: Optional[int] = None) -> str:\n         \"\"\"\n         Encode a UUID into a string (LSB first) according to the alphabet.\n \n         If leftmost (MSB) bits are 0, the string might be shorter.\n         \"\"\"\n         if not isinstance(uuid, _uu.UUID):\n             raise ValueError(\"Input `uuid` must be a UUID object.\")\n         if pad_length is None:\n             pad_length = self._length\n         return int_to_string(uuid.int, self._alphabet, padding=pad_length)\n \n     def decode(self, string: str, legacy: bool = False) -> _uu.UUID:\n         \"\"\"\n         Decode a string according to the current alphabet into a UUID.\n \n         Raises ValueError when encountering illegal characters or a too-long string.\n \n         If string too short, fills leftmost (MSB) bits with 0.\n \n         Pass `legacy=True` if your UUID was encoded with a ShortUUID version prior to\n         1.0.0.\n         \"\"\"\n         if not isinstance(string, str):\n             raise ValueError(\"Input `string` must be a str.\")\n         if legacy:\n             string = string[::-1]\n         return _uu.UUID(int=string_to_int(string, self._alphabet))\n \n     def uuid(self, name: Optional[str] = None, pad_length: Optional[int] = None) -> str:\n         \"\"\"\n         Generate and return a UUID.\n \n         If the name parameter is provided, set the namespace to the provided\n         name and generate a UUID.\n         \"\"\"\n         if pad_length is None:\n             pad_length = self._length\n \n         # If no name is given, generate a random UUID.\n         if name is None:\n             u = _uu.uuid4()\n         elif name.lower().startswith((\"http://\", \"https://\")):\n             u = _uu.uuid5(_uu.NAMESPACE_URL, name)\n         else:\n             u = _uu.uuid5(_uu.NAMESPACE_DNS, name)\n         return self.encode(u, pad_length)\n \n     def random(self, length: Optional[int] = None) -> str:\n         \"\"\"Generate and return a cryptographically secure short random string of `length`.\"\"\"\n         if length is None:\n             length = self._length\n \n         random_num = int(binascii.b2a_hex(os.urandom(length)), 16)\n         return int_to_string(random_num, self._alphabet, padding=length)[:length]\n \n     def get_alphabet(self) -> str:\n         \"\"\"Return the current alphabet used for new UUIDs.\"\"\"\n         return \"\".join(self._alphabet)\n \n     def set_alphabet(self, alphabet: str) -> None:\n         \"\"\"Set the alphabet to be used for new UUIDs.\"\"\"\n         # Turn the alphabet into a set and sort it to prevent duplicates\n         # and ensure reproducibility.\n         new_alphabet = list(sorted(set(alphabet)))\n         if len(new_alphabet) > 1:\n             self._alphabet = new_alphabet\n             self._alpha_len = len(self._alphabet)\n         else:\n             raise ValueError(\"Alphabet with more than \" \"one unique symbols required.\")\n \n     def encoded_length(self, num_bytes: int = 16) -> int:\n         \"\"\"Return the string length of the shortened UUID.\"\"\"\n         factor = math.log(256) / math.log(self._alpha_len)\n         return int(math.ceil(factor * num_bytes))\n \n \n # For backwards compatibility\n _global_instance = ShortUUID()\n encode = _global_instance.encode\n decode = _global_instance.decode\n uuid = _global_instance.uuid\n random = _global_instance.random\n get_alphabet = _global_instance.get_alphabet\n set_alphabet = _global_instance.set_alphabet\n ", "input_code": "def string_to_int(string: str, alphabet: List[str]) -> int:\n\"\"\"\nConvert a string to a number, using the given alphabet.\n\nThe input is assumed to have the most significant digit first.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def string_to_int(string: str, alphabet: List[str]) -> int:\n    \"\"\"\n    Convert a string to a number, using the given alphabet.\n\n    The input is assumed to have the most significant digit first.\n    \"\"\"\n    number = 0\n    alpha_len = len(alphabet)\n    for char in string:\n        number = number * alpha_len + alphabet.index(char)\n    return number", "signature": "def string_to_int(string: str, alphabet: List[str]) -> int:", "completion_path": "shortuuid/main.py"}
{"ce_id": "62ece4982e6aefcf4aabbd6f", "namespace": "62ece4982e6aefcf4aabbd6f", "namespace_real": "swh.lister.arch.lister.get_repo_archive", "real_proj_path": "SoftwareHeritage---swh-lister/", "type": "class", "class_name": "lister", "function_name": "get_repo_archive", "contexts_above": "# Copyright (C) 2022  The Software Heritage developers\n# See the AUTHORS file at the top-level directory of this distribution\n# License: GNU General Public License version 3, or any later version\n# See top-level LICENSE file for more information\nimport datetime\nimport logging\nfrom pathlib import Path\nimport re\nimport tarfile\nfrom typing import Any, Dict, Iterator, List, Optional\nfrom urllib.parse import unquote, urljoin\n\nfrom bs4 import BeautifulSoup\nimport requests\n\nfrom swh.model.hashutil import hash_to_hex\nfrom swh.scheduler.interface import SchedulerInterface\nfrom swh.scheduler.model import ListedOrigin\n\nfrom ..pattern import CredentialsType, StatelessLister\n\nlogger = logging.getLogger(__name__)\n\n# Aliasing the page results returned by `get_pages` method from the lister.\nArchListerPage = List[Dict[str, Any]]\n\n\ndef size_to_bytes(size: str) -> int:\n    \"\"\"Convert human readable file size to bytes.\n\n    Resulting value is an approximation as input value is in most case rounded.\n\n    Args:\n        size: A string representing a human readable file size (eg: '500K')\n\n    Returns:\n        A decimal representation of file size\n\n        Examples::\n\n            >>> size_to_bytes(\"500\")\n            500\n            >>> size_to_bytes(\"1K\")\n            1000\n    \"\"\"\n    units = {\n        \"K\": 1000,\n        \"M\": 1000**2,\n        \"G\": 1000**3,\n        \"T\": 1000**4,\n        \"P\": 1000**5,\n        \"E\": 1000**6,\n        \"Z\": 1000**7,\n        \"Y\": 1000**8,\n    }\n    if size.endswith(tuple(units)):\n        v, u = (size[:-1], size[-1])\n        return int(v) * units[u]\n    else:\n        return int(size)\n\n\nclass ArchLister(StatelessLister[ArchListerPage]):\n    \"\"\"List Arch linux origins from 'core', 'extra', and 'community' repositories\n\n    For 'official' Arch Linux it downloads core.tar.gz, extra.tar.gz and community.tar.gz\n    from https://archive.archlinux.org/repos/last/ extract to a temp directory and\n    then walks through each 'desc' files.\n\n    Each 'desc' file describe the latest released version of a package and helps\n    to build an origin url from where scrapping artifacts metadata.\n\n    For 'arm' Arch Linux it follow the same discovery process parsing 'desc' files.\n    The main difference is that we can't get existing versions of an arm package\n    because https://archlinuxarm.org does not have an 'archive' website or api.\n    \"\"\"\n\n    LISTER_NAME = \"arch\"\n    VISIT_TYPE = \"arch\"\n    INSTANCE = \"arch\"\n\n    DESTINATION_PATH = Path(\"/tmp/archlinux_archive\")\n\n    ARCH_PACKAGE_URL_PATTERN = \"{base_url}/packages/{repo}/{arch}/{pkgname}\"\n    ARCH_PACKAGE_VERSIONS_URL_PATTERN = \"{base_url}/packages/{pkgname[0]}/{pkgname}\"\n    ARCH_PACKAGE_DOWNLOAD_URL_PATTERN = (\n        \"{base_url}/packages/{pkgname[0]}/{pkgname}/{filename}\"\n    )\n    ARCH_API_URL_PATTERN = \"{base_url}/packages/{repo}/{arch}/{pkgname}/json\"\n\n    ARM_PACKAGE_URL_PATTERN = \"{base_url}/packages/{arch}/{pkgname}\"\n    ARM_PACKAGE_DOWNLOAD_URL_PATTERN = \"{base_url}/{arch}/{repo}/{filename}\"\n\n    def __init__(\n        self,\n        scheduler: SchedulerInterface,\n        credentials: Optional[CredentialsType] = None,\n        flavours: Dict[str, Any] = {\n            \"official\": {\n                \"archs\": [\"x86_64\"],\n                \"repos\": [\"core\", \"extra\", \"community\"],\n                \"base_info_url\": \"https://archlinux.org\",\n                \"base_archive_url\": \"https://archive.archlinux.org\",\n                \"base_mirror_url\": \"\",\n                \"base_api_url\": \"https://archlinux.org\",\n            },\n            \"arm\": {\n                \"archs\": [\"armv7h\", \"aarch64\"],\n                \"repos\": [\"core\", \"extra\", \"community\"],\n                \"base_info_url\": \"https://archlinuxarm.org\",\n                \"base_archive_url\": \"\",\n                \"base_mirror_url\": \"https://uk.mirror.archlinuxarm.org\",\n                \"base_api_url\": \"\",\n            },\n        },\n    ):\n        super().__init__(\n            scheduler=scheduler,\n            credentials=credentials,\n            url=flavours[\"official\"][\"base_info_url\"],\n            instance=self.INSTANCE,\n        )\n\n        self.flavours = flavours\n\n    def scrap_package_versions(\n        self, name: str, repo: str, base_url: str\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Given a package 'name' and 'repo', make an http call to origin url and parse its content\n        to get package versions artifacts data.\n        That method is suitable only for 'official' Arch Linux, not 'arm'.\n\n        Args:\n            name: Package name\n            repo: The repository the package belongs to (one of self.repos)\n\n        Returns:\n            A list of dict of version\n\n            Example::\n\n                [\n                    {\"url\": \"https://archive.archlinux.org/packages/d/dialog/dialog-1:1.3_20190211-1-x86_64.pkg.tar.xz\",  # noqa: B950\n                    \"arch\": \"x86_64\",\n                    \"repo\": \"core\",\n                    \"name\": \"dialog\",\n                    \"version\": \"1:1.3_20190211-1\",\n                    \"length\": 180000,\n                    \"filename\": \"dialog-1:1.3_20190211-1-x86_64.pkg.tar.xz\",\n                    \"last_modified\": \"2019-02-13T08:36:00\"},\n                ]\n        \"\"\"\n        url = self.ARCH_PACKAGE_VERSIONS_URL_PATTERN.format(\n            pkgname=name, base_url=base_url\n        )\n        soup = BeautifulSoup(requests.get(url).text, \"html.parser\")\n        links = soup.find_all(\"a\", href=True)\n\n        # drop the first line (used to go to up directory)\n        if links[0].attrs[\"href\"] == \"../\":\n            links.pop(0)\n\n        versions = []\n\n        for link in links:\n            # filename displayed can be cropped if name is too long, get it from href instead\n            filename = unquote(link.attrs[\"href\"])\n\n            if filename.endswith((\".tar.xz\", \".tar.zst\")):\n                # Extract arch from filename\n                arch_rex = re.compile(\n                    rf\"^{re.escape(name)}-(?P<version>.*)-(?P<arch>any|i686|x86_64)\"\n                    rf\"(.pkg.tar.(?:zst|xz))$\"\n                )\n                m = arch_rex.match(filename)\n                if m is None:\n                    logger.error(\n                        \"Can not find a match for architecture in %(filename)s\"\n                        % dict(filename=filename)\n                    )\n                else:\n                    arch = m.group(\"arch\")\n                    version = m.group(\"version\")\n\n                # Extract last_modified and an approximate file size\n                raw_text = link.next_sibling\n                raw_text_rex = re.compile(\n                    r\"^(?P<last_modified>\\d+-\\w+-\\d+ \\d\\d:\\d\\d)\\s+(?P<size>\\w+)$\"\n                )\n                s = raw_text_rex.search(raw_text.strip())\n                if s is None:\n                    logger.error(\n                        \"Can not find a match for 'last_modified' and/or \"\n                        \"'size' in '%(raw_text)s'\" % dict(raw_text=raw_text)\n                    )\n                else:\n                    assert s.groups()\n                    assert len(s.groups()) == 2\n                    last_modified_str, size = s.groups()\n\n                # format as expected\n                last_modified = datetime.datetime.strptime(\n                    last_modified_str, \"%d-%b-%Y %H:%M\"\n                ).isoformat()\n\n                length = size_to_bytes(size)  # we want bytes\n\n                # link url is relative, format a canonical one\n                url = self.ARCH_PACKAGE_DOWNLOAD_URL_PATTERN.format(\n                    base_url=base_url, pkgname=name, filename=filename\n                )\n                versions.append(\n                    dict(\n                        name=name,\n                        version=version,\n                        repo=repo,\n                        arch=arch,\n                        filename=filename,\n                        url=url,\n                        last_modified=last_modified,\n                        length=length,\n                    )\n                )\n        return versions\n", "contexts_below": "    def parse_desc_file(\n         self,\n         path: Path,\n         repo: str,\n         base_url: str,\n         dl_url_fmt: str,\n     ) -> Dict[str, Any]:\n         \"\"\"Extract package information from a 'desc' file.\n         There are subtle differences between parsing 'official' and 'arm' des files\n \n         Args:\n             path: A path to a 'desc' file on disk\n             repo: The repo the package belongs to\n \n         Returns:\n             A dict of metadata\n \n             Example::\n \n                 {'api_url': 'https://archlinux.org/packages/core/x86_64/dialog/json',\n                  'arch': 'x86_64',\n                  'base': 'dialog',\n                  'builddate': '1650081535',\n                  'csize': '203028',\n                  'desc': 'A tool to display dialog boxes from shell scripts',\n                  'filename': 'dialog-1:1.3_20220414-1-x86_64.pkg.tar.zst',\n                  'isize': '483988',\n                  'license': 'LGPL2.1',\n                  'md5sum': '06407c0cb11c50d7bf83d600f2e8107c',\n                  'name': 'dialog',\n                  'packager': 'Evangelos Foutras <foutrelis@archlinux.org>',\n                  'pgpsig': 'pgpsig content xxx',\n                  'project_url': 'https://invisible-island.net/dialog/',\n                  'provides': 'libdialog.so=15-64',\n                  'repo': 'core',\n                  'sha256sum': 'ef8c8971f591de7db0f455970ef5d81d5aced1ddf139f963f16f6730b1851fa7',\n                  'url': 'https://archive.archlinux.org/packages/.all/dialog-1:1.3_20220414-1-x86_64.pkg.tar.zst',  # noqa: B950\n                  'version': '1:1.3_20220414-1'}\n         \"\"\"\n         rex = re.compile(r\"^\\%(?P<k>\\w+)\\%\\n(?P<v>.*)\\n$\", re.M)\n         with path.open(\"rb\") as content:\n             parsed = rex.findall(content.read().decode())\n             data = {entry[0].lower(): entry[1] for entry in parsed}\n \n             if \"url\" in data.keys():\n                 data[\"project_url\"] = data[\"url\"]\n \n             assert data[\"name\"]\n             assert data[\"filename\"]\n             assert data[\"arch\"]\n \n             data[\"repo\"] = repo\n             data[\"url\"] = urljoin(\n                 base_url,\n                 dl_url_fmt.format(\n                     base_url=base_url,\n                     pkgname=data[\"name\"],\n                     filename=data[\"filename\"],\n                     arch=data[\"arch\"],\n                     repo=repo,\n                 ),\n             )\n \n             assert data[\"md5sum\"]\n             assert data[\"sha256sum\"]\n             data[\"checksums\"] = {\n                 \"md5sum\": hash_to_hex(data[\"md5sum\"]),\n                 \"sha256sum\": hash_to_hex(data[\"sha256sum\"]),\n             }\n         return data\n \n     def get_pages(self) -> Iterator[ArchListerPage]:\n         \"\"\"Yield an iterator sorted by name in ascending order of pages.\n \n         Each page is a list of package belonging to a flavour ('official', 'arm'),\n         and a repo ('core', 'extra', 'community')\n         \"\"\"\n \n         for name, flavour in self.flavours.items():\n             for arch in flavour[\"archs\"]:\n                 for repo in flavour[\"repos\"]:\n                     page = []\n                     if name == \"official\":\n                         prefix = urljoin(flavour[\"base_archive_url\"], \"/repos/last/\")\n                         filename = f\"{repo}.files.tar.gz\"\n                         archive_url = urljoin(prefix, f\"{repo}/os/{arch}/{filename}\")\n                         destination_path = Path(self.DESTINATION_PATH, arch, filename)\n                         base_url = flavour[\"base_archive_url\"]\n                         dl_url_fmt = self.ARCH_PACKAGE_DOWNLOAD_URL_PATTERN\n                         base_info_url = flavour[\"base_info_url\"]\n                         info_url_fmt = self.ARCH_PACKAGE_URL_PATTERN\n                     elif name == \"arm\":\n                         filename = f\"{repo}.files.tar.gz\"\n                         archive_url = urljoin(\n                             flavour[\"base_mirror_url\"], f\"{arch}/{repo}/{filename}\"\n                         )\n                         destination_path = Path(self.DESTINATION_PATH, arch, filename)\n                         base_url = flavour[\"base_mirror_url\"]\n                         dl_url_fmt = self.ARM_PACKAGE_DOWNLOAD_URL_PATTERN\n                         base_info_url = flavour[\"base_info_url\"]\n                         info_url_fmt = self.ARM_PACKAGE_URL_PATTERN\n \n                     archive = self.get_repo_archive(\n                         url=archive_url, destination_path=destination_path\n                     )\n \n                     assert archive\n \n                     packages_desc = list(archive.glob(\"**/desc\"))\n                     logger.debug(\n                         \"Processing %(instance)s source packages info from \"\n                         \"%(flavour)s %(arch)s %(repo)s repository, \"\n                         \"(%(qty)s packages).\"\n                         % dict(\n                             instance=self.instance,\n                             flavour=name,\n                             arch=arch,\n                             repo=repo,\n                             qty=len(packages_desc),\n                         )\n                     )\n \n                     for package_desc in packages_desc:\n                         data = self.parse_desc_file(\n                             path=package_desc,\n                             repo=repo,\n                             base_url=base_url,\n                             dl_url_fmt=dl_url_fmt,\n                         )\n \n                         assert data[\"builddate\"]\n                         last_modified = datetime.datetime.fromtimestamp(\n                             float(data[\"builddate\"]), tz=datetime.timezone.utc\n                         )\n \n                         assert data[\"name\"]\n                         assert data[\"filename\"]\n                         assert data[\"arch\"]\n                         url = info_url_fmt.format(\n                             base_url=base_info_url,\n                             pkgname=data[\"name\"],\n                             filename=data[\"filename\"],\n                             repo=repo,\n                             arch=data[\"arch\"],\n                         )\n \n                         assert data[\"version\"]\n                         if name == \"official\":\n                             # find all versions of a package scrapping archive\n                             versions = self.scrap_package_versions(\n                                 name=data[\"name\"],\n                                 repo=repo,\n                                 base_url=base_url,\n                             )\n                         elif name == \"arm\":\n                             # There is no way to get related versions of a package,\n                             # but 'data' represents the latest released version,\n                             # use it in this case\n                             assert data[\"builddate\"]\n                             assert data[\"csize\"]\n                             assert data[\"url\"]\n                             versions = [\n                                 dict(\n                                     name=data[\"name\"],\n                                     version=data[\"version\"],\n                                     repo=repo,\n                                     arch=data[\"arch\"],\n                                     filename=data[\"filename\"],\n                                     url=data[\"url\"],\n                                     last_modified=last_modified.replace(\n                                         tzinfo=None\n                                     ).isoformat(timespec=\"seconds\"),\n                                     length=int(data[\"csize\"]),\n                                 )\n                             ]\n \n                         package = {\n                             \"name\": data[\"name\"],\n                             \"version\": data[\"version\"],\n                             \"last_modified\": last_modified,\n                             \"url\": url,\n                             \"versions\": versions,\n                             \"data\": data,\n                         }\n                         page.append(package)\n                     yield page\n \n     def get_origins_from_page(self, page: ArchListerPage) -> Iterator[ListedOrigin]:\n         \"\"\"Iterate on all arch pages and yield ListedOrigin instances.\"\"\"\n         assert self.lister_obj.id is not None\n         for origin in page:\n             yield ListedOrigin(\n                 lister_id=self.lister_obj.id,\n                 visit_type=self.VISIT_TYPE,\n                 url=origin[\"url\"],\n                 last_update=origin[\"last_modified\"],\n                 extra_loader_arguments={\n                     \"artifacts\": origin[\"versions\"],\n                 },\n             )\n ", "input_code": "def get_repo_archive(self, url: str, destination_path: Path) -> Path:\n\"\"\"\nGiven an url and a destination path, retrieve and extract .tar.gz archive\nwhich contains 'desc' file for each package.\nEach .tar.gz archive corresponds to an Arch Linux repo ('core', 'extra', 'community').\n\nArgs:\n    url: url of the .tar.gz archive to download\n    destination_path: the path on disk where to extract archive\n\nReturns:\n    a directory Path where the archive has been extracted to.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def get_repo_archive(self, url: str, destination_path: Path) -> Path:\n        \"\"\"Given an url and a destination path, retrieve and extract .tar.gz archive\n        which contains 'desc' file for each package.\n        Each .tar.gz archive corresponds to an Arch Linux repo ('core', 'extra', 'community').\n\n        Args:\n            url: url of the .tar.gz archive to download\n            destination_path: the path on disk where to extract archive\n\n        Returns:\n            a directory Path where the archive has been extracted to.\n        \"\"\"\n        res = requests.get(url)\n        destination_path.parent.mkdir(parents=True, exist_ok=True)\n        destination_path.write_bytes(res.content)\n\n        extract_to = Path(str(destination_path).split(\".tar.gz\")[0])\n        tar = tarfile.open(destination_path)\n        tar.extractall(path=extract_to)\n        tar.close()\n\n        return extract_to", "signature": "def get_repo_archive(self, url: str, destination_path: Path) -> Path:", "completion_path": "swh/lister/arch/lister.py"}
{"ce_id": "62ece4982e6aefcf4aabbd70", "namespace": "62ece4982e6aefcf4aabbd70", "namespace_real": "cloudmesh.common.systeminfo.os_is_mac", "real_proj_path": "cloudmesh---cloudmesh-common/", "type": "function", "class_name": null, "function_name": "os_is_mac", "contexts_above": "import platform\nimport sys\nimport os\nfrom pathlib import Path\nfrom cloudmesh.common.util import readfile\nfrom collections import OrderedDict\nimport pip\nimport psutil\nimport humanize\nimport re\nimport multiprocessing\n\n\ndef os_is_windows():\n    \"\"\"\n    Checks if the os is windows\n\n    :return: True is windows\n    :rtype: bool\n    \"\"\"\n    return platform.system() == \"Windows\"\n\n\n# noinspection PyBroadException\ndef os_is_linux():\n    \"\"\"\n    Checks if the os is linux\n\n    :return: True is linux\n    :rtype: bool\n    \"\"\"\n    try:\n        content = readfile('/etc/os-release')\n        return platform.system() == \"Linux\" and \"raspbian\" not in content\n    except:  # noqa: E722\n        return False\n\n", "contexts_below": "\n # noinspection PyBroadException\n def os_is_pi():\n     \"\"\"\n     Checks if the os is Raspberry OS\n \n     :return: True is Raspberry OS\n     :rtype: bool\n     \"\"\"\n     try:\n         content = readfile('/etc/os-release')\n         return platform.system() == \"Linux\" and \"raspbian\" in content\n     except:  # noqa: E722\n         return False\n \n def sys_user():\n     if \"COLAB_GPU\" in os.environ:\n         return \"collab\"\n     try:\n         if sys.platform == \"win32\":\n             return os.environ[\"USERNAME\"]\n     except:\n         pass\n     try:\n         return os.environ[\"USER\"]\n     except:\n         pass\n     try:\n         if os.environ[\"HOME\"] == \"/root\":\n             return \"root\"\n     except:\n         pass\n \n     return \"None\"\n \n def get_platform():\n     if sys.platform == \"darwin\":\n         return \"macos\"\n     elif sys.platform == \"win32\":\n         return \"windows\"\n     try:\n         content = readfile('/etc/os-release')\n         if sys.platform == 'linux' and \"raspbian\" in content:\n             return \"raspberry\"\n         else:\n             return sys.platform\n     except:\n         return sys.platform\n \n \n def systeminfo(info=None, user=None, node=None):\n     uname = platform.uname()\n     mem = psutil.virtual_memory()\n \n     # noinspection PyPep8\n     def add_binary(value):\n         try:\n             r = humanize.naturalsize(value, binary=True)\n         except:\n             r = \"\"\n         return r\n \n     try:\n         frequency = psutil.cpu_freq()\n     except:\n         frequency = None\n \n     try:\n         cores = psutil.cpu_count(logical=False)\n     except:\n         cores = \"unkown\"\n \n     operating_system = get_platform()\n \n     description = \"\"\n     try:\n         if operating_system == \"macos\":\n             description = os.popen(\"sysctl -n machdep.cpu.brand_string\").read()\n         elif operating_system == \"win32\":\n             description = platform.processor()\n         elif operating_system == \"linux\":\n             lines = readfile(\"/proc/cpuinfo\").strip().splitlines()\n             for line in lines:\n                 if \"model name\" in line:\n                     description = re.sub(\".*model name.*:\", \"\", line, 1)\n     except:\n         pass\n \n \n     data = OrderedDict({\n         'cpu': description.strip(),\n         'cpu_count': multiprocessing.cpu_count(),\n         'cpu_threads': multiprocessing.cpu_count(),\n         'cpu_cores': cores,\n         'uname.system': uname.system,\n         'uname.node': uname.node,\n         'uname.release': uname.release,\n         'uname.version': uname.version,\n         'uname.machine': uname.machine,\n         'uname.processor': uname.processor,\n         'sys.platform': sys.platform,\n         'python': sys.version,\n         'python.version': sys.version.split(\" \", 1)[0],\n         'python.pip': pip.__version__,\n         'user': sys_user(),\n         'mem.percent': str(mem.percent) + \" %\",\n         'frequency': frequency\n     })\n     for attribute in [\"total\",\n                       \"available\",\n                       \"used\",\n                       \"free\",\n                       \"active\",\n                       \"inactive\",\n                       \"wired\"\n                       ]:\n         try:\n             data[f\"mem.{attribute}\"] = \\\n                 humanize.naturalsize(getattr(mem, attribute), binary=True)\n         except:\n             pass\n     # svmem(total=17179869184, available=6552825856, percent=61.9,\n \n     if data['sys.platform'] == 'darwin':\n         data['platform.version'] = platform.mac_ver()[0]\n     elif data['sys.platform'] == 'win32':\n         data['platform.version'] = platform.win32_ver()\n     else:\n         data['platform.version'] = uname.version\n \n     try:\n         release_files = Path(\"/etc\").glob(\"*release\")\n         for filename in release_files:\n             content = readfile(filename.resolve()).splitlines()\n             for line in content:\n                 if \"=\" in line:\n                     attribute, value = line.split(\"=\", 1)\n                     attribute = attribute.replace(\" \", \"\")\n                     data[attribute] = value\n     except:\n         pass\n     if info is not None:\n         data.update(info)\n     if user is not None:\n         data[\"user\"] = user\n     if node is not None:\n         data[\"uname.node\"] = node\n     return dict(data)\n ", "input_code": "def os_is_mac():\n\"\"\"\nChecks if the os is macOS\n\n:return: True is macOS\n:rtype: bool\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def os_is_mac():\n    \"\"\"\n    Checks if the os is macOS\n\n    :return: True is macOS\n    :rtype: bool\n    \"\"\"\n    return platform.system() == \"Darwin\"", "signature": "def os_is_mac():", "completion_path": "cloudmesh/common/systeminfo.py"}
{"ce_id": "62ece4982e6aefcf4aabbd71", "namespace": "62ece4982e6aefcf4aabbd71", "namespace_real": "makeprojects.util.regex_dict", "real_proj_path": "burgerbecky---makeprojects/", "type": "function", "class_name": null, "function_name": "regex_dict", "contexts_above": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nThe util module contains subroutines used everywhere.\n\n@package makeprojects.util\n\"\"\"\n\nfrom __future__ import absolute_import, print_function, unicode_literals\n\nimport os\nimport re\nimport fnmatch\nfrom burger import string_to_bool, is_string, import_py_script\nfrom .enums import FileTypes\n\n# pylint: disable=consider-using-f-string\n\n########################################\n\n\ndef validate_enum_type(value, data_type):\n    \"\"\"\n    Verify a value is a specific data type.\n\n    Check if the value is either None or an instance of a\n    specfic data type. If so, return immediately. If the value is a string,\n    call the lookup() function of the data type for conversion.\n\n    Args:\n        value: Value to check.\n        data_type: Type instance of the class type to match.\n\n    Returns:\n        Value converted to data_type or None.\n\n    Raises:\n        TypeError\n\n    \"\"\"\n\n    if value is not None:\n        # Perform the lookup\n        new_value = data_type.lookup(value)\n        if new_value is None:\n            msg = '\"{}\" must be of type \"{}\".'.format(\n                value, data_type.__name__)\n            raise TypeError(msg)\n        # Save the converted type\n        value = new_value\n    return value\n\n########################################\n\n", "contexts_below": "########################################\n \n \n def validate_boolean(value):\n     \"\"\"\n     Verify a value is a boolean.\n \n     Check if the value can be converted to a bool, if so, return the value as\n     bool. None is converted to False.\n \n     Args:\n         value: Value to check.\n \n     Returns:\n         Value converted to data_type or None.\n \n     Raises:\n         ValueError\n     \"\"\"\n \n     if value is not None:\n         # Convert to bool\n         value = string_to_bool(value)\n     return value\n \n ########################################\n \n \n def validate_string(value):\n     \"\"\"\n     Verify a value is a string.\n \n     Check if the value is a string, if so, return the value as is or None.\n \n     Args:\n         value: Value to check.\n \n     Returns:\n         Value is string or None.\n \n     Raises:\n         ValueError\n     \"\"\"\n \n     if value is not None:\n         # Convert to bool\n         if not is_string(value):\n             raise ValueError('\"{}\" must be a string.'.format(value))\n     return value\n \n ########################################\n \n \n def source_file_filter(file_list, file_type_list):\n     \"\"\"\n     Prune the file list for a specific type.\n \n     Note: file_type_list can either be a single enums.FileTypes enum or an\n         iterable list of enums.FileTypes\n \n     Args:\n         file_list: list of core.SourceFile entries.\n         file_type_list: enums.FileTypes to match.\n     Returns:\n         list of matching core.SourceFile entries.\n     \"\"\"\n \n     result_list = []\n \n     # If a single item was passed, use a simple loop\n     if isinstance(file_type_list, FileTypes):\n         for item in file_list:\n             if item.type is file_type_list:\n                 result_list.append(item)\n     else:\n         # A list was passed, so test against the list\n         for item in file_list:\n             if item.type in file_type_list:\n                 result_list.append(item)\n     return result_list\n \n ########################################\n \n \n def add_build_rules(build_rules_list, file_name, verbose, is_root, basename):\n     \"\"\"\n     Load in the file ``build_rules.py``\n \n     Load the build_rules.py file. If the variable ``*_GENERIC`` is ``True``\n     or if ``is_root`` is ``True``, append the module to ``build_rules_list``.\n     If the variable ``*_CONTINUE`` was found in the file, check if it is set\n     to ``True``. If so, return ``True`` to allow processing to continue. If\n     the file is not found, return ``True`` to allow processing the parent\n     folder.\n \n     Since this is called from ``buildme``, ``cleanme``, and ``makeprojects``,\n     the prefix needed for the tool is passed in ``basename``. An example is\n     \"CLEANME\".\n \n     Args:\n         build_rules_list: List to add ``build_rules.py`` instances.\n         file_name: Full path name of the build_rules.py to load.\n         verbose: True for verbose output.\n         is_root: True if *_GENERIC is ignored.\n         basename: Variable prefix to substitute * in *_GENERIC\n     Returns:\n         True if the parent folder should be checked, False if not.\n     \"\"\"\n \n     # Ensure the absolute path is used.\n     file_name = os.path.abspath(file_name)\n     build_rules = import_py_script(file_name)\n \n     # Not found? Continue parsing folders.\n     if not build_rules:\n         return True\n \n     if is_root or getattr(build_rules, basename + \"_GENERIC\", False):\n         # Add to the list\n         build_rules_list.append(build_rules)\n \n     if verbose:\n         print('Using configuration file {}'.format(file_name))\n \n     # Test if this is considered the last one in the chain.\n     return getattr(build_rules, basename + \"_CONTINUE\", False)\n ", "input_code": "def regex_dict(item):\n\"\"\"\nConvert *.cpp keys to regex keys\n\nGiven a dict where the keys are all filenames with wildcards, convert only\nthe keys into equivalent regexes and leave the values intact.\n\nExample:\n\nrules = {\n    '*.cpp':\n        {'a': 'arf', 'b': 'bark', 'c': 'coo'},\n    '*.h':\n        {'h': 'help'}\n}\nregex_keys = regex_dict(rules)\n\nArgs:\n    item: dict to convert\nReturns:\n    dict with keys converted to regexes\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def regex_dict(item):\n    \"\"\"\n    Convert *.cpp keys to regex keys\n\n    Given a dict where the keys are all filenames with wildcards, convert only\n    the keys into equivalent regexes and leave the values intact.\n\n    Example:\n\n    rules = {\n        '*.cpp':\n            {'a': 'arf', 'b': 'bark', 'c': 'coo'},\n        '*.h':\n            {'h': 'help'}\n    }\n    regex_keys = regex_dict(rules)\n\n    Args:\n        item: dict to convert\n    Returns:\n        dict with keys converted to regexes\n    \"\"\"\n\n    output = {}\n    for key in item:\n        output[re.compile(fnmatch.translate(key)).match] = item[key]\n    return output", "signature": "def regex_dict(item):", "completion_path": "makeprojects/util.py"}
{"ce_id": "62ece4982e6aefcf4aabbd72", "namespace": "62ece4982e6aefcf4aabbd72", "namespace_real": "rdiffweb.core.librdiff.unquote", "real_proj_path": "ikus060---rdiffweb/", "type": "function", "class_name": null, "function_name": "unquote", "contexts_above": "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport bisect\nimport calendar\nimport encodings\nimport logging\nimport os\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport threading\nimport time\nfrom datetime import timedelta\nfrom distutils import spawn\nfrom subprocess import CalledProcessError\n\nimport psutil\nfrom cached_property import cached_property\n\nfrom rdiffweb.tools.i18n import ugettext as _\n\n# Define the logger\nlogger = logging.getLogger(__name__)\n\n# Constant for the rdiff-backup-data folder name.\nRDIFF_BACKUP_DATA = b\"rdiff-backup-data\"\n\n# Increment folder name.\nINCREMENTS = b\"increments\"\n\n# Define the default LANG environment variable to be passed to rdiff-backup\n# restore command line to make sure the binary output stdout as utf8 otherwise\n# we end up with \\x encoded characters.\nSTDOUT_ENCODING = 'utf-8'\nLANG = \"en_US.\" + STDOUT_ENCODING\n\n# PATH for executable lookup\nPATH = path = os.path.dirname(sys.executable) + os.pathsep + os.environ['PATH']\n\n\ndef rdiff_backup_version():\n    \"\"\"\n    Get rdiff-backup version\n    \"\"\"\n    try:\n        output = subprocess.check_output([find_rdiff_backup(), '--version'])\n        m = re.search(b'([0-9]+).([0-9]+).([0-9]+)', output)\n        return (int(m.group(1)), int(m.group(2)), int(m.group(3)))\n    except Exception:\n        return (0, 0, 0)\n\n\ndef find_rdiff_backup():\n    \"\"\"\n    Lookup for `rdiff-backup` executable. Raise an exception if not found.\n    \"\"\"\n    cmd = spawn.find_executable('rdiff-backup', PATH)\n    if not cmd:\n        raise FileNotFoundError(\"can't find `rdiff-backup` executable in PATH: %s\" % PATH)\n    return os.fsencode(cmd)\n\n\ndef find_rdiff_backup_delete():\n    \"\"\"\n    Lookup for `rdiff-backup-delete` executable. Raise an exception if not found.\n    \"\"\"\n    cmd = spawn.find_executable('rdiff-backup-delete', PATH)\n    if not cmd:\n        raise FileNotFoundError(\n            \"can't find `rdiff-backup-delete` executable in PATH: %s, make sure you have rdiff-backup >= 2.0.1 installed\"\n            % PATH\n        )\n    return os.fsencode(cmd)\n\n", "contexts_below": "\n def popen(cmd, stderr=None, env=None):\n     \"\"\"\n     Alternative to os.popen() to support a `cmd` with a list of arguments and\n     return a file object that return bytes instead of string.\n \n     `stderr` could be subprocess.STDOUT or subprocess.DEVNULL or a function.\n     Otherwise, the error is redirect to logger.\n     \"\"\"\n     # Check if stderr should be pipe.\n     pipe_stderr = stderr == subprocess.PIPE or hasattr(stderr, '__call__') or stderr is None\n     proc = subprocess.Popen(\n         cmd,\n         shell=False,\n         stdout=subprocess.PIPE,\n         stderr=subprocess.PIPE if pipe_stderr else stderr,\n         env=env,\n     )\n     if pipe_stderr:\n         t = threading.Thread(target=_readerthread, args=(proc.stderr, stderr))\n         t.daemon = True\n         t.start()\n     return _wrap_close(proc.stdout, proc)\n \n \n # Helper for popen() to redirect stderr to a logger.\n \n \n def _readerthread(stream, func):\n     \"\"\"\n     Read stderr and pipe each line to logger.\n     \"\"\"\n     func = func or logger.debug\n     for line in stream:\n         func(line.decode(STDOUT_ENCODING, 'replace').strip('\\n'))\n     stream.close()\n \n \n # Helper for popen() to close process when the pipe is closed.\n \n \n class _wrap_close:\n     def __init__(self, stream, proc):\n         self._stream = stream\n         self._proc = proc\n \n     def close(self):\n         self._stream.close()\n         returncode = self._proc.wait()\n         if returncode == 0:\n             return None\n         return returncode\n \n     def __enter__(self):\n         return self\n \n     def __exit__(self, *args):\n         self.close()\n \n     def __getattr__(self, name):\n         return getattr(self._stream, name)\n \n     def __iter__(self):\n         return iter(self._stream)\n \n \n class AccessDeniedError(Exception):\n     pass\n \n \n class DoesNotExistError(Exception):\n     pass\n \n \n class RdiffTime(object):\n \n     \"\"\"Time information has two components: the local time, stored in GMT as\n     seconds since Epoch, and the timezone, stored as a seconds offset. Since\n     the server may not be in the same timezone as the user, we cannot rely on\n     the built-in localtime() functions, but look at the rdiff-backup string\n     for timezone information.  As a general rule, we always display the\n     \"local\" time, but pass the timezone information on to rdiff-backup, so\n     it can restore to the correct state\"\"\"\n \n     def __init__(self, value=None, tz_offset=None):\n         assert value is None or isinstance(value, int) or isinstance(value, str)\n         if value is None:\n             # Get GMT time.\n             self._time_seconds = int(time.time())\n             self._tz_offset = 0\n         elif isinstance(value, int):\n             self._time_seconds = value\n             self._tz_offset = tz_offset or 0\n         else:\n             self._from_str(value)\n \n     def _from_str(self, time_string):\n         try:\n             date, daytime = time_string[:19].split(\"T\")\n             year, month, day = list(map(int, date.split(\"-\")))\n             hour, minute, second = list(map(int, daytime.split(\":\")))\n             assert 1900 < year < 2100, year\n             assert 1 <= month <= 12\n             assert 1 <= day <= 31\n             assert 0 <= hour <= 23\n             assert 0 <= minute <= 59\n             assert 0 <= second <= 61  # leap seconds\n             timetuple = (year, month, day, hour, minute, second, -1, -1, 0)\n             self._time_seconds = calendar.timegm(timetuple)\n             self._tz_offset = self._tzdtoseconds(time_string[19:])\n             self._tz_str()  # to get assertions there\n         except (TypeError, ValueError, AssertionError):\n             raise ValueError(time_string)\n \n     def epoch(self):\n         return self._time_seconds - self._tz_offset\n \n     def _tz_str(self):\n         if self._tz_offset:\n             hours, minutes = divmod(abs(self._tz_offset) // 60, 60)\n             assert 0 <= hours <= 23\n             assert 0 <= minutes <= 59\n             if self._tz_offset > 0:\n                 plus_minus = \"+\"\n             else:\n                 plus_minus = \"-\"\n             return \"%s%s:%s\" % (plus_minus, \"%02d\" % hours, \"%02d\" % minutes)\n         else:\n             return \"Z\"\n \n     def set_time(self, hour, minute, second):\n         year = time.gmtime(self._time_seconds)[0]\n         month = time.gmtime(self._time_seconds)[1]\n         day = time.gmtime(self._time_seconds)[2]\n         _time_seconds = calendar.timegm((year, month, day, hour, minute, second, -1, -1, 0))\n         return RdiffTime(_time_seconds, self._tz_offset)\n \n     def _tzdtoseconds(self, tzd):\n         \"\"\"Given w3 compliant TZD, converts it to number of seconds from UTC\"\"\"\n         if tzd == \"Z\":\n             return 0\n         assert len(tzd) == 6  # only accept forms like +08:00 for now\n         assert (tzd[0] == \"-\" or tzd[0] == \"+\") and tzd[3] == \":\"\n         if tzd[0] == \"+\":\n             plus_minus = 1\n         else:\n             plus_minus = -1\n         return plus_minus * 60 * (60 * int(tzd[1:3]) + int(tzd[4:]))\n \n     def __add__(self, other):\n         \"\"\"Support plus (+) timedelta\"\"\"\n         assert isinstance(other, timedelta)\n         return RdiffTime(self._time_seconds + int(other.total_seconds()), self._tz_offset)\n \n     def __sub__(self, other):\n         \"\"\"Support minus (-) timedelta\"\"\"\n         assert isinstance(other, timedelta) or isinstance(other, RdiffTime)\n         # Sub with timedelta, return RdiffTime\n         if isinstance(other, timedelta):\n             return RdiffTime(self._time_seconds - int(other.total_seconds()), self._tz_offset)\n \n         # Sub with RdiffTime, return timedelta\n         if isinstance(other, RdiffTime):\n             return timedelta(seconds=self._time_seconds - other._time_seconds)\n \n     def __int__(self):\n         \"\"\"Return this date as seconds since epoch.\"\"\"\n         return self.epoch()\n \n     def __lt__(self, other):\n         assert isinstance(other, RdiffTime)\n         return self.epoch() < other.epoch()\n \n     def __le__(self, other):\n         assert isinstance(other, RdiffTime)\n         return self.epoch() <= other.epoch()\n \n     def __gt__(self, other):\n         assert isinstance(other, RdiffTime)\n         return self.epoch() > other.epoch()\n \n     def __ge__(self, other):\n         assert isinstance(other, RdiffTime)\n         return self.epoch() >= other.epoch()\n \n     def __eq__(self, other):\n         return isinstance(other, RdiffTime) and self.epoch() == other.epoch()\n \n     def __hash__(self):\n         return hash(self.epoch())\n \n     def __str__(self):\n         \"\"\"return utf-8 string\"\"\"\n         value = time.strftime(\"%Y-%m-%dT%H:%M:%S\", time.gmtime(self._time_seconds))\n         return value + self._tz_str()\n \n     def __repr__(self):\n         \"\"\"return second since epoch\"\"\"\n         return \"RdiffTime('\" + str(self) + \"')\"\n \n \n class RdiffDirEntry(object):\n     \"\"\"\n     Includes name, isdir, file_size, exists, and dict (change_dates) of sorted\n     local dates when backed up.\n     \"\"\"\n \n     def __init__(self, repo, path, exists, increments):\n         assert isinstance(repo, RdiffRepo)\n         assert isinstance(path, bytes)\n         # Keep reference to the path and repo object.\n         self._repo = repo\n         self.path = path\n         # Absolute path to the directory\n         if self.isroot:\n             self.full_path = self._repo.full_path\n         else:\n             self.full_path = os.path.join(self._repo.full_path, self.path)\n         # May need to compute our own state if not provided.\n         self.exists = exists\n         # Store the increments sorted by date.\n         # See self.last_change_date()\n         self._increments = sorted(increments, key=lambda x: x.date)\n \n     @property\n     def display_name(self):\n         \"\"\"Return the most human readable filename. Without quote.\"\"\"\n         return self._repo.get_display_name(self.path)\n \n     @property\n     def isroot(self):\n         \"\"\"\n         Check if the directory entry represent the root of the repository.\n         Return True when path is empty.\n         \"\"\"\n         return self.path == b''\n \n     @cached_property\n     def isdir(self):\n         \"\"\"Lazy check if entry is a directory\"\"\"\n         if self.exists:\n             # If the entry exists, check if it's a directory\n             return os.path.isdir(self.full_path)\n         # Check if increments is a directory\n         for increment in self._increments:\n             if increment.is_missing:\n                 # Ignore missing increment...\n                 continue\n             return increment.isdir\n \n     @cached_property\n     def file_size(self):\n         \"\"\"Return the file size in bytes.\"\"\"\n         if self.isdir:\n             return 0\n         elif self.exists:\n             try:\n                 return os.lstat(self.full_path).st_size\n             except Exception:\n                 logger.warning(\"cannot lstat on file [%s]\", self.full_path, exc_info=1)\n         else:\n             # The only viable place to get the filesize of a deleted entry\n             # it to get it from file_statistics\n             try:\n                 stats = self._repo.file_statistics[self.last_change_date]\n                 # File stats uses unquoted name.\n                 unquote_path = unquote(self.path)\n                 return stats.get_source_size(unquote_path)\n             except Exception:\n                 logger.warning(\"cannot find file statistic [%s]\", self.last_change_date, exc_info=1)\n         return 0\n \n     @cached_property\n     def change_dates(self):\n         \"\"\"\n         Return a list of dates when this item has changes. Represent the\n         previous revision. From old to new.\n         \"\"\"\n         # Exception for root path, use backups dates.\n         if self.isroot:\n             return self._repo.backup_dates\n \n         # Compute the dates\n         change_dates = set()\n         for increment in self._increments:\n             # Get date of the increment as reference\n             change_date = increment.date\n             # If the increment is a \"missing\" increment, need to get the date\n             # before the folder was removed.\n             if increment.is_missing:\n                 change_date = self._get_previous_backup_date(change_date)\n \n             if change_date:\n                 change_dates.add(change_date)\n \n         # If the directory exists, add the last known backup date.\n         if self.exists and self._repo.last_backup_date:\n             change_dates.add(self._repo.last_backup_date)\n \n         # Return the list of dates.\n         return sorted(change_dates)\n \n     def _get_previous_backup_date(self, date):\n         \"\"\"Return the previous backup date.\"\"\"\n         index = bisect.bisect_left(self._repo.backup_dates, date)\n         if index == 0:\n             return None\n         return self._repo.backup_dates[index - 1]\n \n     @cached_property\n     def last_change_date(self):\n         \"\"\"Return last change date or False.\"\"\"\n         return self.change_dates and self.change_dates[-1]\n \n \n class AbstractEntry:\n     SUFFIXES = None\n \n     @classmethod\n     def _extract_date(cls, filename, onerror=None):\n         \"\"\"\n         Extract date from rdiff-backup filenames.\n         \"\"\"\n         # Extract suffix\n         suffix = None\n         for s in cls.SUFFIXES:\n             if filename.endswith(s):\n                 suffix = s\n                 break\n         if not suffix:\n             raise ValueError(filename)\n         # Parse date\n         filename_without_suffix = filename[: -len(suffix)]\n         parts = filename_without_suffix.rsplit(b'.', 1)\n         if len(parts) != 2:\n             return onerror(ValueError(''))\n         date_string = unquote(parts[1]).decode('ascii')\n         try:\n             return RdiffTime(date_string)\n         except Exception as e:\n             if onerror is None:\n                 raise\n             return onerror(e)\n \n \n class MetadataEntry(AbstractEntry):\n     PREFIX = None\n     SUFFIXES = None\n     on_date_error = None\n \n     def __init__(self, repo, name):\n         assert isinstance(repo, RdiffRepo)\n         assert isinstance(name, bytes)\n         assert name.startswith(self.PREFIX)\n         assert any(name.endswith(s) for s in self.SUFFIXES), 'name %s should ends with: %s' % (name, self.SUFFIXES)\n         self.repo = repo\n         self.name = name\n         self.path = os.path.join(self.repo._data_path, self.name)\n         self.date = self._extract_date(name, onerror=self.on_date_error)\n \n     def _open(self):\n         \"\"\"\n         Should be used to open the increment file. This method handle\n         compressed vs not-compressed file.\n         \"\"\"\n         if self._is_compressed:\n             return popen(['zcat', self.path])\n         return open(self.path, 'rb')\n \n     @property\n     def _is_compressed(self):\n         return self.name.endswith(b\".gz\")\n \n \n class MirrorMetadataEntry(MetadataEntry):\n     PREFIX = b'mirror_metadata.'\n     SUFFIXES = [\n         b'.diff',\n         b'.diff.gz',\n         b\".snapshot.gz\",\n         b\".snapshot\",\n     ]\n \n \n class IncrementEntry(AbstractEntry):\n \n     \"\"\"Instance of the class represent one increment at a specific date for one\n     repository. The base repository is provided in the default constructor\n     and the date is provided using an error_log.* file\"\"\"\n \n     SUFFIXES = [\n         b\".missing\",\n         b\".snapshot.gz\",\n         b\".snapshot\",\n         b\".diff\",\n         b\".diff.gz\",\n         b\".dir\",\n     ]\n \n     def __init__(self, name):\n         \"\"\"Default constructor for an increment entry. User must provide the\n         repository directory and an entry name. The entry name correspond\n         to an error_log.* filename.\"\"\"\n         self.name, self.date, self.suffix = IncrementEntry._split(name)\n \n     @property\n     def isdir(self):\n         return self.suffix == b\".dir\"\n \n     @property\n     def is_missing(self):\n         \"\"\"Check if the curent entry is a missing increment.\"\"\"\n         return self.suffix == b\".missing\"\n \n     @property\n     def is_snapshot(self):\n         \"\"\"Check if the current entry is a snapshot increment.\"\"\"\n         return self.suffix in [b\".snapshot.gz\", b\".snapshot\"]\n \n     @classmethod\n     def _split(cls, filename):\n         \"\"\"Return tuple with filename, date, suffix\"\"\"\n         assert isinstance(filename, bytes)\n         # Extract suffix\n         suffix = None\n         for s in cls.SUFFIXES:\n             if filename.endswith(s):\n                 suffix = s\n                 break\n         if not suffix:\n             raise ValueError(filename)\n         # Parse date and raise error on failure\n         filename_without_suffix = filename[: -len(suffix)]\n         name, date_string = filename_without_suffix.rsplit(b'.', 1)\n         date_string = unquote(date_string).decode('ascii')\n         date = RdiffTime(date_string)\n         return (name, date, suffix)\n \n     def __gt__(self, other):\n         return self.date.__gt__(other.date)\n \n     def __lt__(self, other):\n         return self.date.__lt__(other.date)\n \n \n class FileStatisticsEntry(MetadataEntry):\n \n     \"\"\"\n     Represent a single file_statistics.\n \n     File Statistics contains different information related to each file of\n     the backup. This class provide a simple and easy way to access this\n     data.\n     \"\"\"\n \n     PREFIX = b'file_statistics.'\n     SUFFIXES = [b'.data', b'.data.gz']\n \n     def get_mirror_size(self, path):\n         \"\"\"Return the value of MirrorSize for the given file.\n         path is the relative path from repo root.\"\"\"\n         try:\n             return int(self._search(path)[\"mirror_size\"])\n         except ValueError:\n             logger.warning(\"mirror size not found for [%r]\", path, exc_info=1)\n             return 0\n \n     def get_source_size(self, path):\n         \"\"\"Return the value of SourceSize for the given file.\n         path is the relative path from repo root.\"\"\"\n         try:\n             return int(self._search(path)[\"source_size\"])\n         except ValueError:\n             logger.warning(\"source size not found for [%r]\", path, exc_info=1)\n             return 0\n \n     def _search(self, path):\n         \"\"\"\n         This function search for a file entry in the file_statistics compress\n         file. Since python gzip.open() seams to be 2 time slower, we directly use\n         zlib library on python2.\n         \"\"\"\n         logger.debug(\"read file_statistics [%r]\", self.name)\n \n         path += b' '\n \n         with self._open() as f:\n             for line in f:\n                 if not line.startswith(path):\n                     continue\n                 break\n \n         # Split the line into array\n         data = line.rstrip(b'\\r\\n').rsplit(b' ', 4)\n         # From array create an entry\n         return {'changed': data[1], 'source_size': data[2], 'mirror_size': data[3], 'increment_size': data[4]}\n \n \n class SessionStatisticsEntry(MetadataEntry):\n     \"\"\"Represent a single session_statistics.\"\"\"\n \n     PREFIX = b'session_statistics.'\n     SUFFIXES = [b'.data', b'.data.gz']\n \n     ATTRS = [\n         'starttime',\n         'endtime',\n         'elapsedtime',\n         'sourcefiles',\n         'sourcefilesize',\n         'mirrorfiles',\n         'mirrorfilesize',\n         'newfiles',\n         'newfilesize',\n         'deletedfiles',\n         'deletedfilesize',\n         'changedfiles',\n         'changedsourcesize',\n         'changedmirrorsize',\n         'incrementfiles',\n         'incrementfilesize',\n         'totaldestinationsizechange',\n         'errors',\n     ]\n \n     def _load(self):\n         \"\"\"This method is used to read the session_statistics and create the\n         appropriate structure to quickly get the data.\n \n         File Statistics contains different information related to each file of\n         the backup. This class provide a simple and easy way to access this\n         data.\"\"\"\n \n         with self._open() as f:\n             for line in f.readlines():\n                 # Read the line into array\n                 line = line.rstrip(b'\\r\\n')\n                 data_line = line.split(b\" \", 2)\n                 # Read line into tuple\n                 (key, value) = tuple(data_line)[0:2]\n                 if b'.' in value:\n                     value = float(value)\n                 else:\n                     value = int(value)\n                 setattr(self, key.lower().decode('ascii'), value)\n \n     def __getattr__(self, name):\n         \"\"\"\n         Intercept attribute getter to load the file.\n         \"\"\"\n         if name in self.ATTRS:\n             self._load()\n         return self.__dict__[name]\n \n \n class CurrentMirrorEntry(MetadataEntry):\n     PID_RE = re.compile(b\"^PID\\\\s*([0-9]+)\", re.I | re.M)\n \n     PREFIX = b'current_mirror.'\n     SUFFIXES = [b'.data']\n \n     def extract_pid(self):\n         \"\"\"\n         Return process ID from a current mirror marker, if any\n         \"\"\"\n         with open(self.path, 'rb') as f:\n             match = self.PID_RE.search(f.read())\n         if not match:\n             return None\n         return int(match.group(1))\n \n \n class LogEntry(MetadataEntry):\n     PREFIX = b'error_log.'\n     SUFFIXES = [b'.data', b'.data.gz']\n \n     @cached_property\n     def is_empty(self):\n         \"\"\"\n         Check if the increment entry is empty.\n         \"\"\"\n         return os.path.getsize(self.path) == 0\n \n     def read(self):\n         \"\"\"Read the error file and return it's content. Raise exception if the\n         file can't be read.\"\"\"\n         # To avoid opening empty file, check the file size first.\n         if self.is_empty:\n             return \"\"\n         encoding = self.repo._encoding.name\n         if self._is_compressed:\n             return subprocess.check_output(\n                 ['zcat', self.path],\n                 stdout=subprocess.PIPE,\n                 stderr=subprocess.STDOUT,\n                 encoding=encoding,\n                 errors='replace',\n             )\n         with open(self.path, 'r', encoding=encoding, errors='replace') as f:\n             return f.read()\n \n     def tail(self, num=2000):\n         \"\"\"\n         Tail content of the file. This is used for logs.\n         \"\"\"\n         # To avoid opening empty file, check the file size first.\n         if self.is_empty:\n             return b''\n         encoding = self.repo._encoding.name\n         if self._is_compressed:\n             zcat = subprocess.Popen([b'zcat', self.path], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n             return subprocess.check_output(\n                 ['tail', '-n', str(num)],\n                 stdin=zcat.stdout,\n                 stderr=subprocess.STDOUT,\n                 encoding=encoding,\n                 errors='replace',\n             )\n         return subprocess.check_output(\n             ['tail', '-n', str(num), self.path], stderr=subprocess.STDOUT, encoding=encoding, errors='replace'\n         )\n \n \n class RestoreLogEntry(LogEntry):\n     PREFIX = b'restore.'\n     SUFFIXES = [b'.log']\n \n     @staticmethod\n     def on_date_error(e):\n         return None\n \n \n class BackupLogEntry(LogEntry):\n     PREFIX = b'backup.'\n     SUFFIXES = [b'.log']\n \n     @staticmethod\n     def on_date_error(e):\n         return None\n \n \n class MetadataKeys:\n     \"\"\"\n     Provide a view on metadata dict keys. See MetadataDict#keys()\n     \"\"\"\n \n     def __init__(self, function, sequence):\n         self._f = function\n         self._sequence = sequence\n \n     def __iter__(self):\n         return map(self._f, self._sequence)\n \n     def __getitem__(self, i):\n         if isinstance(i, slice):\n             return list(map(self._f, self._sequence[i]))\n         else:\n             return self._f(self._sequence[i])\n \n     def __len__(self):\n         return len(self._sequence)\n \n \n class MetadataDict(object):\n     \"\"\"\n     This is used to access repository metadata quickly in a pythonic way. It\n     make an abstraction to access a range of increment entries using index and\n     date while also supporting slice to get a range of entries.\n     \"\"\"\n \n     def __init__(self, repo, cls):\n         assert isinstance(repo, RdiffRepo)\n         assert hasattr(cls, '__call__')\n         self._repo = repo\n         assert cls.PREFIX\n         self._prefix = cls.PREFIX\n         self._cls = cls\n \n     @cached_property\n     def _entries(self):\n         return [e for e in self._repo._entries if e.startswith(self._prefix)]\n \n     def __getitem__(self, key):\n         if isinstance(key, RdiffTime):\n             idx = bisect.bisect_left(self.keys(), key)\n             if idx < len(self._entries):\n                 item = self._cls(self._repo, self._entries[idx])\n                 if item.date == key:\n                     return item\n             raise KeyError(key)\n         elif isinstance(key, slice):\n             if isinstance(key.start, RdiffTime):\n                 idx = bisect.bisect_left(self.keys(), key.start)\n                 key = slice(idx, key.stop, key.step)\n             if isinstance(key.stop, RdiffTime):\n                 idx = bisect.bisect_right(self.keys(), key.stop)\n                 key = slice(key.start, idx, key.step)\n             return [self._cls(self._repo, e) for e in self._entries[key]]\n         elif isinstance(key, int):\n             try:\n                 return self._cls(self._repo, self._entries[key])\n             except IndexError:\n                 raise KeyError(key)\n         else:\n             raise KeyError(key)\n \n     def __iter__(self):\n         for e in self._entries:\n             yield self._cls(self._repo, e)\n \n     def __len__(self):\n         return len(self._entries)\n \n     def keys(self):\n         return MetadataKeys(lambda e: self._cls._extract_date(e), self._entries)\n \n \n class RdiffRepo(object):\n \n     \"\"\"Represent one rdiff-backup repository.\"\"\"\n \n     def __init__(self, user_root, path, encoding):\n         if isinstance(user_root, str):\n             user_root = os.fsencode(user_root)\n         if isinstance(path, str):\n             path = os.fsencode(path)\n         assert isinstance(user_root, bytes)\n         assert isinstance(path, bytes)\n         assert encoding\n         self._encoding = encodings.search_function(encoding)\n         assert self._encoding\n         self.path = path.strip(b\"/\")\n         if self.path:\n             self.full_path = os.path.normpath(os.path.join(user_root, self.path))\n         else:\n             self.full_path = os.path.normpath(user_root)\n \n         # The location of rdiff-backup-data directory.\n         self._data_path = os.path.join(self.full_path, RDIFF_BACKUP_DATA)\n         assert isinstance(self._data_path, bytes)\n         self._increment_path = os.path.join(self._data_path, INCREMENTS)\n         self.current_mirror = MetadataDict(self, CurrentMirrorEntry)\n         self.error_log = MetadataDict(self, LogEntry)\n         self.mirror_metadata = MetadataDict(self, MirrorMetadataEntry)\n         self.file_statistics = MetadataDict(self, FileStatisticsEntry)\n         self.session_statistics = MetadataDict(self, SessionStatisticsEntry)\n \n     @property\n     def backup_dates(self):\n         \"\"\"Return a list of dates when backup was executed. This list is\n         sorted from old to new (ascending order). To identify dates,\n         'mirror_metadata' file located in rdiff-backup-data are used.\"\"\"\n         return self.mirror_metadata.keys()\n \n     @property\n     def backup_log(self):\n         \"\"\"\n         Return the location of the backup log.\n         \"\"\"\n         return BackupLogEntry(self, b'backup.log')\n \n     def delete(self, path):\n         \"\"\"\n         Delete this entry from the repository history using rdiff-backup-delete.\n         \"\"\"\n         path_obj = self.fstat(path)\n         if path_obj.isroot:\n             return self.delete_repo()\n \n         rdiff_backup_delete = find_rdiff_backup_delete()\n         cmdline = [rdiff_backup_delete, path_obj.full_path]\n         logger.info('executing: %r' % cmdline)\n         process = subprocess.Popen(cmdline, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, env={'LANG': LANG})\n         for line in process.stdout:\n             line = line.rstrip(b'\\n').decode('utf-8', errors='replace')\n             logger.info('rdiff-backup-delete: %s' % line)\n         retcode = process.wait()\n         if retcode:\n             raise CalledProcessError(retcode, cmdline)\n \n     def delete_repo(self):\n         \"\"\"Delete the repository permanently.\"\"\"\n         # Try to change the permissions of the file or directory to delete\n         # them.\n         def handle_error(func, path, exc_info):\n             if exc_info[0] == PermissionError:\n                 # Parent directory must allow rwx\n                 if not os.access(os.path.dirname(path), os.W_OK | os.R_OK | os.X_OK):\n                     os.chmod(os.path.dirname(path), 0o0700)\n                 if not os.access(path, os.W_OK | os.R_OK):\n                     os.chmod(path, 0o0600)\n                 if os.path.isdir(path):\n                     return shutil.rmtree(path, onerror=handle_error)\n                 else:\n                     return os.unlink(path)\n             raise\n \n         try:\n             shutil.rmtree(self.full_path, onerror=handle_error)\n         except Exception:\n             logger.warning('fail to delete repo', exc_info=1)\n \n     @property\n     def display_name(self):\n         \"\"\"Return the most human representation of the repository name.\"\"\"\n         return self.get_display_name(b'')\n \n     def _decode(self, value, errors='replace'):\n         \"\"\"Used to decode a repository path into unicode.\"\"\"\n         assert isinstance(value, bytes)\n         return self._encoding.decode(value, errors)[0]\n \n     @cached_property\n     def _entries(self):\n         return sorted(os.listdir(self._data_path))\n \n     def listdir(self, path):\n         \"\"\"\n         Return a list of RdiffDirEntry each representing a file or a folder in the given path.\n         \"\"\"\n         # Compute increment directory location.\n         full_path = os.path.realpath(os.path.join(self.full_path, path.strip(b'/')))\n         relative_path = os.path.relpath(full_path, self.full_path)\n         if relative_path.startswith(RDIFF_BACKUP_DATA):\n             raise DoesNotExistError(path)\n         increment_path = os.path.normpath(os.path.join(self._increment_path, relative_path))\n         if not full_path.startswith(self.full_path) or not increment_path.startswith(self.full_path):\n             raise AccessDeniedError('%s make reference outside the repository')\n \n         # Get list of all increments and existing file and folder\n         try:\n             existing_items = os.listdir(full_path)\n             if relative_path == b'.':\n                 existing_items.remove(RDIFF_BACKUP_DATA)\n         except (NotADirectoryError, FileNotFoundError):\n             existing_items = []\n         except OSError:\n             raise AccessDeniedError(path)\n         try:\n             increment_items = os.listdir(increment_path)\n         except (NotADirectoryError, FileNotFoundError):\n             increment_items = []\n         except OSError:\n             raise AccessDeniedError(path)\n         # Raise error if nothing is found\n         if not existing_items and not increment_items:\n             raise DoesNotExistError(path)\n \n         # Merge information from both location\n         # Regroup all information into RdiffDirEntry\n         entries = {}\n         for name in existing_items:\n             entries[name] = RdiffDirEntry(\n                 self,\n                 os.path.normpath(os.path.join(relative_path, name)),\n                 exists=True,\n                 increments=[],\n             )\n         for item in increment_items:\n             try:\n                 increment = IncrementEntry(item)\n             except ValueError:\n                 # Ignore any increment that cannot be parsed\n                 continue\n             entry = entries.get(increment.name, None)\n             if not entry:\n                 # Create a new Direntry\n                 entry = entries[increment.name] = RdiffDirEntry(\n                     self,\n                     os.path.normpath(os.path.join(relative_path, increment.name)),\n                     exists=False,\n                     increments=[increment] if increment else [],\n                 )\n             else:\n                 # Add increment to dir entry\n                 bisect.insort_left(entry._increments, increment)\n         return sorted(list(entries.values()), key=lambda e: e.path)\n \n     def fstat(self, path):\n         \"\"\"Return a new instance of DirEntry to represent the given path.\"\"\"\n         # Compute increment directory location.\n         assert isinstance(path, bytes)\n         full_path = os.path.normpath(os.path.join(self.full_path, path.strip(b'/')))\n         increment_path = os.path.normpath(os.path.join(self._increment_path, path.strip(b'/'), b'..'))\n         if not full_path.startswith(self.full_path) or not increment_path.startswith(self.full_path):\n             raise AccessDeniedError('%s make reference outside the repository')\n         relative_path = os.path.relpath(full_path, self.full_path)\n         if relative_path.startswith(RDIFF_BACKUP_DATA):\n             raise DoesNotExistError(path)\n         # Get if the path request is the root path.\n         if relative_path == b'.':\n             return RdiffDirEntry(self, b'', True, [])\n \n         # TODO Check symlink\n         # p = os.path.realpath(os.path.join(self.full_path, path))\n         # if not p.startswith(self.full_path):\n         #    raise AccessDeniedError(path)\n \n         # Check if path exists\n         try:\n             os.lstat(full_path)\n             exists = True\n         except (OSError, ValueError):\n             exists = False\n \n         # Get incrmement data\n         increment_items = os.listdir(increment_path)\n \n         # Create dir entry\n         prefix = os.path.basename(full_path)\n         entry = RdiffDirEntry(self, relative_path, exists, [])\n         for item in increment_items:\n             if not item.startswith(prefix):\n                 # Ignore increment not matching our path\n                 continue\n             try:\n                 increment = IncrementEntry(item)\n             except ValueError:\n                 # Ignore any increment that cannot be parsed\n                 continue\n             if increment.name != prefix:\n                 # Ignore increment not matching our path\n                 continue\n             # Add increment to dir entry\n             bisect.insort_left(entry._increments, increment)\n \n         # Check if path exists or has increment. If not raise an exception.\n         if not exists and not entry._increments:\n             logger.error(\"path [%r] doesn't exists\", path)\n             raise DoesNotExistError(path)\n \n         # Create a directory entry.\n         return entry\n \n     @property\n     def last_backup_date(self):\n         \"\"\"Return the last known backup dates.\"\"\"\n         try:\n             if len(self.current_mirror) > 0:\n                 return self.current_mirror[-1].date\n             return None\n         except (PermissionError, FileNotFoundError):\n             return None\n \n     def get_display_name(self, path):\n         \"\"\"\n         Return proper display name of the given path according to repository encoding and quoted characters.\n         \"\"\"\n         assert isinstance(path, bytes)\n         path = path.strip(b'/')\n         if path in [b'.', b'']:\n             # For repository we use either path if defined or the directory base name\n             if not self.path:\n                 return self._decode(unquote(os.path.basename(self.full_path)))\n             return self._decode(unquote(self.path))\n         else:\n             # For path, we use the dir name\n             return self._decode(unquote(os.path.basename(path)))\n \n     def remove_older(self, remove_older_than):\n         logger.info(\"execute rdiff-backup --force --remove-older-than=%sD %r\", remove_older_than, self.full_path)\n         subprocess.call(\n             [\n                 b'rdiff-backup',\n                 b'--force',\n                 b'--remove-older-than=' + str(remove_older_than).encode(encoding='latin1') + b'D',\n                 self.full_path,\n             ]\n         )\n \n     def restore(self, path, restore_as_of, kind=None):\n         \"\"\"\n         Restore the current directory entry into a fileobj containing the\n         file content of the directory compressed into an archive.\n \n         `kind` must be one of the supported archive type or none to use `zip` for folder and `raw` for file.\n \n         Return a filename and a fileobj.\n         \"\"\"\n         assert isinstance(path, bytes)\n         assert restore_as_of, \"restore_as_of must be defined\"\n         assert kind in ['tar', 'tar.bz2', 'tar.gz', 'tbz2', 'tgz', 'zip', 'raw', None]\n \n         # Define proper kind according to path type.\n         path_obj = self.fstat(path)\n         if path_obj.isdir:\n             if kind == 'raw':\n                 raise ValueError('raw type not supported for directory')\n             kind = kind or 'zip'\n         else:\n             kind = kind or 'raw'\n \n         # Define proper filename according to the path\n         if kind == 'raw':\n             filename = path_obj.display_name\n         else:\n             filename = \"%s.%s\" % (path_obj.display_name, kind)\n \n         # Call external process to offload processing.\n         # python -m rdiffweb.core.restore --restore-as-of 123456 --encoding utf-8 --kind zip -\n         cmdline = [\n             os.fsencode(sys.executable),\n             b'-m',\n             b'rdiffweb.core.restore',\n             b'--restore-as-of',\n             str(restore_as_of).encode('latin'),\n             b'--encoding',\n             self._encoding.name.encode('latin'),\n             b'--kind',\n             kind.encode('latin'),\n             os.path.join(self.full_path, unquote(path_obj.path)),\n             b'-',\n         ]\n         proc = subprocess.Popen(\n             cmdline,\n             shell=False,\n             stdout=subprocess.PIPE,\n             stderr=subprocess.PIPE,\n             env=None,\n         )\n         # Check if the processing is properly started\n         # Read stderr output until \"Starting restore of\"\n         output = b''\n         success = False\n         line = proc.stderr.readline()\n         while line:\n             output += line\n             if b'Starting restore of' in line:\n                 success = True\n                 break\n             line = proc.stderr.readline()\n         if not success:\n             raise CalledProcessError(1, cmdline, output)\n         # Start a Thread to pipe the rest of the stream to the log\n         t = threading.Thread(target=_readerthread, args=(proc.stderr, logger.debug))\n         t.daemon = True\n         t.start()\n         return filename, _wrap_close(proc.stdout, proc)\n \n     @property\n     def restore_log(self):\n         \"\"\"\n         Return the location of the restore log.\n         \"\"\"\n         return RestoreLogEntry(self, b'restore.log')\n \n     @cached_property\n     def status(self):\n         \"\"\"Check if a backup is in progress for the current repo.\"\"\"\n \n         # Read content of the file and check if pid still exists\n         try:\n             # Make sure repoRoot is a valid rdiff-backup repository\n             for current_mirror in self.current_mirror:\n                 pid = current_mirror.extract_pid()\n                 try:\n                     p = psutil.Process(pid)\n                     if any('rdiff-backup' in c for c in p.cmdline()):\n                         return ('in_progress', _('A backup is currently in progress to this repository.'))\n                 except psutil.NoSuchProcess:\n                     logger.debug('pid [%s] does not exists', pid)\n \n             # If multiple current_mirror file exists and none of them are associated to a PID, this mean the last backup was interrupted.\n             # Also, if the last backup date is undefined, this mean the first\n             # initial backup was interrupted.\n             if len(self.current_mirror) > 1 or len(self.current_mirror) == 0:\n                 self._status = ('interrupted', _('The previous backup seams to have failed.'))\n                 return self._status\n         except FileNotFoundError:\n             self._entries = []\n             return ('failed', _('The repository cannot be found or is badly damaged.'))\n         except PermissionError:\n             self._entries = []\n             logger.warning('error reading current_mirror files', exc_info=1)\n             return ('failed', _(\"Permissions denied. Contact administrator to check repository's permissions.\"))\n \n         return ('ok', '')\n ", "input_code": "def unquote(name):\n\"\"\"\nRemove quote from the given name.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def unquote(name):\n    \"\"\"Remove quote from the given name.\"\"\"\n    assert isinstance(name, bytes)\n\n    # This function just gives back the original text if it can decode it\n    def unquoted_char(match):\n        \"\"\"For each ;000 return the corresponding byte.\"\"\"\n        if len(match.group()) != 4:\n            return match.group\n        try:\n            return bytes([int(match.group()[1:])])\n        except ValueError:\n            return match.group\n\n    # Remove quote using regex\n    return re.sub(b\";[0-9]{3}\", unquoted_char, name, re.S)", "signature": "def unquote(name):", "completion_path": "rdiffweb/core/librdiff.py"}
{"ce_id": "62ece4982e6aefcf4aabbd73", "namespace": "62ece4982e6aefcf4aabbd73", "namespace_real": "cloudmesh.common.shlex.split", "real_proj_path": "cloudmesh---cloudmesh-common/", "type": "function", "class_name": null, "function_name": "split", "contexts_above": "# This file was copied from https://github.com/jdjebi/winshlex\n#\nimport sys\nimport re\n", "contexts_below": "", "input_code": "def split(s, platform='this'):\n\"\"\"\nMulti-platform variant of shlex.split() for command-line splitting.\nFor use with subprocess, for argv injection etc. Using fast REGEX.\n\nplatform: 'this' = auto from current platform;\n          1 = POSIX;\n          0 = Windows/CMD\n          (other values reserved)\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def split(s, platform='this'):\n    \"\"\"Multi-platform variant of shlex.split() for command-line splitting.\n    For use with subprocess, for argv injection etc. Using fast REGEX.\n\n    platform: 'this' = auto from current platform;\n              1 = POSIX;\n              0 = Windows/CMD\n              (other values reserved)\n    \"\"\"\n    if platform == 'this':\n        platform = (sys.platform != 'win32')\n    if platform == 1:\n        RE_CMD_LEX = r'''\"((?:\\\\[\"\\\\]|[^\"])*)\"|'([^']*)'|(\\\\.)|(&&?|\\|\\|?|\\d?\\>|[<])|([^\\s'\"\\\\&|<>]+)|(\\s+)|(.)'''\n    elif platform == 0:\n        RE_CMD_LEX = r'''\"((?:\"\"|\\\\[\"\\\\]|[^\"])*)\"?()|(\\\\\\\\(?=\\\\*\")|\\\\\")|(&&?|\\|\\|?|\\d?>|[<])|([^\\s\"&|<>]+)|(\\s+)|(.)'''\n    else:\n        raise AssertionError('unkown platform %r' % platform)\n\n    args = []\n    accu = None   # collects pieces of one arg\n    for qs, qss, esc, pipe, word, white, fail in re.findall(RE_CMD_LEX, s):\n        if word:\n            pass   # most frequent\n        elif esc:\n            word = esc[1]\n        elif white or pipe:\n            if accu is not None:\n                args.append(accu)\n            if pipe:\n                args.append(pipe)\n            accu = None\n            continue\n        elif fail:\n            raise ValueError(\"invalid or incomplete shell string\")\n        elif qs:\n            word = qs.replace('\\\\\"', '\"').replace('\\\\\\\\', '\\\\')\n            if platform == 0:\n                word = word.replace('\"\"', '\"')\n        else:\n            word = qss   # may be even empty; must be last\n\n        accu = (accu or '') + word\n\n    if accu is not None:\n        args.append(accu)\n\n    return args", "signature": "def split(s, platform='this'):", "completion_path": "cloudmesh/common/shlex.py"}
{"ce_id": "62ece4982e6aefcf4aabbd74", "namespace": "62ece4982e6aefcf4aabbd74", "namespace_real": "swh.lister.arch.tests.__init__.prepare_repository_from_archive", "real_proj_path": "SoftwareHeritage---swh-lister/", "type": "function", "class_name": null, "function_name": "prepare_repository_from_archive", "contexts_above": "# Copyright (C) 2022 the Software Heritage developers\n# License: GNU General Public License version 3, or any later version\n# See top-level LICENSE file for more information\n\nimport os\nfrom pathlib import PosixPath\nimport subprocess\nfrom typing import Optional, Union\n\n# TODO: prepare_repository_from_archive method is duplicated from crates lister tests,\n# centralize to tests utils?\n\n", "contexts_below": "", "input_code": "def prepare_repository_from_archive(archive_path: str, filename: Optional[str]=None, tmp_path: Union[PosixPath, str]='/tmp') -> str:\n\"\"\"\nGiven an existing archive_path, uncompress it.\nReturns a file repo url which can be used as origin url.\n\nThis does not deal with the case where the archive passed along does not exist.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def prepare_repository_from_archive(\n    archive_path: str,\n    filename: Optional[str] = None,\n    tmp_path: Union[PosixPath, str] = \"/tmp\",\n) -> str:\n    \"\"\"Given an existing archive_path, uncompress it.\n    Returns a file repo url which can be used as origin url.\n\n    This does not deal with the case where the archive passed along does not exist.\n    \"\"\"\n    if not isinstance(tmp_path, str):\n        tmp_path = str(tmp_path)\n    # uncompress folder/repositories/dump for the loader to ingest\n    subprocess.check_output([\"tar\", \"xf\", archive_path, \"-C\", tmp_path])\n    # build the origin url (or some derivative form)\n    _fname = filename if filename else os.path.basename(archive_path)\n    repo_url = f\"file://{tmp_path}/{_fname}\"\n    return repo_url", "signature": "def prepare_repository_from_archive(archive_path: str, filename: Optional[str]=None, tmp_path: Union[PosixPath, str]='/tmp') -> str:", "completion_path": "swh/lister/arch/tests/__init__.py"}
{"ce_id": "62ece4982e6aefcf4aabbd75", "namespace": "62ece4982e6aefcf4aabbd75", "namespace_real": "src.flashbake.plugins.ignored.addignored", "real_proj_path": "commandline---flashbake/", "type": "class", "class_name": "ignored", "function_name": "addignored", "contexts_above": "#    Copyright 2022 Ian Paul\n#    Copyright 2009 Thomas Gideon\n#\n#    This file is part of flashbake.\n#\n#    flashbake is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#    (at your option) any later version.\n#\n#    flashbake is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n#\n#    You should have received a copy of the GNU General Public License\n#    along with flashbake.  If not, see <http://www.gnu.org/licenses/>.\n\n''' This plugin was inspired by a suggestion from @xtaran on GitHub. It adds information to the commit message about files in the specified directory that are present and being ignored by git. '''\n\nfrom flashbake.plugins import AbstractMessagePlugin\nimport subprocess\n\nclass Ignored(AbstractMessagePlugin):\n    def __init__(self, plugin_spec):\n        AbstractMessagePlugin.__init__(self, plugin_spec, False)\n        self.define_property('ignored', required=False) \n    def addcontext(self, message_file, config):\n\n        ''' Add a list of the git repository's ignored but present files. '''\n        if self.ignored == None:\n            message_file.write('Please specify the git directory containing ignored files.')\n        else:\n            t = self.addignored(self.ignored)\n            message_file.write(t)\n", "contexts_below": "", "input_code": "def addignored(self, ignored):\n\"\"\"\nUse the git command to obtain the file names, turn it into a list, sort the list for only ignored files, return those files as a single string with each filename separated by a comma.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def addignored(self, ignored):\n        ''' Use the git command to obtain the file names, turn it into a list, sort the list for only ignored files, return those files as a single string with each filename separated by a comma.'''\n        fldr=subprocess.run([\"git\", \"-C\", ignored, \"status\", \"-s\", \"--ignored\"], capture_output=True, text=True).stdout.strip(\"\\n\")\n        x = fldr.splitlines()\n        sub = \"!\"\n        g = ([s for s in x if sub in s])\n        i = [elem.replace(sub, '') for elem in g]\n        t = \", \".join(i)\n        return t", "signature": "def addignored(self, ignored):", "completion_path": "src/flashbake/plugins/ignored.py"}
{"ce_id": "62ece4982e6aefcf4aabbd76", "namespace": "62ece4982e6aefcf4aabbd76", "namespace_real": "docopt.__init__.match", "real_proj_path": "bazaar-projects---docopt-ng/", "type": "class", "class_name": "__init__", "function_name": "match", "contexts_above": "\"\"\"Docopt is a Pythonic command-line interface parser that will make you smile.\n\nNow: with spellcheck, flag extension (de-abbreviation), and capitalization fixes.\n(but only when unambiguous)\n\n * Licensed under terms of MIT license (see LICENSE-MIT)\n\nContributors (roughly in chronological order):\n\n * Copyright (c) 2012 Andrew Kassen <atkassen@ucdavis.edu>\n * Copyright (c) 2012 jeffrimko <jeffrimko@gmail.com>\n * Copyright (c) 2012 Andrew Sutton <met48@met48.com>\n * Copyright (c) 2012 Andrew Sutton <met48@met48.com>\n * Copyright (c) 2012 Nima Johari <nimajohari@gmail.com>\n * Copyright (c) 2012-2013 Vladimir Keleshev, vladimir@keleshev.com\n * Copyright (c) 2014-2018 Matt Boersma <matt@sprout.org>\n * Copyright (c) 2016 amir <ladsgroup@gmail.com>\n * Copyright (c) 2015 Benjamin Bach <benjaoming@gmail.com>\n * Copyright (c) 2017 Oleg Bulkin <o.bulkin@gmail.com>\n * Copyright (c) 2018 Iain Barnett <iainspeed@gmail.com>\n * Copyright (c) 2019 itdaniher, itdaniher@gmail.com\n\n\"\"\"\nfrom __future__ import annotations\n\nimport sys\nimport re\nimport inspect\n\nfrom typing import Any, Type, Union, Callable, cast\n\n__all__ = [\"docopt\", \"magic_docopt\", \"magic\", \"DocoptExit\"]\n__version__ = \"0.7.2\"\n\n\ndef levenshtein_norm(source: str, target: str) -> float:\n    \"\"\"Calculates the normalized Levenshtein distance between two string\n    arguments. The result will be a float in the range [0.0, 1.0], with 1.0\n    signifying the biggest possible distance between strings with these lengths\n    \"\"\"\n\n    # Compute Levenshtein distance using helper function. The max is always\n    # just the length of the longer string, so this is used to normalize result\n    # before returning it\n    distance = levenshtein(source, target)\n    return float(distance) / max(len(source), len(target))\n\n\ndef levenshtein(source: str, target: str) -> int:\n    \"\"\"Computes the Levenshtein\n    (https://en.wikipedia.org/wiki/Levenshtein_distance)\n    and restricted Damerau-Levenshtein\n    (https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance)\n    distances between two Unicode strings with given lengths using the\n    Wagner-Fischer algorithm\n    (https://en.wikipedia.org/wiki/Wagner%E2%80%93Fischer_algorithm).\n    These distances are defined recursively, since the distance between two\n    strings is just the cost of adjusting the last one or two characters plus\n    the distance between the prefixes that exclude these characters (e.g. the\n    distance between \"tester\" and \"tested\" is 1 + the distance between \"teste\"\n    and \"teste\"). The Wagner-Fischer algorithm retains this idea but eliminates\n    redundant computations by storing the distances between various prefixes in\n    a matrix that is filled in iteratively.\n    \"\"\"\n\n    # Create matrix of correct size (this is s_len + 1 * t_len + 1 so that the\n    # empty prefixes \"\" can also be included). The leftmost column represents\n    # transforming various source prefixes into an empty string, which can\n    # always be done by deleting all characters in the respective prefix, and\n    # the top row represents transforming the empty string into various target\n    # prefixes, which can always be done by inserting every character in the\n    # respective prefix. The ternary used to build the list should ensure that\n    # this row and column are now filled correctly\n    s_range = range(len(source) + 1)\n    t_range = range(len(target) + 1)\n    matrix = [[(i if j == 0 else j) for j in t_range] for i in s_range]\n\n    # Iterate through rest of matrix, filling it in with Levenshtein\n    # distances for the remaining prefix combinations\n    for i in s_range[1:]:\n        for j in t_range[1:]:\n            # Applies the recursive logic outlined above using the values\n            # stored in the matrix so far. The options for the last pair of\n            # characters are deletion, insertion, and substitution, which\n            # amount to dropping the source character, the target character,\n            # or both and then calculating the distance for the resulting\n            # prefix combo. If the characters at this point are the same, the\n            # situation can be thought of as a free substitution\n            del_dist = matrix[i - 1][j] + 1\n            ins_dist = matrix[i][j - 1] + 1\n            sub_trans_cost = 0 if source[i - 1] == target[j - 1] else 1\n            sub_dist = matrix[i - 1][j - 1] + sub_trans_cost\n\n            # Choose option that produces smallest distance\n            matrix[i][j] = min(del_dist, ins_dist, sub_dist)\n\n    # At this point, the matrix is full, and the biggest prefixes are just the\n    # strings themselves, so this is the desired distance\n    return matrix[len(source)][len(target)]\n\n\nclass DocoptLanguageError(Exception):\n\n    \"\"\"Error in construction of usage-message by developer.\"\"\"\n\n\nclass DocoptExit(SystemExit):\n\n    \"\"\"Exit in case user invoked program with incorrect arguments.\"\"\"\n\n    usage = \"\"\n\n    def __init__(\n        self,\n        message: str = \"\",\n        collected: list[Pattern] = None,\n        left: list[Pattern] = None,\n    ) -> None:\n        self.collected = collected if collected is not None else []\n        self.left = left if left is not None else []\n        SystemExit.__init__(self, (message + \"\\n\" + self.usage).strip())\n\n\nclass Pattern:\n    def __init__(\n        self, name: str | None, value: list[str] | str | int | None = None\n    ) -> None:\n        self._name, self.value = name, value\n\n    @property\n    def name(self) -> str | None:\n        return self._name\n\n    def __eq__(self, other) -> bool:\n        return repr(self) == repr(other)\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n\ndef transform(pattern: BranchPattern) -> Either:\n    \"\"\"Expand pattern into an (almost) equivalent one, but with single Either.\n\n    Example: ((-a | -b) (-c | -d)) => (-a -c | -a -d | -b -c | -b -d)\n    Quirks: [-a] => (-a), (-a...) => (-a -a)\n\n    \"\"\"\n    result = []\n    groups = [[pattern]]\n    while groups:\n        children = groups.pop(0)\n        parents = [Required, NotRequired, OptionsShortcut, Either, OneOrMore]\n        if any(t in map(type, children) for t in parents):\n            child = [c for c in children if type(c) in parents][0]\n            children.remove(child)\n            if type(child) is Either:\n                for c in child.children:\n                    groups.append([c] + children)\n            elif type(child) is OneOrMore:\n                groups.append(child.children * 2 + children)\n            else:\n                groups.append(child.children + children)\n        else:\n            result.append(children)\n    return Either(*[Required(*e) for e in result])\n\n\nTSingleMatch = tuple[Union[int, None], Union[\"LeafPattern\", None]]\n\n\nclass LeafPattern(Pattern):\n\n    \"\"\"Leaf/terminal node of a pattern tree.\"\"\"\n\n    def __repr__(self) -> str:\n        return \"%s(%r, %r)\" % (self.__class__.__name__, self.name, self.value)\n\n    def single_match(self, left: list[LeafPattern]) -> TSingleMatch:\n        raise NotImplementedError  # pragma: no cover\n\n    def flat(self, *types) -> list[LeafPattern]:\n        return [self] if not types or type(self) in types else []\n", "contexts_below": "\n class BranchPattern(Pattern):\n \n     \"\"\"Branch/inner node of a pattern tree.\"\"\"\n \n     def __init__(self, *children) -> None:\n         self.children = list(children)\n \n     def match(self, left: list[Pattern], collected: list[Pattern] = None) -> Any:\n         raise NotImplementedError  # pragma: no cover\n \n     def fix(self) -> \"BranchPattern\":\n         self.fix_identities()\n         self.fix_repeating_arguments()\n         return self\n \n     def fix_identities(self, uniq: Any | None = None) -> None:\n         \"\"\"Make pattern-tree tips point to same object if they are equal.\"\"\"\n         flattened = self.flat()\n         uniq = list(set(flattened)) if uniq is None else uniq\n         for i, child in enumerate(self.children):\n             if not hasattr(child, \"children\"):\n                 assert child in uniq\n                 self.children[i] = uniq[uniq.index(child)]\n             else:\n                 child.fix_identities(uniq)\n         return None\n \n     def fix_repeating_arguments(self) -> BranchPattern:\n         \"\"\"Fix elements that should accumulate/increment values.\"\"\"\n         either = [list(child.children) for child in transform(self).children]\n         for case in either:\n             for e in [child for child in case if case.count(child) > 1]:\n                 if type(e) is Argument or type(e) is Option and e.argcount:\n                     if e.value is None:\n                         e.value = []\n                     elif type(e.value) is not list:\n                         e.value = cast(str, e.value)\n                         e.value = e.value.split()\n                 if type(e) is Command or type(e) is Option and e.argcount == 0:\n                     e.value = 0\n         return self\n \n     def __repr__(self) -> str:\n         return \"%s(%s)\" % (\n             self.__class__.__name__,\n             \", \".join(repr(a) for a in self.children),\n         )\n \n     def flat(self, *types) -> Any:\n         if type(self) in types:\n             return [self]\n         return sum([child.flat(*types) for child in self.children], [])\n \n \n class Argument(LeafPattern):\n     def single_match(self, left: list[LeafPattern]) -> TSingleMatch:\n         for n, pattern in enumerate(left):\n             if type(pattern) is Argument:\n                 return n, Argument(self.name, pattern.value)\n         return None, None\n \n \n class Command(Argument):\n     def __init__(self, name: str | None, value: bool = False) -> None:\n         self._name, self.value = name, value\n \n     def single_match(self, left: list[LeafPattern]) -> TSingleMatch:\n         for n, pattern in enumerate(left):\n             if type(pattern) is Argument:\n                 if pattern.value == self.name:\n                     return n, Command(self.name, True)\n                 else:\n                     break\n         return None, None\n \n \n class Option(LeafPattern):\n     def __init__(\n         self,\n         short: str | None = None,\n         longer: str | None = None,\n         argcount: int = 0,\n         value: list[str] | str | int | None = False,\n     ) -> None:\n         assert argcount in (0, 1)\n         self.short, self.longer, self.argcount = short, longer, argcount\n         self.value = None if value is False and argcount else value\n \n     @classmethod\n     def parse(class_, option_description: str) -> Option:\n         short, longer, argcount, value = None, None, 0, False\n         options, _, description = option_description.strip().partition(\"  \")\n         options = options.replace(\",\", \" \").replace(\"=\", \" \")\n         for s in options.split():\n             if s.startswith(\"--\"):\n                 longer = s\n             elif s.startswith(\"-\"):\n                 short = s\n             else:\n                 argcount = 1\n         if argcount:\n             matched = re.findall(r\"\\[default: (.*)\\]\", description, flags=re.I)\n             value = matched[0] if matched else None\n         return class_(short, longer, argcount, value)\n \n     def single_match(self, left: list[LeafPattern]) -> TSingleMatch:\n         for n, pattern in enumerate(left):\n             if self.name == pattern.name:\n                 return n, pattern\n         return None, None\n \n     @property\n     def name(self) -> str | None:\n         return self.longer or self.short\n \n     def __repr__(self) -> str:\n         return \"Option(%r, %r, %r, %r)\" % (\n             self.short,\n             self.longer,\n             self.argcount,\n             self.value,\n         )\n \n \n class Required(BranchPattern):\n     def match(self, left: list[Pattern], collected: list[Pattern] | None = None) -> Any:\n         collected = [] if collected is None else collected\n         original_collected = collected\n         original_left = left\n         for pattern in self.children:\n             matched, left, collected = pattern.match(left, collected)\n             if not matched:\n                 return False, original_left, original_collected\n         return True, left, collected\n \n \n class NotRequired(BranchPattern):\n     def match(self, left: list[Pattern], collected: list[Pattern] = None) -> Any:\n         collected = [] if collected is None else collected\n         for pattern in self.children:\n             _, left, collected = pattern.match(left, collected)\n         return True, left, collected\n \n \n class OptionsShortcut(NotRequired):\n \n     \"\"\"Marker/placeholder for [options] shortcut.\"\"\"\n \n \n class OneOrMore(BranchPattern):\n     def match(self, left: list[Pattern], collected: list[Pattern] = None) -> Any:\n         assert len(self.children) == 1\n         collected = [] if collected is None else collected\n         original_collected = collected\n         original_left = left\n         last_left = None\n         matched = True\n         times = 0\n         while matched:\n             matched, left, collected = self.children[0].match(left, collected)\n             times += 1 if matched else 0\n             if last_left == left:\n                 break\n             last_left = left\n         if times >= 1:\n             return True, left, collected\n         return False, original_left, original_collected\n \n \n class Either(BranchPattern):\n     def match(self, left: list[Pattern], collected: list[Pattern] = None) -> Any:\n         collected = [] if collected is None else collected\n         outcomes = []\n         for pattern in self.children:\n             matched, _, _ = outcome = pattern.match(left, collected)\n             if matched:\n                 outcomes.append(outcome)\n         if outcomes:\n             return min(outcomes, key=lambda outcome: len(outcome[1]))\n         return False, left, collected\n \n \n class Tokens(list):\n     def __init__(\n         self,\n         source: list[str] | str,\n         error: Type[DocoptExit] | Type[DocoptLanguageError] = DocoptExit,\n     ) -> None:\n         if isinstance(source, list):\n             self += source\n         else:\n             self += source.split()\n         self.error = error\n \n     @staticmethod\n     def from_pattern(source: str) -> Tokens:\n         source = re.sub(r\"([\\[\\]\\(\\)\\|]|\\.\\.\\.)\", r\" \\1 \", source)\n         fragments = [s for s in re.split(r\"\\s+|(\\S*<.*?>)\", source) if s]\n         return Tokens(fragments, error=DocoptLanguageError)\n \n     def move(self) -> str | None:\n         return self.pop(0) if len(self) else None\n \n     def current(self) -> str | None:\n         return self[0] if len(self) else None\n \n \n def parse_longer(\n     tokens: Tokens, options: list[Option], argv: bool = False, more_magic: bool = False\n ) -> list[Pattern]:\n     \"\"\"longer ::= '--' chars [ ( ' ' | '=' ) chars ] ;\"\"\"\n     current_token = tokens.move()\n     if current_token is None or not current_token.startswith(\"--\"):\n         raise tokens.error(\n             f\"parse_longer got what appears to be an invalid token: {current_token}\"\n         )  # pragma: no cover\n     longer, maybe_eq, maybe_value = current_token.partition(\"=\")\n     if maybe_eq == maybe_value == \"\":\n         value = None\n     else:\n         value = maybe_value\n     similar = [o for o in options if o.longer and longer == o.longer]\n     start_collision = (\n         len(\n             [\n                 o\n                 for o in options\n                 if o.longer and longer in o.longer and o.longer.startswith(longer)\n             ]\n         )\n         > 1\n     )\n     if argv and not len(similar) and not start_collision:\n         similar = [\n             o\n             for o in options\n             if o.longer and longer in o.longer and o.longer.startswith(longer)\n         ]\n     # try advanced matching\n     if more_magic and not similar:\n         corrected = [\n             (longer, o)\n             for o in options\n             if o.longer and levenshtein_norm(longer, o.longer) < 0.25\n         ]\n         if corrected:\n             print(f\"NB: Corrected {corrected[0][0]} to {corrected[0][1].longer}\")\n         similar = [correct for (original, correct) in corrected]\n     if len(similar) > 1:\n         raise tokens.error(\n             f\"{longer} is not a unique prefix: {similar}?\"\n         )  # pragma: no cover\n     elif len(similar) < 1:\n         argcount = 1 if maybe_eq == \"=\" else 0\n         o = Option(None, longer, argcount)\n         options.append(o)\n         if tokens.error is DocoptExit:\n             o = Option(None, longer, argcount, value if argcount else True)\n     else:\n         o = Option(\n             similar[0].short, similar[0].longer, similar[0].argcount, similar[0].value\n         )\n         if o.argcount == 0:\n             if value is not None:\n                 raise tokens.error(\"%s must not have an argument\" % o.longer)\n         else:\n             if value is None:\n                 if tokens.current() in [None, \"--\"]:\n                     raise tokens.error(\"%s requires argument\" % o.longer)\n                 value = tokens.move()\n         if tokens.error is DocoptExit:\n             o.value = value if value is not None else True\n     return [o]\n \n \n def parse_shorts(\n     tokens: Tokens, options: list[Option], more_magic: bool = False\n ) -> list[Pattern]:\n     \"\"\"shorts ::= '-' ( chars )* [ [ ' ' ] chars ] ;\"\"\"\n     token = tokens.move()\n     if token is None or not token.startswith(\"-\") or token.startswith(\"--\"):\n         raise ValueError(\n             f\"parse_shorts got what appears to be an invalid token: {token}\"\n         )  # pragma: no cover\n     left = token.lstrip(\"-\")\n     parsed: list[Pattern] = []\n     while left != \"\":\n         short, left = \"-\" + left[0], left[1:]\n         transformations: dict[str | None, Callable[[str], str]] = {None: lambda x: x}\n         if more_magic:\n             transformations[\"lowercase\"] = lambda x: x.lower()\n             transformations[\"uppercase\"] = lambda x: x.upper()\n         # try identity, lowercase, uppercase, iff such resolves uniquely\n         # (ie if upper and lowercase are not both defined)\n         similar: list[Option] = []\n         de_abbreviated = False\n         for transform_name, transform in transformations.items():\n             transformed = list(set([transform(o.short) for o in options if o.short]))\n             no_collisions = len(\n                 [\n                     o\n                     for o in options\n                     if o.short and transformed.count(transform(o.short)) == 1\n                 ]\n             )  # == len(transformed)\n             if no_collisions:\n                 similar = [\n                     o\n                     for o in options\n                     if o.short and transform(o.short) == transform(short)\n                 ]\n                 if similar:\n                     if transform_name:\n                         print(\n                             f\"NB: Corrected {short} to {similar[0].short} \"\n                             f\"via {transform_name}\"\n                         )\n                     break\n             # if transformations do not resolve, try abbreviations of 'longer' forms\n             # iff such resolves uniquely (ie if no two longer forms begin with the\n             # same letter)\n             if not similar and more_magic:\n                 abbreviated = [\n                     transform(o.longer[1:3])\n                     for o in options\n                     if o.longer and not o.short\n                 ] + [transform(o.short) for o in options if o.short and not o.longer]\n                 nonredundantly_abbreviated_options = [\n                     o for o in options if o.longer and abbreviated.count(short) == 1\n                 ]\n                 no_collisions = len(nonredundantly_abbreviated_options) == len(\n                     abbreviated\n                 )\n                 if no_collisions:\n                     for o in options:\n                         if (\n                             not o.short\n                             and o.longer\n                             and transform(short) == transform(o.longer[1:3])\n                         ):\n                             similar = [o]\n                             print(\n                                 f\"NB: Corrected {short} to {similar[0].longer} \"\n                                 f\"via abbreviation (case change: {transform_name})\"\n                             )\n                             break\n                 if len(similar):\n                     de_abbreviated = True\n                     break\n         if len(similar) > 1:\n             raise tokens.error(\n                 \"%s is specified ambiguously %d times\" % (short, len(similar))\n             )\n         elif len(similar) < 1:\n             o = Option(short, None, 0)\n             options.append(o)\n             if tokens.error is DocoptExit:\n                 o = Option(short, None, 0, True)\n         else:\n             if de_abbreviated:\n                 option_short_value = None\n             else:\n                 option_short_value = transform(short)\n             o = Option(\n                 option_short_value,\n                 similar[0].longer,\n                 similar[0].argcount,\n                 similar[0].value,\n             )\n             value = None\n             current_token = tokens.current()\n             if o.argcount != 0:\n                 if left == \"\":\n                     if current_token is None or current_token == \"--\":\n                         raise tokens.error(\"%s requires argument\" % short)\n                     else:\n                         value = tokens.move()\n                 else:\n                     value = left\n                     left = \"\"\n             if tokens.error is DocoptExit:\n                 o.value = value if value is not None else True\n         parsed.append(o)\n     return parsed\n \n \n def parse_pattern(source: str, options: list[Option]) -> Required:\n     tokens = Tokens.from_pattern(source)\n     result = parse_expr(tokens, options)\n     if tokens.current() is not None:\n         raise tokens.error(\"unexpected ending: %r\" % \" \".join(tokens))\n     return Required(*result)\n \n \n def parse_expr(tokens: Tokens, options: list[Option]) -> list[Pattern]:\n     \"\"\"expr ::= seq ( '|' seq )* ;\"\"\"\n     result: list[Pattern] = []\n     seq_0: list[Pattern] = parse_seq(tokens, options)\n     if tokens.current() != \"|\":\n         return seq_0\n     if len(seq_0) > 1:\n         result.append(Required(*seq_0))\n     else:\n         result += seq_0\n     while tokens.current() == \"|\":\n         tokens.move()\n         seq_1 = parse_seq(tokens, options)\n         if len(seq_1) > 1:\n             result += [Required(*seq_1)]\n         else:\n             result += seq_1\n     return [Either(*result)]\n \n \n def parse_seq(tokens: Tokens, options: list[Option]) -> list[Pattern]:\n     \"\"\"seq ::= ( atom [ '...' ] )* ;\"\"\"\n     result: list[Pattern] = []\n     while tokens.current() not in [None, \"]\", \")\", \"|\"]:\n         atom = parse_atom(tokens, options)\n         if tokens.current() == \"...\":\n             atom = [OneOrMore(*atom)]\n             tokens.move()\n         result += atom\n     return result\n \n \n def parse_atom(tokens: Tokens, options: list[Option]) -> list[Pattern]:\n     \"\"\"atom ::= '(' expr ')' | '[' expr ']' | 'options'\n     | longer | shorts | argument | command ;\n     \"\"\"\n     token = tokens.current()\n     if not token:\n         return [Command(tokens.move())]  # pragma: no cover\n     elif token in \"([\":\n         tokens.move()\n         matching = {\"(\": \")\", \"[\": \"]\"}[token]\n         pattern = {\"(\": Required, \"[\": NotRequired}[token]\n         matched_pattern = pattern(*parse_expr(tokens, options))\n         if tokens.move() != matching:\n             raise tokens.error(\"unmatched '%s'\" % token)\n         return [matched_pattern]\n     elif token == \"options\":\n         tokens.move()\n         return [OptionsShortcut()]\n     elif token.startswith(\"--\") and token != \"--\":\n         return parse_longer(tokens, options)\n     elif token.startswith(\"-\") and token not in (\"-\", \"--\"):\n         return parse_shorts(tokens, options)\n     elif token.startswith(\"<\") and token.endswith(\">\") or token.isupper():\n         return [Argument(tokens.move())]\n     else:\n         return [Command(tokens.move())]\n \n \n def parse_argv(\n     tokens: Tokens,\n     options: list[Option],\n     options_first: bool = False,\n     more_magic: bool = False,\n ) -> list[Pattern]:\n     \"\"\"Parse command-line argument vector.\n \n     If options_first:\n         argv ::= [ longer | shorts ]* [ argument ]* [ '--' [ argument ]* ] ;\n     else:\n         argv ::= [ longer | shorts | argument ]* [ '--' [ argument ]* ] ;\n \n     \"\"\"\n \n     def isanumber(x):\n         try:\n             float(x)\n             return True\n         except ValueError:\n             return False\n \n     parsed: list[Pattern] = []\n     current_token = tokens.current()\n     while current_token is not None:\n         if current_token == \"--\":\n             return parsed + [Argument(None, v) for v in tokens]\n         elif current_token.startswith(\"--\"):\n             parsed += parse_longer(tokens, options, argv=True, more_magic=more_magic)\n         elif (\n             current_token.startswith(\"-\")\n             and current_token != \"-\"\n             and not isanumber(current_token)\n         ):\n             parsed += parse_shorts(tokens, options, more_magic=more_magic)\n         elif options_first:\n             return parsed + [Argument(None, v) for v in tokens]\n         else:\n             parsed.append(Argument(None, tokens.move()))\n         current_token = tokens.current()\n     return parsed\n \n \n def parse_defaults(docstring: str) -> list[Option]:\n     defaults = []\n     for s in parse_section(\"options:\", docstring):\n         options_literal, _, s = s.partition(\":\")\n         if \" \" in options_literal:\n             _, _, options_literal = options_literal.partition(\" \")\n         assert options_literal.lower().strip() == \"options\"\n         split = re.split(r\"\\n[ \\t]*(-\\S+?)\", \"\\n\" + s)[1:]\n         split = [s1 + s2 for s1, s2 in zip(split[::2], split[1::2])]\n         for s in split:\n             if s.startswith(\"-\"):\n                 arg, _, description = s.partition(\"  \")\n                 flag, _, var = arg.replace(\"=\", \" \").partition(\" \")\n                 option = Option.parse(s)\n                 defaults.append(option)\n     return defaults\n \n \n def parse_section(name: str, source: str) -> list[str]:\n     pattern = re.compile(\n         \"^([^\\n]*\" + name + \"[^\\n]*\\n?(?:[ \\t].*?(?:\\n|$))*)\",\n         re.IGNORECASE | re.MULTILINE,\n     )\n     r = [\n         s.strip() for s in pattern.findall(source) if s.strip().lower() != name.lower()\n     ]\n     return r\n \n \n def formal_usage(section: str) -> str:\n     _, _, section = section.partition(\":\")  # drop \"usage:\"\n     pu = section.split()\n     return \"( \" + \" \".join(\") | (\" if s == pu[0] else s for s in pu[1:]) + \" )\"\n \n \n def extras(\n     default_help: bool, version: None, options: list[Pattern], docstring: str\n ) -> None:\n     if default_help and any(\n         (o.name in (\"-h\", \"--help\")) and o.value\n         for o in options\n         if isinstance(o, Option)\n     ):\n         print(docstring.strip(\"\\n\"))\n         sys.exit()\n     if version and any(\n         o.name == \"--version\" and o.value for o in options if isinstance(o, Option)\n     ):\n         print(version)\n         sys.exit()\n \n \n class ParsedOptions(dict):\n     def __repr__(self):\n         return \"{%s}\" % \",\\n \".join(\"%r: %r\" % i for i in sorted(self.items()))\n \n     def __getattr__(self, name: str) -> str | bool | None:\n         return self.get(name) or {\n             name: self.get(k)\n             for k in self.keys()\n             if name in [k.lstrip(\"-\").replace(\"-\", \"_\"), k.lstrip(\"<\").rstrip(\">\")]\n         }.get(name)\n \n \n def docopt(\n     docstring: str | None = None,\n     argv: list[str] | str | None = None,\n     default_help: bool = True,\n     version: Any = None,\n     options_first: bool = False,\n     more_magic: bool = False,\n ) -> ParsedOptions:\n     \"\"\"Parse `argv` based on command-line interface described in `doc`.\n \n     `docopt` creates your command-line interface based on its\n     description that you pass as `docstring`. Such description can contain\n     --options, <positional-argument>, commands, which could be\n     [optional], (required), (mutually | exclusive) or repeated...\n \n     Parameters\n     ----------\n     docstring : str (default: first __doc__ in parent scope)\n         Description of your command-line interface.\n     argv : list of str, optional\n         Argument vector to be parsed. sys.argv[1:] is used if not\n         provided.\n     default_help : bool (default: True)\n         Set to False to disable automatic help on -h or --help\n         options.\n     version : any object\n         If passed, the object will be printed if --version is in\n         `argv`.\n     options_first : bool (default: False)\n         Set to True to require options precede positional arguments,\n         i.e. to forbid options and positional arguments intermix.\n     more_magic : bool (default: False)\n         Try to be extra-helpful; pull results into globals() of caller as 'arguments',\n         offer advanced pattern-matching and spellcheck.\n         Also activates if `docopt` aliased to a name containing 'magic'.\n \n     Returns\n     -------\n     arguments: dict-like\n         A dictionary, where keys are names of command-line elements\n         such as e.g. \"--verbose\" and \"<path>\", and values are the\n         parsed values of those elements. Also supports dot acccess.\n \n     Example\n     -------\n     >>> from docopt import docopt\n     >>> doc = '''\n     ... Usage:\n     ...     my_program tcp <host> <port> [--timeout=<seconds>]\n     ...     my_program serial <port> [--baud=<n>] [--timeout=<seconds>]\n     ...     my_program (-h | --help | --version)\n     ...\n     ... Options:\n     ...     -h, --help  Show this screen and exit.\n     ...     --baud=<n>  Baudrate [default: 9600]\n     ... '''\n     >>> argv = ['tcp', '127.0.0.1', '80', '--timeout', '30']\n     >>> docopt(doc, argv)\n     {'--baud': '9600',\n      '--help': False,\n      '--timeout': '30',\n      '--version': False,\n      '<host>': '127.0.0.1',\n      '<port>': '80',\n      'serial': False,\n      'tcp': True}\n \n     \"\"\"\n     argv = sys.argv[1:] if argv is None else argv\n     maybe_frame = inspect.currentframe()\n     if maybe_frame:\n         parent_frame = doc_parent_frame = magic_parent_frame = maybe_frame.f_back\n     if not more_magic:  # make sure 'magic' isn't in the calling name\n         while not more_magic and magic_parent_frame:\n             imported_as = {\n                 v: k\n                 for k, v in magic_parent_frame.f_globals.items()\n                 if hasattr(v, \"__name__\") and v.__name__ == docopt.__name__\n             }.get(docopt)\n             if imported_as and \"magic\" in imported_as:\n                 more_magic = True\n             else:\n                 magic_parent_frame = magic_parent_frame.f_back\n     if not docstring:  # go look for one, if none exists, raise Exception\n         while not docstring and doc_parent_frame:\n             docstring = doc_parent_frame.f_locals.get(\"__doc__\")\n             if not docstring:\n                 doc_parent_frame = doc_parent_frame.f_back\n         if not docstring:\n             raise DocoptLanguageError(\n                 \"Either __doc__ must be defined in the scope of a parent \"\n                 \"or passed as the first argument.\"\n             )\n     output_value_assigned = False\n     if more_magic and parent_frame:\n         import dis\n \n         instrs = dis.get_instructions(parent_frame.f_code)\n         for instr in instrs:\n             if instr.offset == parent_frame.f_lasti:\n                 break\n         assert instr.opname.startswith(\"CALL_\")\n         MAYBE_STORE = next(instrs)\n         if MAYBE_STORE and (\n             MAYBE_STORE.opname.startswith(\"STORE\")\n             or MAYBE_STORE.opname.startswith(\"RETURN\")\n         ):\n             output_value_assigned = True\n     usage_sections = parse_section(\"usage:\", docstring)\n     if len(usage_sections) == 0:\n         raise DocoptLanguageError(\n             '\"usage:\" section (case-insensitive) not found. '\n             \"Perhaps missing indentation?\"\n         )\n     if len(usage_sections) > 1:\n         raise DocoptLanguageError('More than one \"usage:\" (case-insensitive).')\n     options_pattern = re.compile(r\"\\n\\s*?options:\", re.IGNORECASE)\n     if options_pattern.search(usage_sections[0]):\n         raise DocoptExit(\n             \"Warning: options (case-insensitive) was found in usage.\"\n             \"Use a blank line between each section..\"\n         )\n     DocoptExit.usage = usage_sections[0]\n     options = parse_defaults(docstring)\n     pattern = parse_pattern(formal_usage(DocoptExit.usage), options)\n     pattern_options = set(pattern.flat(Option))\n     for options_shortcut in pattern.flat(OptionsShortcut):\n         doc_options = parse_defaults(docstring)\n         options_shortcut.children = [\n             opt for opt in doc_options if opt not in pattern_options\n         ]\n     parsed_arg_vector = parse_argv(\n         Tokens(argv), list(options), options_first, more_magic\n     )\n     extras(default_help, version, parsed_arg_vector, docstring)\n     matched, left, collected = pattern.fix().match(parsed_arg_vector)\n     if matched and left == []:\n         output_obj = ParsedOptions(\n             (a.name, a.value) for a in (pattern.flat() + collected)\n         )\n         target_parent_frame = parent_frame or magic_parent_frame or doc_parent_frame\n         if more_magic and target_parent_frame and not output_value_assigned:\n             if not target_parent_frame.f_globals.get(\"arguments\"):\n                 target_parent_frame.f_globals[\"arguments\"] = output_obj\n         return output_obj\n     if left:\n         raise DocoptExit(f\"Warning: found unmatched (duplicate?) arguments {left}\")\n     raise DocoptExit(collected=collected, left=left)\n \n \n magic = magic_docopt = docopt\n ", "input_code": "def match(self, left: list[LeafPattern], collected: list[Pattern]=None) -> tuple[bool, list[LeafPattern], list[Pattern]]:\n\"\"\"\nCheck if the filename is a type that this module supports\n\nArgs:\n    filename: Filename to match\nReturns:\n    False if not a match, True if supported\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def match(\n        self, left: list[LeafPattern], collected: list[Pattern] = None\n    ) -> tuple[bool, list[LeafPattern], list[Pattern]]:\n        collected = [] if collected is None else collected\n        increment: Any | None = None\n        pos, match = self.single_match(left)\n        if match is None or pos is None:\n            return False, left, collected\n        left_ = left[:pos] + left[(pos + 1) :]\n        same_name = [a for a in collected if a.name == self.name]\n        if type(self.value) == int and len(same_name) > 0:\n            if isinstance(same_name[0].value, int):\n                same_name[0].value += 1\n            return True, left_, collected\n        if type(self.value) == int and not same_name:\n            match.value = 1\n            return True, left_, collected + [match]\n        if same_name and type(self.value) == list:\n            if type(match.value) == str:\n                increment = [match.value]\n            if same_name[0].value is not None and increment is not None:\n                if isinstance(same_name[0].value, type(increment)):\n                    same_name[0].value += increment\n            return True, left_, collected\n        elif not same_name and type(self.value) == list:\n            if isinstance(match.value, str):\n                match.value = [match.value]\n            return True, left_, collected + [match]\n        return True, left_, collected + [match]", "signature": "def match(self, left: list[LeafPattern], collected: list[Pattern]=None) -> tuple[bool, list[LeafPattern], list[Pattern]]:", "completion_path": "docopt/__init__.py"}
{"ce_id": "62ece4982e6aefcf4aabbd77", "namespace": "62ece4982e6aefcf4aabbd77", "namespace_real": "borgmatic.borg.check.parse_frequency", "real_proj_path": "witten---borgmatic/", "type": "function", "class_name": null, "function_name": "parse_frequency", "contexts_above": "import argparse\nimport datetime\nimport json\nimport logging\nimport os\nimport pathlib\n\nfrom borgmatic.borg import extract, info, state\nfrom borgmatic.execute import DO_NOT_CAPTURE, execute_command\n\nDEFAULT_CHECKS = (\n    {'name': 'repository', 'frequency': '2 weeks'},\n    {'name': 'archives', 'frequency': '2 weeks'},\n)\nDEFAULT_PREFIX = '{hostname}-'\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef parse_checks(consistency_config, only_checks=None):\n    '''\n    Given a consistency config with a \"checks\" sequence of dicts and an optional list of override\n    checks, return a tuple of named checks to run.\n\n    For example, given a retention config of:\n\n        {'checks': ({'name': 'repository'}, {'name': 'archives'})}\n\n    This will be returned as:\n\n        ('repository', 'archives')\n\n    If no \"checks\" option is present in the config, return the DEFAULT_CHECKS. If a checks value\n    has a name of \"disabled\", return an empty tuple, meaning that no checks should be run.\n\n    If the \"data\" check is present, then make sure the \"archives\" check is included as well.\n    '''\n    checks = only_checks or tuple(\n        check_config['name']\n        for check_config in (consistency_config.get('checks', None) or DEFAULT_CHECKS)\n    )\n    checks = tuple(check.lower() for check in checks)\n    if 'disabled' in checks:\n        if len(checks) > 1:\n            logger.warning(\n                'Multiple checks are configured, but one of them is \"disabled\"; not running any checks'\n            )\n        return ()\n\n    if 'data' in checks and 'archives' not in checks:\n        return checks + ('archives',)\n\n    return checks\n\n", "contexts_below": "\n def filter_checks_on_frequency(location_config, consistency_config, borg_repository_id, checks):\n     '''\n     Given a location config, a consistency config with a \"checks\" sequence of dicts, a Borg\n     repository ID, and sequence of checks, filter down those checks based on the configured\n     \"frequency\" for each check as compared to its check time file.\n \n     In other words, a check whose check time file's timestamp is too new (based on the configured\n     frequency) will get cut from the returned sequence of checks. Example:\n \n     consistency_config = {\n         'checks': [\n             {\n                 'name': 'archives',\n                 'frequency': '2 weeks',\n             },\n         ]\n     }\n \n     When this function is called with that consistency_config and \"archives\" in checks, \"archives\"\n     will get filtered out of the returned result if its check time file is newer than 2 weeks old,\n     indicating that it's not yet time to run that check again.\n \n     Raise ValueError if a frequency cannot be parsed.\n     '''\n     filtered_checks = list(checks)\n \n     for check_config in consistency_config.get('checks', DEFAULT_CHECKS):\n         check = check_config['name']\n         if checks and check not in checks:\n             continue\n \n         frequency_delta = parse_frequency(check_config.get('frequency'))\n         if not frequency_delta:\n             continue\n \n         check_time = read_check_time(\n             make_check_time_path(location_config, borg_repository_id, check)\n         )\n         if not check_time:\n             continue\n \n         # If we've not yet reached the time when the frequency dictates we're ready for another\n         # check, skip this check.\n         if datetime.datetime.now() < check_time + frequency_delta:\n             remaining = check_time + frequency_delta - datetime.datetime.now()\n             logger.info(\n                 f\"Skipping {check} check due to configured frequency; {remaining} until next check\"\n             )\n             filtered_checks.remove(check)\n \n     return tuple(filtered_checks)\n \n \n def make_check_flags(checks, check_last=None, prefix=None):\n     '''\n     Given a parsed sequence of checks, transform it into tuple of command-line flags.\n \n     For example, given parsed checks of:\n \n         ('repository',)\n \n     This will be returned as:\n \n         ('--repository-only',)\n \n     However, if both \"repository\" and \"archives\" are in checks, then omit them from the returned\n     flags because Borg does both checks by default.\n \n     Additionally, if a check_last value is given and \"archives\" is in checks, then include a\n     \"--last\" flag. And if a prefix value is given and \"archives\" is in checks, then include a\n     \"--prefix\" flag.\n     '''\n     if 'archives' in checks:\n         last_flags = ('--last', str(check_last)) if check_last else ()\n         prefix_flags = ('--prefix', prefix) if prefix else ()\n     else:\n         last_flags = ()\n         prefix_flags = ()\n         if check_last:\n             logger.info('Ignoring check_last option, as \"archives\" is not in consistency checks')\n         if prefix:\n             logger.info(\n                 'Ignoring consistency prefix option, as \"archives\" is not in consistency checks'\n             )\n \n     common_flags = last_flags + prefix_flags + (('--verify-data',) if 'data' in checks else ())\n \n     if {'repository', 'archives'}.issubset(set(checks)):\n         return common_flags\n \n     return (\n         tuple('--{}-only'.format(check) for check in checks if check in ('repository', 'archives'))\n         + common_flags\n     )\n \n \n def make_check_time_path(location_config, borg_repository_id, check_type):\n     '''\n     Given a location configuration dict, a Borg repository ID, and the name of a check type\n     (\"repository\", \"archives\", etc.), return a path for recording that check's time (the time of\n     that check last occurring).\n     '''\n     return os.path.join(\n         os.path.expanduser(\n             location_config.get(\n                 'borgmatic_source_directory', state.DEFAULT_BORGMATIC_SOURCE_DIRECTORY\n             )\n         ),\n         'checks',\n         borg_repository_id,\n         check_type,\n     )\n \n \n def write_check_time(path):  # pragma: no cover\n     '''\n     Record a check time of now as the modification time of the given path.\n     '''\n     logger.debug(f'Writing check time at {path}')\n \n     os.makedirs(os.path.dirname(path), mode=0o700, exist_ok=True)\n     pathlib.Path(path, mode=0o600).touch()\n \n \n def read_check_time(path):\n     '''\n     Return the check time based on the modification time of the given path. Return None if the path\n     doesn't exist.\n     '''\n     logger.debug(f'Reading check time from {path}')\n \n     try:\n         return datetime.datetime.fromtimestamp(os.stat(path).st_mtime)\n     except FileNotFoundError:\n         return None\n \n \n def check_archives(\n     repository,\n     location_config,\n     storage_config,\n     consistency_config,\n     local_path='borg',\n     remote_path=None,\n     progress=None,\n     repair=None,\n     only_checks=None,\n ):\n     '''\n     Given a local or remote repository path, a storage config dict, a consistency config dict,\n     local/remote commands to run, whether to include progress information, whether to attempt a\n     repair, and an optional list of checks to use instead of configured checks, check the contained\n     Borg archives for consistency.\n \n     If there are no consistency checks to run, skip running them.\n \n     Raises ValueError if the Borg repository ID cannot be determined.\n     '''\n     try:\n         borg_repository_id = json.loads(\n             info.display_archives_info(\n                 repository,\n                 storage_config,\n                 argparse.Namespace(json=True, archive=None),\n                 local_path,\n                 remote_path,\n             )\n         )['repository']['id']\n     except (json.JSONDecodeError, KeyError):\n         raise ValueError(f'Cannot determine Borg repository ID for {repository}')\n \n     checks = filter_checks_on_frequency(\n         location_config,\n         consistency_config,\n         borg_repository_id,\n         parse_checks(consistency_config, only_checks),\n     )\n     check_last = consistency_config.get('check_last', None)\n     lock_wait = None\n     extra_borg_options = storage_config.get('extra_borg_options', {}).get('check', '')\n \n     if set(checks).intersection({'repository', 'archives', 'data'}):\n         lock_wait = storage_config.get('lock_wait', None)\n \n         verbosity_flags = ()\n         if logger.isEnabledFor(logging.INFO):\n             verbosity_flags = ('--info',)\n         if logger.isEnabledFor(logging.DEBUG):\n             verbosity_flags = ('--debug', '--show-rc')\n \n         prefix = consistency_config.get('prefix', DEFAULT_PREFIX)\n \n         full_command = (\n             (local_path, 'check')\n             + (('--repair',) if repair else ())\n             + make_check_flags(checks, check_last, prefix)\n             + (('--remote-path', remote_path) if remote_path else ())\n             + (('--lock-wait', str(lock_wait)) if lock_wait else ())\n             + verbosity_flags\n             + (('--progress',) if progress else ())\n             + (tuple(extra_borg_options.split(' ')) if extra_borg_options else ())\n             + (repository,)\n         )\n \n         # The Borg repair option triggers an interactive prompt, which won't work when output is\n         # captured. And progress messes with the terminal directly.\n         if repair or progress:\n             execute_command(full_command, output_file=DO_NOT_CAPTURE)\n         else:\n             execute_command(full_command)\n \n         for check in checks:\n             write_check_time(make_check_time_path(location_config, borg_repository_id, check))\n \n     if 'extract' in checks:\n         extract.extract_last_archive_dry_run(repository, lock_wait, local_path, remote_path)\n         write_check_time(make_check_time_path(location_config, borg_repository_id, 'extract'))\n ", "input_code": "def parse_frequency(frequency):\n\"\"\"\nGiven a frequency string with a number and a unit of time, return a corresponding\ndatetime.timedelta instance or None if the frequency is None or \"always\".\n\nFor instance, given \"3 weeks\", return datetime.timedelta(weeks=3)\n\nRaise ValueError if the given frequency cannot be parsed.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def parse_frequency(frequency):\n    '''\n    Given a frequency string with a number and a unit of time, return a corresponding\n    datetime.timedelta instance or None if the frequency is None or \"always\".\n\n    For instance, given \"3 weeks\", return datetime.timedelta(weeks=3)\n\n    Raise ValueError if the given frequency cannot be parsed.\n    '''\n    if not frequency:\n        return None\n\n    frequency = frequency.strip().lower()\n\n    if frequency == 'always':\n        return None\n\n    try:\n        number, time_unit = frequency.split(' ')\n        number = int(number)\n    except ValueError:\n        raise ValueError(f\"Could not parse consistency check frequency '{frequency}'\")\n\n    if not time_unit.endswith('s'):\n        time_unit += 's'\n\n    if time_unit == 'months':\n        number *= 4\n        time_unit = 'weeks'\n    elif time_unit == 'years':\n        number *= 365\n        time_unit = 'days'\n\n    try:\n        return datetime.timedelta(**{time_unit: number})\n    except TypeError:\n        raise ValueError(f\"Could not parse consistency check frequency '{frequency}'\")", "signature": "def parse_frequency(frequency):", "completion_path": "borgmatic/borg/check.py"}
{"ce_id": "62ece4992e6aefcf4aabbd78", "namespace": "62ece4992e6aefcf4aabbd78", "namespace_real": "cloudmesh.common.util.is_local", "real_proj_path": "cloudmesh---cloudmesh-common/", "type": "function", "class_name": null, "function_name": "is_local", "contexts_above": "import subprocess\nimport collections\nimport glob\nimport inspect\nimport os\nimport random\nimport re\nimport shutil\nimport tempfile\nimport time\nfrom contextlib import contextmanager\nimport sys\nimport psutil\nimport requests\nfrom pathlib import Path\nfrom cloudmesh.common.console import Console\nfrom cloudmesh.common.systeminfo import is_gitbash, is_cmd_exe\nimport pyfiglet\nimport socket\nimport platform\n\n\ntry:\n    collectionsAbc = collections.abc\nexcept AttributeError:\n    collectionsAbc = collections\n\n\n@contextmanager\ndef tempdir(*args, **kwargs):\n    \"\"\"A contextmanager to work in an auto-removed temporary directory\n\n    Arguments are passed through to tempfile.mkdtemp\n\n    example:\n\n    >>> with tempdir() as path:\n    ...    pass\n    \"\"\"\n\n    d = tempfile.mkdtemp(*args, **kwargs)\n    try:\n        yield d\n    finally:\n        shutil.rmtree(d)\n\n\ndef check_root(dryrun=False, terminate=True):\n    \"\"\"\n    check if I am the root user. If not, simply exits the program.\n    :param dryrun: if set to true, does not terminate if not root user\n    :type dryrun: bool\n    :param terminate: terminates if not root user and dryrun is False\n    :type terminate: bool\n    \"\"\"\n    uid = os.getuid()\n    if uid == 0:\n        Console.ok(\"You are executing as a root user\")\n    else:\n        Console.error(\"You do not run as root\")\n        if terminate and not dryrun:\n            sys.exit()\n\n\ndef exponential_backoff(fn, sleeptime_s_max=30 * 60):\n    \"\"\"\n    Calls `fn` until it returns True, with an exponentially increasing wait\n    time between calls\n\n    :param fn: the function to be called that returns Truw or False\n    :type fn: object\n    :param sleeptime_s_max: the sleep time in milliseconds\n    :type sleeptime_s_max: int\n    :return: None\n    \"\"\"\n    sleeptime_ms = 500\n    while True:\n        if fn():\n            return True\n        else:\n            print('Sleeping {} ms'.format(sleeptime_ms))\n            time.sleep(sleeptime_ms / 1000.0)\n            sleeptime_ms *= 2\n\n        if sleeptime_ms / 1000.0 > sleeptime_s_max:\n            return False\n\n\ndef download(source, destination, force=False):\n    \"\"\"\n    Downloads the file from source to destination\n\n    For large files, see cloudmesh.common.Shell.download\n\n    :param source: The http source\n    :param destination: The destination in the file system\n    :param force: If True the file will be downloaded even if\n                  it already exists\n    \"\"\"\n    if os.path.isfile(destination) and not force:\n        Console.warning(f\"File {destination} already exists. \"\n                        \"Skipping download ...\")\n    else:\n\n        directory = os.path.dirname(destination)\n        Path(directory).mkdir(parents=True, exist_ok=True)\n        r = requests.get(source, allow_redirects=True)\n        open(destination, 'wb').write(r.content)\n\n\ndef search(lines, pattern):\n    \"\"\"\n    return all lines that match the pattern\n    #TODO: we need an example\n\n    :param lines:\n    :param pattern:\n    :return:\n    \"\"\"\n    p = pattern.replace(\"*\", \".*\")\n    test = re.compile(p)\n    result = []\n    for l in lines:  # noqa: E741\n        if test.search(l):\n            result.append(l)\n    return result\n\n\ndef grep(pattern, filename):\n    \"\"\"Very simple grep that returns the first matching line in a file.\n    String matching only, does not do REs as currently implemented.\n    \"\"\"\n    try:\n        # for line in file\n        # if line matches pattern:\n        #    return line\n        return next((L for L in open(filename) if L.find(pattern) >= 0))\n    except StopIteration:\n        return ''\n\n", "contexts_below": "\n # noinspection PyPep8\n def is_gitbash():\n     \"\"\"\n     returns True if you run in a Windows gitbash\n \n     :return: True if gitbash\n     \"\"\"\n     try:\n         exepath = os.environ['EXEPATH']\n         return \"Git\" in exepath\n     except:\n         return False\n \n \n def is_powershell():\n     \"\"\"\n     True if you run in powershell\n \n     :return: True if you run in powershell\n     \"\"\"\n     # psutil.Process(parent_pid).name() returns -\n     # cmd.exe for CMD\n     # powershell.exe for powershell\n     # bash.exe for git bash\n     return (psutil.Process(os.getppid()).name() == \"powershell.exe\")\n \n \n def is_cmd_exe():\n     \"\"\"\n     return True if you run in a Windows CMD\n \n     :return: True if you run in CMD\n     \"\"\"\n     if is_gitbash():\n         return False\n     else:\n         try:\n             return os.environ['OS'] == 'Windows_NT'\n         except:\n             return False\n \n \n \n def path_expand(text):\n     \"\"\" returns a string with expanded variable.\n \n     :param text: the path to be expanded, which can include ~ and environment variables\n     :param text: string\n \n     \"\"\"\n     result = os.path.expandvars(os.path.expanduser(text))\n \n     if result.startswith(\"./\"):\n         result = result.replace(\".\", os.getcwd(), 1)\n \n     if is_gitbash() or is_cmd_exe():\n         result = result.replace(\"/\", \"\\\\\")\n \n     return result\n \n \n def convert_from_unicode(data):\n     \"\"\"\n     converts unicode data to a string\n     :param data: the data to convert\n     :return:\n     \"\"\"\n     # if isinstance(data, basestring):\n \n     if isinstance(data, str):\n         return str(data)\n     elif isinstance(data, collectionsAbc.Mapping):\n         return dict(map(convert_from_unicode, data.items()))\n     elif isinstance(data, collectionsAbc.Iterable):\n         return type(data)(map(convert_from_unicode, data))\n     else:\n         return data\n \n \n def yn_choice(message, default='y', tries=None):\n     \"\"\"asks for a yes/no question.\n \n     :param tries: the number of tries\n     :param message: the message containing the question\n     :param default: the default answer\n     \"\"\"\n     # http://stackoverflow.com/questions/3041986/python-command-line-yes-no-input\"\"\"\n     choices = 'Y/n' if default.lower() in ('y', 'yes') else 'y/N'\n     if tries is None:\n         choice = input(f\"{message} ({choices}) \")\n         values = ('y', 'yes', '') if default == 'y' else ('y', 'yes')\n         return True if choice.strip().lower() in values else False\n     else:\n         while tries > 0:\n             choice = input(f\"{message} ({choices}) ('q' to discard)\")\n             choice = choice.strip().lower()\n             if choice in ['y', 'yes']:\n                 return True\n             elif choice in ['n', 'no', 'q']:\n                 return False\n             else:\n                 print(\"Invalid input...\")\n                 tries -= 1\n \n \n def str_banner(txt=None, c=\"-\", prefix=\"#\", debug=True, label=None,\n                color=\"BLUE\", padding=False,\n                figlet=False, font=\"big\"):\n     \"\"\"\n     prints a banner of the form with a frame of # around the txt::\n \n     # --------------------------\n     # txt\n     # --------------------------\n \n     :param color: prints in the given color\n     :param label: adds a label\n     :param debug: prints only if debug is true\n     :param txt: a text message to be printed\n     :type txt: string\n     :param c: the character used instead of c\n     :type c: character\n     \"\"\"\n     output = \"\"\n     if debug:\n         output = \"\\n\"\n         output += prefix + \" \" + 70 * c + \"\\n\"\n         if padding:\n             output += prefix + \"\\n\"\n         if label is not None:\n             output += prefix + \" \" + label + \"\\n\"\n             output += prefix + \" \" + 70 * c + \"\\n\"\n \n         if txt is not None:\n \n             if figlet:\n                 txt = pyfiglet.figlet_format(txt, font=font)\n \n             for line in txt.splitlines():\n                 output += prefix + \" \" + line + \"\\n\"\n             if padding:\n                 output += prefix + \"\\n\"\n             output += prefix + \" \" + 70 * c + \"\\n\"\n \n     return output\n \n \n def banner(txt=None, c=\"-\", prefix=\"#\", debug=True, label=None,\n            color=\"BLUE\", padding=False,\n            figlet=False, font=\"big\"):\n     \"\"\"\n     prints a banner of the form with a frame of # around the txt::\n \n     # --------------------------\n     # txt\n     # --------------------------\n \n     :param color: prints in the given color\n     :param label: adds a label\n     :param debug: prints only if debug is true\n     :param txt: a text message to be printed\n     :type txt: string\n     :param c: the character used instead of c\n     :type c: character\n     :param padding: ads additional comment line around the text so the banner is larger\n     :type padding: bool\n     \"\"\"\n \n     output = str_banner(txt=txt, c=c, prefix=prefix, debug=debug, label=label,\n                         color=color, padding=padding, figlet=figlet, font=font)\n     Console.cprint(color, \"\", output)\n \n \n \n # noinspection PyPep8Naming\n def HEADING(txt=None, c=\"#\", color=\"HEADER\"):\n     \"\"\"\n     Prints a message to stdout with #### surrounding it. This is useful for\n     pytests to better distinguish them.\n \n     :param c: uses the given char to wrap the header\n     :param txt: a text message to be printed\n     :type txt: string\n     \"\"\"\n     frame = inspect.getouterframes(inspect.currentframe())\n \n     filename = frame[1][1].replace(os.getcwd(), \"\")\n     line = frame[1][2] - 1\n     method = frame[1][3]\n     if txt is None:\n         msg = \"{} {} {}\".format(method, filename, line)\n     else:\n         msg = \"{}\\n {} {} {}\".format(txt, method, filename, line)\n \n     print()\n     banner(msg, c=c, color=color)\n \n # noinspection PyPep8Naming\n def FUNCTIONNAME():\n     \"\"\"\n     Returns the anme of a function.\n     \"\"\"\n     frame = inspect.getouterframes(inspect.currentframe())\n \n     filename = frame[1][1].replace(os.getcwd(), \"\")\n     line = frame[1][2] - 1\n     method = frame[1][3]\n     return method\n \n def backup_name(filename):\n     \"\"\"\n     :param filename: given a filename creates a backup name of the form\n                      filename.bak.1. If the filename already exists\n                      the number will be increased as  much as needed so\n                      the file does not exist in the given location.\n                      The filename can consists a path and is expanded\n                      with ~ and environment variables.\n     :type filename: string\n     :rtype: string\n     \"\"\"\n     location = path_expand(filename)\n     n = 0\n     found = True\n     backup = None\n     while found:\n         n += 1\n         backup = \"{0}.bak.{1}\".format(location, n)\n         found = os.path.isfile(backup)\n     return backup\n \n \n def auto_create_version(class_name, version, filename=\"__init__.py\"):\n     \"\"\"\n     creates a version number in the __init__.py file.\n     it can be accessed with __version__\n     :param class_name:\n     :param version:\n     :param filename:\n     :return:\n     \"\"\"\n     version_filename = Path(\n         \"{classname}/{filename}\".format(classname=class_name,\n                                         filename=filename))\n     with open(version_filename, \"r\") as f:\n         content = f.read()\n \n     if content != '__version__ = \"{0}\"'.format(version):\n         banner(\"Updating version to {0}\".format(version))\n         with open(version_filename, \"w\") as text_file:\n             text_file.write('__version__ = \"{0:s}\"'.format(version))\n \n \n def auto_create_requirements(requirements):\n     \"\"\"\n \n     creates a requirement.txt file form the requirements in the list. If the file\n     exists, it get changed only if the\n     requirements in the list are different from the existing file\n \n     :param requirements: the requirements in a list\n     \"\"\"\n     banner(\"Creating requirements.txt file\")\n     try:\n         with open(\"requirements.txt\", \"r\") as f:\n             file_content = f.read()\n     except:\n         file_content = \"\"\n \n     setup_requirements = '\\n'.join(requirements)\n \n     if setup_requirements != file_content:\n         with open(\"requirements.txt\", \"w\") as text_file:\n             text_file.write(setup_requirements)\n \n \n def copy_files(files_glob, source_dir, dest_dir):\n     \"\"\"\n     copies the files to the destination\n \n     :param files_glob: `*.yaml`\n     :param source_dir: source directory\n     :param dest_dir: destination directory\n \n     \"\"\"\n \n     files = glob.iglob(os.path.join(source_dir, files_glob))\n     for filename in files:\n         if os.path.isfile(filename):\n             shutil.copy2(filename, dest_dir)\n \n \n def readfile(filename, mode='r'):\n     \"\"\"\n     returns the content of a file\n     :param filename: the filename\n     :return:\n     \"\"\"\n     if mode != 'r' and mode != 'rb':\n         Console.error(f\"incorrect mode : expected 'r' or 'rb' given {mode}\")\n     else:\n         with open(path_expand(filename), mode) as f:\n             content = f.read()\n             f.close()\n         return content\n \n \n def writefile(filename, content):\n     \"\"\"\n     writes the content into the file\n     :param filename: the filename\n     :param content: teh content\n     :return:\n     \"\"\"\n     with open(path_expand(filename), 'w') as outfile:\n         outfile.write(content)\n         outfile.truncate()\n \n \n def writefd(filename, content, mode='w', flags=os.O_RDWR | os.O_CREAT, mask=0o600):\n     \"\"\"\n     writes the content into the file and control permissions\n     :param filename: the full or relative path to the filename\n     :param content: the content being written\n     :param mode: the write mode ('w') or write bytes mode ('wb')\n     :param flags: the os flags that determine the permissions for the file\n     :param mask: the mask that the permissions will be applied to\n     \"\"\"\n     if mode != 'w' and mode != 'wb':\n         Console.error(f\"incorrect mode : expected 'w' or 'wb' given {mode}\")\n \n     with os.fdopen(os.open(filename, flags, mask), mode) as outfile:\n         outfile.write(content)\n         outfile.truncate()\n         outfile.close()\n \n \n def sudo_readfile(filename, split=True, trim=False):\n     \"\"\"\n     Reads the content of the file as sudo and returns the result\n \n     :param filename: the filename\n     :type filename: str\n     :param split: uf true returns a list of lines\n     :type split: bool\n     :param trim: trim trailing whitespace. This is useful to\n                  prevent empty string entries when splitting by '\\n'\n     :type trim: bool\n     :return: the content\n     :rtype: str or list\n     \"\"\"\n     result = subprocess.getoutput(f\"sudo cat {filename}\")\n \n     if trim:\n         result = result.rstrip()\n \n     if split:\n         result = result.split('\\n')\n \n     return result\n \n \n # Reference: http://interactivepython.org/runestone/static/everyday/2013/01/3_password.html\n def generate_password(length=8, lower=True, upper=True, number=True):\n     \"\"\"\n     generates a simple password. We should not really use this in production.\n     :param length: the length of the password\n     :param lower: True of lower case characters are allowed\n     :param upper: True if upper case characters are allowed\n     :param number: True if numbers are allowed\n     :return:\n     \"\"\"\n     lletters = \"abcdefghijklmnopqrstuvwxyz\"\n     uletters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n     # This doesn't guarantee both lower and upper cases will show up\n     alphabet = lletters + uletters\n     digit = \"0123456789\"\n     mypw = \"\"\n \n     def _random_character(texts):\n         return texts[random.randrange(len(texts))]\n \n     if not lower:\n         alphabet = uletters\n     elif not upper:\n         alphabet = lletters\n \n     for i in range(length):\n         # last half length will be filled with numbers\n         if number and i >= int(length / 2):\n             mypw = mypw + _random_character(digit)\n         else:\n             mypw = mypw + _random_character(alphabet)\n     return mypw\n \n \n def str_bool(value):\n     return str(value).lower() in ['yes', '1', 'y', 'true', 't']\n ", "input_code": "def is_local(host):\n\"\"\"\nChecks if the host is the localhost\n\n:param host: The hostname or ip\n:return: True if the host is the localhost\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def is_local(host):\n    \"\"\"\n    Checks if the host is the localhost\n\n    :param host: The hostname or ip\n    :return: True if the host is the localhost\n    \"\"\"\n    return host in [\"127.0.0.1\",\n                    \"localhost\",\n                    socket.gethostname(),\n                    # just in case socket.gethostname() does not work  we also try the following:\n                    platform.node(),\n                    socket.gethostbyaddr(socket.gethostname())[0]\n                    ]", "signature": "def is_local(host):", "completion_path": "cloudmesh/common/util.py"}
{"ce_id": "62ece4992e6aefcf4aabbd79", "namespace": "62ece4992e6aefcf4aabbd79", "namespace_real": "borgmatic.borg.list.make_find_paths", "real_proj_path": "witten---borgmatic/", "type": "function", "class_name": null, "function_name": "make_find_paths", "contexts_above": "import copy\nimport logging\nimport re\n\nfrom borgmatic.borg.flags import make_flags, make_flags_from_arguments\nfrom borgmatic.execute import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\ndef resolve_archive_name(repository, archive, storage_config, local_path='borg', remote_path=None):\n    '''\n    Given a local or remote repository path, an archive name, a storage config dict, a local Borg\n    path, and a remote Borg path, simply return the archive name. But if the archive name is\n    \"latest\", then instead introspect the repository for the latest archive and return its name.\n\n    Raise ValueError if \"latest\" is given but there are no archives in the repository.\n    '''\n    if archive != \"latest\":\n        return archive\n\n    lock_wait = storage_config.get('lock_wait', None)\n\n    full_command = (\n        (local_path, 'list')\n        + (('--info',) if logger.getEffectiveLevel() == logging.INFO else ())\n        + (('--debug', '--show-rc') if logger.isEnabledFor(logging.DEBUG) else ())\n        + make_flags('remote-path', remote_path)\n        + make_flags('lock-wait', lock_wait)\n        + make_flags('last', 1)\n        + ('--short', repository)\n    )\n\n    output = execute_command(full_command, output_log_level=None, borg_local_path=local_path)\n    try:\n        latest_archive = output.strip().splitlines()[-1]\n    except IndexError:\n        raise ValueError('No archives found in the repository')\n\n    logger.debug('{}: Latest archive is {}'.format(repository, latest_archive))\n\n    return latest_archive\n\n\nMAKE_FLAGS_EXCLUDES = ('repository', 'archive', 'successful', 'paths', 'find_paths')\n\n\ndef make_list_command(\n    repository, storage_config, list_arguments, local_path='borg', remote_path=None\n):\n    '''\n    Given a local or remote repository path, a storage config dict, the arguments to the list\n    action, and local and remote Borg paths, return a command as a tuple to list archives or paths\n    within an archive.\n    '''\n    lock_wait = storage_config.get('lock_wait', None)\n\n    return (\n        (local_path, 'list')\n        + (\n            ('--info',)\n            if logger.getEffectiveLevel() == logging.INFO and not list_arguments.json\n            else ()\n        )\n        + (\n            ('--debug', '--show-rc')\n            if logger.isEnabledFor(logging.DEBUG) and not list_arguments.json\n            else ()\n        )\n        + make_flags('remote-path', remote_path)\n        + make_flags('lock-wait', lock_wait)\n        + make_flags_from_arguments(list_arguments, excludes=MAKE_FLAGS_EXCLUDES,)\n        + (\n            ('::'.join((repository, list_arguments.archive)),)\n            if list_arguments.archive\n            else (repository,)\n        )\n        + (tuple(list_arguments.paths) if list_arguments.paths else ())\n    )\n\n", "contexts_below": "\n def list_archives(repository, storage_config, list_arguments, local_path='borg', remote_path=None):\n     '''\n     Given a local or remote repository path, a storage config dict, the arguments to the list\n     action, and local and remote Borg paths, display the output of listing Borg archives in the\n     repository or return JSON output. Or, if an archive name is given, list the files in that\n     archive. Or, if list_arguments.find_paths are given, list the files by searching across multiple\n     archives.\n     '''\n     # If there are any paths to find (and there's not a single archive already selected), start by\n     # getting a list of archives to search.\n     if list_arguments.find_paths and not list_arguments.archive:\n         repository_arguments = copy.copy(list_arguments)\n         repository_arguments.archive = None\n         repository_arguments.json = False\n         repository_arguments.format = None\n \n         # Ask Borg to list archives. Capture its output for use below.\n         archive_lines = tuple(\n             execute_command(\n                 make_list_command(\n                     repository, storage_config, repository_arguments, local_path, remote_path\n                 ),\n                 output_log_level=None,\n                 borg_local_path=local_path,\n             )\n             .strip('\\n')\n             .split('\\n')\n         )\n     else:\n         archive_lines = (list_arguments.archive,)\n \n     # For each archive listed by Borg, run list on the contents of that archive.\n     for archive_line in archive_lines:\n         try:\n             archive = archive_line.split()[0]\n         except (AttributeError, IndexError):\n             archive = None\n \n         if archive:\n             logger.warning(archive_line)\n \n         archive_arguments = copy.copy(list_arguments)\n         archive_arguments.archive = archive\n         main_command = make_list_command(\n             repository, storage_config, archive_arguments, local_path, remote_path\n         ) + make_find_paths(list_arguments.find_paths)\n \n         output = execute_command(\n             main_command,\n             output_log_level=None if list_arguments.json else logging.WARNING,\n             borg_local_path=local_path,\n         )\n \n         if list_arguments.json:\n             return output\n ", "input_code": "def make_find_paths(find_paths):\n\"\"\"\nGiven a sequence of path fragments or patterns as passed to `--find`, transform all path\nfragments into glob patterns. Pass through existing patterns untouched.\n\nFor example, given find_paths of:\n\n  ['foo.txt', 'pp:root/somedir']\n\n... transform that into:\n\n  ['sh:**/*foo.txt*/**', 'pp:root/somedir']\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def make_find_paths(find_paths):\n    '''\n    Given a sequence of path fragments or patterns as passed to `--find`, transform all path\n    fragments into glob patterns. Pass through existing patterns untouched.\n\n    For example, given find_paths of:\n\n      ['foo.txt', 'pp:root/somedir']\n\n    ... transform that into:\n\n      ['sh:**/*foo.txt*/**', 'pp:root/somedir']\n    '''\n\n    return tuple(\n        find_path\n        if re.compile(r'([-!+RrPp] )|(\\w\\w:)').match(find_path)\n        else f'sh:**/*{find_path}*/**'\n        for find_path in find_paths\n    )", "signature": "def make_find_paths(find_paths):", "completion_path": "borgmatic/borg/list.py"}
{"ce_id": "62ece4992e6aefcf4aabbd7a", "namespace": "62ece4992e6aefcf4aabbd7a", "namespace_real": "cloudmesh.common.util.is_gitbash", "real_proj_path": "cloudmesh---cloudmesh-common/", "type": "function", "class_name": null, "function_name": "is_gitbash", "contexts_above": "import subprocess\nimport collections\nimport glob\nimport inspect\nimport os\nimport random\nimport re\nimport shutil\nimport tempfile\nimport time\nfrom contextlib import contextmanager\nimport sys\nimport psutil\nimport requests\nfrom pathlib import Path\nfrom cloudmesh.common.console import Console\nfrom cloudmesh.common.systeminfo import is_gitbash, is_cmd_exe\nimport pyfiglet\nimport socket\nimport platform\n\n\ntry:\n    collectionsAbc = collections.abc\nexcept AttributeError:\n    collectionsAbc = collections\n\n\n@contextmanager\ndef tempdir(*args, **kwargs):\n    \"\"\"A contextmanager to work in an auto-removed temporary directory\n\n    Arguments are passed through to tempfile.mkdtemp\n\n    example:\n\n    >>> with tempdir() as path:\n    ...    pass\n    \"\"\"\n\n    d = tempfile.mkdtemp(*args, **kwargs)\n    try:\n        yield d\n    finally:\n        shutil.rmtree(d)\n\n\ndef check_root(dryrun=False, terminate=True):\n    \"\"\"\n    check if I am the root user. If not, simply exits the program.\n    :param dryrun: if set to true, does not terminate if not root user\n    :type dryrun: bool\n    :param terminate: terminates if not root user and dryrun is False\n    :type terminate: bool\n    \"\"\"\n    uid = os.getuid()\n    if uid == 0:\n        Console.ok(\"You are executing as a root user\")\n    else:\n        Console.error(\"You do not run as root\")\n        if terminate and not dryrun:\n            sys.exit()\n\n\ndef exponential_backoff(fn, sleeptime_s_max=30 * 60):\n    \"\"\"\n    Calls `fn` until it returns True, with an exponentially increasing wait\n    time between calls\n\n    :param fn: the function to be called that returns Truw or False\n    :type fn: object\n    :param sleeptime_s_max: the sleep time in milliseconds\n    :type sleeptime_s_max: int\n    :return: None\n    \"\"\"\n    sleeptime_ms = 500\n    while True:\n        if fn():\n            return True\n        else:\n            print('Sleeping {} ms'.format(sleeptime_ms))\n            time.sleep(sleeptime_ms / 1000.0)\n            sleeptime_ms *= 2\n\n        if sleeptime_ms / 1000.0 > sleeptime_s_max:\n            return False\n\n\ndef download(source, destination, force=False):\n    \"\"\"\n    Downloads the file from source to destination\n\n    For large files, see cloudmesh.common.Shell.download\n\n    :param source: The http source\n    :param destination: The destination in the file system\n    :param force: If True the file will be downloaded even if\n                  it already exists\n    \"\"\"\n    if os.path.isfile(destination) and not force:\n        Console.warning(f\"File {destination} already exists. \"\n                        \"Skipping download ...\")\n    else:\n\n        directory = os.path.dirname(destination)\n        Path(directory).mkdir(parents=True, exist_ok=True)\n        r = requests.get(source, allow_redirects=True)\n        open(destination, 'wb').write(r.content)\n\n\ndef search(lines, pattern):\n    \"\"\"\n    return all lines that match the pattern\n    #TODO: we need an example\n\n    :param lines:\n    :param pattern:\n    :return:\n    \"\"\"\n    p = pattern.replace(\"*\", \".*\")\n    test = re.compile(p)\n    result = []\n    for l in lines:  # noqa: E741\n        if test.search(l):\n            result.append(l)\n    return result\n\n\ndef grep(pattern, filename):\n    \"\"\"Very simple grep that returns the first matching line in a file.\n    String matching only, does not do REs as currently implemented.\n    \"\"\"\n    try:\n        # for line in file\n        # if line matches pattern:\n        #    return line\n        return next((L for L in open(filename) if L.find(pattern) >= 0))\n    except StopIteration:\n        return ''\n\n\ndef is_local(host):\n    \"\"\"\n    Checks if the host is the localhost\n\n    :param host: The hostname or ip\n    :return: True if the host is the localhost\n    \"\"\"\n    return host in [\"127.0.0.1\",\n                    \"localhost\",\n                    socket.gethostname(),\n                    # just in case socket.gethostname() does not work  we also try the following:\n                    platform.node(),\n                    socket.gethostbyaddr(socket.gethostname())[0]\n                    ]\n\n\n# noinspection PyPep8", "contexts_below": "\n def is_powershell():\n     \"\"\"\n     True if you run in powershell\n \n     :return: True if you run in powershell\n     \"\"\"\n     # psutil.Process(parent_pid).name() returns -\n     # cmd.exe for CMD\n     # powershell.exe for powershell\n     # bash.exe for git bash\n     return (psutil.Process(os.getppid()).name() == \"powershell.exe\")\n \n \n def is_cmd_exe():\n     \"\"\"\n     return True if you run in a Windows CMD\n \n     :return: True if you run in CMD\n     \"\"\"\n     if is_gitbash():\n         return False\n     else:\n         try:\n             return os.environ['OS'] == 'Windows_NT'\n         except:\n             return False\n \n \n \n def path_expand(text):\n     \"\"\" returns a string with expanded variable.\n \n     :param text: the path to be expanded, which can include ~ and environment variables\n     :param text: string\n \n     \"\"\"\n     result = os.path.expandvars(os.path.expanduser(text))\n \n     if result.startswith(\"./\"):\n         result = result.replace(\".\", os.getcwd(), 1)\n \n     if is_gitbash() or is_cmd_exe():\n         result = result.replace(\"/\", \"\\\\\")\n \n     return result\n \n \n def convert_from_unicode(data):\n     \"\"\"\n     converts unicode data to a string\n     :param data: the data to convert\n     :return:\n     \"\"\"\n     # if isinstance(data, basestring):\n \n     if isinstance(data, str):\n         return str(data)\n     elif isinstance(data, collectionsAbc.Mapping):\n         return dict(map(convert_from_unicode, data.items()))\n     elif isinstance(data, collectionsAbc.Iterable):\n         return type(data)(map(convert_from_unicode, data))\n     else:\n         return data\n \n \n def yn_choice(message, default='y', tries=None):\n     \"\"\"asks for a yes/no question.\n \n     :param tries: the number of tries\n     :param message: the message containing the question\n     :param default: the default answer\n     \"\"\"\n     # http://stackoverflow.com/questions/3041986/python-command-line-yes-no-input\"\"\"\n     choices = 'Y/n' if default.lower() in ('y', 'yes') else 'y/N'\n     if tries is None:\n         choice = input(f\"{message} ({choices}) \")\n         values = ('y', 'yes', '') if default == 'y' else ('y', 'yes')\n         return True if choice.strip().lower() in values else False\n     else:\n         while tries > 0:\n             choice = input(f\"{message} ({choices}) ('q' to discard)\")\n             choice = choice.strip().lower()\n             if choice in ['y', 'yes']:\n                 return True\n             elif choice in ['n', 'no', 'q']:\n                 return False\n             else:\n                 print(\"Invalid input...\")\n                 tries -= 1\n \n \n def str_banner(txt=None, c=\"-\", prefix=\"#\", debug=True, label=None,\n                color=\"BLUE\", padding=False,\n                figlet=False, font=\"big\"):\n     \"\"\"\n     prints a banner of the form with a frame of # around the txt::\n \n     # --------------------------\n     # txt\n     # --------------------------\n \n     :param color: prints in the given color\n     :param label: adds a label\n     :param debug: prints only if debug is true\n     :param txt: a text message to be printed\n     :type txt: string\n     :param c: the character used instead of c\n     :type c: character\n     \"\"\"\n     output = \"\"\n     if debug:\n         output = \"\\n\"\n         output += prefix + \" \" + 70 * c + \"\\n\"\n         if padding:\n             output += prefix + \"\\n\"\n         if label is not None:\n             output += prefix + \" \" + label + \"\\n\"\n             output += prefix + \" \" + 70 * c + \"\\n\"\n \n         if txt is not None:\n \n             if figlet:\n                 txt = pyfiglet.figlet_format(txt, font=font)\n \n             for line in txt.splitlines():\n                 output += prefix + \" \" + line + \"\\n\"\n             if padding:\n                 output += prefix + \"\\n\"\n             output += prefix + \" \" + 70 * c + \"\\n\"\n \n     return output\n \n \n def banner(txt=None, c=\"-\", prefix=\"#\", debug=True, label=None,\n            color=\"BLUE\", padding=False,\n            figlet=False, font=\"big\"):\n     \"\"\"\n     prints a banner of the form with a frame of # around the txt::\n \n     # --------------------------\n     # txt\n     # --------------------------\n \n     :param color: prints in the given color\n     :param label: adds a label\n     :param debug: prints only if debug is true\n     :param txt: a text message to be printed\n     :type txt: string\n     :param c: the character used instead of c\n     :type c: character\n     :param padding: ads additional comment line around the text so the banner is larger\n     :type padding: bool\n     \"\"\"\n \n     output = str_banner(txt=txt, c=c, prefix=prefix, debug=debug, label=label,\n                         color=color, padding=padding, figlet=figlet, font=font)\n     Console.cprint(color, \"\", output)\n \n \n \n # noinspection PyPep8Naming\n def HEADING(txt=None, c=\"#\", color=\"HEADER\"):\n     \"\"\"\n     Prints a message to stdout with #### surrounding it. This is useful for\n     pytests to better distinguish them.\n \n     :param c: uses the given char to wrap the header\n     :param txt: a text message to be printed\n     :type txt: string\n     \"\"\"\n     frame = inspect.getouterframes(inspect.currentframe())\n \n     filename = frame[1][1].replace(os.getcwd(), \"\")\n     line = frame[1][2] - 1\n     method = frame[1][3]\n     if txt is None:\n         msg = \"{} {} {}\".format(method, filename, line)\n     else:\n         msg = \"{}\\n {} {} {}\".format(txt, method, filename, line)\n \n     print()\n     banner(msg, c=c, color=color)\n \n # noinspection PyPep8Naming\n def FUNCTIONNAME():\n     \"\"\"\n     Returns the anme of a function.\n     \"\"\"\n     frame = inspect.getouterframes(inspect.currentframe())\n \n     filename = frame[1][1].replace(os.getcwd(), \"\")\n     line = frame[1][2] - 1\n     method = frame[1][3]\n     return method\n \n def backup_name(filename):\n     \"\"\"\n     :param filename: given a filename creates a backup name of the form\n                      filename.bak.1. If the filename already exists\n                      the number will be increased as  much as needed so\n                      the file does not exist in the given location.\n                      The filename can consists a path and is expanded\n                      with ~ and environment variables.\n     :type filename: string\n     :rtype: string\n     \"\"\"\n     location = path_expand(filename)\n     n = 0\n     found = True\n     backup = None\n     while found:\n         n += 1\n         backup = \"{0}.bak.{1}\".format(location, n)\n         found = os.path.isfile(backup)\n     return backup\n \n \n def auto_create_version(class_name, version, filename=\"__init__.py\"):\n     \"\"\"\n     creates a version number in the __init__.py file.\n     it can be accessed with __version__\n     :param class_name:\n     :param version:\n     :param filename:\n     :return:\n     \"\"\"\n     version_filename = Path(\n         \"{classname}/{filename}\".format(classname=class_name,\n                                         filename=filename))\n     with open(version_filename, \"r\") as f:\n         content = f.read()\n \n     if content != '__version__ = \"{0}\"'.format(version):\n         banner(\"Updating version to {0}\".format(version))\n         with open(version_filename, \"w\") as text_file:\n             text_file.write('__version__ = \"{0:s}\"'.format(version))\n \n \n def auto_create_requirements(requirements):\n     \"\"\"\n \n     creates a requirement.txt file form the requirements in the list. If the file\n     exists, it get changed only if the\n     requirements in the list are different from the existing file\n \n     :param requirements: the requirements in a list\n     \"\"\"\n     banner(\"Creating requirements.txt file\")\n     try:\n         with open(\"requirements.txt\", \"r\") as f:\n             file_content = f.read()\n     except:\n         file_content = \"\"\n \n     setup_requirements = '\\n'.join(requirements)\n \n     if setup_requirements != file_content:\n         with open(\"requirements.txt\", \"w\") as text_file:\n             text_file.write(setup_requirements)\n \n \n def copy_files(files_glob, source_dir, dest_dir):\n     \"\"\"\n     copies the files to the destination\n \n     :param files_glob: `*.yaml`\n     :param source_dir: source directory\n     :param dest_dir: destination directory\n \n     \"\"\"\n \n     files = glob.iglob(os.path.join(source_dir, files_glob))\n     for filename in files:\n         if os.path.isfile(filename):\n             shutil.copy2(filename, dest_dir)\n \n \n def readfile(filename, mode='r'):\n     \"\"\"\n     returns the content of a file\n     :param filename: the filename\n     :return:\n     \"\"\"\n     if mode != 'r' and mode != 'rb':\n         Console.error(f\"incorrect mode : expected 'r' or 'rb' given {mode}\")\n     else:\n         with open(path_expand(filename), mode) as f:\n             content = f.read()\n             f.close()\n         return content\n \n \n def writefile(filename, content):\n     \"\"\"\n     writes the content into the file\n     :param filename: the filename\n     :param content: teh content\n     :return:\n     \"\"\"\n     with open(path_expand(filename), 'w') as outfile:\n         outfile.write(content)\n         outfile.truncate()\n \n \n def writefd(filename, content, mode='w', flags=os.O_RDWR | os.O_CREAT, mask=0o600):\n     \"\"\"\n     writes the content into the file and control permissions\n     :param filename: the full or relative path to the filename\n     :param content: the content being written\n     :param mode: the write mode ('w') or write bytes mode ('wb')\n     :param flags: the os flags that determine the permissions for the file\n     :param mask: the mask that the permissions will be applied to\n     \"\"\"\n     if mode != 'w' and mode != 'wb':\n         Console.error(f\"incorrect mode : expected 'w' or 'wb' given {mode}\")\n \n     with os.fdopen(os.open(filename, flags, mask), mode) as outfile:\n         outfile.write(content)\n         outfile.truncate()\n         outfile.close()\n \n \n def sudo_readfile(filename, split=True, trim=False):\n     \"\"\"\n     Reads the content of the file as sudo and returns the result\n \n     :param filename: the filename\n     :type filename: str\n     :param split: uf true returns a list of lines\n     :type split: bool\n     :param trim: trim trailing whitespace. This is useful to\n                  prevent empty string entries when splitting by '\\n'\n     :type trim: bool\n     :return: the content\n     :rtype: str or list\n     \"\"\"\n     result = subprocess.getoutput(f\"sudo cat {filename}\")\n \n     if trim:\n         result = result.rstrip()\n \n     if split:\n         result = result.split('\\n')\n \n     return result\n \n \n # Reference: http://interactivepython.org/runestone/static/everyday/2013/01/3_password.html\n def generate_password(length=8, lower=True, upper=True, number=True):\n     \"\"\"\n     generates a simple password. We should not really use this in production.\n     :param length: the length of the password\n     :param lower: True of lower case characters are allowed\n     :param upper: True if upper case characters are allowed\n     :param number: True if numbers are allowed\n     :return:\n     \"\"\"\n     lletters = \"abcdefghijklmnopqrstuvwxyz\"\n     uletters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n     # This doesn't guarantee both lower and upper cases will show up\n     alphabet = lletters + uletters\n     digit = \"0123456789\"\n     mypw = \"\"\n \n     def _random_character(texts):\n         return texts[random.randrange(len(texts))]\n \n     if not lower:\n         alphabet = uletters\n     elif not upper:\n         alphabet = lletters\n \n     for i in range(length):\n         # last half length will be filled with numbers\n         if number and i >= int(length / 2):\n             mypw = mypw + _random_character(digit)\n         else:\n             mypw = mypw + _random_character(alphabet)\n     return mypw\n \n \n def str_bool(value):\n     return str(value).lower() in ['yes', '1', 'y', 'true', 't']\n ", "input_code": "def is_gitbash():\n\"\"\"\nreturns True if you run in a Windows gitbash\n\n:return: True if gitbash\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def is_gitbash():\n    \"\"\"\n    returns True if you run in a Windows gitbash\n\n    :return: True if gitbash\n    \"\"\"\n    try:\n        exepath = os.environ['EXEPATH']\n        return \"Git\" in exepath\n    except:\n        return False", "signature": "def is_gitbash():", "completion_path": "cloudmesh/common/util.py"}
{"ce_id": "62ece4992e6aefcf4aabbd7b", "namespace": "62ece4992e6aefcf4aabbd7b", "namespace_real": "borgmatic.config.generate.write_configuration", "real_proj_path": "witten---borgmatic/", "type": "function", "class_name": null, "function_name": "write_configuration", "contexts_above": "import collections\nimport io\nimport os\nimport re\n\nfrom ruamel import yaml\n\nfrom borgmatic.config import load, normalize\n\nINDENT = 4\nSEQUENCE_INDENT = 2\n\n\ndef _insert_newline_before_comment(config, field_name):\n    '''\n    Using some ruamel.yaml black magic, insert a blank line in the config right before the given\n    field and its comments.\n    '''\n    config.ca.items[field_name][1].insert(\n        0, yaml.tokens.CommentToken('\\n', yaml.error.CommentMark(0), None)\n    )\n\n\ndef _schema_to_sample_configuration(schema, level=0, parent_is_sequence=False):\n    '''\n    Given a loaded configuration schema, generate and return sample config for it. Include comments\n    for each section based on the schema \"description\".\n    '''\n    schema_type = schema.get('type')\n    example = schema.get('example')\n    if example is not None:\n        return example\n\n    if schema_type == 'array':\n        config = yaml.comments.CommentedSeq(\n            [_schema_to_sample_configuration(schema['items'], level, parent_is_sequence=True)]\n        )\n        add_comments_to_configuration_sequence(config, schema, indent=(level * INDENT))\n    elif schema_type == 'object':\n        config = yaml.comments.CommentedMap(\n            [\n                (field_name, _schema_to_sample_configuration(sub_schema, level + 1))\n                for field_name, sub_schema in schema['properties'].items()\n            ]\n        )\n        indent = (level * INDENT) + (SEQUENCE_INDENT if parent_is_sequence else 0)\n        add_comments_to_configuration_object(\n            config, schema, indent=indent, skip_first=parent_is_sequence\n        )\n    else:\n        raise ValueError('Schema at level {} is unsupported: {}'.format(level, schema))\n\n    return config\n\n\ndef _comment_out_line(line):\n    # If it's already is commented out (or empty), there's nothing further to do!\n    stripped_line = line.lstrip()\n    if not stripped_line or stripped_line.startswith('#'):\n        return line\n\n    # Comment out the names of optional sections, inserting the '#' after any indent for aesthetics.\n    matches = re.match(r'(\\s*)', line)\n    indent_spaces = matches.group(0) if matches else ''\n    count_indent_spaces = len(indent_spaces)\n\n    return '# '.join((indent_spaces, line[count_indent_spaces:]))\n\n\ndef _comment_out_optional_configuration(rendered_config):\n    '''\n    Post-process a rendered configuration string to comment out optional key/values, as determined\n    by a sentinel in the comment before each key.\n\n    The idea is that the pre-commented configuration prevents the user from having to comment out a\n    bunch of configuration they don't care about to get to a minimal viable configuration file.\n\n    Ideally ruamel.yaml would support commenting out keys during configuration generation, but it's\n    not terribly easy to accomplish that way.\n    '''\n    lines = []\n    optional = False\n\n    for line in rendered_config.split('\\n'):\n        # Upon encountering an optional configuration option, comment out lines until the next blank\n        # line.\n        if line.strip().startswith('# {}'.format(COMMENTED_OUT_SENTINEL)):\n            optional = True\n            continue\n\n        # Hit a blank line, so reset commenting.\n        if not line.strip():\n            optional = False\n\n        lines.append(_comment_out_line(line) if optional else line)\n\n    return '\\n'.join(lines)\n\n\ndef render_configuration(config):\n    '''\n    Given a config data structure of nested OrderedDicts, render the config as YAML and return it.\n    '''\n    dumper = yaml.YAML()\n    dumper.indent(mapping=INDENT, sequence=INDENT + SEQUENCE_INDENT, offset=INDENT)\n    rendered = io.StringIO()\n    dumper.dump(config, rendered)\n\n    return rendered.getvalue()\n\n", "contexts_below": "\n def add_comments_to_configuration_sequence(config, schema, indent=0):\n     '''\n     If the given config sequence's items are object, then mine the schema for the description of the\n     object's first item, and slap that atop the sequence. Indent the comment the given number of\n     characters.\n \n     Doing this for sequences of maps results in nice comments that look like:\n \n     ```\n     things:\n         # First key description. Added by this function.\n         - key: foo\n           # Second key description. Added by add_comments_to_configuration_object().\n           other: bar\n     ```\n     '''\n     if schema['items'].get('type') != 'object':\n         return\n \n     for field_name in config[0].keys():\n         field_schema = schema['items']['properties'].get(field_name, {})\n         description = field_schema.get('description')\n \n         # No description to use? Skip it.\n         if not field_schema or not description:\n             return\n \n         config[0].yaml_set_start_comment(description, indent=indent)\n \n         # We only want the first key's description here, as the rest of the keys get commented by\n         # add_comments_to_configuration_object().\n         return\n \n \n REQUIRED_SECTION_NAMES = {'location', 'retention'}\n REQUIRED_KEYS = {'source_directories', 'repositories', 'keep_daily'}\n COMMENTED_OUT_SENTINEL = 'COMMENT_OUT'\n \n \n def add_comments_to_configuration_object(config, schema, indent=0, skip_first=False):\n     '''\n     Using descriptions from a schema as a source, add those descriptions as comments to the given\n     config mapping, before each field. Indent the comment the given number of characters.\n     '''\n     for index, field_name in enumerate(config.keys()):\n         if skip_first and index == 0:\n             continue\n \n         field_schema = schema['properties'].get(field_name, {})\n         description = field_schema.get('description', '').strip()\n \n         # If this is an optional key, add an indicator to the comment flagging it to be commented\n         # out from the sample configuration. This sentinel is consumed by downstream processing that\n         # does the actual commenting out.\n         if field_name not in REQUIRED_SECTION_NAMES and field_name not in REQUIRED_KEYS:\n             description = (\n                 '\\n'.join((description, COMMENTED_OUT_SENTINEL))\n                 if description\n                 else COMMENTED_OUT_SENTINEL\n             )\n \n         # No description to use? Skip it.\n         if not field_schema or not description:  # pragma: no cover\n             continue\n \n         config.yaml_set_comment_before_after_key(key=field_name, before=description, indent=indent)\n \n         if index > 0:\n             _insert_newline_before_comment(config, field_name)\n \n \n RUAMEL_YAML_COMMENTS_INDEX = 1\n \n \n def remove_commented_out_sentinel(config, field_name):\n     '''\n     Given a configuration CommentedMap and a top-level field name in it, remove any \"commented out\"\n     sentinel found at the end of its YAML comments. This prevents the given field name from getting\n     commented out by downstream processing that consumes the sentinel.\n     '''\n     try:\n         last_comment_value = config.ca.items[field_name][RUAMEL_YAML_COMMENTS_INDEX][-1].value\n     except KeyError:\n         return\n \n     if last_comment_value == '# {}\\n'.format(COMMENTED_OUT_SENTINEL):\n         config.ca.items[field_name][RUAMEL_YAML_COMMENTS_INDEX].pop()\n \n \n def merge_source_configuration_into_destination(destination_config, source_config):\n     '''\n     Deep merge the given source configuration dict into the destination configuration CommentedMap,\n     favoring values from the source when there are collisions.\n \n     The purpose of this is to upgrade configuration files from old versions of borgmatic by adding\n     new\n     configuration keys and comments.\n     '''\n     if not source_config:\n         return destination_config\n     if not destination_config or not isinstance(source_config, collections.abc.Mapping):\n         return source_config\n \n     for field_name, source_value in source_config.items():\n         # Since this key/value is from the source configuration, leave it uncommented and remove any\n         # sentinel that would cause it to get commented out.\n         remove_commented_out_sentinel(destination_config, field_name)\n \n         # This is a mapping. Recurse for this key/value.\n         if isinstance(source_value, collections.abc.Mapping):\n             destination_config[field_name] = merge_source_configuration_into_destination(\n                 destination_config[field_name], source_value\n             )\n             continue\n \n         # This is a sequence. Recurse for each item in it.\n         if isinstance(source_value, collections.abc.Sequence) and not isinstance(source_value, str):\n             destination_value = destination_config[field_name]\n             destination_config[field_name] = yaml.comments.CommentedSeq(\n                 [\n                     merge_source_configuration_into_destination(\n                         destination_value[index] if index < len(destination_value) else None,\n                         source_item,\n                     )\n                     for index, source_item in enumerate(source_value)\n                 ]\n             )\n             continue\n \n         # This is some sort of scalar. Simply set it into the destination.\n         destination_config[field_name] = source_config[field_name]\n \n     return destination_config\n \n \n def generate_sample_configuration(\n     source_filename, destination_filename, schema_filename, overwrite=False\n ):\n     '''\n     Given an optional source configuration filename, and a required destination configuration\n     filename, the path to a schema filename in a YAML rendition of the JSON Schema format, and\n     whether to overwrite a destination file, write out a sample configuration file based on that\n     schema. If a source filename is provided, merge the parsed contents of that configuration into\n     the generated configuration.\n     '''\n     schema = yaml.round_trip_load(open(schema_filename))\n     source_config = None\n \n     if source_filename:\n         source_config = load.load_configuration(source_filename)\n         normalize.normalize(source_config)\n \n     destination_config = merge_source_configuration_into_destination(\n         _schema_to_sample_configuration(schema), source_config\n     )\n \n     write_configuration(\n         destination_filename,\n         _comment_out_optional_configuration(render_configuration(destination_config)),\n         overwrite=overwrite,\n     )\n ", "input_code": "def write_configuration(config_filename, rendered_config, mode=384, overwrite=False):\n\"\"\"\nGiven a target config filename and rendered config YAML, write it out to file. Create any\ncontaining directories as needed. But if the file already exists and overwrite is False,\nabort before writing anything.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def write_configuration(config_filename, rendered_config, mode=0o600, overwrite=False):\n    '''\n    Given a target config filename and rendered config YAML, write it out to file. Create any\n    containing directories as needed. But if the file already exists and overwrite is False,\n    abort before writing anything.\n    '''\n    if not overwrite and os.path.exists(config_filename):\n        raise FileExistsError(\n            '{} already exists. Aborting. Use --overwrite to replace the file.'.format(\n                config_filename\n            )\n        )\n\n    try:\n        os.makedirs(os.path.dirname(config_filename), mode=0o700)\n    except (FileExistsError, FileNotFoundError):\n        pass\n\n    with open(config_filename, 'w') as config_file:\n        config_file.write(rendered_config)\n\n    os.chmod(config_filename, mode)", "signature": "def write_configuration(config_filename, rendered_config, mode=384, overwrite=False):", "completion_path": "borgmatic/config/generate.py"}
{"ce_id": "62ece4992e6aefcf4aabbd7c", "namespace": "62ece4992e6aefcf4aabbd7c", "namespace_real": "cloudmesh.common.Shell.oneline", "real_proj_path": "cloudmesh---cloudmesh-common/", "type": "class", "class_name": "Shell", "function_name": "oneline", "contexts_above": "\"\"\"\nA convenient method to execute shell commands and return their output. Note:\nthat this method requires that the command be completely execute before the\noutput is returned. FOr many activities in cloudmesh this is sufficient.\n\n\"\"\"\nimport errno\nimport glob\nimport os\nimport platform as os_platform\nimport requests\nimport shlex\nimport shutil\nimport subprocess\nimport sys\nimport textwrap\nimport zipfile\nfrom pathlib import Path\nfrom pipes import quote\nfrom sys import platform\nfrom tqdm import tqdm\n\nimport psutil\nfrom cloudmesh.common.StopWatch import StopWatch\nfrom cloudmesh.common.console import Console\nfrom cloudmesh.common.dotdict import dotdict\nfrom cloudmesh.common.systeminfo import get_platform\nfrom cloudmesh.common.util import path_expand\nfrom cloudmesh.common.util import readfile\n\n\n# from functools import wraps\n# def timer(func):\n#    @wraps(func)\n#    def wrapper(*args,**kwargs):\n#        print(f\"{func.__name__!r} begins\")\n#        start_time = time.time()\n#        result = func(*args,**kwargs)\n#        print(f\"{func.__name__!r} ends in {time.time()-start_time}  secs\")\n#        return result\n#    return wrapper\n\n# def NotImplementedInWindows(f):\n#    def new_f(*args):\n#        if sys.platform == \"win32\":\n#            Console.error(\"The method {f.__name__} is not implemented in Windows,\"\n#                        \" please implement, and/or submit an issue.\")\n#            sys.exit()\n#        f(args)\n#    return new_f\n\ndef windows_not_supported(f):\n    def wrapper(*args, **kwargs):\n        host = get_platform()\n        if host == \"windows\":\n            Console.error(\"Not supported on windows\")\n            return \"\"\n        else:\n            return f(*args, **kwargs)\n\n    return wrapper\n\ndef NotImplementedInWindows():\n    if sys.platform == \"win32\":\n        Console.error(f\"The method {__name__} is not implemented in Windows.\")\n        sys.exit()\n\n\nclass Brew(object):\n\n    @classmethod\n    def install(cls, name):\n\n        r = Shell.brew(\"install\", name)\n        print(r)\n\n        if \"already satisfied: \" + name in r:\n            print(name, \"... already installed\")\n            Console.ok(r)\n        elif \"Successfully installed esptool\":\n            print(name, \"... installed\")\n            Console.ok(r)\n        else:\n            print(name, \"... error\")\n            Console.error(r)\n\n    @classmethod\n    def version(cls, name):\n        r = Shell.brew(\"ls\", \"--version\", \"name\")\n        print(r)\n\n\nclass Pip(object):\n    @classmethod\n    def install(cls, name):\n        r = Shell.pip(\"install\", name)\n        if f\"already satisfied: {name}\" in r:\n            print(name, \"... already installed\")\n            Console.ok(r)\n        elif f\"Successfully installed {name}\":\n            print(name, \"... installed\")\n            Console.ok(r)\n        else:\n            print(name, \"... error\")\n            Console.error(r)\n\n\nclass SubprocessError(Exception):\n    \"\"\"\n    Manages the formatting of the error and stdout.\n    This command should not be directly called. Instead use Shell\n    \"\"\"\n\n    def __init__(self, cmd, returncode, stderr, stdout):\n        \"\"\"\n        sets the error\n        :param cmd: the command executed\n        :param returncode: the return code\n        :param stderr: the stderr\n        :param stdout: the stdout\n        \"\"\"\n        self.cmd = cmd\n        self.returncode = returncode\n        self.stderr = stderr\n        self.stdout = stdout\n\n    def __str__(self):\n\n        def indent(lines, amount, ch=' '):\n            \"\"\"\n            indent the lines by multiples of ch\n            :param lines:\n            :param amount:\n            :param ch:\n            :return:\n            \"\"\"\n            padding = amount * ch\n            return padding + ('\\n' + padding).join(lines.split('\\n'))\n\n        cmd = ' '.join(map(quote, self.cmd))\n        s = ''\n        s += 'Command: %s\\n' % cmd\n        s += 'Exit code: %s\\n' % self.returncode\n\n        if self.stderr:\n            s += 'Stderr:\\n' + indent(self.stderr, 4)\n        if self.stdout:\n            s += 'Stdout:\\n' + indent(self.stdout, 4)\n\n        return s\n\n\nclass Subprocess(object):\n    \"\"\"\n    Executes a command. This class should not be directly used, but\n    instead you should use Shell.\n    \"\"\"\n\n    def __init__(self, cmd, cwd=None, stderr=subprocess.PIPE,\n                 stdout=subprocess.PIPE, env=None):\n        \"\"\"\n        execute the given command\n        :param cmd: the command\n        :param cwd: the directory in which to execute the command\n        :param stderr: the pipe for stderror\n        :param stdout: the pipe for the stdoutput\n        :param env:\n        \"\"\"\n        Console.debug_msg('Running cmd: {}'.format(' '.join(map(quote, cmd))))\n\n        proc = subprocess.Popen(cmd, stderr=stderr, stdout=stdout, cwd=cwd,\n                                env=env)\n        stdout, stderr = proc.communicate()\n\n        self.returncode = proc.returncode\n        self.stderr = stderr\n        self.stdout = stdout\n\n        if self.returncode != 0:\n            raise SubprocessError(cmd, self.returncode, self.stderr,\n                                  self.stdout)\n\n\nclass Shell(object):\n    \"\"\"\n    The shell class allowing us to conveniently access many operating system commands.\n    TODO: This works well on Linux and OSX, but has not been tested much on Windows\n    \"\"\"\n\n    # TODO: we have not supported cygwin for a while\n    # cygwin_path = 'bin'  # i copied fom C:\\cygwin\\bin\n\n    command = {\n        'windows': {},\n        'linux': {},\n        'darwin': {}\n    }\n\n    # TODO\n    #\n    # how do we now define dynamically functions based on a list that we want to support\n    #\n    # what we want is where args are multiple unlimited parameters to the function\n    #\n    # def f(args...):\n    #     name = get the name from f\n    #     a = list of args...\n    #\n    #    cls.execute(cmd, arguments=a, capture=True, verbose=False)\n    #\n    # commands = ['ps', 'ls', ..... ]\n    # for c in commands:\n    #    generate this command and add to this class dynamically\n    #\n    # or do something more simple\n    #\n    # ls = cls.execute('cmd', args...)\n    @staticmethod\n    def timezone(default=\"America/Indiana/Indianapolis\"):\n        # BUG we need to be able to pass the default from the cmdline\n        host = get_platform()\n        if host == \"windows\":\n            return default\n        else:\n            # result = Shell.run(\"ls -l /etc/localtime\").strip().split(\"/\")\n            try:\n                result = Shell.run(\"ls -l /etc/localtime\").strip().split(\"zoneinfo\")[1][1:]\n                return result\n            except IndexError as e:\n                return default\n\n    @staticmethod\n    @windows_not_supported\n    def locale():\n        try:\n            result = Shell.run('locale').split('\\n')[0].split('_')[1].split('.')[0].lower()\n            return result\n        except IndexError as e:\n            Console.warning('Could not determine locale. Defaulting to \"us\"')\n            return 'us'\n\n    @staticmethod\n    def run_timed(label, command, encoding=None, service=None):\n        \"\"\"\n        runs the command and uses the StopWatch to time it\n        :param label: name of the StopWatch\n        :param command: the command to be executed\n        :param encoding: the encoding\n        :param service: a prefix to the stopwatch label\n        :return:\n        \"\"\"\n        _label = str(label)\n        print(_label, command)\n        StopWatch.start(f\"{service} {_label}\")\n        result = Shell.run(command, encoding)\n        StopWatch.stop(f\"{service} {_label}\")\n        return str(result)\n\n    @staticmethod\n    def run(command, exit=\"; exit 0\", encoding='utf-8'):\n        \"\"\"\n        executes the command and returns the output as string\n        :param command:\n        :param encoding:\n        :return:\n        \"\"\"\n\n        if sys.platform == \"win32\":\n            command = f\"{command}\"\n        else:\n            command = f\"{command} {exit}\"\n\n        r = subprocess.check_output(command,\n                                    stderr=subprocess.STDOUT,\n                                    shell=True)\n        if encoding is None or encoding == 'utf-8':\n            return str(r, 'utf-8')\n        else:\n            return r\n\n    @staticmethod\n    def run2(command, encoding='utf-8'):\n        \"\"\"\n        executes the command and returns the output as string. This command also\n        allows execution of 32 bit commands.\n\n        :param command: the program or command to be executed\n        :param encoding: encoding of the output\n        :return:\n        \"\"\"\n        if platform.lower() == 'win32':\n            import ctypes\n\n            class disable_file_system_redirection:\n                _disable = ctypes.windll.kernel32.Wow64DisableWow64FsRedirection\n                _revert = ctypes.windll.kernel32.Wow64RevertWow64FsRedirection\n\n                def __enter__(self):\n                    self.old_value = ctypes.c_long()\n                    self.success = self._disable(ctypes.byref(self.old_value))\n\n                def __exit__(self, type, value, traceback):\n                    if self.success:\n                        self._revert(self.old_value)\n\n            with disable_file_system_redirection():\n                command = f\"{command}\"\n                r = subprocess.check_output(command,\n                                            stderr=subprocess.STDOUT,\n                                            shell=True)\n                if encoding is None or encoding == 'utf-8':\n                    return str(r, 'utf-8')\n                else:\n                    return r\n        elif platform.lower() == 'linux' or platform.lower() == 'darwin':\n            command = f\"{command}\"\n            r = subprocess.check_output(command,\n                                        stderr=subprocess.STDOUT,\n                                        shell=True)\n            if encoding is None or encoding == 'utf-8':\n                return str(r, 'utf-8')\n            else:\n                return r\n\n    @classmethod\n    def execute(cls,\n                cmd,\n                arguments=\"\",\n                shell=False,\n                cwd=None,\n                traceflag=True,\n                witherror=True):\n        \"\"\"Run Shell command\n\n        :param witherror: if set to False the error will not be printed\n        :param traceflag: if set to true the trace is printed in case of an error\n        :param cwd: the current working directory in which the command is\n        supposed to be executed.\n        :param shell: if set to true the subprocess is called as part of a shell\n        :param cmd: command to run\n        :param arguments: we do not know yet\n        :return:\n        \"\"\"\n        # print \"--------------\"\n        result = None\n        terminal = cls.terminal_type()\n        # print cls.command\n        os_command = [cmd]\n        if terminal in ['linux', 'windows']:\n            os_command = [cmd]\n        elif 'cygwin' in terminal:\n            if not cls.command_exists(cmd):\n                print(\"ERROR: the command could not be found\", cmd)\n                return\n            else:\n                os_command = [cls.command[cls.operating_system()][cmd]]\n\n        if isinstance(arguments, list):\n            os_command = os_command + arguments\n        elif isinstance(arguments, tuple):\n            os_command = os_command + list(arguments)\n        elif isinstance(arguments, str):\n            os_command = os_command + arguments.split()\n        else:\n            print(\"ERROR: Wrong parameter type\", type(arguments))\n\n        if cwd is None:\n            cwd = os.getcwd()\n        # noinspection PyPep8\n        try:\n            if shell:\n                if platform.lower() == 'win32':\n                    import ctypes\n\n                    class disable_file_system_redirection:\n                        _disable = ctypes.windll.kernel32.Wow64DisableWow64FsRedirection\n                        _revert = ctypes.windll.kernel32.Wow64RevertWow64FsRedirection\n\n                        def __enter__(self):\n                            self.old_value = ctypes.c_long()\n                            self.success = self._disable(\n                                ctypes.byref(self.old_value))\n\n                        def __exit__(self, type, value, traceback):\n                            if self.success:\n                                self._revert(self.old_value)\n\n                    if len(os_command) == 1:\n                        os_command = os_command[0].split(' ')\n                    with disable_file_system_redirection():\n                        result = subprocess.check_output(os_command,\n                                                         stderr=subprocess.STDOUT,\n                                                         shell=True,\n                                                         cwd=cwd)\n                else:\n                    result = subprocess.check_output(\n                        os_command,\n                        stderr=subprocess.STDOUT,\n                        shell=True,\n                        cwd=cwd)\n            else:\n                result = subprocess.check_output(\n                    os_command,\n                    # shell=True,\n                    stderr=subprocess.STDOUT,\n                    cwd=cwd)\n        except:\n            if witherror:\n                Console.error(\"problem executing subprocess\",\n                              traceflag=traceflag)\n        if result is not None:\n            result = result.strip().decode()\n        return result\n\n    @staticmethod", "contexts_below": "    @staticmethod\n     def is_root():\n         \"\"\"\n         checks if the user is root\n \n         :return: True if the user is root\n         :rtype: boolean\n         \"\"\"\n         username = subprocess.getoutput(\"whoami\")\n         return username == \"root\"\n \n     @staticmethod\n     def rmdir(top, verbose=False):\n         \"\"\"\n         removes a directory\n \n         :param top: removes the directory tree from the top\n         :type top: str\n         :param verbose: unused\n         :type verbose: unused\n         :return: void\n         :rtype: void\n         \"\"\"\n         p = Path(top)\n         if not p.exists():\n             return\n         try:\n             shutil.rmtree(path_expand(top))\n         except Exception as e:\n             pass\n             # print(e.strerror)\n             # assert False, f\"Directory {top} could not be deleted\"\n \n     @staticmethod\n     def dot2svg(filename, engine='dot'):\n         data = {\n             'engine': engine,\n             'file': filename.replace(\".dot\", \"\")\n         }\n         command = \"{engine} -Tsvg {file}.dot > {file}.svg\".format(**data)\n         print(command)\n         os.system(command)\n \n     @staticmethod\n     def browser(filename):\n         data = {\n             'engine': 'python -m webbrowser',\n             'file': filename\n         }\n         if 'file:' not in filename and 'http' not in filename:\n             os.system(\"python -m webbrowser -t file:///{file}\".format(**data))\n         else:\n             os.system(\"python -m webbrowser -t {file}\".format(**data))\n \n     @staticmethod\n     def terminal_title(name):\n         \"\"\"\n         sets the title of the terminal\n \n         :param name: the title\n         :type name: str\n         :return: void\n         :rtype: void\n         \"\"\"\n         return f'echo -n -e \\\"\\033]0;{name}\\007\\\"'\n \n     @classmethod\n     def terminal(cls, command='pwd', title=None, kind=None):\n         \"\"\"\n         starts a terminal and executes the command in that terminal\n \n         :param command: the command to be executed\n         :type command: str\n         :param title: the title\n         :type title: str\n         :param kind: for windows you can set \"cmd\", \"powershell\", or \"gitbash\"\n         :type kind: str\n         :return: void\n         :rtype: void\n         \"\"\"\n         # title nameing not implemented\n         print(platform)\n         if platform == 'darwin':\n             label = Shell.terminal_title(title)\n \n             os.system(\n                 f\"osascript -e 'tell application \\\"Terminal\\\" to do script \\\"{command}\\\"'\"\n             )\n         elif platform == \"linux\":  # for ubuntu running gnome\n             dist = os_platform.linux_distribution()[0]\n             linux_apps = {'ubuntu': 'gnome-terminal', 'debian':'lxterminal'}\n             os.system(f\"{linux_apps[dist]} -e \\\"bash -c \\'{command}; exec $SHELL\\'\\\"\")\n \n         elif platform == \"win32\":\n             if kind is None:\n                 if Path.is_dir(Path(r\"C:\\Program Files\\Git\")):\n                     kind = \"gitbash\"\n             kind = kind.lower()\n             if kind == \"gitbash\":\n                 p = subprocess.Popen([r\"C:\\Program Files\\Git\\git-bash.exe\",\n                                   \"-c\", f\"{command}\"])\n                 return p.pid\n             elif kind == \"cmd\":\n                 Console.error(f\"Command not implemented for {kind}\")\n             elif kind == \"powershell\":\n                 Console.error(f\"Command not implemented for {kind}\")\n             else:\n                 Console.error(\"Git bash is not found, please make sure it \"\n                               \"is installed. Other terminals not supported.\")\n                 raise NotImplementedError\n         else:\n             raise NotImplementedError\n \n     @classmethod\n     def live(cls, command, cwd=None):\n         if cwd is None:\n             cwd = os.getcwd()\n         process = subprocess.Popen(shlex.split(command), cwd=cwd,\n                                    stdout=subprocess.PIPE)\n         result = b''\n         while True:\n             output = process.stdout.read(1)\n             if output == b'' and process.poll() is not None:\n                 break\n             if output:\n                 result = result + output\n                 sys.stdout.write(output.decode(\"utf-8\"))\n                 sys.stdout.flush()\n         rc = process.poll()\n         data = dotdict({\n             \"status\": rc,\n             \"text\": output.decode(\"utf-8\")\n         })\n         return data\n \n     @classmethod\n     def get_python(cls):\n         \"\"\"\n         returns the python and pip version\n         :return: python version, pip version\n         \"\"\"\n         python_version = sys.version_info[:3]\n         v_string = [str(i) for i in python_version]\n         python_version_s = '.'.join(v_string)\n \n         # pip_version = pip.__version__\n         pip_version = Shell.pip(\"--version\").split()[1]\n         return python_version_s, pip_version\n \n     @classmethod\n     def check_output(cls, *args, **kwargs):\n         \"\"\"Thin wrapper around :func:`subprocess.check_output`\n         \"\"\"\n         return subprocess.check_output(*args, **kwargs)\n \n     @classmethod\n     def ls(cls, match=\".\"):\n         \"\"\"\n         executes ls with the given arguments\n         :param args:\n         :return: list\n         \"\"\"\n         d = glob.glob(match)\n         return d\n \n     @classmethod\n     # @NotImplementedInWindows\n     def unix_ls(cls, *args):\n         \"\"\"\n         executes ls with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('ls', args)\n \n     @staticmethod\n     def ps():\n         \"\"\"\n         using psutil to return the process information pid, name and comdline,\n         cmdline may be a list\n \n         :return: a list of dicts of process information\n         \"\"\"\n         found = []\n         for proc in psutil.process_iter():\n             try:\n                 pinfo = proc.as_dict(attrs=['pid', 'name', 'cmdline'])\n             except psutil.NoSuchProcess:\n                 pass\n             else:\n                 found.append(pinfo)\n         if len(pinfo) == 0:\n             return None\n         else:\n             return found\n \n     @classmethod\n     def bash(cls, *args):\n         \"\"\"\n         executes bash with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('bash', args)\n \n     @classmethod\n     # @NotImplementedInWindows\n     def brew(cls, *args):\n         \"\"\"\n         executes bash with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         NotImplementedInWindows()\n         return cls.execute('brew', args)\n \n     @classmethod\n     # @NotImplementedInWindows\n     def cat(cls, *args):\n         \"\"\"\n         executes cat with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         NotImplementedInWindows()\n         # TODO: replace with file read and reading the content. We need to deal\n         #       with line endings and add maybe a flag endings=\"unix\"/\"windows\".\n         #       check the finction readlines.\n         return cls.execute('cat', args)\n \n     @classmethod\n     def git(cls, *args):\n         \"\"\"\n         executes git with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         NotImplementedInWindows()\n         return cls.execute('git', args)\n \n     # noinspection PyPep8Naming\n     @classmethod\n     def VBoxManage(cls, *args):\n         \"\"\"\n         executes VboxManage with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n \n         if platform == \"darwin\":\n             command = \"/Applications/VirtualBox.app/Contents/MacOS/VBoxManage\"\n         else:\n             command = 'VBoxManage'\n         return cls.execute(command, args)\n \n     @classmethod\n     def blockdiag(cls, *args):\n         \"\"\"\n         executes blockdiag with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('blockdiag', args)\n \n     @classmethod\n     def cm(cls, *args):\n         \"\"\"\n         executes cm with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('cm', args)\n \n     @classmethod\n     def cms(cls, *args):\n         \"\"\"\n         executes cm with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('cms', args)\n \n     @classmethod\n     def cmsd(cls, *args):\n         \"\"\"\n         executes cm with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('cmsd', args)\n \n     @classmethod\n     # @NotImplementedInWindows\n     def head(cls, *args):\n         \"\"\"\n         executes head with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         NotImplementedInWindows()\n         # TODO: reimplement with readlines\n         return cls.execute('head', args)\n \n     @classmethod\n     def keystone(cls, *args):\n         \"\"\"\n         executes keystone with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('keystone', args)\n \n     @staticmethod\n     def kill_pid(pid):\n \n         if sys.platform == 'win32':\n             try:\n                 result = Shell.run(f\"taskkill /IM {pid} /F\")\n             except Exception as e:\n                 result = str(e)\n         else:\n             try:\n                 result = Shell.kill(\"-9\", pid)\n             except subprocess.CalledProcessError:\n                 result = 'server is already down...'\n         return result\n \n     @classmethod\n     # @NotImplementedInWindows\n     def kill(cls, *args):\n         \"\"\"\n         executes kill with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         NotImplementedInWindows()\n         # TODO: use tasklisk, compare to linux\n         return cls.execute('kill', args)\n \n     @classmethod\n     def download(cls, source, destination, force=False, provider=None, chunk_size=128):\n         \"\"\"\n         Given a source url and a destination filename, download the file at the source url\n         to the destination.\n \n         If provider is None, the request lib is used\n         If provider is 'system', wget, curl, and requests lib are attempted in that order\n         \"\"\"\n         destination = path_expand(destination)\n \n         if os.path.exists(destination) and not force:\n             return destination\n \n         if provider == 'system':\n             # First try wget\n             wget_return = os.system(f'wget -O {destination} {source}')\n             if wget_return == 0:\n                 Console.info('Used wget')\n                 return destination\n             # Then curl\n             curl_return = os.system(f'curl -L -o {destination} {source}')\n             if curl_return == 0:\n                 Console.info('Used curl')\n                 return destination\n         # Default is requests lib. If provider is None, or if provider == 'system'\n         # but wget and curl fail, default here\n         r = requests.get(source, stream=True, allow_redirects=True)\n         total_size = int(r.headers.get('content-length'))\n \n         with open(destination, 'wb') as fd:\n             with tqdm(total=total_size, unit=\"B\",\n                unit_scale=True, desc=destination, initial=0, ascii=True) as pbar:\n                 for chunk in r.iter_content(chunk_size=chunk_size):\n                     fd.write(chunk)\n                     pbar.update(len(chunk))\n \n             return destination\n \n     @classmethod\n     def mount(cls, *args):\n         \"\"\"\n         mounts a given mountpoint to a file\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('mount', args)\n \n     @classmethod\n     def umount(cls, *args):\n         \"\"\"\n         umounts a given mountpoint to a file\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('umount', args)\n \n     @classmethod\n     def nova(cls, *args):\n         \"\"\"\n         executes nova with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('nova', args)\n \n     @classmethod\n     def ping(cls, host=None, count=1):\n         \"\"\"\n         execute ping\n         :param host: the host to ping\n         :param count: the number of pings\n         :return:\n         \"\"\"\n         option = '-n' if platform == 'windows' else '-c'\n         return cls.execute('ping',\n                            \"{option} {count} {host}\".format(option=option,\n                                                             count=count,\n                                                             host=host))\n \n     @classmethod\n     def pwd(cls, *args):\n         \"\"\"\n         executes pwd with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return os.getcwd()\n \n     @classmethod\n     def rackdiag(cls, *args):\n         \"\"\"\n         executes rackdiag with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('rackdiag', args)\n \n     @classmethod\n     # @NotImplementedInWindows\n     def rm(cls, location):\n         \"\"\"\n         executes rm tree with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         shutil.rmtree(path_expand(location))\n \n     @classmethod\n     def rsync(cls, *args):\n         \"\"\"\n         executes rsync with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('rsync', args)\n \n     @classmethod\n     def scp(cls, *args):\n         \"\"\"\n         executes scp with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('scp', args)\n \n     @classmethod\n     # @NotImplementedInWindows\n     def sort(cls, *args):\n         \"\"\"\n         executes sort with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         NotImplementedInWindows()\n         # TODO: https://superuser.com/questions/1316317/is-there-a-windows-equivalent-to-the-unix-uniq\n         return cls.execute('sort', args)\n \n     @classmethod\n     def sh(cls, *args):\n         \"\"\"\n         executes sh with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('sh', args)\n \n     @classmethod\n     def ssh(cls, *args):\n         \"\"\"\n         executes ssh with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('ssh', args)\n \n     @classmethod\n     # @NotImplementedInWindows\n     def sudo(cls, *args):\n         \"\"\"\n         executes sudo with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         NotImplementedInWindows()\n         # TODO: https://stackoverflow.com/questions/9652720/how-to-run-sudo-command-in-windows\n         return cls.execute('sudo', args)\n \n     @classmethod\n     # @NotImplementedInWindows\n     def tail(cls, *args):\n         \"\"\"\n         executes tail with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         NotImplementedInWindows()\n         # TODO: implement with readlines on a file.\n         return cls.execute('tail', args)\n \n     @classmethod\n     def vagrant(cls, *args):\n         \"\"\"\n         executes vagrant with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('vagrant', args, shell=True)\n \n     @classmethod\n     def pandoc(cls, *args):\n         \"\"\"\n         executes vagrant with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('pandoc', args)\n \n     @classmethod\n     def mongod(cls, *args):\n         \"\"\"\n         executes mongod with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('mongod', args)\n \n     @classmethod\n     # @NotImplementedInWindows\n     def dialog(cls, *args):\n         \"\"\"\n         executes dialof with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         NotImplementedInWindows()\n         return cls.execute('dialog', args)\n \n     @classmethod\n     def pip(cls, *args):\n         \"\"\"\n         executes pip with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         return cls.execute('pip', args)\n \n     @classmethod\n     # @NotImplementedInWindows\n     def fgrep(cls, *args):\n         \"\"\"\n         executes fgrep with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         NotImplementedInWindows()\n         # TODO: see cm_grep\n         return cls.execute('fgrep', args)\n \n     @classmethod\n     # @NotImplementedInWindows\n     def grep(cls, *args):\n         \"\"\"\n         executes grep with the given arguments\n         :param args:\n         :return:\n         \"\"\"\n         NotImplementedInWindows()\n         return cls.execute('grep', args)\n \n     @classmethod\n     def cm_grep(cls, lines, what):\n         \"\"\"\n         returns all lines that contain what\n         :param lines:\n         :param what:\n         :return:\n         \"\"\"\n         if type(lines) == str:\n             _lines = lines.splitlines()\n         else:\n             _lines = lines\n         result = []\n         for line in _lines:\n             if what in line:\n                 result.append(line)\n         return result\n \n     @classmethod\n     def remove_line_with(cls, lines, what):\n         \"\"\"\n         returns all lines that do not contain what\n         :param lines:\n         :param what:\n         :return:\n         \"\"\"\n         if type(lines) == str:\n             _lines = lines.splitlines()\n         else:\n             _lines = lines\n         result = []\n         for line in _lines:\n             if what not in line:\n                 result = result + [line]\n         return result\n \n     @classmethod\n     def find_lines_with(cls, lines, what):\n         \"\"\"\n         returns all lines that contain what\n         :param lines:\n         :param what:\n         :return:\n         \"\"\"\n         if type(lines) == str:\n             _lines = lines.splitlines()\n         else:\n             _lines = lines\n         result = []\n         for line in _lines:\n             if what in line:\n                 result = result + [line]\n         return result\n \n     @classmethod\n     def find_lines_from(cls, lines, what):\n         \"\"\"\n         returns all lines that come after a particular line\n         :param lines:\n         :param what:\n         :return:\n         \"\"\"\n         if type(lines) == str:\n             _lines = lines.splitlines()\n         else:\n             _lines = lines\n         result = []\n         found = False\n         for line in _lines:\n             found = found or what in line\n             if found:\n                 result = result + [line]\n         return result\n \n     @classmethod\n     def find_lines_between(cls, lines, what_from, what_to):\n         \"\"\"\n         returns all lines that come between the markers\n         :param lines:\n         :param what:\n         :return:\n         \"\"\"\n         select = Shell.find_lines_from(lines, what_from)\n         select = Shell.find_lines_to(select, what_to)\n         return select\n \n     @classmethod\n     def find_lines_to(cls, lines, what):\n         \"\"\"\n         returns all lines that come before a particular line\n         :param lines:\n         :param what:\n         :return:\n         \"\"\"\n         if type(lines) == str:\n             _lines = lines.splitlines()\n         else:\n             _lines = lines\n         result = []\n         found = True\n         for line in _lines:\n             if what in line:\n                 return result\n             else:\n                 result = result + [line]\n         return result\n \n     @classmethod\n     def terminal_type(cls):\n         \"\"\"\n         returns  darwin, cygwin, cmd, or linux\n         \"\"\"\n         what = sys.platform\n \n         kind = 'UNDEFINED_TERMINAL_TYPE'\n         if 'linux' in what:\n             kind = 'linux'\n         elif 'darwin' in what:\n             kind = 'darwin'\n         elif 'cygwin' in what:\n             kind = 'cygwin'\n         elif what in ['windows', 'win32']:\n             kind = 'windows'\n \n         return kind\n \n     @classmethod\n     def which(cls, command):\n         \"\"\"\n         returns the path of the command with which\n         :param command: teh command\n         :return: the path\n         \"\"\"\n         return shutil.which(command)\n \n     @classmethod\n     def command_exists(cls, name):\n         \"\"\"\n         returns True if the command exists\n         :param name:\n         :return:\n         \"\"\"\n         return cls.which(name) is not None\n \n     @classmethod\n     def operating_system(cls):\n         \"\"\"\n         the name of the os\n         :return: the name of the os\n         \"\"\"\n         return platform\n \n     @staticmethod\n     def get_pid(name, service=\"psutil\"):\n         pid = None\n         for proc in psutil.process_iter():\n             if name in proc.name():\n                 pid = proc.pid\n         return pid\n \n     @staticmethod\n     def cms(command, encoding='utf-8'):\n         return Shell.run(\"cms \" + command, encoding=encoding)\n \n     @classmethod\n     def check_python(cls):\n         \"\"\"\n         checks if the python version is supported\n         :return: True if it is supported\n         \"\"\"\n         python_version = sys.version_info[:3]\n \n         v_string = [str(i) for i in python_version]\n \n         python_version_s = '.'.join(v_string)\n \n         if python_version[0] == 2:\n \n             print(\n                 \"You are running an unsupported version of python: {:}\".format(\n                     python_version_s))\n \n             # python_version_s = '.'.join(v_string)\n             # if (python_version[0] == 2) and (python_version[1] >= 7) and (python_version[2] >= 9):\n \n             #    print(\"You are running an unsupported version of python: {:}\".format(python_version_s))\n             # else:\n             #    print(\"WARNING: You are running an unsupported version of python: {:}\".format(python_version_s))\n             #    print(\"         We recommend you update your python\")\n \n         elif python_version[0] == 3:\n \n             if (python_version[0] == 3) and (python_version[1] >= 7) and (python_version[2] >= 0):\n \n                 print(\n                     \"You are running a supported version of python: {:}\".format(\n                         python_version_s))\n             else:\n                 print(\n                     \"WARNING: You are running an unsupported version of python: {:}\".format(\n                         python_version_s))\n                 print(\"         We recommend you update your python\")\n \n         # pip_version = pip.__version__\n         python_version, pip_version = cls.get_python()\n \n         if int(pip_version.split(\".\")[0]) >= 19:\n             print(\"You are running a supported version of pip: \" + str(\n                 pip_version))\n         else:\n             print(\"WARNING: You are running an old version of pip: \" + str(\n                 pip_version))\n             print(\"         We recommend you update your pip  with \\n\")\n             print(\"             pip install -U pip\\n\")\n \n     @classmethod\n     def mkdir(cls, directory):\n         \"\"\"\n         creates a directory with all its parents in ots name\n         :param directory: the path of the directory\n         :return:\n         \"\"\"\n         directory = path_expand(directory)\n         Path(directory).mkdir(parents=True, exist_ok=True)\n \n         #try:\n         #    os.makedirs(directory)\n         #except OSError as e:\n \n             # EEXIST (errno 17) occurs under two conditions when the path exists:\n             # - it is a file\n             # - it is a directory\n             #\n             # if it is a file, this is a valid error, otherwise, all\n             # is fine.\n         #    if e.errno == errno.EEXIST and os.path.isdir(directory):\n         #        pass\n         #    else:\n         #        raise\n \n     def unzip(cls, source_filename, dest_dir):\n         \"\"\"\n         unzips a file into the destination directory\n         :param source_filename: the source\n         :param dest_dir: the destination directory\n         :return:\n         \"\"\"\n \n         with zipfile.ZipFile(source_filename) as zf:\n             for member in zf.infolist():\n                 # Path traversal defense copied from\n                 # http://hg.python.org/cpython/file/tip/Lib/http/server.py#l789\n                 words = member.filename.split('/')\n                 path = path_expand(dest_dir)\n                 for word in words[:-1]:\n                     drive, word = os.path.splitdrive(word)\n                     head, word = os.path.split(word)\n                     if word in (os.curdir, os.pardir, ''):\n                         continue\n                     path = os.path.join(path, word)\n                 zf.extract(member, path)\n \n     @staticmethod\n     def edit(filename):\n         if platform == 'darwin':\n             os.system(\"emacs \" + filename)\n         elif platform == \"windows\":\n             os.system(\"notepad \" + filename)\n         else:\n             raise NotImplementedError(\"Editor not configured for OS\")\n \n     @classmethod\n     # @NotImplementedInWindows\n     def lsb_release(cls):\n         \"\"\"\n         executes lsb_release command\n         :param args:\n         :return:\n         \"\"\"\n         NotImplementedInWindows()\n         return cls.execute('lsb_release', ['-a'])\n \n     @classmethod\n     def distribution(cls):\n         \"\"\"\n         executes lsb_release command\n         :param args:\n         :return:\n \n         TODO: needs testing\n         \"\"\"\n \n         machine = platform.lower()\n \n         result = {\"platform\": machine,\n                   \"distribution\": None}\n \n         if machine == \"linux\":\n             try:\n                 release = readfile(\"/etc/os-release\")\n                 for line in release.splitlines():\n                     attribute, value = line.split(\"=\", 1)\n                     result[attribute] = value\n                 if \"Debian\" in result[\"NAME\"]:\n                     result[\"distribution\"] = \"debian\"\n                 elif \"Ubuntu\" in result[\"NAME\"]:\n                     result[\"distribution\"] = \"ubuntu\"\n \n             except:\n                 try:\n                     r = cls.lsb_release()\n                     for line in r.split():\n                         if \":\" in line:\n                             attribute, value = line.split(\":\", 1)\n                             attribute = attribute.strip().replace(\" \",\n                                                                   \"_\").lower()\n                             value = value.strip()\n                             result[attribute] = value\n                     result[\"distribution\"] = result[\"description\"].split(\" \")[\n                         0].lower()\n                 except:\n                     Console.error(\n                         f\"lsb_release not found for the platform {machine}\")\n                     raise NotImplementedError\n         elif machine == 'darwin':\n             result[\"distribution\"] = \"macos\"\n             result[\"version\"] = os_platform.mac_ver()[0]\n         elif machine == 'win32':\n             result[\"distribution\"] = \"windows\"\n             result[\"version\"] = os_platform.win_ver()[0]\n         else:\n             Console.error(f\"not implemented for the platform {machine}\")\n             raise NotImplementedError\n \n         return result\n \n \n def main():\n     \"\"\"\n     a test that should actually be added into a pytest\n     :return:\n     \"\"\"\n \n     print(Shell.terminal_type())\n \n     r = Shell.execute('pwd')  # copy line replace\n     print(r)\n \n     # shell.list()\n \n     # print json.dumps(shell.command, indent=4)\n \n     # test some commands without args\n     \"\"\"\n     for cmd in ['whoami', 'pwd']:\n         r = shell._execute(cmd)\n         print (\"---------------------\")\n         print (\"Command: {:}\".format(cmd))\n         print (\"{:}\".format(r))\n         print (\"---------------------\")\n     \"\"\"\n     r = Shell.execute('ls', [\"-l\", \"-a\"])\n     print(r)\n \n     r = Shell.execute('ls', \"-l -a\")\n     print(r)\n \n     if sys.platform != \"win32\":\n         r = Shell.unix_ls(\"-aux\")\n         print(r)\n \n         r = Shell.unix_ls(\"-a\", \"-u\", \"-x\")\n         print(r)\n \n     r = Shell.ls(\"./*.py\")\n     print(r)\n \n     r = Shell.ls(\"*/*.py\")\n     print(r)\n \n     r = Shell.pwd()\n     print(r)\n \n \n if __name__ == \"__main__\":\n     main()\n ", "input_code": "@staticmethod\ndef oneline(script, seperator=' && '):\n\"\"\"\nconverts a script to one line command.\nTHis is useful to run a single ssh command and pass a one line script.\n\n:param script:\n:return:\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def oneline(script, seperator=\" && \"):\n        \"\"\"\n        converts a script to one line command.\n        THis is useful to run a single ssh command and pass a one line script.\n\n        :param script:\n        :return:\n        \"\"\"\n        return seperator.join(textwrap.dedent(script).strip().splitlines())", "signature": "@staticmethod\ndef oneline(script, seperator=' && '):", "completion_path": "cloudmesh/common/Shell.py"}
{"ce_id": "62ece4992e6aefcf4aabbd7d", "namespace": "62ece4992e6aefcf4aabbd7d", "namespace_real": "lib.matplotlib.testing.__init__.subprocess_run_helper", "real_proj_path": "rougier---matplotlib/", "type": "function", "class_name": null, "function_name": "subprocess_run_helper", "contexts_above": "\"\"\"\nHelper functions for testing.\n\"\"\"\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport locale\nimport logging\nimport os\nimport subprocess\nimport sys\n\nimport matplotlib as mpl\nfrom matplotlib import _api\n\n_log = logging.getLogger(__name__)\n\n\ndef set_font_settings_for_testing():\n    mpl.rcParams['font.family'] = 'DejaVu Sans'\n    mpl.rcParams['text.hinting'] = 'none'\n    mpl.rcParams['text.hinting_factor'] = 8\n\n\ndef set_reproducibility_for_testing():\n    mpl.rcParams['svg.hashsalt'] = 'matplotlib'\n\n\ndef setup():\n    # The baseline images are created in this locale, so we should use\n    # it during all of the tests.\n\n    try:\n        locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')\n    except locale.Error:\n        try:\n            locale.setlocale(locale.LC_ALL, 'English_United States.1252')\n        except locale.Error:\n            _log.warning(\n                \"Could not set locale to English/United States. \"\n                \"Some date-related tests may fail.\")\n\n    mpl.use('Agg')\n\n    with _api.suppress_matplotlib_deprecation_warning():\n        mpl.rcdefaults()  # Start with all defaults\n\n    # These settings *must* be hardcoded for running the comparison tests and\n    # are not necessarily the default values as specified in rcsetup.py.\n    set_font_settings_for_testing()\n    set_reproducibility_for_testing()\n\n", "contexts_below": "\n def _check_for_pgf(texsystem):\n     \"\"\"\n     Check if a given TeX system + pgf is available\n \n     Parameters\n     ----------\n     texsystem : str\n         The executable name to check\n     \"\"\"\n     with TemporaryDirectory() as tmpdir:\n         tex_path = Path(tmpdir, \"test.tex\")\n         tex_path.write_text(r\"\"\"\n             \\documentclass{minimal}\n             \\usepackage{pgf}\n             \\begin{document}\n             \\typeout{pgfversion=\\pgfversion}\n             \\makeatletter\n             \\@@end\n         \"\"\", encoding=\"utf-8\")\n         try:\n             subprocess.check_call(\n                 [texsystem, \"-halt-on-error\", str(tex_path)], cwd=tmpdir,\n                 stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n         except (OSError, subprocess.CalledProcessError):\n             return False\n         return True\n \n \n def _has_tex_package(package):\n     try:\n         mpl.dviread._find_tex_file(f\"{package}.sty\")\n         return True\n     except FileNotFoundError:\n         return False\n ", "input_code": "def subprocess_run_helper(func, *args, timeout, extra_env=None):\n\"\"\"\nRun a function in a sub-process.\n\nParameters\n----------\nfunc : function\n    The function to be run.  It must be in a module that is importable.\n*args : str\n    Any additional command line arguments to be passed in\n    the first argument to ``subprocess.run``.\nextra_env : dict[str, str]\n    Any additional environment variables to be set for the subprocess.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def subprocess_run_helper(func, *args, timeout, extra_env=None):\n    \"\"\"\n    Run a function in a sub-process.\n\n    Parameters\n    ----------\n    func : function\n        The function to be run.  It must be in a module that is importable.\n    *args : str\n        Any additional command line arguments to be passed in\n        the first argument to ``subprocess.run``.\n    extra_env : dict[str, str]\n        Any additional environment variables to be set for the subprocess.\n    \"\"\"\n    target = func.__name__\n    module = func.__module__\n    proc = subprocess.run(\n        [sys.executable,\n         \"-c\",\n         f\"from {module} import {target}; {target}()\",\n         *args],\n        env={**os.environ, \"SOURCE_DATE_EPOCH\": \"0\", **(extra_env or {})},\n        timeout=timeout, check=True,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True)\n    return proc", "signature": "def subprocess_run_helper(func, *args, timeout, extra_env=None):", "completion_path": "lib/matplotlib/testing/__init__.py"}
{"ce_id": "62ece4992e6aefcf4aabbd7e", "namespace": "62ece4992e6aefcf4aabbd7e", "namespace_real": "borgmatic.config.override._resolve_string", "real_proj_path": "witten---borgmatic/", "type": "function", "class_name": null, "function_name": "_resolve_string", "contexts_above": "import io\nimport os\nimport re\n\nimport ruamel.yaml\n\n_VARIABLE_PATTERN = re.compile(r'(?<!\\\\)\\$\\{(?P<name>[A-Za-z0-9_]+)((:?-)(?P<default>[^}]+))?\\}')\n\n\ndef set_values(config, keys, value):\n    '''\n    Given a hierarchy of configuration dicts, a sequence of parsed key strings, and a string value,\n    descend into the hierarchy based on the keys to set the value into the right place.\n    '''\n    if not keys:\n        return\n\n    first_key = keys[0]\n    if len(keys) == 1:\n        config[first_key] = value\n        return\n\n    if first_key not in config:\n        config[first_key] = {}\n\n    set_values(config[first_key], keys[1:], value)\n\n\ndef convert_value_type(value):\n    '''\n    Given a string value, determine its logical type (string, boolean, integer, etc.), and return it\n    converted to that type.\n\n    Raise ruamel.yaml.error.YAMLError if there's a parse issue with the YAML.\n    '''\n    return ruamel.yaml.YAML(typ='safe').load(io.StringIO(value))\n\n\ndef parse_overrides(raw_overrides):\n    '''\n    Given a sequence of configuration file override strings in the form of \"section.option=value\",\n    parse and return a sequence of tuples (keys, values), where keys is a sequence of strings. For\n    instance, given the following raw overrides:\n\n        ['section.my_option=value1', 'section.other_option=value2']\n\n    ... return this:\n\n        (\n            (('section', 'my_option'), 'value1'),\n            (('section', 'other_option'), 'value2'),\n        )\n\n    Raise ValueError if an override can't be parsed.\n    '''\n    if not raw_overrides:\n        return ()\n\n    parsed_overrides = []\n\n    for raw_override in raw_overrides:\n        try:\n            raw_keys, value = raw_override.split('=', 1)\n            parsed_overrides.append((tuple(raw_keys.split('.')), convert_value_type(value),))\n        except ValueError:\n            raise ValueError(\n                f\"Invalid override '{raw_override}'. Make sure you use the form: SECTION.OPTION=VALUE\"\n            )\n        except ruamel.yaml.error.YAMLError as error:\n            raise ValueError(f\"Invalid override '{raw_override}': {error.problem}\")\n\n    return tuple(parsed_overrides)\n\n\ndef apply_overrides(config, raw_overrides):\n    '''\n    Given a sequence of configuration file override strings in the form of \"section.option=value\"\n    and a configuration dict, parse each override and set it the configuration dict.\n    '''\n    overrides = parse_overrides(raw_overrides)\n\n    for (keys, value) in overrides:\n        set_values(config, keys, value)\n\n", "contexts_below": "\n def resolve_env_variables(item):\n     '''\n     Resolves variables like or ${FOO} from given configuration with values from process environment\n     Supported formats:\n      - ${FOO} will return FOO env variable\n      - ${FOO-bar} or ${FOO:-bar} will return FOO env variable if it exists, else \"bar\"\n \n     If any variable is missing in environment and no default value is provided, an Error is raised.\n     '''\n     if isinstance(item, str):\n         return _VARIABLE_PATTERN.sub(_resolve_string, item)\n     if isinstance(item, list):\n         for i, subitem in enumerate(item):\n             item[i] = resolve_env_variables(subitem)\n     if isinstance(item, dict):\n         for key, value in item.items():\n             item[key] = resolve_env_variables(value)\n     return item\n ", "input_code": "def _resolve_string(matcher):\n\"\"\"\nGet the value from environment given a matcher containing a name and an optional default value.\nIf the variable is not defined in environment and no default value is provided, an Error is raised.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _resolve_string(matcher):\n    '''\n    Get the value from environment given a matcher containing a name and an optional default value.\n    If the variable is not defined in environment and no default value is provided, an Error is raised.\n    '''\n    name, default = matcher.group(\"name\"), matcher.group(\"default\")\n    out = os.getenv(name, default=default)\n    if out is None:\n        raise ValueError(\"Cannot find variable ${name} in envivonment\".format(name=name))\n    return out", "signature": "def _resolve_string(matcher):", "completion_path": "borgmatic/config/override.py"}
{"ce_id": "62ece4992e6aefcf4aabbd7f", "namespace": "62ece4992e6aefcf4aabbd7f", "namespace_real": "cinder.image.glance._parse_image_ref", "real_proj_path": "openstack---cinder/", "type": "function", "class_name": null, "function_name": "_parse_image_ref", "contexts_above": "# Copyright 2010 OpenStack Foundation\n# Copyright 2013 NTT corp.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"Implementation of an image service that uses Glance as the backend\"\"\"\n\nimport copy\nimport itertools\nimport random\nimport shutil\nimport sys\nimport textwrap\nimport time\nfrom typing import (Any, Callable, Dict, Iterable, List,  # noqa: H301\n                    NoReturn, Optional, Tuple)            # noqa: H301\nimport urllib\nimport urllib.parse\n\nimport glanceclient\nimport glanceclient.exc\nfrom keystoneauth1.loading import session as ks_session\nfrom oslo_config import cfg\nfrom oslo_log import log as logging\nfrom oslo_serialization import jsonutils\nfrom oslo_utils import timeutils\n\nfrom cinder import context\nfrom cinder import exception\nfrom cinder.i18n import _\nfrom cinder.image import image_utils\nfrom cinder import service_auth\n\n\nimage_opts = [\n    cfg.ListOpt('allowed_direct_url_schemes',\n                default=[],\n                help='A list of url schemes that can be downloaded directly '\n                     'via the direct_url.  Currently supported schemes: '\n                     '[file, cinder].'),\n    cfg.StrOpt('verify_glance_signatures',\n               choices=['disabled', 'enabled'],\n               default='enabled',\n               help=textwrap.dedent(\n                   \"\"\"\n                   Enable image signature verification.\n\n                   Cinder uses the image signature metadata from Glance and\n                   verifies the signature of a signed image while downloading\n                   that image. There are two options here.\n\n                   1. ``enabled``: verify when image has signature metadata.\n                   2. ``disabled``: verification is turned off.\n\n                   If the image signature cannot be verified or if the image\n                   signature metadata is incomplete when required, then Cinder\n                   will not create the volume and update it into an error\n                   state. This provides end users with stronger assurances\n                   of the integrity of the image data they are using to\n                   create volumes.\n                   \"\"\")),\n    cfg.StrOpt('glance_catalog_info',\n               default='image:glance:publicURL',\n               help='Info to match when looking for glance in the service '\n                    'catalog. Format is: separated values of the form: '\n                    '<service_type>:<service_name>:<endpoint_type> - '\n                    'Only used if glance_api_servers are not provided.'),\n]\nglance_core_properties_opts = [\n    cfg.ListOpt('glance_core_properties',\n                default=['checksum', 'container_format',\n                         'disk_format', 'image_name', 'image_id',\n                         'min_disk', 'min_ram', 'name', 'size'],\n                help='Default core properties of image')\n]\nCONF = cfg.CONF\nCONF.register_opts(image_opts)\nCONF.register_opts(glance_core_properties_opts)\n\n_SESSION = None\n\nLOG = logging.getLogger(__name__)\n\n", "contexts_below": "\n def _create_glance_client(context: context.RequestContext,\n                           netloc: str,\n                           use_ssl: bool) -> glanceclient.Client:\n     \"\"\"Instantiate a new glanceclient.Client object.\"\"\"\n     params = {'global_request_id': context.global_id}\n \n     if use_ssl and CONF.auth_strategy == 'noauth':\n         params = {'insecure': CONF.glance_api_insecure,\n                   'cacert': CONF.glance_ca_certificates_file,\n                   'timeout': CONF.glance_request_timeout,\n                   'split_loggers': CONF.split_loggers\n                   }\n     if CONF.auth_strategy == 'keystone':\n         global _SESSION\n         if not _SESSION:\n             config_options = {'insecure': CONF.glance_api_insecure,\n                               'cacert': CONF.glance_ca_certificates_file,\n                               'timeout': CONF.glance_request_timeout,\n                               'cert': CONF.glance_certfile,\n                               'key': CONF.glance_keyfile,\n                               'split_loggers': CONF.split_loggers\n                               }\n             _SESSION = ks_session.Session().load_from_options(**config_options)\n \n         auth = service_auth.get_auth_plugin(context)\n         params['auth'] = auth\n         params['session'] = _SESSION\n \n     scheme = 'https' if use_ssl else 'http'\n     endpoint = '%s://%s' % (scheme, netloc)\n     return glanceclient.Client('2', endpoint, **params)\n \n \n def get_api_servers(context: context.RequestContext) -> Iterable:\n     \"\"\"Return Iterable over shuffled api servers.\n \n     Shuffle a list of glance_api_servers and return an iterator\n     that will cycle through the list, looping around to the beginning\n     if necessary. If CONF.glance_api_servers is None then they will\n     be retrieved from the catalog.\n     \"\"\"\n     api_servers = []\n     api_servers_info = []\n \n     if CONF.glance_api_servers is None:\n         info = CONF.glance_catalog_info\n         try:\n             service_type, service_name, endpoint_type = info.split(':')\n         except ValueError:\n             raise exception.InvalidConfigurationValue(_(\n                 \"Failed to parse the configuration option \"\n                 \"'glance_catalog_info', must be in the form \"\n                 \"<service_type>:<service_name>:<endpoint_type>\"))\n         for entry in context.service_catalog:\n             if entry.get('type') == service_type:\n                 api_servers.append(\n                     entry.get('endpoints')[0].get(endpoint_type))\n     else:\n         for api_server in CONF.glance_api_servers:\n             api_servers.append(api_server)\n \n     for api_server in api_servers:\n         if '//' not in api_server:\n             api_server = 'http://' + api_server\n         url = urllib.parse.urlparse(api_server)\n         netloc = url.netloc + url.path\n         use_ssl = (url.scheme == 'https')\n         api_servers_info.append((netloc, use_ssl))\n \n     random.shuffle(api_servers_info)\n     return itertools.cycle(api_servers_info)\n \n \n class GlanceClientWrapper(object):\n     \"\"\"Glance client wrapper class that implements retries.\"\"\"\n \n     def __init__(self,\n                  context: Optional[context.RequestContext] = None,\n                  netloc: Optional[str] = None,\n                  use_ssl: bool = False):\n         self.client: Optional[glanceclient.Client]\n         if netloc is not None:\n             assert context is not None\n             self.client = self._create_static_client(context,\n                                                      netloc,\n                                                      use_ssl)\n         else:\n             self.client = None\n         self.api_servers: Optional[Iterable] = None\n \n     def _create_static_client(self,\n                               context: context.RequestContext,\n                               netloc: str,\n                               use_ssl: bool) -> glanceclient.Client:\n         \"\"\"Create a client that we'll use for every call.\"\"\"\n         self.netloc = netloc\n         self.use_ssl = use_ssl\n         return _create_glance_client(context,\n                                      self.netloc,\n                                      self.use_ssl)\n \n     def _create_onetime_client(\n             self,\n             context: context.RequestContext) -> glanceclient.Client:\n         \"\"\"Create a client that will be used for one call.\"\"\"\n         if self.api_servers is None:\n             self.api_servers = get_api_servers(context)\n         self.netloc, self.use_ssl = next(self.api_servers)  # type: ignore\n         return _create_glance_client(context,\n                                      self.netloc,\n                                      self.use_ssl)\n \n     def call(self,\n              context: context.RequestContext,\n              method: str,\n              *args: Any,\n              **kwargs: str) -> Any:\n         \"\"\"Call a glance client method.\n \n         If we get a connection error,\n         retry the request according to CONF.glance_num_retries.\n         \"\"\"\n \n         retry_excs = (glanceclient.exc.ServiceUnavailable,\n                       glanceclient.exc.InvalidEndpoint,\n                       glanceclient.exc.CommunicationError)\n         num_attempts = 1 + CONF.glance_num_retries\n         glance_controller = kwargs.pop('controller', 'images')\n         store_id = kwargs.pop('store_id', None)\n         base_image_ref = kwargs.pop('base_image_ref', None)\n \n         for attempt in range(1, num_attempts + 1):\n             client = self.client or self._create_onetime_client(context)\n \n             keys = ('x-image-meta-store', 'x-openstack-base-image-ref',)\n             values = (store_id, base_image_ref,)\n \n             headers = {k: v for (k, v) in zip(keys, values) if v is not None}\n             if headers:\n                 client.http_client.additional_headers = headers\n \n             try:\n                 controller = getattr(client, glance_controller)\n                 return getattr(controller, method)(*args, **kwargs)\n             except retry_excs as e:\n                 netloc = self.netloc\n                 extra = \"retrying\"\n                 error_msg = _(\"Error contacting glance server \"\n                               \"'%(netloc)s' for '%(method)s', \"\n                               \"%(extra)s.\")\n                 if attempt == num_attempts:\n                     extra = 'done trying'\n                     LOG.exception(error_msg, {'netloc': netloc,\n                                               'method': method,\n                                               'extra': extra})\n                     raise exception.GlanceConnectionFailed(reason=e)\n \n                 LOG.exception(error_msg, {'netloc': netloc,\n                                           'method': method,\n                                           'extra': extra})\n                 time.sleep(1)\n             except glanceclient.exc.HTTPOverLimit as e:\n                 raise exception.ImageLimitExceeded(e)\n \n \n class GlanceImageService(object):\n     \"\"\"Provides storage and retrieval of disk image objects within Glance.\"\"\"\n \n     def __init__(self, client: Optional[Any] = None):\n         self._client = client or GlanceClientWrapper()\n         self._image_schema: Optional[glanceclient.v2.schemas.Schema] = None\n         self.temp_images: Optional[image_utils.TemporaryImages] = None\n \n     def detail(self,\n                context: context.RequestContext,\n                **kwargs: str) -> List[dict]:\n         \"\"\"Calls out to Glance for a list of detailed image information.\"\"\"\n         params = self._extract_query_params(kwargs)\n         try:\n             images = self._client.call(context, 'list', **params)\n         except Exception:\n             _reraise_translated_exception()\n \n         _images = []\n         for image in images:\n             if self._is_image_available(context, image):\n                 _images.append(self._translate_from_glance(context, image))\n \n         return _images\n \n     def _extract_query_params(self, params: dict) -> Dict[str, Any]:\n         _params = {}\n         accepted_params = ('filters', 'marker', 'limit',\n                            'sort_key', 'sort_dir')\n         for param in accepted_params:\n             if param in params:\n                 _params[param] = params.get(param)\n \n         return _params\n \n     def list_members(self,\n                      context: context.RequestContext,\n                      image_id: str) -> List[dict]:\n         \"\"\"Returns a list of dicts with image member data.\"\"\"\n         try:\n             return self._client.call(context,\n                                      'list',\n                                      controller='image_members',\n                                      image_id=image_id)\n         except Exception:\n             _reraise_translated_image_exception(image_id)\n \n     def get_stores(self, context: context.RequestContext):\n         \"\"\"Returns a list of dicts with stores information.\"\"\"\n         try:\n             return self._client.call(context,\n                                      'get_stores_info')\n         except Exception:\n             _reraise_translated_exception()\n \n     def show(self,\n              context: context.RequestContext,\n              image_id: str) -> Dict[str, Any]:\n         \"\"\"Returns a dict with image data for the given opaque image id.\"\"\"\n         try:\n             image = self._client.call(context, 'get', image_id)\n         except Exception:\n             _reraise_translated_image_exception(image_id)\n \n         if not self._is_image_available(context, image):\n             raise exception.ImageNotFound(image_id=image_id)\n \n         base_image_meta = self._translate_from_glance(context, image)\n         return base_image_meta\n \n     def get_location(self,\n                      context: context.RequestContext,\n                      image_id: str) -> Tuple[Optional[str], Any]:\n         \"\"\"Get backend storage location url.\n \n         Returns a tuple containing the direct url and locations representing\n         the backend storage location, or (None, None) if these attributes are\n         not shown by Glance.\n         \"\"\"\n         try:\n             # direct_url is returned by v2 api\n             client = GlanceClientWrapper()\n             image_meta = client.call(context, 'get', image_id)\n         except Exception:\n             _reraise_translated_image_exception(image_id)\n \n         if not self._is_image_available(context, image_meta):\n             raise exception.ImageNotFound(image_id=image_id)\n \n         # some glance stores like nfs only meta data\n         # is stored and returned as locations.\n         # so composite of two needs to be returned.\n         return (getattr(image_meta, 'direct_url', None),\n                 getattr(image_meta, 'locations', None))\n \n     def add_location(self,\n                      context: context.RequestContext,\n                      image_id: str,\n                      url: str,\n                      metadata: dict) -> dict:\n         \"\"\"Add a backend location url to an image.\n \n         Returns a dict containing image metadata on success.\n         \"\"\"\n         client = GlanceClientWrapper()\n         try:\n             return client.call(context, 'add_location',\n                                image_id, url, metadata)\n         except Exception:\n             _reraise_translated_image_exception(image_id)\n \n     def download(self,\n                  context: context.RequestContext,\n                  image_id: str,\n                  data=None):\n         \"\"\"Calls out to Glance for data and writes data.\"\"\"\n         if data and 'file' in CONF.allowed_direct_url_schemes:\n             direct_url, locations = self.get_location(context, image_id)\n             urls = [direct_url] + [loc.get('url') for loc in locations or []]\n             for url in urls:\n                 if url is None:\n                     continue\n                 parsed_url = urllib.parse.urlparse(url)\n                 if parsed_url.scheme == \"file\":\n                     # a system call to cp could have significant performance\n                     # advantages, however we do not have the path to files at\n                     # this point in the abstraction.\n                     with open(parsed_url.path, \"rb\") as f:\n                         shutil.copyfileobj(f, data)\n                     return\n \n         try:\n             image_chunks = self._client.call(context, 'data', image_id)\n         except Exception:\n             _reraise_translated_image_exception(image_id)\n \n         if image_chunks is None:\n             raise exception.ImageDownloadFailed(\n                 image_href=image_id, reason=_('image contains no data.'))\n \n         if not data:\n             return image_chunks\n         else:\n             for chunk in image_chunks:\n                 data.write(chunk)\n \n     def create(self,\n                context: context.RequestContext,\n                image_meta: Dict[str, Any],\n                data=None) -> Dict[str, Any]:\n         \"\"\"Store the image data and return the new image object.\"\"\"\n         sent_service_image_meta = self._translate_to_glance(image_meta)\n \n         if data:\n             sent_service_image_meta['data'] = data\n \n         recv_service_image_meta = self._client.call(context, 'create',\n                                                     **sent_service_image_meta)\n \n         return self._translate_from_glance(context, recv_service_image_meta)\n \n     def update(self,\n                context: context.RequestContext,\n                image_id: str,\n                image_meta: dict,\n                data=None,\n                purge_props: bool = True,\n                store_id: Optional[str] = None,\n                base_image_ref: Optional[str] = None) -> dict:\n         \"\"\"Modify the given image with the new data.\"\"\"\n         # For v2, _translate_to_glance stores custom properties in image meta\n         # directly. We need the custom properties to identify properties to\n         # remove if purge_props is True. Save the custom properties before\n         # translate.\n         if purge_props:\n             props_to_update = image_meta.get('properties', {}).keys()\n \n         image_meta = self._translate_to_glance(image_meta)\n \n         # NOTE(bcwaldon): id is not an editable field, but it is likely to be\n         # passed in by calling code. Let's be nice and ignore it.\n         image_meta.pop('id', None)\n         kwargs = {}\n         if store_id:\n             kwargs['store_id'] = store_id\n         if base_image_ref:\n             kwargs['base_image_ref'] = base_image_ref\n \n         try:\n             if data:\n                 self._client.call(context, 'upload', image_id, data, **kwargs)\n             if image_meta:\n                 if purge_props:\n                     # Properties to remove are those not specified in\n                     # input properties.\n                     cur_image_meta = self.show(context, image_id)\n                     cur_props = cur_image_meta['properties'].keys()\n                     remove_props = list(set(cur_props) -\n                                         set(props_to_update))\n                     image_meta['remove_props'] = remove_props\n                 image_meta = self._client.call(context, 'update', image_id,\n                                                **image_meta)\n             else:\n                 image_meta = self._client.call(context, 'get', image_id)\n         except Exception:\n             _reraise_translated_image_exception(image_id)\n         else:\n             return self._translate_from_glance(context, image_meta)\n \n     def delete(self, context: context.RequestContext, image_id: str) -> bool:\n         \"\"\"Delete the given image.\n \n         :raises ImageNotFound: if the image does not exist.\n         :raises NotAuthorized: if the user is not an owner.\n \n         \"\"\"\n         try:\n             self._client.call(context, 'delete', image_id)\n         except glanceclient.exc.NotFound:\n             raise exception.ImageNotFound(image_id=image_id)\n         return True\n \n     def _translate_from_glance(self,\n                                context: context.RequestContext,\n                                image: Dict[str, Any]) -> dict:\n         \"\"\"Get image metadata from glance image.\n \n         Extract metadata from image and convert it's properties\n         to type cinder expected.\n \n         :param image: glance image object\n         :return: image metadata dictionary\n         \"\"\"\n         if self._image_schema is None:\n             self._image_schema = self._client.call(context, 'get',\n                                                    controller='schemas',\n                                                    schema_name='image')\n         assert self._image_schema is not None\n         # NOTE(aarefiev): get base image property, store image 'schema'\n         #                 is redundant, so ignore it.\n         image_meta: dict = {\n             key: getattr(image, key)\n             for key in image.keys()\n             if self._image_schema.is_base_property(key) is True and\n             key != 'schema'}\n \n         # Process 'cinder_encryption_key_id' as a metadata key\n         if 'cinder_encryption_key_id' in image.keys():\n             image_meta['cinder_encryption_key_id'] = \\\n                 image['cinder_encryption_key_id']\n \n         # NOTE(aarefiev): nova is expected that all image properties\n         # (custom or defined in schema-image.json) stores in\n         # 'properties' key.\n         image_meta['properties'] = {\n             key: getattr(image, key) for key in image.keys()\n             if self._image_schema.is_base_property(key) is False}\n \n         image_meta = _convert_timestamps_to_datetimes(image_meta)\n         image_meta = _convert_from_string(image_meta)\n         return image_meta\n \n     @staticmethod\n     def _translate_to_glance(image_meta: Dict[str, Any]) -> Dict[str, Any]:\n         image_meta = _convert_to_string(image_meta)\n         image_meta = _remove_read_only(image_meta)\n \n         # NOTE(tsekiyama): From the Image API v2, custom properties must\n         # be stored in image_meta directly, instead of the 'properties' key.\n         properties = image_meta.get('properties')\n         if properties:\n             image_meta.update(properties)\n             del image_meta['properties']\n \n         return image_meta\n \n     def _is_image_available(self,\n                             context: context.RequestContext,\n                             image) -> bool:\n         \"\"\"Check image availability.\n \n         This check is needed in case Nova and Glance are deployed\n         without authentication turned on.\n         \"\"\"\n         # The presence of an auth token implies this is an authenticated\n         # request and we need not handle the noauth use-case.\n         if hasattr(context, 'auth_token') and context.auth_token:\n             return True\n \n         if context.is_admin:\n             return True\n \n         if (getattr(image, 'is_public', False) or\n                 getattr(image, 'visibility', 'private') == 'public'):\n             return True\n \n         properties = image.properties\n \n         if context.project_id and ('owner_id' in properties):\n             return str(properties['owner_id']) == str(context.project_id)\n \n         if context.project_id and ('project_id' in properties):\n             return str(properties['project_id']) == str(context.project_id)\n \n         if image.visibility == 'shared':\n             for member in self.list_members(context, image.id):\n                 if (context.project_id == member['member_id'] and\n                         member['status'] == 'accepted'):\n                     return True\n \n         try:\n             user_id = properties['user_id']\n         except KeyError:\n             return False\n \n         return str(user_id) == str(context.user_id)\n \n \n def _convert_timestamps_to_datetimes(image_meta: dict) -> dict:\n     \"\"\"Returns image with timestamp fields converted to datetime objects.\"\"\"\n     for attr in ['created_at', 'updated_at', 'deleted_at']:\n         if image_meta.get(attr):\n             image_meta[attr] = timeutils.parse_isotime(image_meta[attr])\n     return image_meta\n \n \n # NOTE(bcwaldon): used to store non-string data in glance metadata\n def _json_loads(properties: dict, attr: str) -> None:\n     prop = properties[attr]\n     if isinstance(prop, str):\n         properties[attr] = jsonutils.loads(prop)\n \n \n def _json_dumps(properties: dict, attr: str) -> None:\n     prop = properties[attr]\n     if not isinstance(prop, str):\n         properties[attr] = jsonutils.dumps(prop)\n \n \n _CONVERT_PROPS = ('block_device_mapping', 'mappings')\n \n \n def _convert(method: Callable[[dict, str], Optional[dict]],\n              metadata: dict) -> dict:\n     metadata = copy.deepcopy(metadata)\n     properties = metadata.get('properties')\n     if properties:\n         for attr in _CONVERT_PROPS:\n             if attr in properties:\n                 method(properties, attr)\n \n     return metadata\n \n \n def _convert_from_string(metadata: dict) -> dict:\n     return _convert(_json_loads, metadata)\n \n \n def _convert_to_string(metadata: dict) -> dict:\n     return _convert(_json_dumps, metadata)\n \n \n def _extract_attributes(image):\n     # NOTE(hdd): If a key is not found, base.Resource.__getattr__() may perform\n     # a get(), resulting in a useless request back to glance. This list is\n     # therefore sorted, with dependent attributes as the end\n     # 'deleted_at' depends on 'deleted'\n     # 'checksum' depends on 'status' == 'active'\n     IMAGE_ATTRIBUTES = ('size', 'disk_format', 'owner',\n                         'container_format', 'status', 'id',\n                         'name', 'created_at', 'updated_at',\n                         'deleted', 'deleted_at', 'checksum',\n                         'min_disk', 'min_ram', 'protected',\n                         'visibility',\n                         'cinder_encryption_key_id')\n \n     output: Dict[str, Any] = {}\n \n     for attr in IMAGE_ATTRIBUTES:\n         if attr == 'deleted_at' and not output['deleted']:\n             output[attr] = None\n         elif attr == 'checksum' and output['status'] != 'active':\n             output[attr] = None\n         else:\n             output[attr] = getattr(image, attr, None)\n \n     output['properties'] = getattr(image, 'properties', {})\n \n     return output\n \n \n def _remove_read_only(image_meta: dict) -> dict:\n     IMAGE_ATTRIBUTES = ['status', 'updated_at', 'created_at', 'deleted_at']\n     output = copy.deepcopy(image_meta)\n     for attr in IMAGE_ATTRIBUTES:\n         if attr in output:\n             del output[attr]\n     return output\n \n \n def _reraise_translated_image_exception(image_id: str) -> NoReturn:\n     \"\"\"Transform the exception for the image but keep its traceback intact.\"\"\"\n     _exc_type, exc_value, exc_trace = sys.exc_info()\n     assert exc_value is not None\n     new_exc = _translate_image_exception(image_id, exc_value)\n     raise new_exc.with_traceback(exc_trace)\n \n \n def _reraise_translated_exception() -> NoReturn:\n     \"\"\"Transform the exception but keep its traceback intact.\"\"\"\n     _exc_type, exc_value, exc_trace = sys.exc_info()\n     assert exc_value is not None\n     new_exc = _translate_plain_exception(exc_value)\n     raise new_exc.with_traceback(exc_trace)\n \n \n def _translate_image_exception(image_id: str,\n                                exc_value: BaseException) -> BaseException:\n     if isinstance(exc_value, (glanceclient.exc.Forbidden,\n                               glanceclient.exc.Unauthorized)):\n         return exception.ImageNotAuthorized(image_id=image_id)\n     if isinstance(exc_value, glanceclient.exc.NotFound):\n         return exception.ImageNotFound(image_id=image_id)\n     if isinstance(exc_value, glanceclient.exc.BadRequest):\n         return exception.Invalid(exc_value)\n     return exc_value\n \n \n def _translate_plain_exception(exc_value: BaseException) -> BaseException:\n     if isinstance(exc_value, (glanceclient.exc.Forbidden,\n                               glanceclient.exc.Unauthorized)):\n         return exception.NotAuthorized(exc_value)\n     if isinstance(exc_value, glanceclient.exc.NotFound):\n         return exception.NotFound(exc_value)\n     if isinstance(exc_value, glanceclient.exc.BadRequest):\n         return exception.Invalid(exc_value)\n     return exc_value\n \n \n def get_remote_image_service(context: context.RequestContext,\n                              image_href) -> Tuple[GlanceImageService, str]:\n     \"\"\"Create an image_service and parse the id from the given image_href.\n \n     The image_href param can be an href of the form\n     'http://example.com:9292/v1/images/b8b2c6f7-7345-4e2f-afa2-eedaba9cbbe3',\n     or just an id such as 'b8b2c6f7-7345-4e2f-afa2-eedaba9cbbe3'. If the\n     image_href is a standalone id, then the default image service is returned.\n \n     :param image_href: href that describes the location of an image\n     :returns: a tuple of the form (image_service, image_id)\n \n     \"\"\"\n     # NOTE(bcwaldon): If image_href doesn't look like a URI, assume its a\n     # standalone image ID\n     if '/' not in str(image_href):\n         image_service = get_default_image_service()\n         return image_service, image_href\n \n     try:\n         (image_id, glance_netloc, use_ssl) = _parse_image_ref(image_href)\n         glance_client = GlanceClientWrapper(context=context,\n                                             netloc=glance_netloc,\n                                             use_ssl=use_ssl)\n     except ValueError:\n         raise exception.InvalidImageRef(image_href=image_href)\n \n     image_service = GlanceImageService(client=glance_client)\n     return image_service, image_id\n \n \n def get_default_image_service() -> GlanceImageService:\n     return GlanceImageService()\n ", "input_code": "def _parse_image_ref(image_href: str) -> Tuple[str, str, bool]:\n\"\"\"\nParse an image href into composite parts.\n\n:param image_href: href of an image\n:returns: a tuple of the form (image_id, netloc, use_ssl)\n:raises ValueError:\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _parse_image_ref(image_href: str) -> Tuple[str, str, bool]:\n    \"\"\"Parse an image href into composite parts.\n\n    :param image_href: href of an image\n    :returns: a tuple of the form (image_id, netloc, use_ssl)\n    :raises ValueError:\n\n    \"\"\"\n    url = urllib.parse.urlparse(image_href)\n    netloc = url.netloc\n    image_id = url.path.split('/')[-1]\n    use_ssl = (url.scheme == 'https')\n    return (image_id, netloc, use_ssl)", "signature": "def _parse_image_ref(image_href: str) -> Tuple[str, str, bool]:", "completion_path": "cinder/image/glance.py"}
{"ce_id": "62ece4992e6aefcf4aabbd80", "namespace": "62ece4992e6aefcf4aabbd80", "namespace_real": "makeprojects.util.remove_ending_os_sep", "real_proj_path": "burgerbecky---makeprojects/", "type": "function", "class_name": null, "function_name": "remove_ending_os_sep", "contexts_above": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nThe util module contains subroutines used everywhere.\n\n@package makeprojects.util\n\"\"\"\n\nfrom __future__ import absolute_import, print_function, unicode_literals\n\nimport os\nimport re\nimport fnmatch\nfrom burger import string_to_bool, is_string, import_py_script\nfrom .enums import FileTypes\nfrom .config import DEFAULT_BUILD_RULES\n\n# pylint: disable=consider-using-f-string\n\n########################################\n\n\ndef validate_enum_type(value, data_type):\n    \"\"\"\n    Verify a value is a specific data type.\n\n    Check if the value is either None or an instance of a\n    specfic data type. If so, return immediately. If the value is a string,\n    call the lookup() function of the data type for conversion.\n\n    Args:\n        value: Value to check.\n        data_type: Type instance of the class type to match.\n\n    Returns:\n        Value converted to data_type or None.\n\n    Raises:\n        TypeError\n\n    \"\"\"\n\n    if value is not None:\n        # Perform the lookup\n        new_value = data_type.lookup(value)\n        if new_value is None:\n            msg = '\"{}\" must be of type \"{}\".'.format(\n                value, data_type.__name__)\n            raise TypeError(msg)\n        # Save the converted type\n        value = new_value\n    return value\n\n########################################\n\n\ndef regex_dict(item):\n    \"\"\"\n    Convert *.cpp keys to regex keys\n\n    Given a dict where the keys are all filenames with wildcards, convert only\n    the keys into equivalent regexes and leave the values intact.\n\n    Examples:\n\n    rules = {\n        '*.cpp':\n            {'a': 'arf', 'b': 'bark', 'c': 'coo'},\n        '*.h':\n            {'h': 'help'}\n    }\n    regex_keys = regex_dict(rules)\n\n    Args:\n        item: dict to convert\n    Returns:\n        dict with keys converted to regexes\n    \"\"\"\n\n    output = {}\n    for key in item:\n        output[re.compile(fnmatch.translate(key)).match] = item[key]\n    return output\n\n########################################\n\n\ndef validate_boolean(value):\n    \"\"\"\n    Verify a value is a boolean.\n\n    Check if the value can be converted to a bool, if so, return the value as\n    bool. None is converted to False.\n\n    Args:\n        value: Value to check.\n\n    Returns:\n        Value converted to data_type or None.\n\n    Raises:\n        ValueError\n    \"\"\"\n\n    if value is not None:\n        # Convert to bool\n        value = string_to_bool(value)\n    return value\n\n########################################\n\n\ndef validate_string(value):\n    \"\"\"\n    Verify a value is a string.\n\n    Check if the value is a string, if so, return the value as is or None.\n\n    Args:\n        value: Value to check.\n\n    Returns:\n        Value is string or None.\n\n    Raises:\n        ValueError\n    \"\"\"\n\n    if value is not None:\n        # Convert to bool\n        if not is_string(value):\n            raise ValueError('\"{}\" must be a string.'.format(value))\n    return value\n\n########################################\n\n\ndef source_file_filter(file_list, file_type_list):\n    \"\"\"\n    Prune the file list for a specific type.\n\n    Note: file_type_list can either be a single enums.FileTypes enum or an\n        iterable list of enums.FileTypes\n\n    Args:\n        file_list: list of core.SourceFile entries.\n        file_type_list: enums.FileTypes to match.\n    Returns:\n        list of matching core.SourceFile entries.\n    \"\"\"\n\n    result_list = []\n\n    # If a single item was passed, use a simple loop\n    if isinstance(file_type_list, FileTypes):\n        for item in file_list:\n            if item.type is file_type_list:\n                result_list.append(item)\n    else:\n        # A list was passed, so test against the list\n        for item in file_list:\n            if item.type in file_type_list:\n                result_list.append(item)\n    return result_list\n\n########################################\n\n\ndef add_build_rules(build_rules_list, file_name, verbose, is_root, basename):\n    \"\"\"\n    Load in the file ``build_rules.py``\n\n    Load the build_rules.py file. If the variable ``*_GENERIC`` is ``True``\n    or if ``is_root`` is ``True``, append the module to ``build_rules_list``.\n    If the variable ``*_CONTINUE`` was found in the file, check if it is set\n    to ``True``. If so, return ``True`` to allow processing to continue. If\n    the file is not found, return ``True`` to allow processing the parent\n    folder.\n\n    Since this is called from ``buildme``, ``cleanme``, and ``makeprojects``,\n    the prefix needed for the tool is passed in ``basename``. An example is\n    \"CLEANME\".\n\n    Args:\n        build_rules_list: List to add ``build_rules.py`` instances.\n        file_name: Full path name of the build_rules.py to load.\n        verbose: True for verbose output.\n        is_root: True if *_GENERIC is ignored.\n        basename: Variable prefix to substitute * in *_GENERIC\n    Returns:\n        True if the parent folder should be checked, False if not.\n    \"\"\"\n\n    # Ensure the absolute path is used.\n    file_name = os.path.abspath(file_name)\n    build_rules = import_py_script(file_name)\n\n    # Not found? Continue parsing folders.\n    if not build_rules:\n        return True\n\n    if is_root or getattr(build_rules, basename + \"_GENERIC\",\n                          False) or getattr(build_rules, \"GENERIC\", False):\n        # Add to the list\n        build_rules_list.append(build_rules)\n\n    if verbose:\n        print('Using configuration file {}'.format(file_name))\n\n    # Test if this is considered the last one in the chain.\n    result = getattr(build_rules, basename + \"_CONTINUE\", None)\n\n    # Not found?\n    if result is None:\n        # Try the catch all version\n        result = getattr(build_rules, \"CONTINUE\", False)\n    return result\n\n########################################\n\n\ndef get_build_rules(working_directory, verbose, build_rules_name, basename):\n    \"\"\"\n    Find all ``build_rules.py`` files that apply to this directory.\n\n    If no files are found, return an empty list.\n\n    Args:\n        working_directory: Directory to scan for ``build_rules.py``\n        verbose: True if verbose output is desired\n        build_rules_name: ``build_rules.py`` or an override\n        basename: \"CLEANME\", \"BUILDME\", etc.\n    Returns:\n        List of loaded ``build_rules.py`` file modules\n    \"\"\"\n\n    # Test if there is a specific build rule\n    build_rules_list = []\n\n    # Load the configuration file at the current directory\n    temp_dir = os.path.abspath(working_directory)\n\n    # Is this the first pass?\n    is_root = True\n    while True:\n\n        # Attempt to load in the build rules.\n        if not add_build_rules(\n            build_rules_list, os.path.join(\n                temp_dir, build_rules_name), verbose, is_root, basename):\n            # Abort if *_CONTINUE = False\n            break\n\n        # Directory traversal is active, require CLEANME_GENERIC\n        is_root = False\n\n        # Pop a folder to check for higher level build_rules.py\n        temp_dir2 = os.path.dirname(temp_dir)\n\n        # Already at the top of the directory?\n        if temp_dir2 is None or temp_dir2 == temp_dir:\n            add_build_rules(\n                build_rules_list,\n                DEFAULT_BUILD_RULES,\n                verbose,\n                True,\n                basename)\n            break\n        # Use the new folder\n        temp_dir = temp_dir2\n    return build_rules_list\n\n########################################\n\n\ndef getattr_build_rules(build_rules_list, attributes, value):\n    \"\"\"\n    Find an attribute in a list of build rules.\n\n    Iterate over the build rules list until an entry has an attribute value.\n    It will return the first one found. If none are found, or there were no\n    entries in ``build_rules_list``, this function returns ``value``.\n\n    Args:\n        build_rules_list: List of ``build_rules.py`` instances.\n        attributes: Attribute name(s) to check for.\n        value: Value to return if the attribute was not found.\n\n    Returns:\n        Attribute value found in ``build_rules_list`` entry, or ``value``.\n    \"\"\"\n\n    # Ensure if it is a single string\n\n    if is_string(attributes):\n        for build_rules in build_rules_list:\n            # Does the entry have this attribute?\n            try:\n                return getattr(build_rules, attributes)\n            except AttributeError:\n                pass\n    else:\n        # Assume attributes is an iterable of strings\n        for build_rules in build_rules_list:\n            # Does the rules file have this attribute?\n            for attribute in attributes:\n                try:\n                    return getattr(build_rules, attribute)\n                except AttributeError:\n                    pass\n\n    # Return the default value\n    return value\n\n########################################\n\n", "contexts_below": "########################################\n \n \n def was_processed(processed, path_name, verbose):\n     \"\"\"\n     Check if a file or directory has already been processed.\n \n     To prevent recursion, expand the path name to an absolution path\n     call this function with a set that will store all the entries and\n     the entry to test. If the entry is already in the set, report the issue\n     and return ``True``. Otherwise, add the entry to the set and return\n     ``False`` to allow the path to be processed.\n \n     Args:\n         processed: Set to store processed pathnames\n         path_name: Path to a directory or file\n         verbose: True if verbose output is requested\n \n     Returns:\n         True if it's already in the set. False if not.\n     \"\"\"\n \n     # Test for recursion\n     if path_name in processed:\n         if verbose:\n             print('{} has already been processed'.format(path_name))\n         return True\n \n     # Mark this list as \"processed\" to prevent recursion\n     if verbose:\n         print('Processing {}.'.format(path_name))\n     processed.add(path_name)\n     return False\n ", "input_code": "def remove_ending_os_sep(input_list):\n\"\"\"\nIterate over a string list and remove trailing os seperator characters.\n\nEach string is tested if its length is greater than one and if the last\ncharacter is the pathname seperator. If so, the pathname seperator character\nis removed.\n\nArgs:\n    input_list: list of strings\n\nReturns:\n    Processed list of strings\n\nRaises:\n    TypeError\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def remove_ending_os_sep(input_list):\n    \"\"\"\n    Iterate over a string list and remove trailing os seperator characters.\n\n    Each string is tested if its length is greater than one and if the last\n    character is the pathname seperator. If so, the pathname seperator character\n    is removed.\n\n    Args:\n        input_list: list of strings\n\n    Returns:\n        Processed list of strings\n\n    Raises:\n        TypeError\n    \"\"\"\n\n    # Input could be None, so test for that case\n    if input_list is None:\n        return []\n\n    return [item[:-1] if len(item) >= 2 and item.endswith(os.sep)\n            else item for item in input_list]", "signature": "def remove_ending_os_sep(input_list):", "completion_path": "makeprojects/util.py"}
{"ce_id": "62ece4992e6aefcf4aabbd82", "namespace": "62ece4992e6aefcf4aabbd82", "namespace_real": "shconfparser.search.get_pattern", "real_proj_path": "kirankotari---shconfparser/", "type": "class", "class_name": "search", "function_name": "get_pattern", "contexts_above": "\"\"\"\nGoal: To search the given text in the data of type dict\n\"\"\"\n\nfrom collections import OrderedDict\nimport re\n\n\nclass Search:\n    def __init__(self):\n        pass\n\n    def validate(self, data, dtype=OrderedDict):\n        \"\"\"\n        This method validates the given data\n        \"\"\"\n        if data == None:\n            return None\n\n        if type(data) != dtype:\n            return None\n\n        return True\n", "contexts_below": "\n     def search_in_tree(self, pattern, data=None):\n         if not self.validate(data):\n             return None\n \n         p = self.get_pattern(pattern)\n         for key in data.keys():\n             if p.match(key):\n                 return key\n         return None\n \n \n     def search_all_in_tree(self, pattern, data=None):\n         if not self.validate(data):\n             return None\n \n         p = self.get_pattern(pattern)\n         match = OrderedDict()\n         for key in data.keys():\n             if p.match(key):\n                 match[key] = key\n \n         return match if len(match) else None\n \n     def search_in_tree_level(self, pattern, data=None, level=0):\n         if not self.validate(data):\n             return None\n \n         p = self.get_pattern(pattern)\n         for key in data:\n             if p.match(key):\n                 return key\n             if data[key] == None:\n                 continue\n             if type(data[key]) == OrderedDict and level > 0:\n                 res = self.search_in_tree_level(p, data[key], level=level - 1)\n                 if res:\n                     return res\n         return None\n \n     def search_in_table(self, pattern, data=None, header_column=None):\n         if not self.validate(data):\n             return None\n \n         p = self.get_pattern(pattern)\n         for each_row in data:\n             if p.match(each_row[header_column]):\n                 return each_row\n \n     def search_all_in_table(self, pattern, data=None, header_column=None):\n         if not self.validate(data):\n             return None\n \n         p = self.get_pattern(pattern)\n         match = []\n         for each_row in data:\n             if p.match(each_row[header_column]):\n                 match.append(each_row)\n \n         return match if len(match) else None\n ", "input_code": "def get_pattern(self, pattern, strip=True):\n\"\"\"\nThis method converts the given string to regex pattern\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def get_pattern(self, pattern, strip=True):\n        \"\"\"\n        This method converts the given string to regex pattern\n        \"\"\"\n        if type(pattern) == re.Pattern:\n            return pattern\n\n        if strip and type(pattern) == str:\n            pattern = pattern.strip()\n\n        return re.compile(pattern)", "signature": "def get_pattern(self, pattern, strip=True):", "completion_path": "shconfparser/search.py"}
{"ce_id": "62ece4992e6aefcf4aabbd83", "namespace": "62ece4992e6aefcf4aabbd83", "namespace_real": "makeprojects.core.run_command", "real_proj_path": "burgerbecky---makeprojects/", "type": "class", "class_name": "core", "function_name": "run_command", "contexts_above": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nModule contains the core classes for makeproject.\n\n@package makeprojects.core\n\"\"\"\n\n# pylint: disable=consider-using-f-string\n# pylint: disable=useless-object-inheritance\n\nfrom __future__ import absolute_import, print_function, unicode_literals\n\nimport os\nimport sys\nfrom operator import attrgetter\nfrom copy import deepcopy\nfrom burger import get_windows_host_type, convert_to_windows_slashes, \\\n    convert_to_linux_slashes, is_string, translate_to_regex_match, \\\n    StringListProperty, BooleanProperty, NoneProperty, run_command\n\nfrom .enums import FileTypes, ProjectTypes, IDETypes, PlatformTypes\nfrom .enums import platformtype_short_code\nfrom .defaults import get_configuration_settings\nfrom .build_rules import rules as default_rules\nfrom .util import validate_enum_type, regex_dict, validate_boolean, \\\n    validate_string\n\n########################################\n\n\nclass BuildError(object):\n    \"\"\"\n    Error message generated by builders.\n\n    When a builder completes, a BuildError class is created and appended\n    to the ``results`` list for logging.\n\n    Attributes:\n        error: Integer error code.\n        filename: File name that generated the error.\n        configuration: Build configuration.\n        msg: Error message.\n    \"\"\"\n\n    def __init__(self, error, filename, configuration=None, msg=None):\n        \"\"\"\n        Initializers for an BuildError.\n\n        Args:\n            error: Integer error code, zero if not error\n            filename: File that generated the error\n            configuration: If applicable, configuration that was compiled\n            msg: Error message test, if available\n\n        \"\"\"\n\n        # Init all the values\n        self.error = error\n        self.filename = filename\n        self.configuration = configuration\n        self.msg = msg\n\n    ########################################\n\n    def get_error_code(self):\n        \"\"\"\n        Return the integer error code.\n        \"\"\"\n        return self.error\n\n    ########################################\n\n    def __repr__(self):\n        \"\"\"\n        Convert the error into a string.\n\n        Returns:\n            A full error string.\n        \"\"\"\n\n        if self.error:\n            result = 'Error #{} in file {}'.format(self.error, self.filename)\n        else:\n            result = 'No error in file {}'.format(self.filename)\n\n        if self.configuration:\n            result += ' Configuration \"{}\"'.format(self.configuration)\n        if self.msg:\n            result += ' \"{}\"'.format(self.msg)\n\n        return result\n\n    def __str__(self):\n        \"\"\"\n        Convert the error into a string.\n\n        Returns:\n            A full error string.\n        \"\"\"\n\n        return self.__repr__()\n\n########################################\n\n\nclass BuildObject(object):\n    \"\"\"\n    Object describing something to build.\n\n    When the directory is parsed, a list of BuildObjects is\n    generated and then sorted by priority and then built.\n\n    Attributes:\n        file_name: Name of file to build.\n        priority: Numeric priorty in ascending order.\n        configuration: Configuration if applicable\n    \"\"\"\n\n    def __init__(self, file_name, priority,\n                 configuration=None):\n        \"\"\"\n        Initializers for an BuildObject.\n\n        Args:\n            file_name: Name of the file to build.\n            priority: Integer priority, lower will be built first.\n            configuration: Configuration to build\n\n        \"\"\"\n\n        self.file_name = file_name\n        self.priority = priority\n        self.configuration = configuration\n\n    ########################################\n\n    def build(self):\n        \"\"\"\n        Perform the build operation\n\n        Returns:\n            BuildError object as Unimplemented build.\n        \"\"\"\n\n        return BuildError(10, self.file_name, self.configuration,\n                          msg=\"Unimplemented build\")\n\n    ########################################\n", "contexts_below": "    ########################################\n \n     def __repr__(self):\n         \"\"\"\n         Convert the object into a string.\n \n         Returns:\n             A full string.\n         \"\"\"\n \n         result = (\n             '{} for file \"{}\" with priority {}').format(\n                 type(self).__name__,\n                 self.file_name,\n                 self.priority)\n \n         if self.configuration:\n             result += ' configuration \"{}\"'.format(self.configuration)\n \n         return result\n \n     def __str__(self):\n         \"\"\"\n         Convert the object into a string.\n \n         Returns:\n             A full string.\n         \"\"\"\n \n         return self.__repr__()\n \n ########################################\n \n \n class Attributes(object):\n     \"\"\"\n     Base class for Solution parts to unify common code\n \n     Attributes:\n         parent: Reference to parent object for chained attribute lookups\n         define_list: List of defines for the compiler\n         include_folders_list: List of folders to add to compiler include list\n         library_folders_list: List of folders to add to linker include list\n         libraries_list: List of libraries to link\n         frameworks_list: Darwin frameworks list\n         exclude_from_build_list: List of patterns to exclude from this config\n         exclude_list: List of files to exclude from directory scanning\n         cw_environment_variables: List of CodeWarrior environment variables\n         custom_rules: Custom build rules\n         platform: @ref enums.PlatformTypes enum for target platform\n         project_type: @ref enums.ProjectTypes enum for target output\n         debug: Boolean for debug information generation\n         link_time_code_generation: Boolean for LTCG\n         optimization: Boolean for optimization enable\n         analyze: Boolean for code analysis\n         use_mfc: Boolean for Microsoft Foundation Classes usage\n         use_atl: Boolean for Active Template Library usage\n         clr_support: C# CLR support usage\n         name: Name of the project or configuration\n         working_directory: Base directory for relative paths\n         deploy_folder: Directory to deploy binaries\n         _source_include_list: Generated file folder list\n         _platform: True @ref platform value\n         _project_type: True @ref project_type\n         _debug: True @ref debug\n         _link_time_code_generation: True @ref link_time_code_generation\n         _optimization: True @ref optimization\n         _analyze: True @ref analyze\n         _use_mfc: True @ref use_mfc\n         _use_atl: True @ref use_atl\n         _clr_support: True @ref clr_support\n         _name: True @ref name\n         _working_directory: True @ref working_directory\n         _deploy_folder: True @ref deploy_folder\n     \"\"\"\n \n     # pylint: disable=too-many-instance-attributes\n \n     define_list = StringListProperty('_define_list')\n     include_folders_list = StringListProperty('_include_folders_list')\n     library_folders_list = StringListProperty('_library_folders_list')\n     libraries_list = StringListProperty('_libraries_list')\n     frameworks_list = StringListProperty('_frameworks_list')\n     exclude_from_build_list = StringListProperty('_exclude_from_build_list')\n     exclude_list = StringListProperty('_exclude_list')\n     cw_environment_variables = StringListProperty('_cw_environment_variables')\n \n     def __init__(self):\n         \"\"\"\n         Perform initialization off all attributes.\n         \"\"\"\n \n         self.parent = None\n         self.define_list = []\n         self.include_folders_list = []\n         self.library_folders_list = []\n         self.libraries_list = []\n         self.frameworks_list = []\n         self.exclude_from_build_list = []\n         self.exclude_list = []\n         self.cw_environment_variables = []\n         self.custom_rules = {}\n \n         # These are internal values\n         self._source_include_list = []\n         self._platform = None\n         self._project_type = None\n         self._debug = None\n         self._link_time_code_generation = None\n         self._optimization = None\n         self._analyze = None\n         self._use_mfc = None\n         self._use_atl = None\n         self._clr_support = None\n         self._name = None\n         self._working_directory = None\n         self._deploy_folder = None\n \n     ########################################\n \n     def get_chained_value(self, name):\n         \"\"\"\n         Follow the chain to find a value.\n \n         Args:\n             self: The 'this' reference.\n             name: Name of the attribute\n         Returns:\n             None or the value.\n         \"\"\"\n \n         # Get the value\n         value = getattr(self, name, None)\n \n         # If not found, follow the chain, if any\n         if value is None and self.parent is not None:\n             value = self.parent.get_chained_value(name)\n         return value\n \n     ########################################\n \n     def get_chained_list(self, name):\n         \"\"\"\n         Return an chained attribute list.\n         @details\n         Obtain the list from the named attribute and append it with the same\n         attribute in parent and return the entire list. This function does not\n         modify the original lists.\n \n         Args:\n             name: Name of the attribute key\n         Returns:\n             A list of all items found. The list can be empty.\n         \"\"\"\n \n         value_list = list(getattr(self, name, []))\n \n         # Is there a reverse link?\n         if self.parent is not None:\n             value_list.extend(getattr(self.parent, name, []))\n         return value_list\n \n     ########################################\n \n     def get_unique_chained_list(self, name):\n         \"\"\"\n         Return an chained attribute list with duplicates removed.\n         @details\n         Obtain the list from the named attribute and append it with the same\n         attribute in parent and return the entire list. This function does not\n         modify the original lists. All duplicates are removed.\n \n         Args:\n             name: Name of the attribute key\n         Returns:\n             A list of all items found. The list can be empty.\n         See Also:\n             get_chained_list\n         \"\"\"\n \n         return list(dict.fromkeys(self.get_chained_list(name)))\n \n     ########################################\n \n     def _getplatform(self):\n         \"\"\"\n         Get the enums.PlatformTypes\n         \"\"\"\n \n         return self.get_chained_value('_platform')\n \n     def _setplatform(self, value):\n         \"\"\"\n         Set the enums.PlatformTypes with validation\n         Args:\n             self: The 'this' reference.\n             value: None or enums.PlatformTypes\n         \"\"\"\n \n         self._platform = validate_enum_type(value, PlatformTypes)\n \n     platform = property(_getplatform, _setplatform)\n \n     ########################################\n \n     def _getproject_type(self):\n         \"\"\"\n         Get the enums.ProjectTypes\n         \"\"\"\n \n         return self.get_chained_value('_project_type')\n \n     def _setproject_type(self, value):\n         \"\"\"\n         Set the enums.ProjectTypes with validation\n         Args:\n             self: The 'this' reference.\n             value: None or enums.ProjectTypes\n         \"\"\"\n \n         self._project_type = validate_enum_type(value, ProjectTypes)\n \n     project_type = property(_getproject_type, _setproject_type)\n \n     ########################################\n \n     def _getdebug(self):\n         \"\"\"\n         Get debug boolean\n         \"\"\"\n \n         return self.get_chained_value('_debug')\n \n     def _setdebug(self, value):\n         \"\"\"\n         Set the boolean with validation\n         Args:\n             self: The 'this' reference.\n             value: None, True or False\n         \"\"\"\n \n         self._debug = validate_boolean(value)\n \n     debug = property(_getdebug, _setdebug)\n \n     ########################################\n \n     def _getlink_time_code_generation(self):\n         \"\"\"\n         Get link time code generation boolean\n         \"\"\"\n \n         return self.get_chained_value('_link_time_code_generation')\n \n     def _setlink_time_code_generation(self, value):\n         \"\"\"\n         Set the boolean with validation\n         Args:\n             self: The 'this' reference.\n             value: None, True or False\n         \"\"\"\n \n         self._link_time_code_generation = validate_boolean(value)\n \n     link_time_code_generation = property(\n         _getlink_time_code_generation,\n         _setlink_time_code_generation)\n \n     ########################################\n \n     def _getoptimization(self):\n         \"\"\"\n         Get optimization boolean\n         \"\"\"\n \n         return self.get_chained_value('_optimization')\n \n     def _setoptimization(self, value):\n         \"\"\"\n         Set the boolean with validation\n         Args:\n             self: The 'this' reference.\n             value: None, True or False\n         \"\"\"\n \n         self._optimization = validate_boolean(value)\n \n     optimization = property(_getoptimization, _setoptimization)\n \n     ########################################\n \n     def _getanalyze(self):\n         \"\"\"\n         Get code analysis boolean\n         \"\"\"\n \n         return self.get_chained_value('_analyze')\n \n     def _setanalyze(self, value):\n         \"\"\"\n         Set the boolean with validation\n         Args:\n             self: The 'this' reference.\n             value: None, True or False\n         \"\"\"\n \n         self._analyze = validate_boolean(value)\n \n     analyze = property(_getanalyze, _setanalyze)\n \n     ########################################\n \n     def _getuse_mfc(self):\n         \"\"\"\n         Get use of Microsoft Foundation class boolean\n         \"\"\"\n \n         return self.get_chained_value('_use_mfc')\n \n     def _setuse_mfc(self, value):\n         \"\"\"\n         Set the boolean with validation\n         Args:\n             self: The 'this' reference.\n             value: None, True or False\n         \"\"\"\n \n         self._use_mfc = validate_boolean(value)\n \n     use_mfc = property(_getuse_mfc, _setuse_mfc)\n \n     ########################################\n \n     def _getuse_atl(self):\n         \"\"\"\n         Get Microsoft Active Template Library boolean\n         \"\"\"\n \n         return self.get_chained_value('_use_atl')\n \n     def _setuse_atl(self, value):\n         \"\"\"\n         Set the boolean with validation\n         Args:\n             self: The 'this' reference.\n             value: None, True or False\n         \"\"\"\n \n         self._use_atl = validate_boolean(value)\n \n     use_atl = property(_getuse_atl, _setuse_atl)\n \n     ########################################\n \n     def _getclr_support(self):\n         \"\"\"\n         Get Common Language Runtime boolean\n         \"\"\"\n \n         return self.get_chained_value('_clr_support')\n \n     def _setclr_support(self, value):\n         \"\"\"\n         Set the boolean with validation\n         Args:\n             self: The 'this' reference.\n             value: None, True or False\n         \"\"\"\n \n         self._clr_support = validate_boolean(value)\n \n     clr_support = property(_getclr_support, _setclr_support)\n \n     ########################################\n \n     def _getname(self):\n         \"\"\"\n         Get name string\n         \"\"\"\n \n         return self.get_chained_value('_name')\n \n     def _setname(self, value):\n         \"\"\"\n         Set the string with validation\n         Args:\n             self: The 'this' reference.\n             value: None, string\n         \"\"\"\n \n         self._name = validate_string(value)\n \n     name = property(_getname, _setname)\n \n     ########################################\n \n     def _getworking_directory(self):\n         \"\"\"\n         Get working directory string\n         \"\"\"\n \n         return self.get_chained_value('_working_directory')\n \n     def _setworking_directory(self, value):\n         \"\"\"\n         Set the string with validation\n         Args:\n             self: The 'this' reference.\n             value: None, string\n         \"\"\"\n \n         self._working_directory = validate_string(value)\n \n     working_directory = property(_getworking_directory, _setworking_directory)\n \n     ########################################\n \n     def _getdeploy_folder(self):\n         \"\"\"\n         Get deployment folder string\n         \"\"\"\n \n         return self.get_chained_value('_deploy_folder')\n \n     def _setdeploy_folder(self, value):\n         \"\"\"\n         Set the string with validation\n         Args:\n             self: The 'this' reference.\n             value: None, string\n         \"\"\"\n \n         self._deploy_folder = validate_string(value)\n \n     deploy_folder = property(_getdeploy_folder, _setdeploy_folder)\n \n ########################################\n \n \n class SourceFile(object):\n     \"\"\"\n     Object for each input file to insert to a solution.\n \n     For every file that could be included into a project file\n     one of these objects is created and attached to a Project object\n     for processing.\n \n     @note\n     For hash consistency, @ref relative_pathname has all directory slashes\n     in Windows format \"\\\" instead of Linux/BSD format on all platforms.\n \n     Attributes:\n         relative_pathname: File base name with extension\n         working_directory: Directory the file is relative to\n         type: File type enumeration, @ref enums.FileTypes\n     \"\"\"\n \n     def __init__(self, relative_pathname, working_directory, filetype):\n         \"\"\"\n         Default constructor.\n \n         Args:\n             relative_pathname: Filename of the input file (relative to the root)\n             working_directory: Pathname of the root directory\n             filetype: Compiler to apply\n         See Also:\n             enums.FileTypes\n         \"\"\"\n \n         # Sanity check\n         if not isinstance(filetype, FileTypes):\n             raise TypeError(\"parameter 'filetype' must be of type FileTypes\")\n \n         self.relative_pathname = convert_to_windows_slashes(relative_pathname)\n         self.working_directory = working_directory\n         self.type = filetype\n \n     ########################################\n \n     def get_group_name(self):\n         r\"\"\"\n         Get the group location for this source file.\n         @details\n         To determine if the file should be in a sub group in the project, scan\n         the filename to find if it's a base filename or part of a directory.\n         If it's a basename, return an empty string.\n         If it's in a folder, remove any ``..\\`` prefixes and ``.\\`` prefixes\n         and return the filename with the basename removed.\n \n         Returns:\n             The group name string with ``\\`` delimiters.\n         \"\"\"\n \n         # Check if there's a group\n         slash = '\\\\'\n         index = self.relative_pathname.rfind(slash)\n         if index == -1:\n             slash = '/'\n             index = self.relative_pathname.rfind(slash)\n             if index == -1:\n                 # It's at the root\n                 return ''\n \n         # Remove the basename\n         group_name = self.relative_pathname[:index]\n \n         # If there are ..\\\\ at the beginning, remove them\n \n         while group_name.startswith('..' + slash):\n             group_name = group_name[3:]\n \n         # If there is a .\\\\, remove the single prefix\n         while group_name.startswith('.' + slash):\n             group_name = group_name[2:]\n \n         return group_name\n \n     ########################################\n \n     def get_abspath(self):\n         \"\"\"\n         Return the full pathname of the file entry.\n \n         Directory slashes will be set to the type that matches the host\n         platform.\n \n         Returns:\n             Absolute pathname for the file.\n         \"\"\"\n \n         if get_windows_host_type():\n             file_name = self.relative_pathname\n         else:\n             file_name = convert_to_linux_slashes(self.relative_pathname)\n         return os.path.abspath(os.path.join(self.working_directory, file_name))\n \n     ########################################\n \n     def __repr__(self):\n         \"\"\"\n         Convert the file record into a human readable file description.\n \n         Returns:\n             Human readable string.\n         \"\"\"\n \n         return 'FileType: {} Pathname: \"{}\"'.format(str(self.type),\n                                                     self.get_abspath())\n \n     def __str__(self):\n         \"\"\"\n         Convert the file record into a human readable file description.\n \n         Returns:\n             Human readable string.\n         \"\"\"\n \n         return self.__repr__()\n \n \n ########################################\n \n \n class Configuration(Attributes):\n     \"\"\"\n     Object for containing attributes specific to a build configuration.\n \n     This object contains all of the items needed to create a specific\n     configuration of a project.\n \n     Valid attributes:\n \n     - ``name`` name of the configuration\n     - ``short_code`` Short code suffix for configuration name\n     - ``platform`` Platform to build for\n     - ``project_type`` Type of binary to generate\n     - ``exclude_from_build_list`` List of files to exclude from this\n         configuration\n     - ``include_folders_list`` List of directories for headers\n     - ``library_folders_list`` List of directories for libraries\n     - ``libraries_list`` List of libraries to include\n     - ``frameworks_list`` List of frameworks to include (macOS/iOS)\n     - ``define_list`` List of defines for compilation\n     - ``debug`` True if debugging defaults are enabled\n     - ``optimization`` 0-4 level of optimization\n     - ``link_time_code_generation`` Enable link time code genration\n \n     If any of these attributes are read, they will always return None.\n     To modify them, use the parent @ref Project\n     - ``source_folders_list`` See Project.source_folders_list\n     - ``vs_props`` See Project.vs_props\n     - ``vs_targets`` See Project.vs_targets\n     - ``vs_rules`` See Project.vs_rules\n \n     Attributes:\n         source_folders_list: Don't allow source folders\n         vs_props: Don't allow Visual Studio props files\n         vs_targets: Don't allow Visual Studio targets files\n         vs_rules: Don't allow Visual Studio rules files\n         project: Project this Configuration is attached to.\n         ide: Get the @ref enums.IDETypes of the parent (Read only)\n         short_code: Short config string for file name suffix\n         _short_code: True @ref short_code\n \n     See Also:\n         Project, Solution\n     \"\"\"\n \n     # Disable these attributes that are present in the parent Project\n     source_folders_list = NoneProperty('_source_folders_list')\n     vs_props = NoneProperty('_vs_props')\n     vs_targets = NoneProperty('_vs_targets')\n     vs_rules = NoneProperty('_vs_rules')\n \n     def __init__(self, *args, **kargs):\n         \"\"\"\n         Init defaults.\n \n         Args:\n             args: name and setting_name for get_configuration_settings()\n             kargs: List of defaults.\n         \"\"\"\n \n         # Init the base class\n         super().__init__()\n \n         self._short_code = None\n \n         # Were there nameless parameters?\n         if args:\n             # Too many parameters?\n             if len(args) >= 3:\n                 raise ValueError(\n                     'Only one or two nameless parameters are allowed')\n \n             # Get the default settings\n             setting_name = None\n             if len(args) == 2:\n                 setting_name = args[1]\n             new_args = get_configuration_settings(args[0], setting_name)\n             if new_args is None:\n                 new_args = {'name': args[0]}\n \n             # Were there defaults found?\n             for item in new_args:\n                 # Only add, never override\n                 if item not in kargs:\n                     kargs[item] = new_args[item]\n \n         # Check the default name\n         if not is_string(kargs.get('name', None)):\n             raise TypeError(\n                 \"string parameter 'name' is required\")\n \n         # Set all the variables\n         for key in kargs.items():\n             setattr(self, key[0], key[1])\n         self.project = None\n \n     ########################################\n \n     def _getide(self):\n         \"\"\"\n         Return the preferred IDE\n         \"\"\"\n         if self.parent is not None:\n             return self.parent.ide\n         return None\n \n     ide = property(_getide)\n \n     ########################################\n \n     def _getshort_code(self):\n         \"\"\"\n         Return the short code\n         \"\"\"\n \n         short_code = getattr(self, '_short_code', None)\n         if short_code is None:\n             return self.name\n         return short_code\n \n     def _setshort_code(self, value):\n         \"\"\"\n         Set the filename suffix\n         Args:\n             self: The 'this' reference.\n             value: New short code\n         \"\"\"\n         self._short_code = validate_string(value)\n \n     short_code = property(_getshort_code, _setshort_code)\n \n     ########################################\n \n     def parse_attributes(self, build_rules_list, working_directory):\n         \"\"\"\n         Initialize the default attributes.\n \n         Args:\n             build_rules_list: List to append a valid build_rules file instance.\n             working_directory: Full path name of the build_rules.py to load.\n         \"\"\"\n \n         default_rules('configuration_settings',\n                       working_directory=working_directory,\n                       configuration=self)\n         for rules in build_rules_list:\n             default = rules(\n                 'configuration_settings',\n                 working_directory=working_directory,\n                 configuration=self)\n \n             # Must test for zero, since None is a break.\n             if default != 0:\n                 break\n \n     ########################################\n \n     def get_suffix(self, force_short=False):\n         \"\"\"\n         Return the proposed suffix.\n         @details\n         Each configuration can generate a seperate binary and\n         if they are stored in the same folder, a suffix\n         is appended to make the filename unique.\n \n         Args:\n             force_short: True to force the platform code to 3 characters\n         Returns:\n             A suffix of the IDE, Platform and Configuration short codes.\n         \"\"\"\n \n         # It's possible to have a platform for\n         # projects that consist of platform neutral data\n         platform = self.platform\n         if platform is not None:\n             platform_text = platform.get_short_code()\n             if force_short:\n                 platform_text = platform_text[:3]\n         else:\n             # Platform neutral\n             platform_text = ''\n \n         return '{}{}{}'.format(\n             self.ide.get_short_code(),\n             platform_text,\n             self.short_code)\n \n     ########################################\n \n     def __repr__(self):\n         \"\"\"\n         Convert the configuration record into a human readable description.\n \n         Returns:\n             Human readable string.\n         \"\"\"\n \n         result_list = []\n         for item in self.__dict__.items():\n             if item[0] == 'parent':\n                 continue\n             if item[0] == 'project':\n                 result_list.append(\n                     'Project: \"{}\"'.format(\n                         item[1].name))\n                 continue\n             item_name = item[0][1:] if item[0].startswith('_') else item[0]\n             result_list.append(\n                 '{0}: {1!s}'.format(\n                     item_name,\n                     item[1]))\n         return 'Configuration: ' + ', '.join(result_list)\n \n     ########################################\n \n     def __str__(self):\n         \"\"\"\n         Convert the configuration record into a human readable description.\n \n         Returns:\n             Human readable string.\n         \"\"\"\n         return self.__repr__()\n \n \n ########################################\n \n \n class Project(Attributes):\n     \"\"\"\n     Object for processing a project file.\n \n     This object contains all of the items needed to generate a project.\n \n     @note On most IDEs, this is merged into one file, but Visual Studio\n     generates a project file for each project.\n \n     Attributes:\n         source_folders_list: List of directories to scan for source code\n         source_files_list: Generated source file list to include in the project\n         vs_props: List of props files for Visual Studio\n         vs_targets: List of targets file for Visual Studio\n         vs_rules: List of rules file for Visual Studio 2005-2008\n         name: Project name\n         working_directory: Working directory for the project\n         solution: No parent solution yet\n         configuration_list: Generate the default configurations\n         project_list: Project records that need to be built first\n         codefiles: Initial array of SourceFile in the solution\n         file_list: Used by scan_directory\n         include_list: Used by scan_directory\n         platform_code: Platform code for generation\n         exclude_list_regex: Regex iterable of files to exclude\n     \"\"\"\n \n     # pylint: disable=too-many-instance-attributes\n \n     source_folders_list = StringListProperty('_source_folders_list')\n     source_files_list = StringListProperty('_source_files_list')\n     vs_props = StringListProperty('_vs_props')\n     vs_targets = StringListProperty('_vs_targets')\n     vs_rules = StringListProperty('_vs_rules')\n \n     def __init__(self, name=None, **kargs):\n         \"\"\"\n         Set defaults.\n \n         Args:\n             name: Name of the project\n             kargs: dict of arguments.\n         \"\"\"\n \n         # Init the base class\n         super().__init__()\n \n         self.source_folders_list = ['.', 'source', 'src']\n         self.source_files_list = []\n         self.vs_props = []\n         self.vs_targets = []\n         self.vs_rules = []\n \n         working_directory = os.getcwd()\n \n         # Set a default project name\n         if name is None:\n             self.name = os.path.basename(working_directory)\n         else:\n             self.name = name\n \n         # Default directory\n         self.working_directory = working_directory\n \n         # Init the rest\n         self.solution = None\n         self.configuration_list = []\n         self.project_list = []\n         self.codefiles = []\n         self.file_list = None\n         self.include_list = None\n         self.platform_code = ''\n \n         # Set all the variables\n         for key in kargs.items():\n             setattr(self, key[0], key[1])\n \n     ########################################\n \n     def _getide(self):\n         \"\"\"\n         Return the preferred IDE\n         \"\"\"\n         if self.parent is not None:\n             return self.parent.ide\n         return None\n \n     ide = property(_getide)\n \n     ########################################\n \n     def add_configuration(self, configuration):\n         \"\"\"\n         Add a configuration to the list of configurations found in this project.\n         @details\n         Given a new Configuration class instance, append it to the list of\n         configurations that this project is managing.\n \n         Args:\n             self: The 'this' reference.\n             configuration: Reference to an instance of a Configuration.\n         Raises:\n             TypeError\n         \"\"\"\n \n         if configuration is None or is_string(configuration):\n             configuration = Configuration(configuration)\n \n         # Singular\n         if not isinstance(configuration, Configuration):\n             raise TypeError((\"parameter 'configuration' \"\n                              \"must be of type Configuration\"))\n             # Set the configuration's parent\n \n         if configuration.platform is None:\n             configuration.platform = PlatformTypes.default()\n \n         if configuration.platform.is_expandable():\n             for platform in configuration.platform.get_expanded():\n                 config = deepcopy(configuration)\n                 config.platform = platform\n                 config.project = self\n                 config.parent = self\n                 self.configuration_list.append(config)\n         else:\n             configuration.project = self\n             configuration.parent = self\n             self.configuration_list.append(configuration)\n \n     ########################################\n \n     def add_project(self, project):\n         \"\"\"\n         Add a dependent project.\n \n         Args:\n             project: Project to depend on.\n         Raises:\n             TypeError\n         \"\"\"\n \n         if project is None or is_string(project):\n             project = Project(project)\n \n         # Sanity check\n         if not isinstance(project, Project):\n             raise TypeError(\n                 \"parameter 'project' must be of type Project or name\")\n \n         project.solution = self.solution\n         project.parent = self.solution\n         self.project_list.append(project)\n         return project\n \n     ########################################\n \n     def get_project_list(self):\n         \"\"\"\n         Return the project list for all projects.\n         @details\n         Iterate over every project and sub project and return\n         a flattened list.\n \n         Returns:\n             list of every project in the solution.\n         \"\"\"\n \n         # Make a copy of the current list\n         project_list = list(self.project_list)\n \n         # Scan the sub projects and add their projects to the\n         # generated list.\n         for project in self.project_list:\n             project_list.extend(project.get_project_list())\n         return project_list\n \n     ########################################\n \n     def set_platforms(self, platform):\n         \"\"\"\n         Update all configurations to a new platform.\n         @details\n         If there are no configurations, Debug and Release will be\n         created.\n \n         Args:\n             platform: Platform to change the configurations to.\n         \"\"\"\n \n         if not self.configuration_list:\n             for item in ('Debug', 'Release'):\n                 self.add_configuration(Configuration(item, platform=platform))\n         else:\n \n             # Create a set of configurations by name\n             config_list = []\n             name_list = []\n             for configuration in self.configuration_list:\n                 if configuration.name in name_list:\n                     continue\n                 name_list.append(configuration.name)\n                 config_list.append(configuration)\n \n             # Expand platform groups\n             self.configuration_list = []\n             for item in platform.get_expanded():\n                 for configuration in config_list:\n                     configuration.platform = item\n                     self.add_configuration(deepcopy(configuration))\n \n     ########################################\n \n     def parse_attributes(self, build_rules_list, working_directory):\n         \"\"\"\n         Initialize the default attributes.\n \n         Args:\n             build_rules_list: List to append a valid build_rules file instance.\n             working_directory: Full path name of the build_rules.py to load.\n         \"\"\"\n \n         default_rules('project_settings',\n                       working_directory=working_directory,\n                       project=self)\n         for rules in build_rules_list:\n             default = rules('project_settings',\n                             working_directory=working_directory,\n                             project=self)\n             # Must test for zero, since None is a break.\n             if default != 0:\n                 break\n \n     ########################################\n \n     def _scan_directory(self, working_directory, recurse, acceptable_list):\n         \"\"\"\n         Given a base directory and a relative directory\n         scan for all the files that are to be included in the project\n \n         Args:\n             working_directory: Directory to scan\n             recurse: Enable recursion\n             acceptable_list: list to store SourceFile records\n         \"\"\"\n \n         # Absolute or relative?\n         if not os.path.isabs(working_directory):\n             working_directory = os.path.abspath(\n                 os.path.join(self.working_directory,\n                              working_directory))\n \n         # Is this a valid directory?\n         if not os.path.isdir(working_directory):\n             return\n \n         # Scan the directory\n         for base_name in os.listdir(working_directory):\n \n             # Is this file in the exclusion list?\n             for item in self.exclude_list_regex:\n                 if item(base_name):\n                     break\n             else:\n \n                 # Is it a file? (Skip links and folders)\n                 file_name = os.path.join(working_directory, base_name)\n                 if os.path.isfile(file_name):\n \n                     # Check against the extension list (Skip if not\n                     # supported)\n                     file_type = FileTypes.lookup(base_name)\n                     if file_type is None:\n                         continue\n \n                     # Found a match, test if the type is in\n                     # the acceptable list\n \n                     if file_type in acceptable_list:\n                         # Create a new entry (Using windows style slashes\n                         # for consistency)\n                         self.file_list.append(SourceFile(\n                             os.path.relpath(\n                                 file_name,\n                                 self.working_directory),\n                             working_directory,\n                             file_type))\n \n                         # Add the directory the file was found for header search\n                         self.include_list.add(\n                             os.path.relpath(\n                                 working_directory, self.working_directory))\n \n                 # Process folders only if in recursion mode\n                 elif recurse and os.path.isdir(file_name):\n                     self._scan_directory(\n                         file_name, recurse, acceptable_list)\n \n     ########################################\n \n     def get_file_list(self, acceptable_list):\n         \"\"\"\n         Obtain the list of source files.\n         @details\n         Set up the variables ``codefiles`` with the list of source files found\n         and ``_source_include_list`` with a list of relative to the\n         working directory folders where the source code was found.\n \n         - ``exclude_list`` for wildcard matching for files to exclude\n         - ``source_folders_list`` for list of folders to search for source code\n         - ``source_files_list`` list of files to add\n         Args:\n             acceptable_list: List of acceptable FileTypes\n         \"\"\"\n \n         # pylint: disable=attribute-defined-outside-init\n \n         # Get the files to exclude in this\n         self.exclude_list_regex = translate_to_regex_match(\n             self.get_unique_chained_list('exclude_list'))\n \n         self.file_list = []\n         self.include_list = set()\n \n         working_directory = self.working_directory\n \n         for item in self.get_unique_chained_list('source_files_list'):\n             if not os.path.isabs(item):\n                 abs_path = os.path.abspath(\n                     os.path.join(working_directory, item))\n             else:\n                 abs_path = item\n \n             # Check against the extension list (Skip if not\n             # supported)\n             file_type = FileTypes.lookup(os.path.basename(abs_path))\n             if file_type is None:\n                 continue\n \n             # Found a match, test if the type is in\n             # the acceptable list\n \n             if file_type in acceptable_list:\n                 # Create a new entry (Using windows style slashes\n                 # for consistency)\n                 self.file_list.append(SourceFile(\n                     os.path.relpath(\n                         abs_path,\n                         working_directory),\n                     os.path.dirname(abs_path),\n                     file_type))\n \n                 # Add the directory the file was found for header search\n                 self.include_list.add(\n                     os.path.relpath(\n                         os.path.dirname(abs_path), working_directory))\n \n         # Pull in all the source folders and scan them\n         for item in self.get_unique_chained_list('source_folders_list'):\n \n             # Is it a recursive test?\n             recurse = False\n             if item.endswith('/*.*'):\n                 # Remove the trailing /*.*\n                 item = item[:-4]\n                 recurse = True\n \n             # Scan the folder for files\n             self._scan_directory(item, recurse, acceptable_list)\n \n         # Since the slashes are all windows (No matter what\n         # host this script is running on, the sort will yield consistent\n         # results so it doesn't matter what platform generated the\n         # file list, it's the same output.\n         self.codefiles = sorted(\n             self.file_list, key=attrgetter('relative_pathname'))\n         self._source_include_list = sorted(self.include_list)\n \n         # Cleanup\n         self.file_list = None\n         self.include_list = None\n         del self.exclude_list_regex\n \n     ########################################\n \n     def __repr__(self):\n         \"\"\"\n         Convert the solultion record into a human readable description\n \n         Returns:\n             Human readable string or None if the solution is invalid\n         \"\"\"\n \n         result_list = []\n         for item in self.__dict__.items():\n             if item[0] == 'parent':\n                 continue\n             if item[0] == 'solution':\n                 if item[1] is None:\n                     continue\n                 result_list.append(\n                     'Solution: \"{}\"'.format(\n                         item[1].name))\n                 continue\n             item_name = item[0][1:] if item[0].startswith('_') else item[0]\n             result_list.append(\n                 '{0}: {1!s}'.format(\n                     item_name,\n                     item[1]))\n         return 'Project: ' + ', '.join(result_list)\n \n     def __str__(self):\n         \"\"\"\n         Convert the solultion record into a human readable description\n \n         Returns:\n             Human readable string or None if the solution is invalid\n         \"\"\"\n \n         return self.__repr__()\n \n \n ########################################\n \n \n class Solution(Attributes):\n     \"\"\"\n     Object for processing a solution file.\n \n     This object contains all of the items needed to create a solution.\n \n     Attributes:\n         source_folders_list: List of directories to scan for source code\n         source_files_list: List of source files to include in the project\n         vs_props: Don't allow Visual Studio props files\n         vs_targets: Don't allow Visual Studio targets files\n         vs_rules: Don't allow Visual Studio rules files\n         perforce: Boolean for using perforce\n         verbose: Boolean for verbose output\n         suffix_enable: Boolean for enabling unique suffixes\n         name: Solution name\n         working_directory: Working directory for the solution\n         ide: @ref enums.IDETypes of the IDE being generated for\n         ide_code: IDE code for generation\n         platform_code: Platform code for generation\n         project_list: List of dependent projects\n         project_type: @ref enums.ProjectTypes enum for target output\n         _ide: Private instance of @ref enums.IDETypes\n     \"\"\"\n \n     # pylint: disable=too-many-instance-attributes\n \n     source_folders_list = StringListProperty('_source_folders_list')\n     source_files_list = StringListProperty('_source_files_list')\n     vs_props = NoneProperty('_vs_props')\n     vs_targets = NoneProperty('_vs_targets')\n     vs_rules = NoneProperty('_vs_rules')\n     perforce = BooleanProperty('_perforce')\n     verbose = BooleanProperty('_verbose')\n     suffix_enable = BooleanProperty('_suffix_enable')\n \n     def __init__(self, name=None, **kargs):\n         \"\"\"\n         Init defaults.\n \n         Args:\n             name: Name of the Solution\n             kargs: dict of arguments.\n         \"\"\"\n \n         # Init the base class\n         super().__init__()\n \n         self._ide = None\n         self.source_folders_list = []\n         self.source_files_list = []\n         self.perforce = True\n         self.verbose = False\n         self.suffix_enable = True\n \n         working_directory = os.getcwd()\n \n         # Use a default solution name\n         if name is None:\n             self.name = os.path.basename(working_directory)\n         else:\n             self.name = name\n \n         # Default directory\n         self.working_directory = working_directory\n \n         # Set a default project type\n         if self.project_type is None:\n             self.project_type = ProjectTypes.default()\n \n         self.project_list = []\n         self.ide_code = ''\n         self.platform_code = ''\n \n         # Set all the variables\n         for key in kargs.items():\n             setattr(self, key[0], key[1])\n \n     ########################################\n \n     def _getide(self):\n         \"\"\"\n         Return the ide type\n         \"\"\"\n         return self._ide\n \n     def _setide(self, value):\n         \"\"\"\n         Set the IDE type with validation\n         Args:\n             self: The 'this' reference.\n             value: None or new IDE type\n         \"\"\"\n         self._ide = validate_enum_type(value, IDETypes)\n \n     ide = property(_getide, _setide)\n \n     ########################################\n \n     def add_project(self, project=None, project_type=None):\n         \"\"\"\n         Add a project to the list of projects found in this solution.\n         @details\n         Given a new Project class instance, append it to the list of\n         projects that this solution is managing.\n \n         Args:\n             self: The 'this' reference.\n             project: Reference to an instance of a Project.\n             project_type: Type of project to create.\n         \"\"\"\n \n         if project is None or is_string(project):\n             project = Project(project, project_type=project_type)\n \n         # Sanity check\n         if not isinstance(project, Project):\n             raise TypeError(\n                 \"parameter 'project' must be of type Project or name\")\n \n         project.solution = self\n         project.parent = self\n         self.project_list.append(project)\n         return project\n \n     ########################################\n \n     def add_tool(self, project=None):\n         \"\"\"\n         Add a project to build a command line tool.\n \n         See Also:\n             add_project\n         \"\"\"\n         return self.add_project(project, ProjectTypes.tool)\n \n     def add_app(self, project=None):\n         \"\"\"\n         Add a project to build an application.\n \n         See Also:\n             add_project\n         \"\"\"\n         return self.add_project(project, ProjectTypes.app)\n \n     def add_library(self, project=None):\n         \"\"\"\n         Add a project to build a static library.\n \n         See Also:\n             add_project\n         \"\"\"\n         return self.add_project(project, ProjectTypes.library)\n \n     def add_shared_library(self, project=None):\n         \"\"\"\n         Add a project to build a dynamic library.\n \n         See Also:\n             add_project\n         \"\"\"\n         return self.add_project(project, ProjectTypes.sharedlibrary)\n \n     ########################################\n \n     def get_project_list(self):\n         \"\"\"\n         Return the project list for all sub projects.\n         @details\n         Create a flattened list by iterating over every sub project.\n \n         Returns:\n             List of every project in the project.\n         \"\"\"\n \n         # Make a copy of the current list\n         project_list = list(self.project_list)\n \n         # Scan the sub projects and add their projects to the\n         # generated list.\n         for project in self.project_list:\n             project_list.extend(project.get_project_list())\n         return project_list\n \n     ########################################\n \n     def set_platforms(self, platform):\n         \"\"\"\n         Update all configurations to a new platform.\n \n         If there are no configurations, Debug and Release will be\n         created.\n \n         Args:\n             platform: Platform to change the configurations to.\n         \"\"\"\n \n         for project in self.get_project_list():\n             project.set_platforms(platform)\n \n     ########################################\n \n     def generate(self, ide=None):\n         \"\"\"\n         Generate a project file and write it out to disk.\n         \"\"\"\n \n         # pylint: disable=import-outside-toplevel\n \n         # Work from a copy to ensure the original is not touched.\n         solution = deepcopy(self)\n \n         # If an ide was passed, check it, otherwise assume\n         # solution.ide is valid\n         if ide is not None:\n             # Note, this will throw if IDE is not an IDE value\n             solution.ide = ide\n \n             # Grab the value back if there was conversion\n             ide = solution.ide\n \n         # Set the default IDE to whatever the system uses\n         if ide is None:\n             ide = IDETypes.default()\n             solution.ide = ide\n \n         # Determine which generator to use based on the selected IDE\n \n         import makeprojects.watcom\n         import makeprojects.makefile\n         import makeprojects.visual_studio\n         import makeprojects.visual_studio_2010\n         import makeprojects.codewarrior\n         import makeprojects.xcode\n         import makeprojects.codeblocks\n \n         generator_list = (\n             makeprojects.visual_studio,\n             makeprojects.visual_studio_2010,\n             makeprojects.watcom,\n             makeprojects.makefile,\n             makeprojects.codewarrior,\n             makeprojects.xcode,\n             makeprojects.codeblocks)\n         for generator in generator_list:\n             if ide in generator.SUPPORTED_IDES:\n                 break\n         else:\n             print('IDE {} is not supported.'.format(ide))\n             return 10\n \n         # Convert keys that need to be regexes from *.cpp to regex\n         solution.custom_rules = regex_dict(solution.custom_rules)\n \n         all_configurations_list = []\n \n         # Process all the projects and configurations\n         for project in solution.get_project_list():\n \n             # Handle projects\n             project.custom_rules = regex_dict(project.custom_rules)\n \n             # Purge unsupported configurations\n             configuration_list = []\n             if not project.configuration_list:\n                 for item in ('Debug', 'Release'):\n                     project.add_configuration(item)\n \n             for configuration in project.configuration_list:\n                 if generator.test(ide, configuration.platform):\n                     configuration_list.append(configuration)\n \n             # Sort the configurations to ensure consistency\n             configuration_list = sorted(\n                 configuration_list, key=lambda x: (\n                     x.name, x.platform))\n             project.configuration_list = configuration_list\n \n             all_configurations_list.extend(configuration_list)\n             project.platform_code = platformtype_short_code(configuration_list)\n \n             # Handle regexes for configurations that will be used\n             for configuration in configuration_list:\n                 configuration.custom_rules = regex_dict(\n                     configuration.custom_rules)\n                 configuration.exclude_list_regex = translate_to_regex_match(\n                     configuration.exclude_list)\n \n         # Get the platform code\n         solution.platform_code = platformtype_short_code(\n             all_configurations_list)\n \n         # Set the IDE code\n         solution.ide_code = ide.get_short_code()\n \n         # Create project files\n         return generator.generate(solution)\n \n     def __repr__(self):\n         \"\"\"\n         Convert the solultion record into a human readable description\n \n         Returns:\n             Human readable string or None if the solution is invalid\n         \"\"\"\n         result_list = []\n         for item in self.__dict__.items():\n             if item[0] == 'parent':\n                 continue\n             item_name = item[0][1:] if item[0].startswith('_') else item[0]\n             result_list.append(\n                 '{0}: {1!s}'.format(\n                     item_name,\n                     item[1]))\n         return 'Solution: ' + ', '.join(result_list)\n \n     def __str__(self):\n         \"\"\"\n         Convert the solultion record into a human readable description\n \n         Returns:\n             Human readable string or None if the solution is invalid\n         \"\"\"\n \n         return self.__repr__()\n ", "input_code": "def run_command(self, cmd, verbose):\n\"\"\"\nCall the given command(s).\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def run_command(self, cmd, verbose):\n        \"\"\"\n        Issue a command and return the generated BuildError\n\n        Args:\n            cmd: command line to execute\n            verbose: True if verbose output is required\n        Returns:\n            BuildError object with error condition, if any.\n        \"\"\"\n\n        # Perform the command\n        try:\n            error_code = run_command(\n                cmd, working_dir=os.path.dirname(self.file_name),\n                quiet=not verbose)[0]\n            msg = None\n        except OSError as error:\n            error_code = getattr(error, 'winerror', error.errno)\n            msg = str(error)\n            print(msg, file=sys.stderr)\n\n        # Return the results\n        return BuildError(error_code, self.file_name,\n                          configuration=self.configuration, msg=msg)", "signature": "def run_command(self, cmd, verbose):", "completion_path": "makeprojects/core.py"}
{"ce_id": "62ece4992e6aefcf4aabbd84", "namespace": "62ece4992e6aefcf4aabbd84", "namespace_real": "gopad.rest.is_ipv4", "real_proj_path": "", "type": "function", "class_name": null, "function_name": "is_ipv4", "contexts_above": "\"\"\"\n    Gopad OpenAPI\n\n    API definition for Gopad  # noqa: E501\n\n    The version of the OpenAPI document: 1.0.0-alpha1\n    Generated by: https://openapi-generator.tech\n\"\"\"\n\n\nimport io\nimport json\nimport logging\nimport re\nimport ssl\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlparse\nfrom urllib.request import proxy_bypass_environment\nimport urllib3\nimport ipaddress\n\nfrom gopad.exceptions import ApiException, UnauthorizedException, ForbiddenException, NotFoundException, ServiceException, ApiValueError\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass RESTResponse(io.IOBase):\n\n    def __init__(self, resp):\n        self.urllib3_response = resp\n        self.status = resp.status\n        self.reason = resp.reason\n        self.data = resp.data\n\n    def getheaders(self):\n        \"\"\"Returns a dictionary of the response headers.\"\"\"\n        return self.urllib3_response.getheaders()\n\n    def getheader(self, name, default=None):\n        \"\"\"Returns a given response header.\"\"\"\n        return self.urllib3_response.getheader(name, default)\n\n\nclass RESTClientObject(object):\n\n    def __init__(self, configuration, pools_size=4, maxsize=None):\n        # urllib3.PoolManager will pass all kw parameters to connectionpool\n        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501\n        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501\n        # maxsize is the number of requests to host that are allowed in parallel  # noqa: E501\n        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501\n\n        # cert_reqs\n        if configuration.verify_ssl:\n            cert_reqs = ssl.CERT_REQUIRED\n        else:\n            cert_reqs = ssl.CERT_NONE\n\n        addition_pool_args = {}\n        if configuration.assert_hostname is not None:\n            addition_pool_args['assert_hostname'] = configuration.assert_hostname  # noqa: E501\n\n        if configuration.retries is not None:\n            addition_pool_args['retries'] = configuration.retries\n\n        if configuration.socket_options is not None:\n            addition_pool_args['socket_options'] = configuration.socket_options\n\n        if maxsize is None:\n            if configuration.connection_pool_maxsize is not None:\n                maxsize = configuration.connection_pool_maxsize\n            else:\n                maxsize = 4\n\n        # https pool manager\n        if configuration.proxy and not should_bypass_proxies(configuration.host, no_proxy=configuration.no_proxy or ''):\n            self.pool_manager = urllib3.ProxyManager(\n                num_pools=pools_size,\n                maxsize=maxsize,\n                cert_reqs=cert_reqs,\n                ca_certs=configuration.ssl_ca_cert,\n                cert_file=configuration.cert_file,\n                key_file=configuration.key_file,\n                proxy_url=configuration.proxy,\n                proxy_headers=configuration.proxy_headers,\n                **addition_pool_args\n            )\n        else:\n            self.pool_manager = urllib3.PoolManager(\n                num_pools=pools_size,\n                maxsize=maxsize,\n                cert_reqs=cert_reqs,\n                ca_certs=configuration.ssl_ca_cert,\n                cert_file=configuration.cert_file,\n                key_file=configuration.key_file,\n                **addition_pool_args\n            )\n\n    def request(self, method, url, query_params=None, headers=None,\n                body=None, post_params=None, _preload_content=True,\n                _request_timeout=None):\n        \"\"\"Perform requests.\n\n        :param method: http request method\n        :param url: http request url\n        :param query_params: query parameters in the url\n        :param headers: http request headers\n        :param body: request json body, for `application/json`\n        :param post_params: request post parameters,\n                            `application/x-www-form-urlencoded`\n                            and `multipart/form-data`\n        :param _preload_content: if False, the urllib3.HTTPResponse object will\n                                 be returned without reading/decoding response\n                                 data. Default is True.\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        \"\"\"\n        method = method.upper()\n        assert method in ['GET', 'HEAD', 'DELETE', 'POST', 'PUT',\n                          'PATCH', 'OPTIONS']\n\n        if post_params and body:\n            raise ApiValueError(\n                \"body parameter cannot be used with post_params parameter.\"\n            )\n\n        post_params = post_params or {}\n        headers = headers or {}\n\n        timeout = None\n        if _request_timeout:\n            if isinstance(_request_timeout, (int, float)):  # noqa: E501,F821\n                timeout = urllib3.Timeout(total=_request_timeout)\n            elif (isinstance(_request_timeout, tuple) and\n                  len(_request_timeout) == 2):\n                timeout = urllib3.Timeout(\n                    connect=_request_timeout[0], read=_request_timeout[1])\n\n        try:\n            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`\n            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:\n                # Only set a default Content-Type for POST, PUT, PATCH and OPTIONS requests\n                if (method != 'DELETE') and ('Content-Type' not in headers):\n                    headers['Content-Type'] = 'application/json'\n                if query_params:\n                    url += '?' + urlencode(query_params)\n                if ('Content-Type' not in headers) or (re.search('json', headers['Content-Type'], re.IGNORECASE)):\n                    request_body = None\n                    if body is not None:\n                        request_body = json.dumps(body)\n                    r = self.pool_manager.request(\n                        method, url,\n                        body=request_body,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501\n                    r = self.pool_manager.request(\n                        method, url,\n                        fields=post_params,\n                        encode_multipart=False,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                elif headers['Content-Type'] == 'multipart/form-data':\n                    # must del headers['Content-Type'], or the correct\n                    # Content-Type which generated by urllib3 will be\n                    # overwritten.\n                    del headers['Content-Type']\n                    r = self.pool_manager.request(\n                        method, url,\n                        fields=post_params,\n                        encode_multipart=True,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                # Pass a `string` parameter directly in the body to support\n                # other content types than Json when `body` argument is\n                # provided in serialized form\n                elif isinstance(body, str) or isinstance(body, bytes):\n                    request_body = body\n                    r = self.pool_manager.request(\n                        method, url,\n                        body=request_body,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                else:\n                    # Cannot generate the request from given parameters\n                    msg = \"\"\"Cannot prepare a request message for provided\n                             arguments. Please check that your arguments match\n                             declared content type.\"\"\"\n                    raise ApiException(status=0, reason=msg)\n            # For `GET`, `HEAD`\n            else:\n                r = self.pool_manager.request(method, url,\n                                              fields=query_params,\n                                              preload_content=_preload_content,\n                                              timeout=timeout,\n                                              headers=headers)\n        except urllib3.exceptions.SSLError as e:\n            msg = \"{0}\\n{1}\".format(type(e).__name__, str(e))\n            raise ApiException(status=0, reason=msg)\n\n        if _preload_content:\n            r = RESTResponse(r)\n\n            # log response body\n            logger.debug(\"response body: %s\", r.data)\n\n        if not 200 <= r.status <= 299:\n            if r.status == 401:\n                raise UnauthorizedException(http_resp=r)\n\n            if r.status == 403:\n                raise ForbiddenException(http_resp=r)\n\n            if r.status == 404:\n                raise NotFoundException(http_resp=r)\n\n            if 500 <= r.status <= 599:\n                raise ServiceException(http_resp=r)\n\n            raise ApiException(http_resp=r)\n\n        return r\n\n    def GET(self, url, headers=None, query_params=None, _preload_content=True,\n            _request_timeout=None):\n        return self.request(\"GET\", url,\n                            headers=headers,\n                            _preload_content=_preload_content,\n                            _request_timeout=_request_timeout,\n                            query_params=query_params)\n\n    def HEAD(self, url, headers=None, query_params=None, _preload_content=True,\n             _request_timeout=None):\n        return self.request(\"HEAD\", url,\n                            headers=headers,\n                            _preload_content=_preload_content,\n                            _request_timeout=_request_timeout,\n                            query_params=query_params)\n\n    def OPTIONS(self, url, headers=None, query_params=None, post_params=None,\n                body=None, _preload_content=True, _request_timeout=None):\n        return self.request(\"OPTIONS\", url,\n                            headers=headers,\n                            query_params=query_params,\n                            post_params=post_params,\n                            _preload_content=_preload_content,\n                            _request_timeout=_request_timeout,\n                            body=body)\n\n    def DELETE(self, url, headers=None, query_params=None, body=None,\n               _preload_content=True, _request_timeout=None):\n        return self.request(\"DELETE\", url,\n                            headers=headers,\n                            query_params=query_params,\n                            _preload_content=_preload_content,\n                            _request_timeout=_request_timeout,\n                            body=body)\n\n    def POST(self, url, headers=None, query_params=None, post_params=None,\n             body=None, _preload_content=True, _request_timeout=None):\n        return self.request(\"POST\", url,\n                            headers=headers,\n                            query_params=query_params,\n                            post_params=post_params,\n                            _preload_content=_preload_content,\n                            _request_timeout=_request_timeout,\n                            body=body)\n\n    def PUT(self, url, headers=None, query_params=None, post_params=None,\n            body=None, _preload_content=True, _request_timeout=None):\n        return self.request(\"PUT\", url,\n                            headers=headers,\n                            query_params=query_params,\n                            post_params=post_params,\n                            _preload_content=_preload_content,\n                            _request_timeout=_request_timeout,\n                            body=body)\n\n    def PATCH(self, url, headers=None, query_params=None, post_params=None,\n              body=None, _preload_content=True, _request_timeout=None):\n        return self.request(\"PATCH\", url,\n                            headers=headers,\n                            query_params=query_params,\n                            post_params=post_params,\n                            _preload_content=_preload_content,\n                            _request_timeout=_request_timeout,\n                            body=body)\n\n# end of class RESTClientObject", "contexts_below": "def in_ipv4net(target, net):\n     \"\"\" Test if target belongs to given IPv4 network\n     \"\"\"\n     try:\n         nw = ipaddress.IPv4Network(net)\n         ip = ipaddress.IPv4Address(target)\n         if ip in nw:\n             return True\n         return False\n     except ipaddress.AddressValueError:\n         return False\n     except ipaddress.NetmaskValueError:\n         return False\n \n def should_bypass_proxies(url, no_proxy=None):\n     \"\"\" Yet another requests.should_bypass_proxies\n     Test if proxies should not be used for a particular url.\n     \"\"\"\n \n     parsed = urlparse(url)\n \n     # special cases\n     if parsed.hostname in [None, '']:\n         return True\n \n     # special cases\n     if no_proxy in [None , '']:\n         return False\n     if no_proxy == '*':\n         return True\n \n     no_proxy = no_proxy.lower().replace(' ','');\n     entries = (\n         host for host in no_proxy.split(',') if host\n     )\n \n     if is_ipv4(parsed.hostname):\n         for item in entries:\n            if in_ipv4net(parsed.hostname, item):\n                return True\n     return proxy_bypass_environment(parsed.hostname, {'no': no_proxy} )\n ", "input_code": "def is_ipv4(target):\n\"\"\"\nTest if IPv4 address or not\n    \n\"\"\"\n", "indent_space": "    ", "ground_truth": "def is_ipv4(target):\n    \"\"\" Test if IPv4 address or not\n    \"\"\"\n    try:\n       chk = ipaddress.IPv4Address(target)\n       return True\n    except ipaddress.AddressValueError:\n       return False", "signature": "def is_ipv4(target):", "completion_path": "gopad/rest.py"}
{"ce_id": "62ece4992e6aefcf4aabbd85", "namespace": "62ece4992e6aefcf4aabbd85", "namespace_real": "rdflib.util.find_roots", "real_proj_path": "mwatts15---rdflib/", "type": "function", "class_name": null, "function_name": "find_roots", "contexts_above": "\"\"\"\nSome utility functions.\n\nMiscellaneous utilities\n\n* list2set\n* first\n* uniq\n* more_than\n\nTerm characterisation and generation\n\n* to_term\n* from_n3\n\nDate/time utilities\n\n* date_time\n* parse_date_time\n\n\"\"\"\n\nfrom calendar import timegm\nfrom os.path import splitext\n\n# from time import daylight\nfrom time import altzone, gmtime, localtime, time, timezone\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Iterable,\n    List,\n    Optional,\n    Set,\n    Tuple,\n    TypeVar,\n)\n\nimport rdflib.graph  # avoid circular dependency\nfrom rdflib.compat import sign\nfrom rdflib.namespace import XSD, Namespace, NamespaceManager\nfrom rdflib.term import BNode, IdentifiedNode, Literal, Node, URIRef\n\nif TYPE_CHECKING:\n    from rdflib.graph import Graph\n\n__all__ = [\n    \"list2set\",\n    \"first\",\n    \"uniq\",\n    \"more_than\",\n    \"to_term\",\n    \"from_n3\",\n    \"date_time\",\n    \"parse_date_time\",\n    \"guess_format\",\n    \"find_roots\",\n    \"get_tree\",\n    \"_coalesce\",\n]\n\n\ndef list2set(seq):\n    \"\"\"\n    Return a new list without duplicates.\n    Preserves the order, unlike set(seq)\n    \"\"\"\n    seen = set()\n    return [x for x in seq if x not in seen and not seen.add(x)]\n\n\ndef first(seq):\n    \"\"\"\n    return the first element in a python sequence\n    for graphs, use graph.value instead\n    \"\"\"\n    for result in seq:\n        return result\n    return None\n\n\ndef uniq(sequence, strip=0):\n    \"\"\"removes duplicate strings from the sequence.\"\"\"\n    if strip:\n        return set(s.strip() for s in sequence)\n    else:\n        return set(sequence)\n\n\ndef more_than(sequence, number):\n    \"Returns 1 if sequence has more items than number and 0 if not.\"\n    i = 0\n    for item in sequence:\n        i += 1\n        if i > number:\n            return 1\n    return 0\n\n\ndef to_term(s, default=None):\n    \"\"\"\n    Creates and returns an Identifier of type corresponding\n    to the pattern of the given positional argument string ``s``:\n\n    '' returns the ``default`` keyword argument value or ``None``\n\n    '<s>' returns ``URIRef(s)`` (i.e. without angle brackets)\n\n    '\"s\"' returns ``Literal(s)`` (i.e. without doublequotes)\n\n    '_s' returns ``BNode(s)`` (i.e. without leading underscore)\n\n    \"\"\"\n    if not s:\n        return default\n    elif s.startswith(\"<\") and s.endswith(\">\"):\n        return URIRef(s[1:-1])\n    elif s.startswith('\"') and s.endswith('\"'):\n        return Literal(s[1:-1])\n    elif s.startswith(\"_\"):\n        return BNode(s)\n    else:\n        msg = \"Unrecognised term syntax: '%s'\" % s\n        raise Exception(msg)\n\n\ndef from_n3(s: str, default=None, backend=None, nsm=None):\n    r'''\n    Creates the Identifier corresponding to the given n3 string.\n\n        >>> from_n3('<http://ex.com/foo>') == URIRef('http://ex.com/foo')\n        True\n        >>> from_n3('\"foo\"@de') == Literal('foo', lang='de')\n        True\n        >>> from_n3('\"\"\"multi\\nline\\nstring\"\"\"@en') == Literal(\n        ...     'multi\\nline\\nstring', lang='en')\n        True\n        >>> from_n3('42') == Literal(42)\n        True\n        >>> from_n3(Literal(42).n3()) == Literal(42)\n        True\n        >>> from_n3('\"42\"^^xsd:integer') == Literal(42)\n        True\n        >>> from rdflib import RDFS\n        >>> from_n3('rdfs:label') == RDFS['label']\n        True\n        >>> nsm = NamespaceManager(rdflib.graph.Graph())\n        >>> nsm.bind('dbpedia', 'http://dbpedia.org/resource/')\n        >>> berlin = URIRef('http://dbpedia.org/resource/Berlin')\n        >>> from_n3('dbpedia:Berlin', nsm=nsm) == berlin\n        True\n\n    '''\n    if not s:\n        return default\n    if s.startswith(\"<\"):\n        # Hack: this should correctly handle strings with either native unicode\n        # characters, or \\u1234 unicode escapes.\n        return URIRef(s[1:-1].encode(\"raw-unicode-escape\").decode(\"unicode-escape\"))\n    elif s.startswith('\"'):\n        if s.startswith('\"\"\"'):\n            quotes = '\"\"\"'\n        else:\n            quotes = '\"'\n        value, rest = s.rsplit(quotes, 1)\n        value = value[len(quotes) :]  # strip leading quotes\n        datatype = None\n        language = None\n\n        # as a given datatype overrules lang-tag check for it first\n        dtoffset = rest.rfind(\"^^\")\n        if dtoffset >= 0:\n            # found a datatype\n            # datatype has to come after lang-tag so ignore everything before\n            # see: http://www.w3.org/TR/2011/WD-turtle-20110809/\n            # #prod-turtle2-RDFLiteral\n            datatype = from_n3(rest[dtoffset + 2 :], default, backend, nsm)\n        else:\n            if rest.startswith(\"@\"):\n                language = rest[1:]  # strip leading at sign\n\n        value = value.replace(r\"\\\"\", '\"')\n        # unicode-escape interprets \\xhh as an escape sequence,\n        # but n3 does not define it as such.\n        value = value.replace(r\"\\x\", r\"\\\\x\")\n        # Hack: this should correctly handle strings with either native unicode\n        # characters, or \\u1234 unicode escapes.\n        value = value.encode(\"raw-unicode-escape\").decode(\"unicode-escape\")\n        return Literal(value, language, datatype)\n    elif s == \"true\" or s == \"false\":\n        return Literal(s == \"true\")\n    elif (\n        s.lower()\n        .replace('.', '', 1)\n        .replace('-', '', 1)\n        .replace('e', '', 1)\n        .isnumeric()\n    ):\n        if \"e\" in s.lower():\n            return Literal(s, datatype=XSD.double)\n        if \".\" in s:\n            return Literal(float(s), datatype=XSD.decimal)\n        return Literal(int(s), datatype=XSD.integer)\n\n    elif s.startswith(\"{\"):\n        identifier = from_n3(s[1:-1])\n        return rdflib.graph.QuotedGraph(backend, identifier)\n    elif s.startswith(\"[\"):\n        identifier = from_n3(s[1:-1])\n        return rdflib.graph.Graph(backend, identifier)\n    elif s.startswith(\"_:\"):\n        return BNode(s[2:])\n    elif \":\" in s:\n        if nsm is None:\n            # instantiate default NamespaceManager and rely on its defaults\n            nsm = NamespaceManager(rdflib.graph.Graph())\n        prefix, last_part = s.split(\":\", 1)\n        ns = dict(nsm.namespaces())[prefix]\n        return Namespace(ns)[last_part]\n    else:\n        return BNode(s)\n\n\ndef date_time(t=None, local_time_zone=False):\n    \"\"\"http://www.w3.org/TR/NOTE-datetime ex: 1997-07-16T19:20:30Z\n\n    >>> date_time(1126482850)\n    '2005-09-11T23:54:10Z'\n\n    @@ this will change depending on where it is run\n    #>>> date_time(1126482850, local_time_zone=True)\n    #'2005-09-11T19:54:10-04:00'\n\n    >>> date_time(1)\n    '1970-01-01T00:00:01Z'\n\n    >>> date_time(0)\n    '1970-01-01T00:00:00Z'\n    \"\"\"\n    if t is None:\n        t = time()\n\n    if local_time_zone:\n        time_tuple = localtime(t)\n        if time_tuple[8]:\n            tz_mins = altzone // 60\n        else:\n            tz_mins = timezone // 60\n        tzd = \"-%02d:%02d\" % (tz_mins // 60, tz_mins % 60)\n    else:\n        time_tuple = gmtime(t)\n        tzd = \"Z\"\n\n    year, month, day, hh, mm, ss, wd, y, z = time_tuple\n    s = \"%0004d-%02d-%02dT%02d:%02d:%02d%s\" % (year, month, day, hh, mm, ss, tzd)\n    return s\n\n\ndef parse_date_time(val):\n    \"\"\"always returns seconds in UTC\n\n    # tests are written like this to make any errors easier to understand\n    >>> parse_date_time('2005-09-11T23:54:10Z') - 1126482850.0\n    0.0\n\n    >>> parse_date_time('2005-09-11T16:54:10-07:00') - 1126482850.0\n    0.0\n\n    >>> parse_date_time('1970-01-01T00:00:01Z') - 1.0\n    0.0\n\n    >>> parse_date_time('1970-01-01T00:00:00Z') - 0.0\n    0.0\n    >>> parse_date_time(\"2005-09-05T10:42:00\") - 1125916920.0\n    0.0\n    \"\"\"\n\n    if \"T\" not in val:\n        val += \"T00:00:00Z\"\n\n    ymd, time = val.split(\"T\")\n    hms, tz_str = time[0:8], time[8:]\n\n    if not tz_str or tz_str == \"Z\":\n        time = time[:-1]\n        tz_offset = 0\n    else:\n        signed_hrs = int(tz_str[:3])\n        mins = int(tz_str[4:6])\n        secs = (sign(signed_hrs) * mins + signed_hrs * 60) * 60\n        tz_offset = -secs\n\n    year, month, day = ymd.split(\"-\")\n    hour, minute, second = hms.split(\":\")\n\n    t = timegm(\n        (int(year), int(month), int(day), int(hour), int(minute), int(second), 0, 0, 0)\n    )\n    t = t + tz_offset\n    return t\n\n\nSUFFIX_FORMAT_MAP = {\n    \"xml\": \"xml\",\n    \"rdf\": \"xml\",\n    \"owl\": \"xml\",\n    \"n3\": \"n3\",\n    \"ttl\": \"turtle\",\n    \"nt\": \"nt\",\n    \"trix\": \"trix\",\n    \"xhtml\": \"rdfa\",\n    \"html\": \"rdfa\",\n    \"svg\": \"rdfa\",\n    \"nq\": \"nquads\",\n    \"nquads\": \"nquads\",\n    \"trig\": \"trig\",\n    \"json\": \"json-ld\",\n    \"jsonld\": \"json-ld\",\n    \"json-ld\": \"json-ld\",\n}\n\n\ndef guess_format(fpath, fmap=None) -> Optional[str]:\n    \"\"\"\n    Guess RDF serialization based on file suffix. Uses\n    ``SUFFIX_FORMAT_MAP`` unless ``fmap`` is provided. Examples:\n\n        >>> guess_format('path/to/file.rdf')\n        'xml'\n        >>> guess_format('path/to/file.owl')\n        'xml'\n        >>> guess_format('path/to/file.ttl')\n        'turtle'\n        >>> guess_format('path/to/file.json')\n        'json-ld'\n        >>> guess_format('path/to/file.xhtml')\n        'rdfa'\n        >>> guess_format('path/to/file.svg')\n        'rdfa'\n        >>> guess_format('path/to/file.xhtml', {'xhtml': 'grddl'})\n        'grddl'\n\n    This also works with just the suffixes, with or without leading dot, and\n    regardless of letter case::\n\n        >>> guess_format('.rdf')\n        'xml'\n        >>> guess_format('rdf')\n        'xml'\n        >>> guess_format('RDF')\n        'xml'\n    \"\"\"\n    fmap = fmap or SUFFIX_FORMAT_MAP\n    return fmap.get(_get_ext(fpath)) or fmap.get(fpath.lower())\n\n\ndef _get_ext(fpath, lower=True):\n    \"\"\"\n    Gets the file extension from a file(path); stripped of leading '.' and in\n    lower case. Examples:\n\n        >>> _get_ext(\"path/to/file.txt\")\n        'txt'\n        >>> _get_ext(\"OTHER.PDF\")\n        'pdf'\n        >>> _get_ext(\"noext\")\n        ''\n        >>> _get_ext(\".rdf\")\n        'rdf'\n    \"\"\"\n    ext = splitext(fpath)[-1]\n    if ext == \"\" and fpath.startswith(\".\"):\n        ext = fpath\n    if lower:\n        ext = ext.lower()\n    if ext.startswith(\".\"):\n        ext = ext[1:]\n    return ext\n\n", "contexts_below": "\n def get_tree(\n     graph: \"Graph\",\n     root: \"IdentifiedNode\",\n     prop: \"URIRef\",\n     mapper: Callable[[\"IdentifiedNode\"], \"IdentifiedNode\"] = lambda x: x,\n     sortkey: Optional[Callable[[Any], Any]] = None,\n     done: Optional[Set[\"IdentifiedNode\"]] = None,\n     dir: str = \"down\",\n ) -> Optional[Tuple[IdentifiedNode, List[Any]]]:\n     \"\"\"\n     Return a nested list/tuple structure representing the tree\n     built by the transitive property given, starting from the root given\n \n     i.e.\n \n     get_tree(graph,\n        rdflib.URIRef(\"http://xmlns.com/foaf/0.1/Person\"),\n        rdflib.RDFS.subClassOf)\n \n     will return the structure for the subClassTree below person.\n \n     dir='down' assumes triple of the form (child, prop, parent),\n     i.e. the direction of RDFS.subClassOf or SKOS.broader\n     Any other dir traverses in the other direction\n \n     \"\"\"\n \n     if done is None:\n         done = set()\n     if root in done:\n         # type error: Return value expected\n         return  # type: ignore[return-value]\n     done.add(root)\n     tree = []\n \n     branches: Iterable[IdentifiedNode]\n     if dir == \"down\":\n         branches = graph.subjects(prop, root)\n     else:\n         # type error: Incompatible types in assignment (expression has type \"Iterable[Node]\", variable has type \"Iterable[IdentifiedNode]\")\n         branches = graph.objects(root, prop)  # type: ignore[assignment]\n \n     for branch in branches:\n         t = get_tree(graph, branch, prop, mapper, sortkey, done, dir)\n         if t:\n             tree.append(t)\n \n     return (mapper(root), sorted(tree, key=sortkey))\n \n \n _AnyT = TypeVar(\"_AnyT\")\n \n \n def _coalesce(*args: Optional[_AnyT]) -> Optional[_AnyT]:\n     \"\"\"\n     This is a null coalescing function, it will return the first non-`None`\n     argument passed to it, otherwise it will return `None`.\n \n     For more info regarding the rationale of this function see deferred `PEP\n     505 <https://peps.python.org/pep-0505/>`_.\n \n     :param args: Values to consider as candidates to return, the first arg that\n         is not `None` will be returned. If no argument is passed this function\n         will return None.\n     :return: The first ``arg`` that is not `None`, otherwise `None` if there\n         are no args or if all args are `None`.\n     \"\"\"\n     for arg in args:\n         if arg is not None:\n             return arg\n     return None\n ", "input_code": "def find_roots(graph: 'Graph', prop: 'URIRef', roots: Optional[Set['Node']]=None) -> Set['Node']:\n\"\"\"\nFind the roots in some sort of transitive hierarchy.\n\nfind_roots(graph, rdflib.RDFS.subClassOf)\nwill return a set of all roots of the sub-class hierarchy\n\nAssumes triple of the form (child, prop, parent), i.e. the direction of\nRDFS.subClassOf or SKOS.broader\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def find_roots(\n    graph: \"Graph\", prop: \"URIRef\", roots: Optional[Set[\"Node\"]] = None\n) -> Set[\"Node\"]:\n    \"\"\"\n    Find the roots in some sort of transitive hierarchy.\n\n    find_roots(graph, rdflib.RDFS.subClassOf)\n    will return a set of all roots of the sub-class hierarchy\n\n    Assumes triple of the form (child, prop, parent), i.e. the direction of\n    RDFS.subClassOf or SKOS.broader\n\n    \"\"\"\n\n    non_roots: Set[Node] = set()\n    if roots is None:\n        roots = set()\n    for x, y in graph.subject_objects(prop):\n        non_roots.add(x)\n        if x in roots:\n            roots.remove(x)\n        if y not in non_roots:\n            roots.add(y)\n    return roots", "signature": "def find_roots(graph: 'Graph', prop: 'URIRef', roots: Optional[Set['Node']]=None) -> Set['Node']:", "completion_path": "rdflib/util.py"}
{"ce_id": "62ece4992e6aefcf4aabbd86", "namespace": "62ece4992e6aefcf4aabbd86", "namespace_real": "tests.unit.mock.yaml_helper._dump_string", "real_proj_path": "ansible-security---ansible_collections.ibm.qradar/", "type": "class", "class_name": "yaml_helper", "function_name": "_dump_string", "contexts_above": "from __future__ import absolute_import, division, print_function\n\n__metaclass__ = type\nimport io\nimport yaml\n\nfrom ansible.module_utils.six import PY3\nfrom ansible.parsing.yaml.loader import AnsibleLoader\nfrom ansible.parsing.yaml.dumper import AnsibleDumper\n\n\nclass YamlTestUtils(object):\n    \"\"\"Mixin class to combine with a unittest.TestCase subclass.\"\"\"\n\n    def _loader(self, stream):\n        \"\"\"Vault related tests will want to override this.\n\n        Vault cases should setup a AnsibleLoader that has the vault password.\"\"\"\n        return AnsibleLoader(stream)\n\n    def _dump_stream(self, obj, stream, dumper=None):\n        \"\"\"Dump to a py2-unicode or py3-string stream.\"\"\"\n        if PY3:\n            return yaml.dump(obj, stream, Dumper=dumper)\n        else:\n            return yaml.dump(obj, stream, Dumper=dumper, encoding=None)\n", "contexts_below": "    def _dump_load_cycle(self, obj):\n         # Each pass though a dump or load revs the 'generation'\n         # obj to yaml string\n         string_from_object_dump = self._dump_string(obj, dumper=AnsibleDumper)\n \n         # wrap a stream/file like StringIO around that yaml\n         stream_from_object_dump = io.StringIO(string_from_object_dump)\n         loader = self._loader(stream_from_object_dump)\n         # load the yaml stream to create a new instance of the object (gen 2)\n         obj_2 = loader.get_data()\n \n         # dump the gen 2 objects directory to strings\n         string_from_object_dump_2 = self._dump_string(\n             obj_2, dumper=AnsibleDumper\n         )\n \n         # The gen 1 and gen 2 yaml strings\n         self.assertEqual(string_from_object_dump, string_from_object_dump_2)\n         # the gen 1 (orig) and gen 2 py object\n         self.assertEqual(obj, obj_2)\n \n         # again! gen 3... load strings into py objects\n         stream_3 = io.StringIO(string_from_object_dump_2)\n         loader_3 = self._loader(stream_3)\n         obj_3 = loader_3.get_data()\n \n         string_from_object_dump_3 = self._dump_string(\n             obj_3, dumper=AnsibleDumper\n         )\n \n         self.assertEqual(obj, obj_3)\n         # should be transitive, but...\n         self.assertEqual(obj_2, obj_3)\n         self.assertEqual(string_from_object_dump, string_from_object_dump_3)\n \n     def _old_dump_load_cycle(self, obj):\n         \"\"\"Dump the passed in object to yaml, load it back up, dump again, compare.\"\"\"\n         stream = io.StringIO()\n \n         yaml_string = self._dump_string(obj, dumper=AnsibleDumper)\n         self._dump_stream(obj, stream, dumper=AnsibleDumper)\n \n         yaml_string_from_stream = stream.getvalue()\n \n         # reset stream\n         stream.seek(0)\n \n         loader = self._loader(stream)\n         # loader = AnsibleLoader(stream, vault_password=self.vault_password)\n         obj_from_stream = loader.get_data()\n \n         stream_from_string = io.StringIO(yaml_string)\n         loader2 = self._loader(stream_from_string)\n         # loader2 = AnsibleLoader(stream_from_string, vault_password=self.vault_password)\n         obj_from_string = loader2.get_data()\n \n         stream_obj_from_stream = io.StringIO()\n         stream_obj_from_string = io.StringIO()\n \n         if PY3:\n             yaml.dump(\n                 obj_from_stream, stream_obj_from_stream, Dumper=AnsibleDumper\n             )\n             yaml.dump(\n                 obj_from_stream, stream_obj_from_string, Dumper=AnsibleDumper\n             )\n         else:\n             yaml.dump(\n                 obj_from_stream,\n                 stream_obj_from_stream,\n                 Dumper=AnsibleDumper,\n                 encoding=None,\n             )\n             yaml.dump(\n                 obj_from_stream,\n                 stream_obj_from_string,\n                 Dumper=AnsibleDumper,\n                 encoding=None,\n             )\n \n         yaml_string_stream_obj_from_stream = stream_obj_from_stream.getvalue()\n         yaml_string_stream_obj_from_string = stream_obj_from_string.getvalue()\n \n         stream_obj_from_stream.seek(0)\n         stream_obj_from_string.seek(0)\n \n         if PY3:\n             yaml_string_obj_from_stream = yaml.dump(\n                 obj_from_stream, Dumper=AnsibleDumper\n             )\n             yaml_string_obj_from_string = yaml.dump(\n                 obj_from_string, Dumper=AnsibleDumper\n             )\n         else:\n             yaml_string_obj_from_stream = yaml.dump(\n                 obj_from_stream, Dumper=AnsibleDumper, encoding=None\n             )\n             yaml_string_obj_from_string = yaml.dump(\n                 obj_from_string, Dumper=AnsibleDumper, encoding=None\n             )\n \n         assert yaml_string == yaml_string_obj_from_stream\n         assert (\n             yaml_string\n             == yaml_string_obj_from_stream\n             == yaml_string_obj_from_string\n         )\n         assert (\n             yaml_string\n             == yaml_string_obj_from_stream\n             == yaml_string_obj_from_string\n             == yaml_string_stream_obj_from_stream\n             == yaml_string_stream_obj_from_string\n         )\n         assert obj == obj_from_stream\n         assert obj == obj_from_string\n         assert obj == yaml_string_obj_from_stream\n         assert obj == yaml_string_obj_from_string\n         assert (\n             obj\n             == obj_from_stream\n             == obj_from_string\n             == yaml_string_obj_from_stream\n             == yaml_string_obj_from_string\n         )\n         return {\n             \"obj\": obj,\n             \"yaml_string\": yaml_string,\n             \"yaml_string_from_stream\": yaml_string_from_stream,\n             \"obj_from_stream\": obj_from_stream,\n             \"obj_from_string\": obj_from_string,\n             \"yaml_string_obj_from_string\": yaml_string_obj_from_string,\n         }\n ", "input_code": "def _dump_string(self, obj, dumper=None):\n\"\"\"\nDump to a py2-unicode or py3-string\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def _dump_string(self, obj, dumper=None):\n        \"\"\"Dump to a py2-unicode or py3-string\"\"\"\n        if PY3:\n            return yaml.dump(obj, Dumper=dumper)\n        else:\n            return yaml.dump(obj, Dumper=dumper, encoding=None)", "signature": "def _dump_string(self, obj, dumper=None):", "completion_path": "tests/unit/mock/yaml_helper.py"}
{"ce_id": "62ece4992e6aefcf4aabbd87", "namespace": "62ece4992e6aefcf4aabbd87", "namespace_real": "apphelpers.loggers.build_app_logger", "real_proj_path": "scrolltech---apphelpers/", "type": "function", "class_name": null, "function_name": "build_app_logger", "contexts_above": "import os\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom loguru import logger as loguru_logger\nfrom converge import settings\n\n\ndef build_api_logger():\n    \"\"\"\n    Builds multiprocess-safe (hence loguru over stdlib logger) API logger\n    \"\"\"\n    level = settings.API_LOGGER.LEVEL\n    handler = settings.API_LOGGER.FILEPATH\n    if handler:  # Else log to sys.stderr by default\n        rotation = settings.API_LOGGER.ROTATION\n        retention = settings.API_LOGGER.RETENTION\n        loguru_logger.add(handler, retention=retention, rotation=rotation,\n                          format=\"{time:YYYY-MM-DD HH:mm:ss} | {message}\",\n                          enqueue=True, level=level)\n    return loguru_logger\n\n", "contexts_below": "\n api_logger = build_api_logger() if settings.API_LOGGER.ENABLED else None\n app_logger = build_app_logger()\n ", "input_code": "def build_app_logger(name='app', logfile='app.log', debug=True):\n\"\"\"\nGeneral purpose application logger. Useful mainly for debugging\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def build_app_logger(name='app', logfile='app.log', debug=True):\n    \"\"\"\n    General purpose application logger. Useful mainly for debugging\n    \"\"\"\n    level = logging.DEBUG if settings.DEBUG else logging.INFO\n    logdir = 'logs'  # TODO: move this to settings\n    if not os.path.exists(logdir):\n        os.mkdir(logdir)\n    logpath = os.path.join(logdir, logfile)\n    maxBytes = 1024 * 1024 * 10\n    handler = RotatingFileHandler(logpath, maxBytes=maxBytes, backupCount=100)\n    handler.setLevel(level)\n    formatter = logging.Formatter('[%(levelname)s] %(asctime)s: %(message)s')\n    handler.setFormatter(formatter)\n    logger = logging.getLogger(name)\n    logger.addHandler(handler)\n    logger.setLevel(level)\n    return logger", "signature": "def build_app_logger(name='app', logfile='app.log', debug=True):", "completion_path": "apphelpers/loggers.py"}
{"ce_id": "62ece4992e6aefcf4aabbd88", "namespace": "62ece4992e6aefcf4aabbd88", "namespace_real": "radiospectra.spectrogram.make_array", "real_proj_path": "sunpy---radiospectra/", "type": "class", "class_name": "spectrogram", "function_name": "make_array", "contexts_above": "\"\"\"\nClasses for spectral analysis.\n\"\"\"\n\nimport datetime\nfrom copy import copy\nfrom math import floor\nfrom random import randint\nfrom distutils.version import LooseVersion\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom matplotlib.colorbar import Colorbar\nfrom matplotlib.figure import Figure\nfrom matplotlib.ticker import FuncFormatter, IndexLocator, MaxNLocator\nfrom numpy import ma\nfrom scipy import ndimage\n\nfrom sunpy import __version__\nfrom sunpy.time import parse_time\n\nfrom radiospectra.spectrum import Spectrum\nfrom radiospectra.util import ConditionalDispatch, Parent, common_base, get_day, merge, to_signed\n\n__all__ = [\"Spectrogram\", \"LinearTimeSpectrogram\"]\n\nSUNPY_LT_1 = LooseVersion(__version__) < LooseVersion(\"1.0\")\n\n# 1080 because that usually is the maximum vertical pixel count on modern\n# screens nowadays (2012).\nDEFAULT_YRES = 1080\n\n# This should not be necessary, as observations do not take more than a day\n# but it is used for completeness' and extendibility's sake.\n# XXX: Leap second?\nSECONDS_PER_DAY = 86400\n\n# Used for COPY_PROPERTIES\nREFERENCE = 0\nCOPY = 1\nDEEPCOPY = 2\n\n\ndef figure(*args, **kwargs):\n    \"\"\"\n    Returns a new SpectroFigure, a figure extended with features useful for\n    analysis of spectrograms.\n\n    Compare pyplot.figure.\n    \"\"\"\n    kw = {\n        \"FigureClass\": SpectroFigure,\n    }\n    kw.update(kwargs)\n    return plt.figure(*args, **kw)\n\n\ndef _min_delt(arr):\n    deltas = arr[:-1] - arr[1:]\n    # Multiple values at the same frequency are just thrown away\n    # in the process of linearizaion\n    return deltas[deltas != 0].min()\n\n\ndef _list_formatter(lst, fun=None):\n    \"\"\"\n    Returns a function that takes x, pos and returns fun(lst[x]) if fun is not\n    None, else lst[x] or \"\" if x is out of range.\n    \"\"\"\n\n    def _fun(x, pos):\n        x = int(x)\n        if x >= len(lst) or x < 0:\n            return \"\"\n\n        elem = lst[x]\n        if fun is None:\n            return elem\n        return fun(elem)\n\n    return _fun\n\n\ndef _union(sets):\n    \"\"\"\n    Returns a union of sets.\n    \"\"\"\n    union = set()\n    for s in sets:\n        union |= s\n    return union\n\n\nclass _LinearView(object):\n    \"\"\"\n    Helper class for frequency channel linearization.\n\n    Attributes\n    ----------\n    arr : Spectrogram\n        Spectrogram to linearize.\n    delt : float\n        Delta between frequency channels in linearized spectrogram. Defaults to\n        (minimum delta / 2.) because of the Shannon sampling theorem.\n    \"\"\"\n\n    def __init__(self, arr, delt=None):\n        self.arr = arr\n        if delt is None:\n            # Nyquist\u2013Shannon sampling theorem\n            delt = _min_delt(arr.freq_axis) / 2.0\n\n        self.delt = delt\n\n        midpoints = (self.arr.freq_axis[:-1] + self.arr.freq_axis[1:]) / 2\n        self.midpoints = np.concatenate([midpoints, arr.freq_axis[-1:]])\n\n        self.max_mp_delt = np.min(self.midpoints[1:] - self.midpoints[:-1])\n\n        self.freq_axis = np.arange(self.arr.freq_axis[0], self.arr.freq_axis[-1], -self.delt)\n        self.time_axis = self.arr.time_axis\n\n        self.shape = (len(self), arr.data.shape[1])\n\n    def __len__(self):\n        return int(1 + (self.arr.freq_axis[0] - self.arr.freq_axis[-1]) / self.delt)\n\n    def _find(self, arr, item):\n        if item < 0:\n            item = item % len(self)\n        if item >= len(self):\n            raise IndexError\n\n        freq_offset = item * self.delt\n        freq = self.arr.freq_axis[0] - freq_offset\n        # The idea is that when we take the biggest delta in the mid points,\n        # we do not have to search anything that is between the beginning and\n        # the first item that can possibly be that frequency.\n        min_mid = int(max(0, (freq - self.midpoints[0]) // self.max_mp_delt))\n        for n, mid in enumerate(self.midpoints[min_mid:]):\n            if mid <= freq:\n                return arr[min_mid + n]\n        return arr[min_mid + n]\n\n    def __getitem__(self, item):\n        return self._find(self.arr, item)\n\n    def get_freq(self, item):\n        return self._find(self.arr.freq_axis, item)\n\n    def make_mask(self, max_dist):\n        mask = np.zeros(self.shape, dtype=np.bool)\n        for n, item in enumerate(range(len(self))):\n            freq = self.arr.freq_axis[0] - item * self.delt\n            if abs(self.get_freq(item) - freq) > max_dist:\n                mask[n, :] = True\n        return mask\n\n\nclass SpectroFigure(Figure):\n    def _init(self, data, freqs):\n        self.data = data\n        self.freqs = freqs\n\n    def ginput_to_time(self, inp):\n        return [self.data.start + datetime.timedelta(seconds=secs) for secs in self.ginput_to_time_secs(inp)]\n\n    def ginput_to_time_secs(self, inp):\n        return np.array([float(self.data.time_axis[x]) for x, y in inp])\n\n    def ginput_to_time_offset(self, inp):\n        v = self.ginput_to_time_secs(inp)\n        return v - v.min()\n\n    def ginput_to_freq(self, inp):\n        return np.array([self.freqs[y] for x, y in inp])\n\n    def time_freq(self, points=0):\n        inp = self.ginput(points)\n        min_ = self.ginput_to_time_secs(inp).min()\n        start = self.data.start + datetime.timedelta(seconds=min_)\n        return TimeFreq(start, self.ginput_to_time_offset(inp), self.ginput_to_freq(inp))\n\n\nclass TimeFreq(object):\n    \"\"\"\n    Class to use for plotting frequency vs time.\n\n    Attributes\n    ----------\n    start : `datetime.datetime`\n        Start time of the plot.\n    time : `~numpy.ndarray`\n        Time of the data points as offset from start in seconds.\n    freq : `~numpy.ndarray`\n        Frequency of the data points in MHz.\n    \"\"\"\n\n    def __init__(self, start, time, freq):\n        self.start = start\n        self.time = time\n        self.freq = freq\n\n    def plot(self, time_fmt=\"%H:%M:%S\", **kwargs):\n        \"\"\"\n        Plot the spectrum.\n\n        Parameters\n        ----------\n        time_fmt : str\n            The time format in a `~datetime.datetime` compatible format\n\n        **kwargs : dict\n            Any additional plot arguments that should be used\n            when plotting.\n\n        Returns\n        -------\n        fig : `~matplotlib.Figure`\n            A plot figure.\n        \"\"\"\n        figure = plt.gcf()\n        axes = figure.add_subplot(111)\n        axes.plot(self.time, self.freq, **kwargs)\n        xa = axes.get_xaxis()\n        xa.set_major_formatter(\n            FuncFormatter(lambda x, pos: (self.start + datetime.timedelta(seconds=x)).strftime(time_fmt))\n        )\n\n        axes.set_xlabel(\"Time [UT]\")\n        axes.set_ylabel(\"Frequency [MHz]\")\n\n        xa = axes.get_xaxis()\n        for tl in xa.get_ticklabels():\n            tl.set_fontsize(10)\n            tl.set_rotation(30)\n        figure.add_axes(axes)\n        figure.subplots_adjust(bottom=0.2)\n        figure.subplots_adjust(left=0.2)\n\n        return figure\n\n    def peek(self, *args, **kwargs):\n        \"\"\"\n        Plot spectrum onto current axes.\n\n        Parameters\n        ----------\n        *args : dict\n\n        **kwargs : dict\n            Any additional plot arguments that should be used\n            when plotting.\n\n        Returns\n        -------\n        fig : `~matplotlib.Figure`\n            A plot figure.\n        \"\"\"\n        plt.figure()\n        ret = self.plot(*args, **kwargs)\n        plt.show()\n        return ret\n\n\nclass Spectrogram(Parent):\n    \"\"\"\n    Spectrogram Class.\n\n    .. warning:: This module is under development! Use at your own risk.\n\n    Attributes\n    ----------\n    data : `~numpy.ndarray`\n        two-dimensional array of the image data of the spectrogram.\n    time_axis : `~numpy.ndarray`\n        one-dimensional array containing the offset from the start\n        for each column of data.\n    freq_axis : `~numpy.ndarray`\n        one-dimensional array containing information about the\n        frequencies each row of the image corresponds to.\n    start : `~datetime.datetime`\n        starting time of the measurement\n    end : `~datetime.datetime`\n        end time of the measurement\n    t_init : int\n        offset from the start of the day the measurement began. If None\n        gets automatically set from start.\n    t_label : str\n        label for the time axis\n    f_label : str\n        label for the frequency axis\n    content : str\n        header for the image\n    instruments : str array\n        instruments that recorded the data, may be more than one if\n        it was constructed using combine_frequencies or join_many.\n    \"\"\"\n\n    # Contrary to what pylint may think, this is not an old-style class.\n    # pylint: disable=E1002,W0142,R0902\n\n    # This needs to list all attributes that need to be\n    # copied to maintain the object and how to handle them.\n    COPY_PROPERTIES = [\n        (\"time_axis\", COPY),\n        (\"freq_axis\", COPY),\n        (\"instruments\", COPY),\n        (\"start\", REFERENCE),\n        (\"end\", REFERENCE),\n        (\"t_label\", REFERENCE),\n        (\"f_label\", REFERENCE),\n        (\"content\", REFERENCE),\n        (\"t_init\", REFERENCE),\n    ]\n    _create = ConditionalDispatch.from_existing(Parent._create)\n\n    @property\n    def shape(self):\n        return self.data.shape\n\n    @property\n    def dtype(self):\n        return self.data.dtype\n\n    def _get_params(self):\n        \"\"\"\n        Implementation detail.\n        \"\"\"\n        return {name: getattr(self, name) for name, _ in self.COPY_PROPERTIES}\n\n    def _slice(self, y_range, x_range):\n        \"\"\"\n        Return new spectrogram reduced to the values passed as slices.\n\n        Implementation detail.\n        \"\"\"\n        data = self.data[y_range, x_range]\n        params = self._get_params()\n\n        soffset = 0 if x_range.start is None else x_range.start\n        soffset = int(soffset)\n        eoffset = self.shape[1] if x_range.stop is None else x_range.stop  # pylint: disable=E1101\n        eoffset -= 1\n        eoffset = int(eoffset)\n\n        params.update(\n            {\n                \"time_axis\": self.time_axis[x_range.start : x_range.stop : x_range.step] - self.time_axis[soffset],\n                \"freq_axis\": self.freq_axis[y_range.start : y_range.stop : y_range.step],\n                \"start\": self.start + datetime.timedelta(seconds=self.time_axis[soffset]),\n                \"end\": self.start + datetime.timedelta(seconds=self.time_axis[eoffset]),\n                \"t_init\": self.t_init + self.time_axis[soffset],\n            }\n        )\n        return self.__class__(data, **params)\n\n    def _with_data(self, data):\n        new = copy(self)\n        new.data = data\n        return new\n\n    def __init__(\n        self,\n        data,\n        time_axis,\n        freq_axis,\n        start,\n        end,\n        t_init=None,\n        t_label=\"Time\",\n        f_label=\"Frequency\",\n        content=\"\",\n        instruments=None,\n    ):\n        # Because of how object creation works, there is no avoiding\n        # unused arguments in this case.\n        self.data = data\n\n        if t_init is None:\n            diff = start - get_day(start)\n            t_init = diff.seconds\n        if instruments is None:\n            instruments = set()\n\n        self.start = start\n        self.end = end\n\n        self.t_label = t_label\n        self.f_label = f_label\n\n        self.t_init = t_init\n\n        self.time_axis = time_axis\n        self.freq_axis = freq_axis\n\n        self.content = content\n        self.instruments = instruments\n\n    def time_formatter(self, x, pos):\n        \"\"\"\n        This returns the label for the tick of value x at a specified pos on\n        the time axis.\n        \"\"\"\n        # Callback, cannot avoid unused arguments.\n        # pylint: disable=W0613\n        x = int(x)\n        if x >= len(self.time_axis) or x < 0:\n            return \"\"\n        return self.format_time(self.start + datetime.timedelta(seconds=float(self.time_axis[x])))\n\n    @staticmethod\n    def format_time(time):\n        \"\"\"\n        Override to configure default plotting.\n        \"\"\"\n        return time.strftime(\"%H:%M:%S\")\n\n    @staticmethod\n    def format_freq(freq):\n        \"\"\"\n        Override to configure default plotting.\n        \"\"\"\n        return \"{freq:0.1f}\".format(freq=freq)\n\n    def peek(self, *args, **kwargs):\n        \"\"\"\n        Plot spectrum onto current axes.\n\n        Parameters\n        ----------\n        *args : dict\n\n        **kwargs : dict\n            Any additional plot arguments that should be used\n            when plotting.\n\n        Returns\n        -------\n        fig : `~matplotlib.Figure`\n            A plot figure.\n        \"\"\"\n        figure()\n        ret = self.plot(*args, **kwargs)\n        plt.show()\n        return ret\n\n    def plot(\n        self,\n        figure=None,\n        overlays=[],\n        colorbar=True,\n        vmin=None,\n        vmax=None,\n        linear=True,\n        showz=True,\n        yres=DEFAULT_YRES,\n        max_dist=None,\n        **matplotlib_args\n    ):\n        \"\"\"\n        Plot spectrogram onto figure.\n\n        Parameters\n        ----------\n        figure : `~matplotlib.Figure`\n            Figure to plot the spectrogram on. If None, new Figure is created.\n        overlays : list\n            List of overlays (functions that receive figure and axes and return\n            new ones) to be applied after drawing.\n        colorbar : bool\n            Flag that determines whether or not to draw a colorbar. If existing\n            figure is passed, it is attempted to overdraw old colorbar.\n        vmin : float\n            Clip intensities lower than vmin before drawing.\n        vmax : float\n            Clip intensities higher than vmax before drawing.\n        linear : bool\n            If set to True, \"stretch\" image to make frequency axis linear.\n        showz : bool\n            If set to True, the value of the pixel that is hovered with the\n            mouse is shown in the bottom right corner.\n        yres : int or None\n            To be used in combination with linear=True. If None, sample the\n            image with half the minimum frequency delta. Else, sample the\n            image to be at most yres pixels in vertical dimension. Defaults\n            to 1080 because that's a common screen size.\n        max_dist : float or None\n            If not None, mask elements that are further than max_dist away\n            from actual data points (ie, frequencies that actually have data\n            from the receiver and are not just nearest-neighbour interpolated).\n        \"\"\"\n        # [] as default argument is okay here because it is only read.\n        # pylint: disable=W0102,R0914\n        if linear:\n            delt = yres\n            if delt is not None:\n                delt = max((self.freq_axis[0] - self.freq_axis[-1]) / (yres - 1), _min_delt(self.freq_axis) / 2.0)\n                delt = float(delt)\n\n            data = _LinearView(self.clip_values(vmin, vmax), delt)\n            freqs = np.arange(self.freq_axis[0], self.freq_axis[-1], -data.delt)\n        else:\n            data = np.array(self.clip_values(vmin, vmax))\n            freqs = self.freq_axis\n\n        figure = plt.gcf()\n\n        if figure.axes:\n            axes = figure.axes[0]\n        else:\n            axes = figure.add_subplot(111)\n\n        params = {\n            \"origin\": \"lower\",\n            \"aspect\": \"auto\",\n        }\n        params.update(matplotlib_args)\n        if linear and max_dist is not None:\n            toplot = ma.masked_array(data, mask=data.make_mask(max_dist))\n        else:\n            toplot = data\n        im = axes.imshow(toplot, **params)\n\n        xa = axes.get_xaxis()\n        ya = axes.get_yaxis()\n\n        xa.set_major_formatter(FuncFormatter(self.time_formatter))\n\n        if linear:\n            # Start with a number that is divisible by 5.\n            init = (self.freq_axis[0] % 5) / data.delt\n            nticks = 15.0\n            # Calculate MHz difference between major ticks.\n            dist = (self.freq_axis[0] - self.freq_axis[-1]) / nticks\n            # Round to next multiple of 10, at least ten.\n            dist = max(round(dist, -1), 10)\n            # One pixel in image space is data.delt MHz, thus we can convert\n            # our distance between the major ticks into image space by dividing\n            # it by data.delt.\n\n            ya.set_major_locator(IndexLocator(dist / data.delt, init))\n            ya.set_minor_locator(IndexLocator(dist / data.delt / 10, init))\n\n            def freq_fmt(x, pos):\n                # This is necessary because matplotlib somehow tries to get\n                # the mid-point of the row, which we do not need here.\n                x = x + 0.5\n                return self.format_freq(self.freq_axis[0] - x * data.delt)\n\n        else:\n            freq_fmt = _list_formatter(freqs, self.format_freq)\n            ya.set_major_locator(MaxNLocator(integer=True, steps=[1, 5, 10]))\n\n        ya.set_major_formatter(FuncFormatter(freq_fmt))\n\n        axes.set_xlabel(self.t_label)\n        axes.set_ylabel(self.f_label)\n        # figure.suptitle(self.content)\n\n        figure.suptitle(\n            \" \".join(\n                [\n                    get_day(self.start).strftime(\"%d %b %Y\"),\n                    \"Radio flux density\",\n                    \"(\" + \", \".join(self.instruments) + \")\",\n                ]\n            )\n        )\n\n        for tl in xa.get_ticklabels():\n            tl.set_fontsize(10)\n            tl.set_rotation(30)\n        figure.add_axes(axes)\n        figure.subplots_adjust(bottom=0.2)\n        figure.subplots_adjust(left=0.2)\n\n        if showz:\n            axes.format_coord = self._mk_format_coord(data, figure.gca().format_coord)\n\n        if colorbar:\n            if len(figure.axes) > 1:\n                Colorbar(figure.axes[1], im).set_label(\"Intensity\")\n            else:\n                figure.colorbar(im).set_label(\"Intensity\")\n\n        for overlay in overlays:\n            figure, axes = overlay(figure, axes)\n\n        for ax in figure.axes:\n            ax.autoscale()\n        if isinstance(figure, SpectroFigure):\n            figure._init(self, freqs)\n        return axes\n\n    def __getitem__(self, key):\n        only_y = not isinstance(key, tuple)\n\n        if only_y:\n            return self.data[int(key)]\n        elif isinstance(key[0], slice) and isinstance(key[1], slice):\n            return self._slice(key[0], key[1])\n        elif isinstance(key[1], slice):\n            # return Spectrum( # XXX: Right class\n            #     super(Spectrogram, self).__getitem__(key),\n            #     self.time_axis[key[1].start:key[1].stop:key[1].step]\n            # )\n            return np.array(self.data[key])\n        elif isinstance(key[0], slice):\n            return Spectrum(self.data[key], self.freq_axis[key[0].start : key[0].stop : key[0].step])\n\n        return self.data[int(key)]\n\n    def clip_freq(self, vmin=None, vmax=None):\n        \"\"\"\n        Return a new spectrogram only consisting of frequencies in the\n        interval.\n\n        [vmin, vmax].\n\n        Parameters\n        ----------\n        vmin : float\n            All frequencies in the result are greater or equal to this.\n        vmax : float\n            All frequencies in the result are smaller or equal to this.\n        \"\"\"\n        left = 0\n        if vmax is not None:\n            while self.freq_axis[left] > vmax:\n                left += 1\n\n        right = len(self.freq_axis) - 1\n\n        if vmin is not None:\n            while self.freq_axis[right] < vmin:\n                right -= 1\n\n        return self[left : right + 1, :]\n\n    def auto_find_background(self, amount=0.05):\n        \"\"\"\n        Automatically find the background. This is done by first subtracting\n        the average value in each channel and then finding those times which\n        have the lowest standard deviation.\n\n        Parameters\n        ----------\n        amount : float\n            The percent amount (out of 1) of lowest standard deviation to\n            consider.\n        \"\"\"\n        # pylint: disable=E1101,E1103\n        data = self.data.astype(to_signed(self.dtype))\n        # Subtract average value from every frequency channel.\n        tmp = data - np.average(self.data, 1).reshape(self.shape[0], 1)\n        # Get standard deviation at every point of time.\n        # Need to convert because otherwise this class's __getitem__\n        # is used which assumes two-dimensionality.\n        sdevs = np.asarray(np.std(tmp, 0))\n\n        # Get indices of values with lowest standard deviation.\n        cand = sorted(list(range(self.shape[1])), key=lambda y: sdevs[y])\n        # Only consider the best 5 %.\n        return cand[: max(1, int(amount * len(cand)))]\n\n    def auto_const_bg(self):\n        \"\"\"\n        Automatically determine background.\n        \"\"\"\n        realcand = self.auto_find_background()\n        bg = np.average(self.data[:, realcand], 1)\n        return bg.reshape(self.shape[0], 1)\n\n    def subtract_bg(self):\n        \"\"\"\n        Perform constant background subtraction.\n        \"\"\"\n        return self._with_data(self.data - self.auto_const_bg())\n\n    def randomized_auto_const_bg(self, amount):\n        \"\"\"\n        Automatically determine background. Only consider a randomly chosen\n        subset of the image.\n\n        Parameters\n        ----------\n        amount : int\n            Size of random sample that is considered for calculation of\n            the background.\n        \"\"\"\n        cols = [randint(0, self.shape[1] - 1) for _ in range(amount)]\n\n        # pylint: disable=E1101,E1103\n        data = self.data.astype(to_signed(self.dtype))\n        # Subtract average value from every frequency channel.\n        tmp = data - np.average(self.data, 1).reshape(self.shape[0], 1)\n        # Get standard deviation at every point of time.\n        # Need to convert because otherwise this class's __getitem__\n        # is used which assumes two-dimensionality.\n        tmp = tmp[:, cols]\n        sdevs = np.asarray(np.std(tmp, 0))\n\n        # Get indices of values with lowest standard deviation.\n        cand = sorted(list(range(amount)), key=lambda y: sdevs[y])\n        # Only consider the best 5 %.\n        realcand = cand[: max(1, int(0.05 * len(cand)))]\n\n        # Average the best 5 %\n        bg = np.average(self[:, [cols[r] for r in realcand]], 1)\n\n        return bg.reshape(self.shape[0], 1)\n\n    def randomized_subtract_bg(self, amount):\n        \"\"\"\n        Perform randomized constant background subtraction. Does not produce\n        the same result every time it is run.\n\n        Parameters\n        ----------\n        amount : int\n            Size of random sample that is considered for calculation of\n            the background.\n        \"\"\"\n        return self._with_data(self.data - self.randomized_auto_const_bg(amount))\n\n    def clip_values(self, vmin=None, vmax=None, out=None):\n        \"\"\"\n        Clip intensities to be in the interval [vmin, vmax].\n\n        Any values greater than the maximum will be assigned the maximum,\n        any values lower than the minimum will be assigned the minimum.\n        If either is left out or None, do not clip at that side of the interval.\n\n        Parameters\n        ----------\n        min : int or float\n            New minimum value for intensities.\n        max : int or float\n            New maximum value for intensities\n        \"\"\"\n        # pylint: disable=E1101\n        if vmin is None:\n            vmin = int(self.data.min())\n\n        if vmax is None:\n            vmax = int(self.data.max())\n\n        return self._with_data(self.data.clip(vmin, vmax, out))\n\n    def rescale(self, vmin=0, vmax=1, dtype=np.dtype(\"float32\")):\n        \"\"\"\n        Rescale intensities to [vmin, vmax]. Note that vmin \u2260 vmax and\n        spectrogram.min() \u2260 spectrogram.max().\n\n        Parameters\n        ----------\n        vmin : float or int\n            New minimum value in the resulting spectrogram.\n        vmax : float or int\n            New maximum value in the resulting spectrogram.\n        dtype : `numpy.dtype`\n            Data-type of the resulting spectrogram.\n        \"\"\"\n        if vmax == vmin:\n            raise ValueError(\"Maximum and minimum must be different.\")\n        if self.data.max() == self.data.min():\n            raise ValueError(\"Spectrogram needs to contain distinct values.\")\n        data = self.data.astype(dtype)  # pylint: disable=E1101\n        return self._with_data(\n            vmin\n            + (vmax - vmin)\n            * (data - self.data.min())\n            / (self.data.max() - self.data.min())  # pylint: disable=E1101  # pylint: disable=E1101\n        )\n\n    def interpolate(self, frequency):\n        \"\"\"\n        Linearly interpolate intensity at unknown frequency using linear\n        interpolation of its two neighbours.\n\n        Parameters\n        ----------\n        frequency : float or int\n            Unknown frequency for which to linearly interpolate the intensities.\n            freq_axis[0] >= frequency >= self_freq_axis[-1]\n        \"\"\"\n        lfreq, lvalue = None, None\n        for freq, value in zip(self.freq_axis, self.data[:, :]):\n            if freq < frequency:\n                break\n            lfreq, lvalue = freq, value\n        else:\n            raise ValueError(\"Frequency not in interpolation range\")\n        if lfreq is None:\n            raise ValueError(\"Frequency not in interpolation range\")\n        diff = frequency - freq  # pylint: disable=W0631\n        ldiff = lfreq - frequency\n        return (ldiff * value + diff * lvalue) / (diff + ldiff)  # pylint: disable=W0631\n\n    def linearize_freqs(self, delta_freq=None):\n        \"\"\"\n        Rebin frequencies so that the frequency axis is linear.\n\n        Parameters\n        ----------\n        delta_freq : float\n            Difference between consecutive values on the new frequency axis.\n            Defaults to half of smallest delta in current frequency axis.\n            Compare Nyquist-Shannon sampling theorem.\n        \"\"\"\n        if delta_freq is None:\n            # Nyquist\u2013Shannon sampling theorem\n            delta_freq = _min_delt(self.freq_axis) / 2.0\n        nsize = int((self.freq_axis.max() - self.freq_axis.min()) / delta_freq + 1)\n        new = np.zeros((int(nsize), self.shape[1]), dtype=self.data.dtype)\n\n        freqs = self.freq_axis - self.freq_axis.max()\n        freqs = freqs / delta_freq\n\n        midpoints = np.round((freqs[:-1] + freqs[1:]) / 2)\n        fillto = np.concatenate([midpoints - 1, np.round([freqs[-1]]) - 1])\n        fillfrom = np.concatenate([np.round([freqs[0]]), midpoints - 1])\n\n        fillto = np.abs(fillto)\n        fillfrom = np.abs(fillfrom)\n\n        for row, from_, to_ in zip(self, fillfrom, fillto):\n            new[int(from_) : int(to_)] = row\n\n        vrs = self._get_params()\n        vrs.update({\"freq_axis\": np.linspace(self.freq_axis.max(), self.freq_axis.min(), nsize)})\n\n        return self.__class__(new, **vrs)\n\n    def freq_overlap(self, other):\n        \"\"\"\n        Get frequency range present in both spectrograms. Returns (min, max)\n        tuple.\n\n        Parameters\n        ----------\n        other : Spectrogram\n            other spectrogram with which to look for frequency overlap\n        \"\"\"\n        lower = max(self.freq_axis[-1], other.freq_axis[-1])\n        upper = min(self.freq_axis[0], other.freq_axis[0])\n        if lower > upper:\n            raise ValueError(\"No overlap.\")\n        return lower, upper\n\n    def time_to_x(self, time):\n        \"\"\"\n        Return x-coordinate in spectrogram that corresponds to the passed\n        `~datetime.datetime` value.\n\n        Parameters\n        ----------\n        time : `~sunpy.time.parse_time` compatible str\n            `~datetime.datetime` to find the x coordinate for.\n        \"\"\"\n        diff = time - self.start\n        diff_s = SECONDS_PER_DAY * diff.days + diff.seconds\n        if self.time_axis[-1] < diff_s < 0:\n            raise ValueError(\"Out of bounds\")\n        for n, elem in enumerate(self.time_axis):\n            if diff_s < elem:\n                return n - 1\n        # The last element is the searched one.\n        return n\n\n    def at_freq(self, freq):\n        return self[np.nonzero(self.freq_axis == freq)[0], :]\n\n    @staticmethod\n    def _mk_format_coord(spec, fmt_coord):\n        def format_coord(x, y):\n            shape = list(map(int, spec.shape))\n\n            xint, yint = int(x), int(y)\n            if 0 <= xint < shape[1] and 0 <= yint < shape[0]:\n                pixel = spec[yint][xint]\n            else:\n                pixel = \"\"\n\n            return \"{!s} z={!s}\".format(fmt_coord(x, y), pixel)\n\n        return format_coord\n\n\nclass LinearTimeSpectrogram(Spectrogram):\n    \"\"\"\n    Spectrogram evenly sampled in time.\n\n    Attributes\n    ----------\n    t_delt : float\n        difference between the items on the time axis\n    \"\"\"\n\n    # pylint: disable=E1002\n    COPY_PROPERTIES = Spectrogram.COPY_PROPERTIES + [\n        (\"t_delt\", REFERENCE),\n    ]\n\n    def __init__(\n        self,\n        data,\n        time_axis,\n        freq_axis,\n        start,\n        end,\n        t_init=None,\n        t_delt=None,\n        t_label=\"Time\",\n        f_label=\"Frequency\",\n        content=\"\",\n        instruments=None,\n    ):\n        if t_delt is None:\n            t_delt = _min_delt(freq_axis)\n\n        super(LinearTimeSpectrogram, self).__init__(\n            data, time_axis, freq_axis, start, end, t_init, t_label, f_label, content, instruments\n        )\n        self.t_delt = t_delt\n\n    @staticmethod", "contexts_below": "    @staticmethod\n     def memmap(filename):\n         \"\"\"\n         Return function that takes shape and dtype and returns a memory mapped\n         array.\n \n         Parameters\n         ----------\n         filename : str\n             File to store the memory mapped array in.\n         \"\"\"\n         return lambda shape, dtype=np.dtype(\"float32\"): np.memmap(filename, mode=\"write\", shape=shape, dtype=dtype)\n \n     def resample_time(self, new_delt):\n         \"\"\"\n         Rescale image so that the difference in time between pixels is new_delt\n         seconds.\n \n         Parameters\n         ----------\n         new_delt : float\n             New delta between consecutive values.\n         \"\"\"\n         if self.t_delt == new_delt:\n             return self\n         factor = self.t_delt / float(new_delt)\n \n         # The last data-point does not change!\n         new_size = floor((self.shape[1] - 1) * factor + 1)  # pylint: disable=E1101\n         data = ndimage.zoom(self.data, (1, new_size / self.shape[1]))  # pylint: disable=E1101\n \n         params = self._get_params()\n         params.update(\n             {\n                 \"time_axis\": np.linspace(\n                     self.time_axis[0], self.time_axis[int((new_size - 1) * new_delt / self.t_delt)], new_size\n                 ),\n                 \"t_delt\": new_delt,\n             }\n         )\n         return self.__class__(data, **params)\n \n     JOIN_REPEAT = object()\n \n     @classmethod\n     def join_many(cls, specs, mk_arr=None, nonlinear=False, maxgap=0, fill=JOIN_REPEAT):\n         \"\"\"\n         Produce new Spectrogram that contains spectrograms joined together in\n         time.\n \n         Parameters\n         ----------\n         specs : list\n             List of spectrograms to join together in time.\n         nonlinear : bool\n             If True, leave out gaps between spectrograms. Else, fill them with\n             the value specified in fill.\n         maxgap : float, int or None\n             Largest gap to allow in second. If None, allow gap of arbitrary\n             size.\n         fill : float or int\n             Value to fill missing values (assuming nonlinear=False) with.\n             Can be LinearTimeSpectrogram.JOIN_REPEAT to repeat the values for\n             the time just before the gap.\n         mk_array: function\n             Function that is called to create the resulting array. Can be set\n             to LinearTimeSpectrogram.memap(filename) to create a memory mapped\n             result array.\n         \"\"\"\n         # XXX: Only load header and load contents of files\n         # on demand.\n         mask = None\n \n         if mk_arr is None:\n             mk_arr = cls.make_array\n \n         specs = sorted(specs, key=lambda x: x.start)\n \n         freqs = specs[0].freq_axis\n         if not all(np.array_equal(freqs, sp.freq_axis) for sp in specs):\n             raise ValueError(\"Frequency channels do not match.\")\n \n         # Smallest time-delta becomes the common time-delta.\n         min_delt = min(sp.t_delt for sp in specs)\n         dtype_ = max(sp.dtype for sp in specs)\n \n         specs = [sp.resample_time(min_delt) for sp in specs]\n         size = sum(sp.shape[1] for sp in specs)\n \n         data = specs[0]\n         start_day = data.start\n \n         xs = []\n         last = data\n         for elem in specs[1:]:\n             e_init = SECONDS_PER_DAY * (get_day(elem.start) - get_day(start_day)).days + elem.t_init\n             x = int((e_init - last.t_init) / min_delt)\n             xs.append(x)\n             diff = last.shape[1] - x\n \n             if maxgap is not None and -diff > maxgap / min_delt:\n                 raise ValueError(\"Too large gap.\")\n \n             # If we leave out undefined values, we do not want to\n             # add values here if x > t_res.\n             if nonlinear:\n                 size -= max(0, diff)\n             else:\n                 size -= diff\n \n             last = elem\n \n         # The non existing element after the last one starts after\n         # the last one. Needed to keep implementation below sane.\n         xs.append(specs[-1].shape[1])\n \n         # We do that here so the user can pass a memory mapped\n         # array if they'd like to.\n         arr = mk_arr((data.shape[0], size), dtype_)\n         time_axis = np.zeros((size,))\n         sx = 0\n         # Amount of pixels left out due to non-linearity. Needs to be\n         # considered for correct time axes.\n         sd = 0\n         for x, elem in zip(xs, specs):\n             diff = x - elem.shape[1]\n             e_time_axis = elem.time_axis\n \n             elem = elem.data\n \n             if x > elem.shape[1]:\n                 if nonlinear:\n                     x = elem.shape[1]\n                 else:\n                     # If we want to stay linear, fill up the missing\n                     # pixels with placeholder zeros.\n                     filler = np.zeros((data.shape[0], diff))\n                     if fill is cls.JOIN_REPEAT:\n                         filler[:, :] = elem[:, -1, np.newaxis]\n                     else:\n                         filler[:] = fill\n                     minimum = e_time_axis[-1]\n                     e_time_axis = np.concatenate(\n                         [e_time_axis, np.linspace(minimum + min_delt, minimum + diff * min_delt, diff)]\n                     )\n                     elem = np.concatenate([elem, filler], 1)\n             arr[:, sx : sx + x] = elem[:, :x]\n \n             if diff > 0:\n                 if mask is None:\n                     mask = np.zeros((data.shape[0], size), dtype=np.uint8)\n                 mask[:, sx + x - diff : sx + x] = 1\n             time_axis[sx : sx + x] = e_time_axis[:x] + data.t_delt * (sx + sd)\n             if nonlinear:\n                 sd += max(0, diff)\n             sx += x\n         params = {\n             \"time_axis\": time_axis,\n             \"freq_axis\": data.freq_axis,\n             \"start\": data.start,\n             \"end\": specs[-1].end,\n             \"t_delt\": data.t_delt,\n             \"t_init\": data.t_init,\n             \"t_label\": data.t_label,\n             \"f_label\": data.f_label,\n             \"content\": data.content,\n             \"instruments\": _union(spec.instruments for spec in specs),\n         }\n         if mask is not None:\n             arr = ma.array(arr, mask=mask)\n         if nonlinear:\n             del params[\"t_delt\"]\n             return Spectrogram(arr, **params)\n         return common_base(specs)(arr, **params)\n \n     def time_to_x(self, time):\n         \"\"\"\n         Return x-coordinate in spectrogram that corresponds to the passed\n         datetime value.\n \n         Parameters\n         ----------\n         time : `~sunpy.time.parse_time` compatible str\n             `datetime.datetime` to find the x coordinate for.\n         \"\"\"\n         # This is impossible for frequencies because that mapping\n         # is not injective.\n         if SUNPY_LT_1:\n             time = parse_time(time)\n         else:\n             time = parse_time(time).datetime\n         diff = time - self.start\n         diff_s = SECONDS_PER_DAY * diff.days + diff.seconds\n         result = diff_s // self.t_delt\n         if 0 <= result <= self.shape[1]:  # pylint: disable=E1101\n             return result\n         raise ValueError(\"Out of range.\")\n \n     @staticmethod\n     def intersect_time(specs):\n         \"\"\"\n         Return slice of spectrograms that is present in all of the ones passed.\n \n         Parameters\n         ----------\n         specs : list\n             List of spectrograms of which to find the time intersections.\n         \"\"\"\n         delt = min(sp.t_delt for sp in specs)\n         start = max(sp.t_init for sp in specs)\n \n         # XXX: Could do without resampling by using\n         # sp.t_init below, not sure if good idea.\n         specs = [sp.resample_time(delt) for sp in specs]\n         cut = [sp[:, int((start - sp.t_init) / delt) :] for sp in specs]\n \n         length = min(sp.shape[1] for sp in cut)\n         return [sp[:, :length] for sp in cut]\n \n     @classmethod\n     def combine_frequencies(cls, specs):\n         \"\"\"\n         Return new spectrogram that contains frequencies from all the\n         spectrograms in spec. Only returns time intersection of all of them.\n \n         Parameters\n         ----------\n         spec : list\n             List of spectrograms of which to combine the frequencies into one.\n         \"\"\"\n         if not specs:\n             raise ValueError(\"Need at least one spectrogram.\")\n \n         specs = cls.intersect_time(specs)\n \n         one = specs[0]\n \n         dtype_ = max(sp.dtype for sp in specs)\n         fsize = sum(sp.shape[0] for sp in specs)\n \n         new = np.zeros((fsize, one.shape[1]), dtype=dtype_)\n \n         freq_axis = np.zeros((fsize,))\n \n         for n, (data, row) in enumerate(\n             merge([[(sp, n) for n in range(sp.shape[0])] for sp in specs], key=lambda x: x[0].freq_axis[x[1]])\n         ):\n             new[n, :] = data[row, :]\n             freq_axis[n] = data.freq_axis[row]\n         params = {\n             \"time_axis\": one.time_axis,  # Should be equal\n             \"freq_axis\": freq_axis,\n             \"start\": one.start,\n             \"end\": one.end,\n             \"t_delt\": one.t_delt,\n             \"t_init\": one.t_init,\n             \"t_label\": one.t_label,\n             \"f_label\": one.f_label,\n             \"content\": one.content,\n             \"instruments\": _union(spec.instruments for spec in specs),\n         }\n         return common_base(specs)(new, **params)\n \n     def check_linearity(self, err=None, err_factor=None):\n         \"\"\"\n         Check linearity of time axis. If err is given, tolerate absolute\n         derivation from average delta up to err. If err_factor is given,\n \n         tolerate up to err_factor * average_delta. If both are given,\n         TypeError is raised. Default to err=0.\n \n         Parameters\n         ----------\n         err : float\n             Absolute difference each delta is allowed to diverge from the\n             average. Cannot be used in combination with err_factor.\n         err_factor : float\n             Relative difference each delta is allowed to diverge from the\n             average, i.e. err_factor * average. Cannot be used in combination\n             with err.\n         \"\"\"\n         deltas = self.time_axis[:-1] - self.time_axis[1:]\n         avg = np.average(deltas)\n         if err is None and err_factor is None:\n             err = 0\n         elif err is None:\n             err = abs(err_factor * avg)\n         elif err_factor is not None:\n             raise TypeError(\"Only supply err or err_factor, not both\")\n         return (abs(deltas - avg) <= err).all()\n \n     def in_interval(self, start=None, end=None):\n         \"\"\"\n         Return part of spectrogram that lies in [start, end).\n \n         Parameters\n         ----------\n         start : None or `~datetime.datetime` or `~sunpy.time.parse_time` compatible string or time string\n             Start time of the part of the spectrogram that is returned. If the\n             measurement only spans over one day, a colon separated string\n             representing the time can be passed.\n         end : None or `~datetime.datetime` or `~sunpy.time.parse_time` compatible string or time string\n             See start.\n         \"\"\"\n         if start is not None:\n             try:\n                 if SUNPY_LT_1:\n                     start = parse_time(start)\n                 else:\n                     start = parse_time(start).datetime\n             except ValueError:\n                 # XXX: We could do better than that.\n                 if get_day(self.start) != get_day(self.end):\n                     raise TypeError(\"Time ambiguous because data spans over more than one day\")\n                 start = datetime.datetime(\n                     self.start.year, self.start.month, self.start.day, *list(map(int, start.split(\":\")))\n                 )\n             start = self.time_to_x(start)\n         if end is not None:\n             try:\n                 if SUNPY_LT_1:\n                     end = parse_time(end)\n                 else:\n                     end = parse_time(end).datetime\n             except ValueError:\n                 if get_day(self.start) != get_day(self.end):\n                     raise TypeError(\"Time ambiguous because data spans over more than one day\")\n                 end = datetime.datetime(\n                     self.start.year, self.start.month, self.start.day, *list(map(int, end.split(\":\")))\n                 )\n             end = self.time_to_x(end)\n         if start:\n             start = int(start)\n         if end:\n             end = int(end)\n         return self[:, start:end]\n ", "input_code": "@staticmethod\ndef make_array(shape, dtype=np.dtype('float32')):\n\"\"\"\nFunction to create an array with shape and dtype.\n\nParameters\n----------\nshape : tuple\n    shape of the array to create\ndtype : `numpy.dtype`\n    data-type of the array to create\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def make_array(shape, dtype=np.dtype(\"float32\")):\n        \"\"\"\n        Function to create an array with shape and dtype.\n\n        Parameters\n        ----------\n        shape : tuple\n            shape of the array to create\n        dtype : `numpy.dtype`\n            data-type of the array to create\n        \"\"\"\n        return np.zeros(shape, dtype=dtype)", "signature": "@staticmethod\ndef make_array(shape, dtype=np.dtype('float32')):", "completion_path": "radiospectra/spectrogram.py"}
{"ce_id": "62ece4992e6aefcf4aabbd89", "namespace": "62ece4992e6aefcf4aabbd89", "namespace_real": "concert.tests.unit.devices.test_monochromator.gaussian", "real_proj_path": "ufo-kit---concert/", "type": "class", "class_name": "test_monochromator", "function_name": "gaussian", "contexts_above": "import random\nimport numpy as np\nfrom concert.tests import assert_almost_equal, TestCase, slow\nfrom concert.quantities import q\nfrom concert.devices.monochromators.dummy import\\\n    Monochromator as DummyMonochromator\nfrom concert.devices.monochromators import base\nfrom concert.devices.monochromators.base import Monochromator\nfrom concert.devices.monochromators.dummy import DoubleMonochromator\nfrom concert.devices.photodiodes.dummy import PhotoDiode as DummyPhotoDiode\n\n\nclass WavelengthMonochromator(Monochromator):\n\n    \"\"\"\n    A monochromator which implements wavelength getter and setter. The\n    conversion needs to be handled in the base class.\n    \"\"\"\n\n    def __init__(self):\n        super(WavelengthMonochromator, self).__init__()\n        self._wavelength = random.random() * 1e-10 * q.m\n\n    async def _get_wavelength_real(self):\n        return self._wavelength\n\n    async def _set_wavelength_real(self, wavelength):\n        self._wavelength = wavelength\n\n\nclass PhotoDiode(DummyPhotoDiode):\n    \"\"\"\n    Photo diode that returns an intensity distribution depending on the bragg_motor2 position.\n\n    \"\"\"\n    def __init__(self, bragg_motor2):\n        self.bragg_motor = bragg_motor2\n        self.function = None\n        super().__init__()\n\n    async def _get_intensity(self):\n        x = (await self.bragg_motor.get_position()).to(q.deg).magnitude\n        return self.function(x) * q.V\n\n\nclass TestDummyMonochromator(TestCase):\n\n    def setUp(self):\n        super(TestDummyMonochromator, self).setUp()\n        self.mono = DummyMonochromator()\n        self.wave_mono = WavelengthMonochromator()\n        self.energy = 25 * q.keV\n        self.wavelength = 0.1 * q.nm\n\n    def test_energy_mono_energy(self):\n        self.mono.energy = self.energy\n        assert_almost_equal(self.mono.energy, self.energy)\n        assert_almost_equal(self.mono.wavelength,\n                            base.energy_to_wavelength(self.mono.energy))\n\n    def test_energy_mono_wavelength(self):\n        self.mono.wavelength = self.wavelength\n        assert_almost_equal(self.mono.wavelength, self.wavelength)\n        assert_almost_equal(base.wavelength_to_energy(self.wavelength),\n                            self.mono.energy)\n\n    def test_wavelength_mono_energy(self):\n        self.wave_mono.energy = self.energy\n        assert_almost_equal(self.wave_mono.energy, self.energy)\n        assert_almost_equal(self.wave_mono.wavelength,\n                            base.energy_to_wavelength(self.wave_mono.energy))\n\n    def test_wavelength_mono_wavelength(self):\n        # Wavelength-based monochromator.\n        self.wave_mono.wavelength = self.wavelength\n        assert_almost_equal(self.wave_mono.wavelength, self.wavelength)\n        assert_almost_equal(base.wavelength_to_energy(self.wavelength),\n                            self.wave_mono.energy)\n\n\n@slow\nclass TestDummyDoubleMonochromator(TestCase):\n    def setUp(self):\n        super(TestDummyDoubleMonochromator, self).setUp()\n        self.mono = DoubleMonochromator()\n        self.diode = PhotoDiode(self.mono._motor_2)\n", "contexts_below": "    def double_gaussian(self, x):\n         \"\"\"\n         Double two gaussian functions centered around zero with a sigma of 0.2 each.\n         \"\"\"\n         mu_1 = -0.2\n         mu_2 = 0.2\n         sigma = 0.2\n         return np.exp(-(x - mu_1) ** 2 / sigma ** 2) + np.exp(-(x - mu_2) ** 2 / sigma ** 2)\n \n     async def test_center(self):\n         \"\"\"\n         This test configures the diode to return a gaussian profile with the center at 0.2 deg.\n         Then it is checked if the monochromator._motor2 is moved to 0.2 deg after the scan and the\n         select_maximum() function.\n         \"\"\"\n         self.diode.function = self.gaussian\n         await self.mono.scan_bragg_angle(diode=self.diode, tune_range=1*q.deg, n_points=100)\n         await self.mono.select_maximum()\n         self.assertAlmostEqual(await self.mono._motor_2.get_position(), 0.2*q.deg, 2)\n \n     async def test_center_of_mass(self):\n         \"\"\"\n         This test configures the diode to return a hat profile with the center at 0.0 deg.\n         Then it is checked if the monochromator._motor2 is moved to 0.0 deg after the scan and the\n         select_center_of_mass() function.\n         \"\"\"\n         self.diode.function = self.double_gaussian\n         await self.mono.scan_bragg_angle(diode=self.diode, tune_range=1*q.deg, n_points=100)\n         await self.mono.select_center_of_mass()\n         self.assertAlmostEqual(await self.mono._motor_2.get_position(), 0.0*q.deg, 2)\n ", "input_code": "def gaussian(self, x):\n\"\"\"\nGaussian centered around 0.2 with a sigma of 0.1.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def gaussian(self, x):\n        \"\"\"\n        Gaussian centered around 0.2 with a sigma of 0.1.\n        \"\"\"\n        mu = 0.2\n        sigma = 0.1\n        return np.exp(-(x-mu)**2/sigma**2)", "signature": "def gaussian(self, x):", "completion_path": "concert/tests/unit/devices/test_monochromator.py"}
{"ce_id": "62ece4992e6aefcf4aabbd8a", "namespace": "62ece4992e6aefcf4aabbd8a", "namespace_real": "borgmatic.commands.borgmatic.load_configurations", "real_proj_path": "witten---borgmatic/", "type": "function", "class_name": null, "function_name": "load_configurations", "contexts_above": "import collections\nimport copy\nimport json\nimport logging\nimport os\nimport sys\nimport time\nfrom queue import Queue\nfrom subprocess import CalledProcessError\n\nimport colorama\nimport pkg_resources\n\nimport borgmatic.commands.completion\nfrom borgmatic.borg import borg as borg_borg\nfrom borgmatic.borg import check as borg_check\nfrom borgmatic.borg import compact as borg_compact\nfrom borgmatic.borg import create as borg_create\nfrom borgmatic.borg import environment as borg_environment\nfrom borgmatic.borg import export_tar as borg_export_tar\nfrom borgmatic.borg import extract as borg_extract\nfrom borgmatic.borg import feature as borg_feature\nfrom borgmatic.borg import info as borg_info\nfrom borgmatic.borg import init as borg_init\nfrom borgmatic.borg import list as borg_list\nfrom borgmatic.borg import mount as borg_mount\nfrom borgmatic.borg import prune as borg_prune\nfrom borgmatic.borg import umount as borg_umount\nfrom borgmatic.borg import version as borg_version\nfrom borgmatic.commands.arguments import parse_arguments\nfrom borgmatic.config import checks, collect, convert, validate\nfrom borgmatic.hooks import command, dispatch, dump, monitor\nfrom borgmatic.logger import configure_logging, should_do_markup\nfrom borgmatic.signals import configure_signals\nfrom borgmatic.verbosity import verbosity_to_log_level\n\nlogger = logging.getLogger(__name__)\n\nLEGACY_CONFIG_PATH = '/etc/borgmatic/config'\n\n\ndef run_configuration(config_filename, config, arguments):\n    '''\n    Given a config filename, the corresponding parsed config dict, and command-line arguments as a\n    dict from subparser name to a namespace of parsed arguments, execute the defined prune, compact,\n    create, check, and/or other actions.\n\n    Yield a combination of:\n\n      * JSON output strings from successfully executing any actions that produce JSON\n      * logging.LogRecord instances containing errors from any actions or backup hooks that fail\n    '''\n    (location, storage, retention, consistency, hooks) = (\n        config.get(section_name, {})\n        for section_name in ('location', 'storage', 'retention', 'consistency', 'hooks')\n    )\n    global_arguments = arguments['global']\n\n    local_path = location.get('local_path', 'borg')\n    remote_path = location.get('remote_path')\n    retries = storage.get('retries', 0)\n    retry_wait = storage.get('retry_wait', 0)\n    borg_environment.initialize(storage)\n    encountered_error = None\n    error_repository = ''\n    using_primary_action = {'prune', 'compact', 'create', 'check'}.intersection(arguments)\n    monitoring_log_level = verbosity_to_log_level(global_arguments.monitoring_verbosity)\n\n    try:\n        local_borg_version = borg_version.local_borg_version(local_path)\n    except (OSError, CalledProcessError, ValueError) as error:\n        yield from log_error_records(\n            '{}: Error getting local Borg version'.format(config_filename), error\n        )\n        return\n\n    try:\n        if using_primary_action:\n            dispatch.call_hooks(\n                'initialize_monitor',\n                hooks,\n                config_filename,\n                monitor.MONITOR_HOOK_NAMES,\n                monitoring_log_level,\n                global_arguments.dry_run,\n            )\n        if using_primary_action:\n            dispatch.call_hooks(\n                'ping_monitor',\n                hooks,\n                config_filename,\n                monitor.MONITOR_HOOK_NAMES,\n                monitor.State.START,\n                monitoring_log_level,\n                global_arguments.dry_run,\n            )\n    except (OSError, CalledProcessError) as error:\n        if command.considered_soft_failure(config_filename, error):\n            return\n\n        encountered_error = error\n        yield from log_error_records('{}: Error pinging monitor'.format(config_filename), error)\n\n    if not encountered_error:\n        repo_queue = Queue()\n        for repo in location['repositories']:\n            repo_queue.put((repo, 0),)\n\n        while not repo_queue.empty():\n            repository_path, retry_num = repo_queue.get()\n            timeout = retry_num * retry_wait\n            if timeout:\n                logger.warning(f'{config_filename}: Sleeping {timeout}s before next retry')\n                time.sleep(timeout)\n            try:\n                yield from run_actions(\n                    arguments=arguments,\n                    config_filename=config_filename,\n                    location=location,\n                    storage=storage,\n                    retention=retention,\n                    consistency=consistency,\n                    hooks=hooks,\n                    local_path=local_path,\n                    remote_path=remote_path,\n                    local_borg_version=local_borg_version,\n                    repository_path=repository_path,\n                )\n            except (OSError, CalledProcessError, ValueError) as error:\n                if retry_num < retries:\n                    repo_queue.put((repository_path, retry_num + 1),)\n                    tuple(  # Consume the generator so as to trigger logging.\n                        log_error_records(\n                            '{}: Error running actions for repository'.format(repository_path),\n                            error,\n                            levelno=logging.WARNING,\n                            log_command_error_output=True,\n                        )\n                    )\n                    logger.warning(\n                        f'{config_filename}: Retrying... attempt {retry_num + 1}/{retries}'\n                    )\n                    continue\n\n                if command.considered_soft_failure(config_filename, error):\n                    return\n\n                yield from log_error_records(\n                    '{}: Error running actions for repository'.format(repository_path), error\n                )\n                encountered_error = error\n                error_repository = repository_path\n\n    if not encountered_error:\n        try:\n            if using_primary_action:\n                dispatch.call_hooks(\n                    'ping_monitor',\n                    hooks,\n                    config_filename,\n                    monitor.MONITOR_HOOK_NAMES,\n                    monitor.State.FINISH,\n                    monitoring_log_level,\n                    global_arguments.dry_run,\n                )\n                dispatch.call_hooks(\n                    'destroy_monitor',\n                    hooks,\n                    config_filename,\n                    monitor.MONITOR_HOOK_NAMES,\n                    monitoring_log_level,\n                    global_arguments.dry_run,\n                )\n        except (OSError, CalledProcessError) as error:\n            if command.considered_soft_failure(config_filename, error):\n                return\n\n            encountered_error = error\n            yield from log_error_records('{}: Error pinging monitor'.format(config_filename), error)\n\n    if encountered_error and using_primary_action:\n        try:\n            command.execute_hook(\n                hooks.get('on_error'),\n                hooks.get('umask'),\n                config_filename,\n                'on-error',\n                global_arguments.dry_run,\n                repository=error_repository,\n                error=encountered_error,\n                output=getattr(encountered_error, 'output', ''),\n            )\n            dispatch.call_hooks(\n                'ping_monitor',\n                hooks,\n                config_filename,\n                monitor.MONITOR_HOOK_NAMES,\n                monitor.State.FAIL,\n                monitoring_log_level,\n                global_arguments.dry_run,\n            )\n            dispatch.call_hooks(\n                'destroy_monitor',\n                hooks,\n                config_filename,\n                monitor.MONITOR_HOOK_NAMES,\n                monitoring_log_level,\n                global_arguments.dry_run,\n            )\n        except (OSError, CalledProcessError) as error:\n            if command.considered_soft_failure(config_filename, error):\n                return\n\n            yield from log_error_records(\n                '{}: Error running on-error hook'.format(config_filename), error\n            )\n\n\ndef run_actions(\n    *,\n    arguments,\n    config_filename,\n    location,\n    storage,\n    retention,\n    consistency,\n    hooks,\n    local_path,\n    remote_path,\n    local_borg_version,\n    repository_path,\n):\n    '''\n    Given parsed command-line arguments as an argparse.ArgumentParser instance, the configuration\n    filename, several different configuration dicts, local and remote paths to Borg, a local Borg\n    version string, and a repository name, run all actions from the command-line arguments on the\n    given repository.\n\n    Yield JSON output strings from executing any actions that produce JSON.\n\n    Raise OSError or subprocess.CalledProcessError if an error occurs running a command for an\n    action or a hook. Raise ValueError if the arguments or configuration passed to action are\n    invalid.\n    '''\n    repository = os.path.expanduser(repository_path)\n    global_arguments = arguments['global']\n    dry_run_label = ' (dry run; not making any changes)' if global_arguments.dry_run else ''\n    hook_context = {\n        'repository': repository_path,\n        # Deprecated: For backwards compatibility with borgmatic < 1.6.0.\n        'repositories': ','.join(location['repositories']),\n    }\n\n    if 'init' in arguments:\n        logger.info('{}: Initializing repository'.format(repository))\n        borg_init.initialize_repository(\n            repository,\n            storage,\n            arguments['init'].encryption_mode,\n            arguments['init'].append_only,\n            arguments['init'].storage_quota,\n            local_path=local_path,\n            remote_path=remote_path,\n        )\n    if 'prune' in arguments:\n        command.execute_hook(\n            hooks.get('before_prune'),\n            hooks.get('umask'),\n            config_filename,\n            'pre-prune',\n            global_arguments.dry_run,\n            **hook_context,\n        )\n        logger.info('{}: Pruning archives{}'.format(repository, dry_run_label))\n        borg_prune.prune_archives(\n            global_arguments.dry_run,\n            repository,\n            storage,\n            retention,\n            local_path=local_path,\n            remote_path=remote_path,\n            stats=arguments['prune'].stats,\n            files=arguments['prune'].files,\n        )\n        command.execute_hook(\n            hooks.get('after_prune'),\n            hooks.get('umask'),\n            config_filename,\n            'post-prune',\n            global_arguments.dry_run,\n            **hook_context,\n        )\n    if 'compact' in arguments:\n        command.execute_hook(\n            hooks.get('before_compact'),\n            hooks.get('umask'),\n            config_filename,\n            'pre-compact',\n            global_arguments.dry_run,\n        )\n        if borg_feature.available(borg_feature.Feature.COMPACT, local_borg_version):\n            logger.info('{}: Compacting segments{}'.format(repository, dry_run_label))\n            borg_compact.compact_segments(\n                global_arguments.dry_run,\n                repository,\n                storage,\n                local_path=local_path,\n                remote_path=remote_path,\n                progress=arguments['compact'].progress,\n                cleanup_commits=arguments['compact'].cleanup_commits,\n                threshold=arguments['compact'].threshold,\n            )\n        else:  # pragma: nocover\n            logger.info(\n                '{}: Skipping compact (only available/needed in Borg 1.2+)'.format(repository)\n            )\n        command.execute_hook(\n            hooks.get('after_compact'),\n            hooks.get('umask'),\n            config_filename,\n            'post-compact',\n            global_arguments.dry_run,\n        )\n    if 'create' in arguments:\n        command.execute_hook(\n            hooks.get('before_backup'),\n            hooks.get('umask'),\n            config_filename,\n            'pre-backup',\n            global_arguments.dry_run,\n            **hook_context,\n        )\n        logger.info('{}: Creating archive{}'.format(repository, dry_run_label))\n        dispatch.call_hooks(\n            'remove_database_dumps',\n            hooks,\n            repository,\n            dump.DATABASE_HOOK_NAMES,\n            location,\n            global_arguments.dry_run,\n        )\n        active_dumps = dispatch.call_hooks(\n            'dump_databases',\n            hooks,\n            repository,\n            dump.DATABASE_HOOK_NAMES,\n            location,\n            global_arguments.dry_run,\n        )\n        stream_processes = [process for processes in active_dumps.values() for process in processes]\n\n        json_output = borg_create.create_archive(\n            global_arguments.dry_run,\n            repository,\n            location,\n            storage,\n            local_borg_version,\n            local_path=local_path,\n            remote_path=remote_path,\n            progress=arguments['create'].progress,\n            stats=arguments['create'].stats,\n            json=arguments['create'].json,\n            files=arguments['create'].files,\n            stream_processes=stream_processes,\n        )\n        if json_output:  # pragma: nocover\n            yield json.loads(json_output)\n\n        dispatch.call_hooks(\n            'remove_database_dumps',\n            hooks,\n            config_filename,\n            dump.DATABASE_HOOK_NAMES,\n            location,\n            global_arguments.dry_run,\n        )\n        command.execute_hook(\n            hooks.get('after_backup'),\n            hooks.get('umask'),\n            config_filename,\n            'post-backup',\n            global_arguments.dry_run,\n            **hook_context,\n        )\n\n    if 'check' in arguments and checks.repository_enabled_for_checks(repository, consistency):\n        command.execute_hook(\n            hooks.get('before_check'),\n            hooks.get('umask'),\n            config_filename,\n            'pre-check',\n            global_arguments.dry_run,\n            **hook_context,\n        )\n        logger.info('{}: Running consistency checks'.format(repository))\n        borg_check.check_archives(\n            repository,\n            location,\n            storage,\n            consistency,\n            local_path=local_path,\n            remote_path=remote_path,\n            progress=arguments['check'].progress,\n            repair=arguments['check'].repair,\n            only_checks=arguments['check'].only,\n            force=arguments['check'].force,\n        )\n        command.execute_hook(\n            hooks.get('after_check'),\n            hooks.get('umask'),\n            config_filename,\n            'post-check',\n            global_arguments.dry_run,\n            **hook_context,\n        )\n    if 'extract' in arguments:\n        command.execute_hook(\n            hooks.get('before_extract'),\n            hooks.get('umask'),\n            config_filename,\n            'pre-extract',\n            global_arguments.dry_run,\n            **hook_context,\n        )\n        if arguments['extract'].repository is None or validate.repositories_match(\n            repository, arguments['extract'].repository\n        ):\n            logger.info(\n                '{}: Extracting archive {}'.format(repository, arguments['extract'].archive)\n            )\n            borg_extract.extract_archive(\n                global_arguments.dry_run,\n                repository,\n                borg_list.resolve_archive_name(\n                    repository, arguments['extract'].archive, storage, local_path, remote_path\n                ),\n                arguments['extract'].paths,\n                location,\n                storage,\n                local_borg_version,\n                local_path=local_path,\n                remote_path=remote_path,\n                destination_path=arguments['extract'].destination,\n                strip_components=arguments['extract'].strip_components,\n                progress=arguments['extract'].progress,\n            )\n        command.execute_hook(\n            hooks.get('after_extract'),\n            hooks.get('umask'),\n            config_filename,\n            'post-extract',\n            global_arguments.dry_run,\n            **hook_context,\n        )\n    if 'export-tar' in arguments:\n        if arguments['export-tar'].repository is None or validate.repositories_match(\n            repository, arguments['export-tar'].repository\n        ):\n            logger.info(\n                '{}: Exporting archive {} as tar file'.format(\n                    repository, arguments['export-tar'].archive\n                )\n            )\n            borg_export_tar.export_tar_archive(\n                global_arguments.dry_run,\n                repository,\n                borg_list.resolve_archive_name(\n                    repository, arguments['export-tar'].archive, storage, local_path, remote_path\n                ),\n                arguments['export-tar'].paths,\n                arguments['export-tar'].destination,\n                storage,\n                local_path=local_path,\n                remote_path=remote_path,\n                tar_filter=arguments['export-tar'].tar_filter,\n                files=arguments['export-tar'].files,\n                strip_components=arguments['export-tar'].strip_components,\n            )\n    if 'mount' in arguments:\n        if arguments['mount'].repository is None or validate.repositories_match(\n            repository, arguments['mount'].repository\n        ):\n            if arguments['mount'].archive:\n                logger.info(\n                    '{}: Mounting archive {}'.format(repository, arguments['mount'].archive)\n                )\n            else:  # pragma: nocover\n                logger.info('{}: Mounting repository'.format(repository))\n\n            borg_mount.mount_archive(\n                repository,\n                borg_list.resolve_archive_name(\n                    repository, arguments['mount'].archive, storage, local_path, remote_path\n                ),\n                arguments['mount'].mount_point,\n                arguments['mount'].paths,\n                arguments['mount'].foreground,\n                arguments['mount'].options,\n                storage,\n                local_path=local_path,\n                remote_path=remote_path,\n            )\n    if 'restore' in arguments:  # pragma: nocover\n        if arguments['restore'].repository is None or validate.repositories_match(\n            repository, arguments['restore'].repository\n        ):\n            logger.info(\n                '{}: Restoring databases from archive {}'.format(\n                    repository, arguments['restore'].archive\n                )\n            )\n            dispatch.call_hooks(\n                'remove_database_dumps',\n                hooks,\n                repository,\n                dump.DATABASE_HOOK_NAMES,\n                location,\n                global_arguments.dry_run,\n            )\n\n            restore_names = arguments['restore'].databases or []\n            if 'all' in restore_names:\n                restore_names = []\n\n            archive_name = borg_list.resolve_archive_name(\n                repository, arguments['restore'].archive, storage, local_path, remote_path\n            )\n            found_names = set()\n\n            for hook_name, per_hook_restore_databases in hooks.items():\n                if hook_name not in dump.DATABASE_HOOK_NAMES:\n                    continue\n\n                for restore_database in per_hook_restore_databases:\n                    database_name = restore_database['name']\n                    if restore_names and database_name not in restore_names:\n                        continue\n\n                    found_names.add(database_name)\n                    dump_pattern = dispatch.call_hooks(\n                        'make_database_dump_pattern',\n                        hooks,\n                        repository,\n                        dump.DATABASE_HOOK_NAMES,\n                        location,\n                        database_name,\n                    )[hook_name]\n\n                    # Kick off a single database extract to stdout.\n                    extract_process = borg_extract.extract_archive(\n                        dry_run=global_arguments.dry_run,\n                        repository=repository,\n                        archive=archive_name,\n                        paths=dump.convert_glob_patterns_to_borg_patterns([dump_pattern]),\n                        location_config=location,\n                        storage_config=storage,\n                        local_borg_version=local_borg_version,\n                        local_path=local_path,\n                        remote_path=remote_path,\n                        destination_path='/',\n                        # A directory format dump isn't a single file, and therefore can't extract\n                        # to stdout. In this case, the extract_process return value is None.\n                        extract_to_stdout=bool(restore_database.get('format') != 'directory'),\n                    )\n\n                    # Run a single database restore, consuming the extract stdout (if any).\n                    dispatch.call_hooks(\n                        'restore_database_dump',\n                        {hook_name: [restore_database]},\n                        repository,\n                        dump.DATABASE_HOOK_NAMES,\n                        location,\n                        global_arguments.dry_run,\n                        extract_process,\n                    )\n\n            dispatch.call_hooks(\n                'remove_database_dumps',\n                hooks,\n                repository,\n                dump.DATABASE_HOOK_NAMES,\n                location,\n                global_arguments.dry_run,\n            )\n\n            if not restore_names and not found_names:\n                raise ValueError('No databases were found to restore')\n\n            missing_names = sorted(set(restore_names) - found_names)\n            if missing_names:\n                raise ValueError(\n                    'Cannot restore database(s) {} missing from borgmatic\\'s configuration'.format(\n                        ', '.join(missing_names)\n                    )\n                )\n\n    if 'list' in arguments:\n        if arguments['list'].repository is None or validate.repositories_match(\n            repository, arguments['list'].repository\n        ):\n            list_arguments = copy.copy(arguments['list'])\n            if not list_arguments.json:  # pragma: nocover\n                logger.warning('{}: Listing archives'.format(repository))\n            list_arguments.archive = borg_list.resolve_archive_name(\n                repository, list_arguments.archive, storage, local_path, remote_path\n            )\n            json_output = borg_list.list_archives(\n                repository,\n                storage,\n                list_arguments=list_arguments,\n                local_path=local_path,\n                remote_path=remote_path,\n            )\n            if json_output:  # pragma: nocover\n                yield json.loads(json_output)\n    if 'info' in arguments:\n        if arguments['info'].repository is None or validate.repositories_match(\n            repository, arguments['info'].repository\n        ):\n            info_arguments = copy.copy(arguments['info'])\n            if not info_arguments.json:  # pragma: nocover\n                logger.warning('{}: Displaying summary info for archives'.format(repository))\n            info_arguments.archive = borg_list.resolve_archive_name(\n                repository, info_arguments.archive, storage, local_path, remote_path\n            )\n            json_output = borg_info.display_archives_info(\n                repository,\n                storage,\n                info_arguments=info_arguments,\n                local_path=local_path,\n                remote_path=remote_path,\n            )\n            if json_output:  # pragma: nocover\n                yield json.loads(json_output)\n    if 'borg' in arguments:\n        if arguments['borg'].repository is None or validate.repositories_match(\n            repository, arguments['borg'].repository\n        ):\n            logger.warning('{}: Running arbitrary Borg command'.format(repository))\n            archive_name = borg_list.resolve_archive_name(\n                repository, arguments['borg'].archive, storage, local_path, remote_path\n            )\n            borg_borg.run_arbitrary_borg(\n                repository,\n                storage,\n                options=arguments['borg'].options,\n                archive=archive_name,\n                local_path=local_path,\n                remote_path=remote_path,\n            )\n\n", "contexts_below": "\n def log_record(suppress_log=False, **kwargs):\n     '''\n     Create a log record based on the given makeLogRecord() arguments, one of which must be\n     named \"levelno\". Log the record (unless suppress log is set) and return it.\n     '''\n     record = logging.makeLogRecord(kwargs)\n     if suppress_log:\n         return record\n \n     logger.handle(record)\n     return record\n \n \n def log_error_records(\n     message, error=None, levelno=logging.CRITICAL, log_command_error_output=False\n ):\n     '''\n     Given error message text, an optional exception object, an optional log level, and whether to\n     log the error output of a CalledProcessError (if any), log error summary information and also\n     yield it as a series of logging.LogRecord instances.\n \n     Note that because the logs are yielded as a generator, logs won't get logged unless you consume\n     the generator output.\n     '''\n     level_name = logging._levelToName[levelno]\n \n     if not error:\n         yield log_record(levelno=levelno, levelname=level_name, msg=message)\n         return\n \n     try:\n         raise error\n     except CalledProcessError as error:\n         yield log_record(levelno=levelno, levelname=level_name, msg=message)\n         if error.output:\n             # Suppress these logs for now and save full error output for the log summary at the end.\n             yield log_record(\n                 levelno=levelno,\n                 levelname=level_name,\n                 msg=error.output,\n                 suppress_log=not log_command_error_output,\n             )\n         yield log_record(levelno=levelno, levelname=level_name, msg=error)\n     except (ValueError, OSError) as error:\n         yield log_record(levelno=levelno, levelname=level_name, msg=message)\n         yield log_record(levelno=levelno, levelname=level_name, msg=error)\n     except:  # noqa: E722\n         # Raising above only as a means of determining the error type. Swallow the exception here\n         # because we don't want the exception to propagate out of this function.\n         pass\n \n \n def get_local_path(configs):\n     '''\n     Arbitrarily return the local path from the first configuration dict. Default to \"borg\" if not\n     set.\n     '''\n     return next(iter(configs.values())).get('location', {}).get('local_path', 'borg')\n \n \n def collect_configuration_run_summary_logs(configs, arguments):\n     '''\n     Given a dict of configuration filename to corresponding parsed configuration, and parsed\n     command-line arguments as a dict from subparser name to a parsed namespace of arguments, run\n     each configuration file and yield a series of logging.LogRecord instances containing summary\n     information about each run.\n \n     As a side effect of running through these configuration files, output their JSON results, if\n     any, to stdout.\n     '''\n     # Run cross-file validation checks.\n     if 'extract' in arguments:\n         repository = arguments['extract'].repository\n     elif 'list' in arguments and arguments['list'].archive:\n         repository = arguments['list'].repository\n     elif 'mount' in arguments:\n         repository = arguments['mount'].repository\n     else:\n         repository = None\n \n     if repository:\n         try:\n             validate.guard_configuration_contains_repository(repository, configs)\n         except ValueError as error:\n             yield from log_error_records(str(error))\n             return\n \n     if not configs:\n         yield from log_error_records(\n             '{}: No valid configuration files found'.format(\n                 ' '.join(arguments['global'].config_paths)\n             )\n         )\n         return\n \n     if 'create' in arguments:\n         try:\n             for config_filename, config in configs.items():\n                 hooks = config.get('hooks', {})\n                 command.execute_hook(\n                     hooks.get('before_everything'),\n                     hooks.get('umask'),\n                     config_filename,\n                     'pre-everything',\n                     arguments['global'].dry_run,\n                 )\n         except (CalledProcessError, ValueError, OSError) as error:\n             yield from log_error_records('Error running pre-everything hook', error)\n             return\n \n     # Execute the actions corresponding to each configuration file.\n     json_results = []\n     for config_filename, config in configs.items():\n         results = list(run_configuration(config_filename, config, arguments))\n         error_logs = tuple(result for result in results if isinstance(result, logging.LogRecord))\n \n         if error_logs:\n             yield from log_error_records(\n                 '{}: Error running configuration file'.format(config_filename)\n             )\n             yield from error_logs\n         else:\n             yield logging.makeLogRecord(\n                 dict(\n                     levelno=logging.INFO,\n                     levelname='INFO',\n                     msg='{}: Successfully ran configuration file'.format(config_filename),\n                 )\n             )\n             if results:\n                 json_results.extend(results)\n \n     if 'umount' in arguments:\n         logger.info('Unmounting mount point {}'.format(arguments['umount'].mount_point))\n         try:\n             borg_umount.unmount_archive(\n                 mount_point=arguments['umount'].mount_point, local_path=get_local_path(configs)\n             )\n         except (CalledProcessError, OSError) as error:\n             yield from log_error_records('Error unmounting mount point', error)\n \n     if json_results:\n         sys.stdout.write(json.dumps(json_results))\n \n     if 'create' in arguments:\n         try:\n             for config_filename, config in configs.items():\n                 hooks = config.get('hooks', {})\n                 command.execute_hook(\n                     hooks.get('after_everything'),\n                     hooks.get('umask'),\n                     config_filename,\n                     'post-everything',\n                     arguments['global'].dry_run,\n                 )\n         except (CalledProcessError, ValueError, OSError) as error:\n             yield from log_error_records('Error running post-everything hook', error)\n \n \n def exit_with_help_link():  # pragma: no cover\n     '''\n     Display a link to get help and exit with an error code.\n     '''\n     logger.critical('')\n     logger.critical('Need some help? https://torsion.org/borgmatic/#issues')\n     sys.exit(1)\n \n \n def main():  # pragma: no cover\n     configure_signals()\n \n     try:\n         arguments = parse_arguments(*sys.argv[1:])\n     except ValueError as error:\n         configure_logging(logging.CRITICAL)\n         logger.critical(error)\n         exit_with_help_link()\n     except SystemExit as error:\n         if error.code == 0:\n             raise error\n         configure_logging(logging.CRITICAL)\n         logger.critical('Error parsing arguments: {}'.format(' '.join(sys.argv)))\n         exit_with_help_link()\n \n     global_arguments = arguments['global']\n     if global_arguments.version:\n         print(pkg_resources.require('borgmatic')[0].version)\n         sys.exit(0)\n     if global_arguments.bash_completion:\n         print(borgmatic.commands.completion.bash_completion())\n         sys.exit(0)\n \n     config_filenames = tuple(collect.collect_config_filenames(global_arguments.config_paths))\n     configs, parse_logs = load_configurations(\n         config_filenames, global_arguments.overrides, global_arguments.resolve_env\n     )\n \n     any_json_flags = any(\n         getattr(sub_arguments, 'json', False) for sub_arguments in arguments.values()\n     )\n     colorama.init(\n         autoreset=True,\n         strip=not should_do_markup(global_arguments.no_color or any_json_flags, configs),\n     )\n     try:\n         configure_logging(\n             verbosity_to_log_level(global_arguments.verbosity),\n             verbosity_to_log_level(global_arguments.syslog_verbosity),\n             verbosity_to_log_level(global_arguments.log_file_verbosity),\n             verbosity_to_log_level(global_arguments.monitoring_verbosity),\n             global_arguments.log_file,\n         )\n     except (FileNotFoundError, PermissionError) as error:\n         configure_logging(logging.CRITICAL)\n         logger.critical('Error configuring logging: {}'.format(error))\n         exit_with_help_link()\n \n     logger.debug('Ensuring legacy configuration is upgraded')\n     convert.guard_configuration_upgraded(LEGACY_CONFIG_PATH, config_filenames)\n \n     summary_logs = parse_logs + list(collect_configuration_run_summary_logs(configs, arguments))\n     summary_logs_max_level = max(log.levelno for log in summary_logs)\n \n     for message in ('', 'summary:'):\n         log_record(\n             levelno=summary_logs_max_level,\n             levelname=logging.getLevelName(summary_logs_max_level),\n             msg=message,\n         )\n \n     for log in summary_logs:\n         logger.handle(log)\n \n     if summary_logs_max_level >= logging.CRITICAL:\n         exit_with_help_link()\n ", "input_code": "def load_configurations(config_filenames, overrides=None, resolve_env=True):\n\"\"\"\nGiven a sequence of configuration filenames, load and validate each configuration file. Return\nthe results as a tuple of: dict of configuration filename to corresponding parsed configuration,\nand sequence of logging.LogRecord instances containing any parse errors.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def load_configurations(config_filenames, overrides=None, resolve_env=True):\n    '''\n    Given a sequence of configuration filenames, load and validate each configuration file. Return\n    the results as a tuple of: dict of configuration filename to corresponding parsed configuration,\n    and sequence of logging.LogRecord instances containing any parse errors.\n    '''\n    # Dict mapping from config filename to corresponding parsed config dict.\n    configs = collections.OrderedDict()\n    logs = []\n\n    # Parse and load each configuration file.\n    for config_filename in config_filenames:\n        try:\n            configs[config_filename] = validate.parse_configuration(\n                config_filename, validate.schema_filename(), overrides, resolve_env\n            )\n        except PermissionError:\n            logs.extend(\n                [\n                    logging.makeLogRecord(\n                        dict(\n                            levelno=logging.WARNING,\n                            levelname='WARNING',\n                            msg='{}: Insufficient permissions to read configuration file'.format(\n                                config_filename\n                            ),\n                        )\n                    ),\n                ]\n            )\n        except (ValueError, OSError, validate.Validation_error) as error:\n            logs.extend(\n                [\n                    logging.makeLogRecord(\n                        dict(\n                            levelno=logging.CRITICAL,\n                            levelname='CRITICAL',\n                            msg='{}: Error parsing configuration file'.format(config_filename),\n                        )\n                    ),\n                    logging.makeLogRecord(\n                        dict(levelno=logging.CRITICAL, levelname='CRITICAL', msg=error)\n                    ),\n                ]\n            )\n\n    return (configs, logs)", "signature": "def load_configurations(config_filenames, overrides=None, resolve_env=True):", "completion_path": "borgmatic/commands/borgmatic.py"}
{"ce_id": "62ece4992e6aefcf4aabbd8b", "namespace": "62ece4992e6aefcf4aabbd8b", "namespace_real": "o2sclpy.utils.force_string", "real_proj_path": "awsteiner---o2sclpy/", "type": "function", "class_name": null, "function_name": "force_string", "contexts_above": "#  -------------------------------------------------------------------\n#  \n#  Copyright (C) 2006-2022, Andrew W. Steiner\n#  \n#  This file is part of O2sclpy.\n#  \n#  O2sclpy is free software; you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation; either version 3 of the License, or\n#  (at your option) any later version.\n#  \n#  O2sclpy is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#  \n#  You should have received a copy of the GNU General Public License\n#  along with O2sclpy. If not, see <http://www.gnu.org/licenses/>.\n#  \n#  -------------------------------------------------------------------\n#\nimport sys\n\n# For os.getenv()\nimport os\n\n# For numpy.bytes_\nimport numpy\n\n# To test between Linux/OSX using system()\nimport platform\n\n# For CDLL loading\nimport ctypes\nfrom ctypes.util import find_library\n\ndef remove_spaces(string):\n    while len(string)>0 and string[0]==' ':\n        string=string[1:]\n    return string\n\ndef doc_replacements(s,base_list_new,ter):\n\n    # Replace commands in base_list_new\n    for i in range(0,len(base_list_new)):\n        s=s.replace('``'+base_list_new[i][0]+'``',\n                    ter.cyan_fg()+ter.bold()+base_list_new[i][0]+\n                    ter.default_fg())\n\n    # For ``code`` formatting\n    s=s.replace(' ``',' ')\n    s=s.replace('`` ',' ')\n    s=s.replace('``, ',', ')\n    s=s.replace('``. ','. ')\n\n    # Combine two spaces to one\n    s=s.replace('  ',' ')\n\n    # For :math:`` equations\n    s=s.replace(' :math:`',' ')\n    s=s.replace('` ',' ')\n    s=s.replace('`.','.')\n    s=s.replace('`',',')\n                    \n    return s\n\ndef reformat_python_docs(cmd,doc_str,base_list_new):\n\n    reflist=doc_str.split('\\n')\n    \n    for i in range(0,len(reflist)):\n        reflist[i]=remove_spaces(reflist[i])\n        #print(i,'x',reflist[i],'x')\n\n    if len(reflist)<1:\n        return\n\n    if reflist[0]=='':\n        if len(reflist)<2:\n            return\n        doc_str2=reflist[1]\n        for i in range(2,len(reflist)):\n            doc_str2=doc_str2+'\\n'+reflist[i]\n    else:\n        doc_str2=reflist[0]\n        for i in range(0,len(reflist)):\n            doc_str2=doc_str2+'\\n'+reflist[i]\n\n    reflist2=doc_str2.split('\\n\\n')\n\n    if False:\n        for i in range(0,len(reflist2)):\n            print(i,'x',reflist2[i],'x')\n    \n    ter=terminal_py()\n    ncols=os.get_terminal_size().columns\n\n    short=''\n    parm_desc=''\n    long_help=''\n\n    # The short description\n    if len(reflist2)>=2:\n        short=reflist2[1]\n\n    # The parameter description\n    if len(reflist2)>=3:\n        parm_desc=reflist2[2].replace('\\n',' ')\n\n        parm_desc=parm_desc.replace('  ',' ')\n        sx='Command-line arguments: ``'\n        if parm_desc[0:len(sx)]==sx:\n            parm_desc=parm_desc[len(sx):]\n        if parm_desc[-2:]=='``':\n            parm_desc=parm_desc[0:-2]\n            \n    print('Usage: '+ter.cyan_fg()+ter.bold()+cmd+\n          ter.default_fg()+' '+parm_desc)\n    print('Short description:',short)\n\n    if len(reflist2)>=4:\n        print('')\n        print('Long description:')\n        for j in range(3,len(reflist2)):\n            if len(reflist2[j])>0:\n                long_help=doc_replacements(reflist2[j].replace('\\n',' '),\n                                           base_list_new,ter)\n                tmplist=wrap_line(long_help,ncols-1)\n                if j!=3:\n                    print('')\n                for k in range(0,len(tmplist)):\n                    print(tmplist[k])\n\ndef string_to_color(str_in):\n    \"\"\"\n    Convert a string to a color\n    \"\"\"\n\n    if str_in[0]=='(':\n        temps=str_in[1:len(str_in)-1]\n        temp2=temps.split(',')\n        return (float(temp2[0]),float(temp2[1]),float(temp2[2]))\n    elif str_in[0]=='[':\n        temps=str_in[1:len(str_in)-1]\n        temp2=temps.split(',')\n        return [float(temp2[0]),float(temp2[1]),float(temp2[2]),\n                float(temp2[3])]\n    \n    return str_in\n\ndef if_yt_then_Agg(backend,argv):\n    # Determine if yt commands are present\n            \n    yt_found=False\n    for i in range(1,len(argv)):\n        if argv[i][0:4]=='-yt-' and yt_found==False:\n            if backend!='' and backend!='agg' and backend!='Agg':\n                print('Backend was not set to Agg but yt commands were found.')\n            yt_found=True\n            backend='Agg'\n    return backend\n\ndef o2scl_get_type(o2scl,amp):\n    \"\"\"\n    Get the type of the current object stored in the acol_manager\n    pointer\n    \"\"\"\n    # pointer types\n    char_ptr=ctypes.POINTER(ctypes.c_char)\n    char_ptr_ptr=ctypes.POINTER(char_ptr)\n    int_ptr=ctypes.POINTER(ctypes.c_int)\n    \n    # Set up wrapper for type function\n    type_fn=o2scl.o2scl_acol_get_type\n    type_fn.argtypes=[ctypes.c_void_p,int_ptr,char_ptr_ptr]\n    \n    # Get current type\n    it=ctypes.c_int(0)\n    type_ptr=char_ptr()\n    type_fn(amp,ctypes.byref(it),ctypes.byref(type_ptr))\n\n    # Construct the type as a byte string\n    curr_type=b''\n    for i in range(0,it.value):\n        curr_type=curr_type+type_ptr[i]\n    return curr_type\n\ndef table3d_get_slice(o2scl,amp,name):\n    \"\"\"\n    Return a slice from the current table3d object stored\n    in the acol_manager object 'amp'\n    \"\"\"\n    get_fn=o2scl.o2scl_acol_get_slice\n    get_fn.argtypes=[ctypes.c_void_p,ctypes.c_char_p,\n                     int_ptr,double_ptr_ptr,\n                     int_ptr,double_ptr_ptr,double_ptr_ptr]\n    \n    slice=ctypes.c_char_p(force_bytes(slice_name))\n    nx=ctypes.c_int(0)\n    ptrx=double_ptr()\n    ny=ctypes.c_int(0)\n    ptry=double_ptr()\n    ptrs=double_ptr()\n    get_fn(amp,slice,ctypes.byref(nx),ctypes.byref(ptrx),\n           ctypes.byref(ny),ctypes.byref(ptry),\n           ctypes.byref(ptrs))\n    return (nx,ptrx,ny,ptry,ptrs)\n\ndef table_get_column(o2scl,amp,name,return_pointer=False):\n    \"\"\"\n    Return a column from the current table object stored\n    in the acol_manager object 'amp'\n    \"\"\"\n\n    # C types\n    int_ptr=ctypes.POINTER(ctypes.c_int)\n    double_ptr=ctypes.POINTER(ctypes.c_double)\n    double_ptr_ptr=ctypes.POINTER(double_ptr)\n\n    # Function interface\n    get_fn=o2scl.o2scl_acol_get_column\n    get_fn.argtypes=[ctypes.c_void_p,ctypes.c_char_p,\n                     int_ptr,double_ptr_ptr]\n    get_fn.restype=ctypes.c_int\n\n    # Arguments\n    col=ctypes.c_char_p(force_bytes(name))\n    size=ctypes.c_int(0)\n    pointer=double_ptr()\n\n    # Function call\n    get_ret=get_fn(amp,col,ctypes.byref(size),ctypes.byref(pointer))\n    if get_ret!=0:\n        print('Failed to get column named \"'+name+'\".')\n        return None\n\n    if return_pointer:\n        return pointer\n        \n    col=[pointer[i] for i in range(0,size.value)]\n    return col\n\ndef is_number(s):\n    \"\"\"\n    Return true if 's' is likely a number\n    \"\"\"\n    try:\n        float(s)\n        return True\n    except ValueError:\n        return False\n    \ndef force_bytes(obj):\n    \"\"\"\n    This function returns the bytes object corresponding to ``obj``\n    in case it is a string using UTF-8. \n    \"\"\"\n    if isinstance(obj,numpy.bytes_)==False and isinstance(obj,bytes)==False:\n        return bytes(obj,'utf-8')\n    return obj\n", "contexts_below": "# This function is probably best replaced by get_str_array() below\n #\n # def parse_col_names(dset):\n #     nc=dset['nc'].__getitem__(0)\n #     nw=dset['nw'].__getitem__(0)\n #     counter=dset['counter']\n #     data=dset['data']\n #     clist=[]\n #     k=0\n #     for i in range(0,nw):\n #         column=''\n #         for j in range(0,counter[i]):\n #             column=column+str(unichr(data[k]))\n #             k=k+1\n #         clist.append(column)\n #     return clist\n \n def default_plot(left_margin=0.14,bottom_margin=0.12,\n                  right_margin=0.04,top_margin=0.04,fontsize=16,\n                  fig_size_x=6.0,fig_size_y=6.0,ticks_in=False,\n                  rt_ticks=False,editor=False):\n     \n     import matplotlib.pyplot as plot\n \n     \"\"\"\n     This function sets up the O\\ :sub:`2`\\ sclpy ``matplotlib``\n     defaults. It returns a pair of objects, the figure object and axes\n     object. The fontsize argument times 0.8 is used \n     for the size of the font labels. Setting the ``ticks_in`` argument\n     to ``True`` makes the ticks point inwards instead of outwards\n     and setting ``rt_ticks`` to ``True`` puts ticks (but not labels)\n     on the right and top edges of the plot. \n     \n     This function is in ``utils.py``.\n     \"\"\"\n     plot.rc('text',usetex=True)\n     plot.rc('font',family='serif')\n     plot.rcParams['lines.linewidth']=0.5\n     \n     if editor:\n         \n         fig=plot.figure(1,figsize=(fig_size_x*2,fig_size_y))\n         fig.set_facecolor('white')\n         \n         ax_left_panel=plot.axes([0,0,0.5,1],facecolor=(1,1,1,0),\n                                 autoscale_on=False)\n         ax_left_panel.margins(x=0,y=0)\n         ax_left_panel.axis('off')\n         \n         ax_right_panel=plot.axes([0.5,0,0.5,1],facecolor=(0.9,0.9,0.9,1),\n                                  autoscale_on=False)\n         ax_right_panel.margins(x=0,y=0)\n         ax_right_panel.get_xaxis().set_visible(False)\n         ax_right_panel.get_yaxis().set_visible(False)\n         ax=plot.axes([left_margin/2.0,bottom_margin,\n                            (1.0-left_margin-right_margin)/2,\n                            1.0-top_margin-bottom_margin])\n     else:\n         \n         fig=plot.figure(1,figsize=(fig_size_x,fig_size_y))\n         fig.set_facecolor('white')\n         \n         ax=plot.axes([left_margin,bottom_margin,\n                       1.0-left_margin-right_margin,\n                       1.0-top_margin-bottom_margin])\n         \n     ax.minorticks_on()\n     # Make the ticks longer than default\n     ax.tick_params('both',length=12,width=1,which='major')\n     ax.tick_params('both',length=5,width=1,which='minor')\n     ax.tick_params(labelsize=fontsize*0.8)\n     plot.grid(False)\n \n     if editor:\n         return (fig,ax,ax_left_panel,ax_right_panel)\n     \n     return (fig,ax)\n     \n def get_str_array(dset):\n     \"\"\"\n     Extract a string array from O\\ :sub:`2`\\ scl HDF5 dataset ``dset``\n     as a python list\n \n     This function is in ``utils.py``.\n     \"\"\"\n     nw=dset['nw'][0]\n     nc=dset['nc'][0]\n     data=dset['data']\n     counter=dset['counter']\n     char_counter=1\n     word_counter=0\n     list=[]\n     col=''\n     for ix in range(0,nc):\n         # Skip empty strings in the array\n         done=0\n         while done==0:\n             if word_counter==nw:\n                 done=1\n             elif counter[word_counter]==0:\n                 word_counter=word_counter+1\n                 list.append('')\n             else:\n                 done=1\n         col=col+str(chr(data[ix]))\n         if char_counter==counter[word_counter]:\n             list.append(col)\n             col=''\n             word_counter=word_counter+1\n             char_counter=1\n         else:\n             char_counter=char_counter+1\n     # We're done with the characters, but there are some blank\n     # strings left. Add the appropriate blanks at the end.\n     while word_counter<nw:\n         list.append('')\n         word_counter=word_counter+1\n     return list\n \n def get_ic_ptrs_to_list(size,lengths,chars):\n     \"\"\"\n     \"\"\"\n     tlist=[]\n     count=0\n     for i in range(0,size.value):\n         strt=b''\n         for j in range(0,lengths[i]):\n             strt=strt+chars[count]\n             count+=1\n         tlist.append(strt)\n     return tlist\n \n def parse_arguments(argv,verbose=0):\n     \"\"\"\n     Old command-line parser (this is currently unused and\n     it's not clear if it will be useful in the future).\n \n     This function is in ``utils.py``.\n     \"\"\"\n     list=[]\n     unproc_list=[]\n     if verbose>1:\n         print('Number of arguments:', len(argv), 'arguments.')\n         print('Argument List:', str(argv))\n     ix=1\n     while ix<len(argv):\n         if verbose>1:\n             print('Processing index',ix,'with value',argv[ix],'.')\n         # Find first option, at index ix\n         initial_ix_done=0\n         while initial_ix_done==0:\n             if ix==len(argv):\n                 initial_ix_done=1\n             elif argv[ix][0]=='-':\n                 initial_ix_done=1\n             else:\n                 if verbose>1:\n                      print('Adding',argv[ix],' to unprocessed list.')\n                 unproc_list.append(argv[ix])\n                 ix=ix+1\n         # If there is an option, then ix is its index\n         if ix<len(argv):\n             list_one=[]\n             # Strip single and double dashes\n             cmd_name=argv[ix][1:]\n             if cmd_name[0]=='-':\n                 cmd_name=cmd_name[1:]\n             # Add command name to list\n             list_one.append(cmd_name)\n             if verbose>1:\n                 print('Found option',cmd_name,'at index',ix)\n             # Set ix_next to the next option, or to the end if\n             # there is no next option\n             ix_next=ix+1\n             ix_next_done=0\n             while ix_next_done==0:\n                 if ix_next==len(argv):\n                     ix_next_done=1\n                 elif argv[ix_next][0]=='-':\n                     ix_next_done=1\n                 else:\n                     if verbose>1:\n                         print('Adding '+argv[ix_next]+' with index '+\n                               str(ix_next)+' to list for '+cmd_name)\n                     list_one.append(argv[ix_next])\n                     ix_next=ix_next+1\n             list.append(list_one)\n             ix=ix_next\n     return (list,unproc_list)\n \n def string_to_dict(s):\n     \"\"\"\n     Convert a string to a dictionary, with extra processing for\n     colors, subdictionaries, and matplotlib keyword arguments which\n     are expected to have integer or floating point values.\n \n     This function is in ``utils.py``.\n     \"\"\"\n \n     # First split into keyword = value pairs\n     arr=s.split(',')\n     # Create empty dictionary\n     dct={}\n     # If we need to skip arguments\n     skip=0\n \n     if len(s)==0:\n         return dct\n     \n     for i in range(0,len(arr)):\n \n         if skip>0:\n             skip=skip-1\n         else:\n             # For each pair, split keyword and value.\n             arr2=arr[i].split('=')\n \n             # Remove preceeding and trailing whitespace from the\n             # keywords (not for the values)\n             while arr2[0][0].isspace():\n                 arr2[0]=arr2[0][1:]\n             while arr2[0][len(arr2[0])-1].isspace():\n                 arr2[0]=arr2[0][:-1]\n \n             # Remove quotes if necessary\n             if len(arr2)>1 and len(arr2[1])>2:\n                 if arr2[1][0]=='\\'' and arr2[1][len(arr2[1])-1]=='\\'':\n                     arr2[1]=arr2[1][1:len(arr2[1])-1]\n                 if arr2[1][0]=='\"' and arr2[1][len(arr2[1])-1]=='\"':\n                     arr2[1]=arr2[1][1:len(arr2[1])-1]\n \n             # If one of the entries is arrowstyle, then combine\n             # it with the head_width, head_length, and tail_width\n             # options if they are present\n             if arr2[0]=='arrowstyle':\n                 for j in range(0,len(arr)):\n                     if arr[j].split('=')[0]=='head_width':\n                         arr2[1]=arr2[1]+',head_width='+arr[j].split('=')[1]\n                     if arr[j].split('=')[0]=='head_length':\n                         arr2[1]=arr2[1]+',head_length='+arr[j].split('=')[1]\n                     if arr[j].split('=')[0]=='tail_width':\n                         arr2[1]=arr2[1]+',tail_width='+arr[j].split('=')[1]\n                     if arr[j].split('=')[0]=='shrink_factor':\n                         arr2[1]=arr2[1]+',shrink_factor='+arr[j].split('=')[1]\n                     if arr[j].split('=')[0]=='widthA':\n                         arr2[1]=arr2[1]+',widthA='+arr[j].split('=')[1]\n                     if arr[j].split('=')[0]=='widthB':\n                         arr2[1]=arr2[1]+',widthB='+arr[j].split('=')[1]\n                     if arr[j].split('=')[0]=='lengthB':\n                         arr2[1]=arr2[1]+',lengthB='+arr[j].split('=')[1]\n                     if arr[j].split('=')[0]=='as_angleB':\n                         arr2[1]=arr2[1]+',angleB='+arr[j].split('=')[1]\n                 print('Found arrowstyle option, reprocessed:',arr2[1])\n \n             # If one of the entries is connection style, then process\n             # accordingly\n             if arr2[0]=='connectionstyle':\n                 for j in range(0,len(arr)):\n                     if arr[j].split('=')[0]=='angleA':\n                         arr2[1]=arr2[1]+',angleA='+arr[j].split('=')[1]\n                     if arr[j].split('=')[0]=='cs_angleB':\n                         arr2[1]=arr2[1]+',angleB='+arr[j].split('=')[1]\n                     if arr[j].split('=')[0]=='armA':\n                         arr2[1]=arr2[1]+',armA='+arr[j].split('=')[1]\n                     if arr[j].split('=')[0]=='armB':\n                         arr2[1]=arr2[1]+',armB='+arr[j].split('=')[1]\n                     if arr[j].split('=')[0]=='rad':\n                         arr2[1]=arr2[1]+',rad='+arr[j].split('=')[1]\n                     if arr[j].split('=')[0]=='fraction':\n                         arr2[1]=arr2[1]+',fraction='+arr[j].split('=')[1]\n                     if arr[j].split('=')[0]=='angle':\n                         arr2[1]=arr2[1]+',angle='+arr[j].split('=')[1]\n                 print('Found connectionstyle option, reprocessed:',arr2[1])\n                 \n             # convert strings to numbers if necessary\n             if arr2[0]=='zorder':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='lw':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='linewidth':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='elinewidth':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='alpha':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='shrinkA':\n                 arr2[1]=int(arr2[1])\n             if arr2[0]=='shrinkB':\n                 arr2[1]=int(arr2[1])\n             if arr2[0]=='bins':\n                 arr2[1]=int(arr2[1])\n             if arr2[0]=='fig_size_x':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='fig_size_y':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='left_margin':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='right_margin':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='top_margin':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='bottom_margin':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='left':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='right':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='top':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='bottom':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='wspace':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='hspace':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='fontsize':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='font':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='scale':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='dpi':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='pad':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='capsize':\n                 arr2[1]=float(arr2[1])\n             if arr2[0]=='capthick':\n                 arr2[1]=float(arr2[1])\n \n             # Convert strings to bool values\n             if arr2[0]=='sharex':\n                 if arr2[1]=='True':\n                     arr2[1]=True\n                 else:\n                     arr2[1]=False\n             if arr2[0]=='lolims':\n                 if arr2[1]=='True':\n                     arr2[1]=True\n                 else:\n                     arr2[1]=False\n             if arr2[0]=='uplims':\n                 if arr2[1]=='True':\n                     arr2[1]=True\n                 else:\n                     arr2[1]=False\n             if arr2[0]=='xlolims':\n                 if arr2[1]=='True':\n                     arr2[1]=True\n                 else:\n                     arr2[1]=False\n             if arr2[0]=='xuplims':\n                 if arr2[1]=='True':\n                     arr2[1]=True\n                 else:\n                     arr2[1]=False\n             if arr2[0]=='reorient':\n                 if arr2[1]=='True':\n                     arr2[1]=True\n                 else:\n                     arr2[1]=False\n             if arr2[0]=='sharey':\n                 if arr2[1]=='True':\n                     arr2[1]=True\n                 else:\n                     arr2[1]=False\n             if arr2[0]=='squeeze':\n                 if arr2[1]=='True':\n                     arr2[1]=True\n                 else:\n                     arr2[1]=False\n             if arr2[0]=='fill':\n                 if arr2[1]=='True':\n                     arr2[1]=True\n                 else:\n                     arr2[1]=False\n             if arr2[0]=='ticks_in':\n                 if arr2[1]=='True':\n                     arr2[1]=True\n                 else:\n                     arr2[1]=False\n             if arr2[0]=='rt_ticks':\n                 if arr2[1]=='True':\n                     arr2[1]=True\n                 else:\n                     arr2[1]=False\n             if arr2[0]=='pcm':\n                 if arr2[1]=='True':\n                     arr2[1]=True\n                 else:\n                     arr2[1]=False\n                     \n             # Process color entries. The challenge here is that\n             # dictionary entries are separated by commas, but there\n             # are also commas inside color specifications. If color\n             # contains a left parenthesis or a left bracket, then we\n             # have to convert the string to an array. However, this\n             # algorithm has a limitation: it can only handle (rgb) or\n             # [rgba], but not [rgb] or (rgba).\n \n             if (arr2[0]=='color' and\n                 arr[i][5]=='=' and arr[i][6]=='('):\n                 arr2[1]=arr2[1]+','+arr[i+1]+','+arr[i+2]\n                 skip=2\n                 arr2[1]=arr2[1][1:len(arr2[1])-1]\n                 arr3=arr2[1].split(',')\n                 arr2[1]=(float(arr3[0]),float(arr3[1]),float(arr3[2]))\n                 print('Found color:',arr2[1])\n             elif (arr2[0]=='color' and\n                   arr[i][5]=='=' and arr[i][6]=='['):\n                 arr2[1]=arr2[1]+','+arr[i+1]+','+arr[i+2]+','+arr[i+3]\n                 skip=3\n                 arr2[1]=arr2[1][1:len(arr2[1])-1]\n                 arr3=arr2[1].split(',')\n                 arr2[1]=[float(arr3[0]),float(arr3[1]),float(arr3[2]),\n                          float(arr3[3])]\n                 print('Found color:',arr2[1])\n             elif (arr2[0]=='textcolor' and\n                 arr[i][9]=='=' and arr[i][10]=='('):\n                 arr2[1]=arr2[1]+','+arr[i+1]+','+arr[i+2]\n                 skip=2\n                 arr2[1]=arr2[1][1:len(arr2[1])-1]\n                 arr3=arr2[1].split(',')\n                 arr2[1]=(float(arr3[0]),float(arr3[1]),float(arr3[2]))\n                 print('Found color:',arr2[1])\n             elif (arr2[0]=='textcolor' and\n                   arr[i][9]=='=' and arr[i][10]=='['):\n                 arr2[1]=arr2[1]+','+arr[i+1]+','+arr[i+2]+','+arr[i+3]\n                 skip=3\n                 arr2[1]=arr2[1][1:len(arr2[1])-1]\n                 arr3=arr2[1].split(',')\n                 arr2[1]=[float(arr3[0]),float(arr3[1]),float(arr3[2]),\n                          float(arr3[3])]\n                 print('Found color:',arr2[1])\n \n             if ((arr2[0]=='ls' or arr2[0]=='linestyle')\n                 and len(arr2)>=2 and len(arr2[1])>1\n                 and arr2[1][0]=='('):\n                 lstemp=arr[i]\n                 skip=0\n                 while (lstemp[-1]!=')' and lstemp[-2]!=')' and\n                        i+1<len(arr)):\n                     lstemp=lstemp+','+arr[i+1]\n                     skip=skip+1\n                     i=i+1\n                 if lstemp[-2]!=')' or lstemp[-1]!=')':\n                     print('Failed to parse line style from',s)\n                     quit()\n                 arr2[1]=eval(lstemp[3:])\n \n             # if (arr2[0]=='color' and (arr2[1].find('(')!=-1 or\n             #                           arr2[1].find('[')!=-1)):\n             #     print('here',arr2[0],arr2[1])\n             #     if arr2[1].find('(')==-1:\n             #         loc1=arr2[1].find('[')\n             #         loc2=arr2[1].find(']')\n             #     else:\n             #         loc1=arr2[1].find('(')\n             #         loc2=arr2[1].find(')')\n             #     print('here2',loc1,loc2)\n             #     arr2[1]=arr2[1][loc1:loc2-loc1+1]\n             #     print('here3',arr2[1])\n             #     temp=arr2[1].split(',')\n             #     if len(temp)==3:\n             #         arr2[1]=[float(temp[0]),float(temp[1]),\n             #                  float(temp[2])]\n             #     else:\n             #         arr2[1]=[float(temp[0]),float(temp[1]),\n             #                  float(temp[2]),float(temp[3])]\n             #     print('here4',arr2[1])\n \n             # assign to dictionary (except for arrowstyle and\n             # connectionstyle options which are handled separately\n             # above)\n             if (arr2[0]!='head_width' and arr2[0]!='head_length' and\n                 arr2[0]!='tail_width' and arr2[0]!='rad' and\n                 arr2[0]!='angleA' and arr2[0]!='as_angleB' and\n                 arr2[0]!='armA' and arr2[0]!='armB' and\n                 arr2[0]!='angle' and arr2[0]!='fraction' and\n                 arr2[0]!='shrink_factor' and arr2[0]!='widthA' and\n                 arr2[0]!='lengthB' and arr2[0]!='widthB' and\n                 arr2[0]!='cs_angleB'):\n                 if len(arr2)<2:\n                     print('Original string:',s)\n                     print('Current entry:',arr2)\n                     print('Current dictionary:',dct)\n                     raise Exception('Failed to parse string \"'+s+\n                                     '\" as dictionary.')\n                 dct[arr2[0]]=arr2[1]\n         \n     return dct\n \n class terminal_py:\n     \"\"\"\n     Handle vt100 formatting sequences\n     \"\"\"\n     \n     redirected=False\n     \"\"\"\n     If true, then the output is being redirected to a file, so \n     don't use the formatting sequences\n     \"\"\"\n     \n     def __init__(self):\n         \"\"\"\n         Determine if the output is being redirected or not\n         \"\"\"\n         if sys.stdout.isatty()==False:\n             self.redirected=True\n         return\n     \n     def cyan_fg(self):\n         \"\"\"\n         Set the foreground color to cyan\n         \"\"\"\n         strt=''\n         if self.redirected:\n             return strt\n         strt=strt+chr(27)+'[36m'\n         return strt\n     \n     def red_fg(self):\n         \"\"\"\n         Set the foreground color to red\n         \"\"\"\n         strt=''\n         if self.redirected:\n             return strt\n         strt=strt+chr(27)+'[31m'\n         return strt\n     \n     def magenta_fg(self):\n         \"\"\"\n         Set the foreground color to magenta\n         \"\"\"\n         strt=''\n         if self.redirected:\n             return strt\n         strt=strt+chr(27)+'[35m'\n         return strt\n     \n     def green_fg(self):\n         \"\"\"\n         Set the foreground color to green\n         \"\"\"\n         strt=''\n         if self.redirected:\n             return strt\n         strt=strt+chr(27)+'[32m'\n         return strt\n     \n     def bold(self):\n         \"\"\"\n         Set the face to bold\n         \"\"\"\n         strt=''\n         if self.redirected:\n             return strt\n         strt=strt+chr(27)+'[1m'\n         return strt\n     \n     def default_fg(self):\n         \"\"\"\n         Set the foreground color to the default\n         \"\"\"\n         strt=''\n         if self.redirected:\n             return strt\n         strt=strt+chr(27)+'[m'\n         return strt\n     \n     def horiz_line(self):\n         \"\"\"\n         Return a string which represents a horizontal line. If possible,\n         vt100-like terminal sequences are used to create a line.\n         Otherwise, dashes are used.\n         \"\"\"\n         str_line=''\n         if self.redirected:\n             for jj in range(0,78):\n                 str_line+='-'\n         else:\n             str_line=str_line+chr(27)+'(0'\n             for jj in range(0,78):\n                 str_line+='q'\n             str_line=str_line+chr(27)+'(B'\n         return str_line\n \n     def type_str(self,strt):\n         return self.magenta_fg()+self.bold()+strt+self.default_fg()\n     \n     def cmd_str(self,strt):\n         return self.cyan_fg()+self.bold()+strt+self.default_fg()\n     \n     def topic_str(self,strt):\n         return self.green_fg()+self.bold()+strt+self.default_fg()\n     \n     def var_str(self,strt):\n         return self.red_fg()+self.bold()+strt+self.default_fg()\n \n def length_without_colors(strt):\n     \"\"\"\n     Compute the length of strt, ignoring characters which correspond\n     to VT100 formatting sequences\n     \"\"\"\n     count=0\n     index=0\n     while index<len(strt):\n         if strt[index]!=chr(27):\n             count=count+1\n         elif index+2<len(strt) and strt[index+1]=='[' and strt[index+2]=='m':\n             index=index+2\n         elif index+3<len(strt) and strt[index+1]=='[' and strt[index+3]=='m':\n             index=index+3\n         elif index+4<len(strt) and strt[index+1]=='[' and strt[index+4]=='m':\n             index=index+4\n         elif index+2<len(strt) and strt[index+1]=='(' and strt[index+2]=='0':\n             index=index+2\n         elif index+2<len(strt) and strt[index+1]=='(' and strt[index+2]=='B':\n             index=index+2\n         index=index+1\n     return count\n             \n def wrap_line(line,ncols=79):\n     \"\"\"\n     From a string 'line', create a list of strings which adds return\n     characters in order to attempt to ensure each line is less than\n     or equal to ncols characters long. This function also respects\n     explicit carriage returns, ensuring they force a new line \n     independent of the line length. This function uses the\n     'length_without_colors()' function above, to ensure VT100 formatting\n     sequences aren't included in the count.\n     \"\"\"\n     list=[]\n     # First, just split by carriage returns\n     post_list=line.split('\\n')\n     for i in range(0,len(post_list)):\n         # If this line is already short enough, then just handle\n         # it directly below\n         if length_without_colors(post_list[i])>ncols:\n             # A temporary string which will hold the current line\n             strt=''\n             # Now split by spaces\n             post_word=post_list[i].split(' ')\n             # Proceed word by word\n             for j in range(0,len(post_word)):\n                 # If the current word is longer than ncols, then\n                 # clear the temporary string and add it to the list\n                 if length_without_colors(post_word[j])>ncols:\n                     if length_without_colors(strt)>0:\n                         list.append(strt)\n                     list.append(post_word[j])\n                     strt=''\n                 elif (length_without_colors(strt)+\n                       length_without_colors(post_word[j])+1)>ncols:\n                     # Otherwise if the next word will take us over the\n                     # limit\n                     list.append(strt)\n                     strt=post_word[j]\n                 elif len(strt)==0:\n                     strt=post_word[j]\n                 else:\n                     strt=strt+' '+post_word[j]\n             # If after the last word we still have anything in the\n             # temporary string, then add it to the list\n             if length_without_colors(strt)>0:\n                 list.append(strt)\n         else:\n             # Now if the line was already short enough, add it\n             # to the list\n             list.append(post_list[i])\n                 \n     return list\n             \n def string_equal_dash(str1,str2):\n     b1=force_bytes(str1)\n     b2=force_bytes(str2)\n     for i in range(0,len(b1)):\n         if b1[i]==b'-':\n             b1[i]=b'-'\n     for i in range(0,len(b2)):\n         if b2[i]==b'-':\n             b2[i]=b'-'\n     if b1==b2:\n         return True\n     return False\n \n def screenify_py(tlist,ncols=79):\n     maxlen=0\n     for i in range(0,len(tlist)):\n         if length_without_colors(tlist[i])>maxlen:\n             maxlen=length_without_colors(tlist[i])\n     # Add to ensure there is at least one space between columns\n     maxlen=maxlen+1\n     ncolumns=int(ncols/maxlen)\n     nrows=int(len(tlist)/ncolumns)\n     while nrows*ncolumns<len(tlist):\n         nrows=nrows+1\n     output_list=[]\n     for i in range(0,nrows):\n         row=''\n         for j in range(0,ncolumns):\n             if i+j*nrows<len(tlist):\n                 colt=tlist[i+j*nrows]\n                 while length_without_colors(colt)<maxlen:\n                     colt=colt+' '\n                 row=row+colt\n         output_list.append(row)\n     return output_list\n ", "input_code": "def force_string(obj):\n\"\"\"\nThis function returns the bytes object corresponding to ``obj``\nin case it is a string using UTF-8. \n\"\"\"\n", "indent_space": "    ", "ground_truth": "def force_string(obj):\n    \"\"\"\n    This function returns the bytes object corresponding to ``obj``\n    in case it is a string using UTF-8. \n    \"\"\"\n    if isinstance(obj,numpy.bytes_)==True or isinstance(obj,bytes)==True:\n        return obj.decode('utf-8')\n    return obj", "signature": "def force_string(obj):", "completion_path": "o2sclpy/utils.py"}
{"ce_id": "62e60723d76274f8a4026b76", "namespace": "62e60723d76274f8a4026b76", "namespace_real": "neo4j.time.__init__.from_ticks", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "class", "class_name": "__init__", "function_name": "from_ticks", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\n\"\"\"\nThis module contains the fundamental types used for temporal accounting as well\nas a number of utility functions.\n\"\"\"\n\n\nfrom datetime import (\n    date,\n    datetime,\n    time,\n    timedelta,\n    timezone,\n)\nfrom functools import total_ordering\nfrom re import compile as re_compile\nfrom time import (\n    gmtime,\n    mktime,\n    struct_time,\n)\n\nfrom ._arithmetic import (\n    nano_add,\n    nano_div,\n    round_half_to_even,\n    symmetric_divmod,\n)\nfrom ._metaclasses import (\n    DateTimeType,\n    DateType,\n    TimeType,\n)\n\n\n__all__ = [\n    \"MIN_INT64\",\n    \"MAX_INT64\",\n    \"MIN_YEAR\",\n    \"MAX_YEAR\",\n    \"Duration\",\n    \"Date\",\n    \"ZeroDate\",\n    \"Time\",\n    \"Midnight\",\n    \"Midday\",\n    \"DateTime\",\n    \"Never\",\n    \"UnixEpoch\",\n]\n\n\nMIN_INT64 = -(2 ** 63)\nMAX_INT64 = (2 ** 63) - 1\n\n#: The smallest year number allowed in a :class:`.Date` or :class:`.DateTime`\n#: object to be compatible with :class:`datetime.date` and\n#: :class:`datetime.datetime`.\nMIN_YEAR = 1\n\n#: The largest year number allowed in a :class:`.Date` or :class:`.DateTime`\n#: object to be compatible with :class:`datetime.date` and\n#: :class:`datetime.datetime`.\nMAX_YEAR = 9999\n\nDATE_ISO_PATTERN = re_compile(r\"^(\\d{4})-(\\d{2})-(\\d{2})$\")\nTIME_ISO_PATTERN = re_compile(\n    r\"^(\\d{2})(:(\\d{2})(:((\\d{2})\"\n    r\"(\\.\\d*)?))?)?(([+-])(\\d{2}):(\\d{2})(:((\\d{2})(\\.\\d*)?))?)?$\"\n)\nDURATION_ISO_PATTERN = re_compile(\n    r\"^P((\\d+)Y)?((\\d+)M)?((\\d+)D)?\"\n    r\"(T((\\d+)H)?((\\d+)M)?(((\\d+)(\\.\\d+)?)?S)?)?$\"\n)\n\nNANO_SECONDS = 1000000000\nAVERAGE_SECONDS_IN_MONTH = 2629746\nAVERAGE_SECONDS_IN_DAY = 86400\n\n\ndef _is_leap_year(year):\n    if year % 4 != 0:\n        return False\n    if year % 100 != 0:\n        return True\n    return year % 400 == 0\n\n\nIS_LEAP_YEAR = {year: _is_leap_year(year) for year in range(MIN_YEAR, MAX_YEAR + 1)}\n\n\ndef _days_in_year(year):\n    return 366 if IS_LEAP_YEAR[year] else 365\n\n\nDAYS_IN_YEAR = {year: _days_in_year(year) for year in range(MIN_YEAR, MAX_YEAR + 1)}\n\n\ndef _days_in_month(year, month):\n    if month in (9, 4, 6, 11):\n        return 30\n    elif month != 2:\n        return 31\n    else:\n        return 29 if IS_LEAP_YEAR[year] else 28\n\n\nDAYS_IN_MONTH = {(year, month): _days_in_month(year, month)\n                 for year in range(MIN_YEAR, MAX_YEAR + 1) for month in range(1, 13)}\n\n\ndef _normalize_day(year, month, day):\n    \"\"\" Coerce the day of the month to an internal value that may or\n    may not match the \"public\" value.\n\n    With the exception of the last three days of every month, all\n    days are stored as-is. The last three days are instead stored\n    as -1 (the last), -2 (the second to last) and -3 (the third to\n    last).\n\n    Therefore, for a 28-day month, the last week is as follows:\n\n        Day   | 22 23 24 25 26 27 28\n        Value | 22 23 24 25 -3 -2 -1\n\n    For a 29-day month, the last week is as follows:\n\n        Day   | 23 24 25 26 27 28 29\n        Value | 23 24 25 26 -3 -2 -1\n\n    For a 30-day month, the last week is as follows:\n\n        Day   | 24 25 26 27 28 29 30\n        Value | 24 25 26 27 -3 -2 -1\n\n    For a 31-day month, the last week is as follows:\n\n        Day   | 25 26 27 28 29 30 31\n        Value | 25 26 27 28 -3 -2 -1\n\n    This slightly unintuitive system makes some temporal arithmetic\n    produce a more desirable outcome.\n\n    :param year:\n    :param month:\n    :param day:\n    :return:\n    \"\"\"\n    if year < MIN_YEAR or year > MAX_YEAR:\n        raise ValueError(\"Year out of range (%d..%d)\" % (MIN_YEAR, MAX_YEAR))\n    if month < 1 or month > 12:\n        raise ValueError(\"Month out of range (1..12)\")\n    days_in_month = DAYS_IN_MONTH[(year, month)]\n    if day in (days_in_month, -1):\n        return year, month, -1\n    if day in (days_in_month - 1, -2):\n        return year, month, -2\n    if day in (days_in_month - 2, -3):\n        return year, month, -3\n    if 1 <= day <= days_in_month - 3:\n        return year, month, int(day)\n    # TODO improve this error message\n    raise ValueError(\"Day %d out of range (1..%d, -1, -2 ,-3)\" % (day, days_in_month))\n\n\nclass ClockTime(tuple):\n    \"\"\" A count of `seconds` and `nanoseconds`. This class can be used to\n    mark a particular point in time, relative to an externally-specified\n    epoch.\n\n    The `seconds` and `nanoseconds` values provided to the constructor can\n    can have any sign but will be normalized internally into a positive or\n    negative `seconds` value along with a positive `nanoseconds` value\n    between `0` and `999,999,999`. Therefore ``ClockTime(-1, -1)`` is\n    normalized to ``ClockTime(-2, 999999999)``.\n\n    Note that the structure of a :class:`.ClockTime` object is similar to\n    the ``timespec`` struct in C.\n    \"\"\"\n\n    def __new__(cls, seconds=0, nanoseconds=0):\n        seconds, nanoseconds = divmod(\n            int(NANO_SECONDS * seconds) + int(nanoseconds), NANO_SECONDS\n        )\n        return tuple.__new__(cls, (seconds, nanoseconds))\n\n    def __add__(self, other):\n        if isinstance(other, (int, float)):\n            other = ClockTime(other)\n        if isinstance(other, ClockTime):\n            return ClockTime(self.seconds + other.seconds, self.nanoseconds + other.nanoseconds)\n        if isinstance(other, Duration):\n            if other.months or other.days:\n                raise ValueError(\"Cannot add Duration with months or days\")\n            return ClockTime(self.seconds + other.seconds, self.nanoseconds +\n                             int(other.nanoseconds))\n        return NotImplemented\n\n    def __sub__(self, other):\n        if isinstance(other, (int, float)):\n            other = ClockTime(other)\n        if isinstance(other, ClockTime):\n            return ClockTime(self.seconds - other.seconds, self.nanoseconds - other.nanoseconds)\n        if isinstance(other, Duration):\n            if other.months or other.days:\n                raise ValueError(\"Cannot subtract Duration with months or days\")\n            return ClockTime(self.seconds - other.seconds, self.nanoseconds - int(other.nanoseconds))\n        return NotImplemented\n\n    def __repr__(self):\n        return \"ClockTime(seconds=%r, nanoseconds=%r)\" % self\n\n    @property\n    def seconds(self):\n        return self[0]\n\n    @property\n    def nanoseconds(self):\n        return self[1]\n\n\nclass Clock:\n    \"\"\" Accessor for time values. This class is fulfilled by implementations\n    that subclass :class:`.Clock`. These implementations are contained within\n    the ``neo4j.time.clock_implementations`` module, and are not intended to be\n    accessed directly.\n\n    Creating a new :class:`.Clock` instance will produce the highest\n    precision clock implementation available.\n\n        >>> clock = Clock()\n        >>> type(clock)                                         # doctest: +SKIP\n        neo4j.time.clock_implementations.LibCClock\n        >>> clock.local_time()                                  # doctest: +SKIP\n        ClockTime(seconds=1525265942, nanoseconds=506844026)\n\n    \"\"\"\n\n    __implementations = None\n\n    def __new__(cls):\n        if cls.__implementations is None:\n            # Find an available clock with the best precision\n            import neo4j.time._clock_implementations\n            cls.__implementations = sorted((clock for clock in Clock.__subclasses__() if clock.available()),\n                                           key=lambda clock: clock.precision(), reverse=True)\n        if not cls.__implementations:\n            raise RuntimeError(\"No clock implementations available\")\n        instance = object.__new__(cls.__implementations[0])\n        return instance\n\n    @classmethod\n    def precision(cls):\n        \"\"\" The precision of this clock implementation, represented as a\n        number of decimal places. Therefore, for a nanosecond precision\n        clock, this function returns `9`.\n        \"\"\"\n        raise NotImplementedError(\"No clock implementation selected\")\n\n    @classmethod\n    def available(cls):\n        \"\"\" A boolean flag to indicate whether or not this clock\n        implementation is available on this platform.\n        \"\"\"\n        raise NotImplementedError(\"No clock implementation selected\")\n\n    @classmethod\n    def local_offset(cls):\n        \"\"\"The offset from UTC for local time read from this clock.\n        This may raise OverflowError if not supported, because of platform depending C libraries.\n\n        :returns:\n        :rtype:\n\n        :raises OverflowError:\n        \"\"\"\n        # Adding and subtracting two days to avoid passing a pre-epoch time to\n        # `mktime`, which can cause a `OverflowError` on some platforms (e.g.,\n        # Windows).\n        return ClockTime(-int(mktime(gmtime(172800))) + 172800)\n\n    def local_time(self):\n        \"\"\" Read and return the current local time from this clock, measured relative to the Unix Epoch.\n        This may raise OverflowError if not supported, because of platform depending C libraries.\n\n        :returns:\n        :rtype:\n\n        :raises OverflowError:\n        \"\"\"\n        return self.utc_time() + self.local_offset()\n\n    def utc_time(self):\n        \"\"\" Read and return the current UTC time from this clock, measured\n        relative to the Unix Epoch.\n        \"\"\"\n        raise NotImplementedError(\"No clock implementation selected\")\n\n\nclass Duration(tuple):\n    \"\"\"A difference between two points in time.\n\n    A :class:`.Duration` represents the difference between two points in time.\n    Duration objects store a composite value of `months`, `days`, `seconds`,\n    and `nanoseconds`. Unlike :class:`datetime.timedelta` however, days, and\n    seconds/nanoseconds are never interchanged. All values except seconds and\n    nanoseconds are applied separately in calculations (element-wise).\n\n    A :class:`.Duration` stores four primary instance attributes internally:\n    `months`, `days`, `seconds` and `nanoseconds`. These are maintained as\n    individual values and are immutable. Each of these four attributes can carry\n    its own sign, with the exception of `nanoseconds`, which always has the same\n    sign as `seconds`. The constructor will establish this state, should the\n    duration be initialized with conflicting `seconds` and `nanoseconds` signs.\n    This structure allows the modelling of durations such as\n    `3 months minus 2 days`.\n\n    To determine if a :class:`Duration` `d` is overflowing the accepted values\n    of the database, first, all `nanoseconds` outside the range -999_999_999 and\n    999_999_999 are transferred into the seconds field. Then, `months`, `days`,\n    and `seconds` are summed up like so:\n    `months * 2629746 + days * 86400 + d.seconds + d.nanoseconds // 1000000000`.\n    (Like the integer division in Python, this one is to be understood as\n    rounding down rather than towards 0.)\n    This value must be between -(2\\\\ :sup:`63`) and (2\\\\ :sup:`63` - 1)\n    inclusive.\n\n    :param years: will be added times 12 to `months`\n    :type years: float\n    :param months: will be truncated to :class:`int` (`int(months)`)\n    :type months: float\n    :param weeks: will be added times 7 to `days`\n    :type weeks: float\n    :param days: will be truncated to :class:`int` (`int(days)`)\n    :type days: float\n    :param hours: will be added times 3,600,000,000,000 to `nanoseconds`\n    :type hours: float\n    :param minutes: will be added times 60,000,000,000 to `nanoseconds`\n    :type minutes: float\n    :param seconds: will be added times 1,000,000,000 to `nanoseconds``\n    :type seconds: float\n    :param milliseconds: will be added times 1,000,000 to `nanoseconds`\n    :type microseconds: float\n    :param microseconds: will be added times 1,000 to `nanoseconds`\n    :type milliseconds: float\n    :param nanoseconds: will be truncated to :class:`int` (`int(nanoseconds)`)\n    :type nanoseconds: float\n\n    :raises ValueError: the components exceed the limits as described above.\n    \"\"\"\n\n    # i64: i64:i64: i32\n\n    min = None\n    \"\"\"The lowest duration value possible.\"\"\"\n\n    max = None\n    \"\"\"The highest duration value possible.\"\"\"\n\n    def __new__(cls, years=0, months=0, weeks=0, days=0, hours=0, minutes=0,\n                seconds=0, milliseconds=0, microseconds=0, nanoseconds=0):\n        mo = int(12 * years + months)\n        if mo < MIN_INT64 or mo > MAX_INT64:\n            raise ValueError(\"Months value out of range\")\n        d = int(7 * weeks + days)\n        ns = (int(3600000000000 * hours) +\n              int(60000000000 * minutes) +\n              int(1000000000 * seconds) +\n              int(1000000 * milliseconds) +\n              int(1000 * microseconds) +\n              int(nanoseconds))\n        s, ns = symmetric_divmod(ns, NANO_SECONDS)\n        avg_total_seconds = (mo * AVERAGE_SECONDS_IN_MONTH\n                             + d * AVERAGE_SECONDS_IN_DAY\n                             + s\n                             - (1 if ns < 0 else 0))\n        if avg_total_seconds < MIN_INT64 or avg_total_seconds > MAX_INT64:\n            raise ValueError(\"Duration value out of range: %r\",\n                             cls.__repr__((mo, d, s, ns)))\n        return tuple.__new__(cls, (mo, d, s, ns))\n\n    def __bool__(self):\n        \"\"\"Falsy if all primary instance attributes are.\"\"\"\n        return any(map(bool, self))\n\n    __nonzero__ = __bool__\n\n    def __add__(self, other):\n        \"\"\"Add a :class:`.Duration` or :class:`datetime.timedelta`.\n\n        :rtype: Duration\n        \"\"\"\n        if isinstance(other, Duration):\n            return Duration(\n                months=self[0] + int(other.months),\n                days=self[1] + int(other.days),\n                seconds=self[2] + int(other.seconds),\n                nanoseconds=self[3] + int(other.nanoseconds)\n            )\n        if isinstance(other, timedelta):\n            return Duration(\n                months=self[0], days=self[1] + other.days,\n                seconds=self[2] + other.seconds,\n                nanoseconds=self[3] + other.microseconds * 1000\n            )\n        return NotImplemented\n\n    def __sub__(self, other):\n        \"\"\"Subtract a :class:`.Duration` or :class:`datetime.timedelta`.\n\n        :rtype: Duration\n        \"\"\"\n        if isinstance(other, Duration):\n            return Duration(\n                months=self[0] - int(other.months),\n                days=self[1] - int(other.days),\n                seconds=self[2] - int(other.seconds),\n                nanoseconds=self[3] - int(other.nanoseconds)\n            )\n        if isinstance(other, timedelta):\n            return Duration(\n                months=self[0],\n                days=self[1] - other.days,\n                seconds=self[2] - other.seconds,\n                nanoseconds=self[3] - other.microseconds * 1000\n            )\n        return NotImplemented\n\n    def __mul__(self, other):\n        \"\"\"Multiply by an :class:`int` or :class:`float`.\n\n        The operation is performed element-wise on\n        ``(months, days, nanaoseconds)`` where\n\n        * years go into months,\n        * weeks go into days,\n        * seconds and all sub-second units go into nanoseconds.\n\n        Each element will be rounded to the nearest integer (.5 towards even).\n\n        :rtype: Duration\n        \"\"\"\n        if isinstance(other, (int, float)):\n            return Duration(\n                months=round_half_to_even(self[0] * other),\n                days=round_half_to_even(self[1] * other),\n                nanoseconds=round_half_to_even(\n                    self[2] * NANO_SECONDS * other\n                    + self[3] * other\n                )\n            )\n        return NotImplemented\n\n    def __floordiv__(self, other):\n        \"\"\"Integer division by an :class:`int`.\n\n        The operation is performed element-wise on\n        ``(months, days, nanaoseconds)`` where\n\n        * years go into months,\n        * weeks go into days,\n        * seconds and all sub-second units go into nanoseconds.\n\n        Each element will be rounded towards -inf.\n\n        :rtype: Duration\n        \"\"\"\n        if isinstance(other, int):\n            return Duration(\n                months=self[0] // other, days=self[1] // other,\n                nanoseconds=(self[2] * NANO_SECONDS + self[3]) // other\n            )\n        return NotImplemented\n\n    def __mod__(self, other):\n        \"\"\"Modulo operation by an :class:`int`.\n\n        The operation is performed element-wise on\n        ``(months, days, nanaoseconds)`` where\n\n        * years go into months,\n        * weeks go into days,\n        * seconds and all sub-second units go into nanoseconds.\n\n        :rtype: Duration\n        \"\"\"\n        if isinstance(other, int):\n            return Duration(\n                months=self[0] % other, days=self[1] % other,\n                nanoseconds=(self[2] * NANO_SECONDS + self[3]) % other\n            )\n        return NotImplemented\n\n    def __divmod__(self, other):\n        \"\"\"Division and modulo operation by an :class:`int`.\n\n        See :meth:`__floordiv__` and :meth:`__mod__`.\n\n        :rtype: (Duration, Duration)\n        \"\"\"\n        if isinstance(other, int):\n            return self.__floordiv__(other), self.__mod__(other)\n        return NotImplemented\n\n    def __truediv__(self, other):\n        \"\"\"Division by an :class:`int` or :class:`float`.\n\n        The operation is performed element-wise on\n        ``(months, days, nanaoseconds)`` where\n\n        * years go into months,\n        * weeks go into days,\n        * seconds and all sub-second units go into nanoseconds.\n\n        Each element will be rounded to the nearest integer (.5 towards even).\n\n        :rtype: Duration\n        \"\"\"\n        if isinstance(other, (int, float)):\n            return Duration(\n                months=round_half_to_even(self[0] / other),\n                days=round_half_to_even(self[1] / other),\n                nanoseconds=round_half_to_even(\n                    self[2] * NANO_SECONDS / other\n                    + self[3] / other\n                )\n            )\n        return NotImplemented\n\n    def __pos__(self):\n        \"\"\"\"\"\"\n        return self\n\n    def __neg__(self):\n        \"\"\"\"\"\"\n        return Duration(months=-self[0], days=-self[1], seconds=-self[2],\n                        nanoseconds=-self[3])\n\n    def __abs__(self):\n        \"\"\"\"\"\"\n        return Duration(months=abs(self[0]), days=abs(self[1]),\n                        seconds=abs(self[2]), nanoseconds=abs(self[3]))\n\n    def __repr__(self):\n        \"\"\"\"\"\"\n        return \"Duration(months=%r, days=%r, seconds=%r, nanoseconds=%r)\" % self\n\n    def __str__(self):\n        \"\"\"\"\"\"\n        return self.iso_format()\n\n    def __copy__(self):\n        return self.__new__(self.__class__, months=self[0], days=self[1],\n                            seconds=self[2], nanoseconds=self[3])\n\n    def __deepcopy__(self, memodict={}):\n        return self.__copy__()\n\n    @classmethod\n    def from_iso_format(cls, s):\n        \"\"\"Parse a ISO formatted duration string.\n\n        Accepted formats (all lowercase letters are placeholders):\n            'P', a zero length duration\n            'PyY', y being a number of years\n            'PmM', m being a number of months\n            'PdD', d being a number of days\n\n            Any combination of the above, e.g., 'P25Y1D' for 25 years and 1 day.\n\n            'PThH', h being a number of hours\n            'PTmM', h being a number of minutes\n            'PTsS', h being a number of seconds\n            'PTs.sss...S', h being a fractional number of seconds\n\n            Any combination of the above, e.g. 'PT5H1.2S' for 5 hours and 1.2\n            seconds.\n            Any combination of all options, e.g. 'P13MT100M' for 13 months and\n            100 minutes.\n\n        :param s: String to parse\n        :type s: str\n\n        :rtype: Duration\n\n        :raises ValueError: if the string does not match the required format.\n        \"\"\"\n        match = DURATION_ISO_PATTERN.match(s)\n        if match:\n            ns = 0\n            if match.group(15):\n                ns = int(match.group(15)[1:10].ljust(9, \"0\"))\n            return cls(\n                years=int(match.group(2) or 0),\n                months=int(match.group(4) or 0),\n                days=int(match.group(6) or 0),\n                hours=int(match.group(9) or 0),\n                minutes=int(match.group(11) or 0),\n                seconds=int(match.group(14) or 0),\n                nanoseconds=ns\n            )\n        raise ValueError(\"Duration string must be in ISO format\")\n\n    fromisoformat = from_iso_format\n\n    def iso_format(self, sep=\"T\"):\n        \"\"\"Return the :class:`Duration` as ISO formatted string.\n\n        :param sep: the separator before the time components.\n        :type sep: str\n\n        :rtype: str\n        \"\"\"\n        parts = []\n        hours, minutes, seconds, nanoseconds = \\\n            self.hours_minutes_seconds_nanoseconds\n        if hours:\n            parts.append(\"%dH\" % hours)\n        if minutes:\n            parts.append(\"%dM\" % minutes)\n        if nanoseconds:\n            if seconds >= 0 and nanoseconds >= 0:\n                parts.append(\"%d.%sS\" %\n                             (seconds,\n                              str(nanoseconds).rjust(9, \"0\").rstrip(\"0\")))\n            elif seconds <= 0 and nanoseconds <= 0:\n                parts.append(\"-%d.%sS\" %\n                             (abs(seconds),\n                              str(abs(nanoseconds)).rjust(9, \"0\").rstrip(\"0\")))\n\n            else:\n                assert False and \"Please report this issue\"\n        elif seconds:\n            parts.append(\"%dS\" % seconds)\n        if parts:\n            parts.insert(0, sep)\n        years, months, days = self.years_months_days\n        if days:\n            parts.insert(0, \"%dD\" % days)\n        if months:\n            parts.insert(0, \"%dM\" % months)\n        if years:\n            parts.insert(0, \"%dY\" % years)\n        if parts:\n            parts.insert(0, \"P\")\n            return \"\".join(parts)\n        else:\n            return \"PT0S\"\n\n    @property\n    def months(self):\n        \"\"\"The months of the :class:`Duration`.\n\n        :type: int\n        \"\"\"\n        return self[0]\n\n    @property\n    def days(self):\n        \"\"\"The days of the :class:`Duration`.\n\n        :type: int\n        \"\"\"\n        return self[1]\n\n    @property\n    def seconds(self):\n        \"\"\"The seconds of the :class:`Duration`.\n\n        :type: int\n        \"\"\"\n        return self[2]\n\n    @property\n    def nanoseconds(self):\n        \"\"\"The nanoseconds of the :class:`Duration`.\n\n        :type: int\n        \"\"\"\n        return self[3]\n\n    @property\n    def years_months_days(self):\n        \"\"\"\n\n        :return:\n        \"\"\"\n        years, months = symmetric_divmod(self[0], 12)\n        return years, months, self[1]\n\n    @property\n    def hours_minutes_seconds_nanoseconds(self):\n        \"\"\" A 4-tuple of (hours, minutes, seconds, nanoseconds).\n\n        :type: (int, int, int, int)\n        \"\"\"\n        minutes, seconds = symmetric_divmod(self[2], 60)\n        hours, minutes = symmetric_divmod(minutes, 60)\n        return hours, minutes, seconds, self[3]\n\n\nDuration.min = Duration(seconds=MIN_INT64, nanoseconds=0)\nDuration.max = Duration(seconds=MAX_INT64, nanoseconds=999999999)\n\n\nclass Date(metaclass=DateType):\n    \"\"\"Idealized date representation.\n\n    A :class:`.Date` object represents a date (year, month, and day) in the\n    `proleptic Gregorian Calendar\n    <https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar>`_.\n\n    Years between `0001` and `9999` are supported, with additional support for\n    the \"zero date\" used in some contexts.\n\n    Each date is based on a proleptic Gregorian ordinal, which models\n    1 Jan 0001 as `day 1` and counts each subsequent day up to, and including,\n    31 Dec 9999. The standard `year`, `month` and `day` value of each date is\n    also available.\n\n    Internally, the day of the month is always stored as-is, with the exception\n    of the last three days of that month. These are always stored as\n    -1, -2 and -3 (counting from the last day). This system allows some temporal\n    arithmetic (particularly adding or subtracting months) to produce a more\n    desirable outcome than would otherwise be produced. Externally, the day\n    number is always the same as would be written on a calendar.\n\n    :param year: the year. Minimum :attr:`.MIN_YEAR` (0001), maximum\n        :attr:`.MAX_YEAR` (9999).\n    :type year: int\n    :param month: the month. Minimum 1, maximum 12.\n    :type month: int\n    :param day: the day. Minimum 1, maximum\n        :attr:`Date.days_in_month(year, month) <Date.days_in_month>`.\n    :type day: int\n\n    A zero date can also be acquired by passing all zeroes to the\n    :class:`neo4j.time.Date` constructor or by using the :attr:`ZeroDate`\n    constant.\n    \"\"\"\n\n    # CONSTRUCTOR #\n\n    def __new__(cls, year, month, day):\n        if year == month == day == 0:\n            return ZeroDate\n        year, month, day = _normalize_day(year, month, day)\n        ordinal = cls.__calc_ordinal(year, month, day)\n        return cls.__new(ordinal, year, month, day)\n\n    @classmethod\n    def __new(cls, ordinal, year, month, day):\n        instance = object.__new__(cls)\n        instance.__ordinal = int(ordinal)\n        instance.__year = int(year)\n        instance.__month = int(month)\n        instance.__day = int(day)\n        return instance\n\n    def __getattr__(self, name):\n        \"\"\" Map standard library attribute names to local attribute names,\n        for compatibility.\n        \"\"\"\n        try:\n            return {\n                \"isocalendar\": self.iso_calendar,\n                \"isoformat\": self.iso_format,\n                \"isoweekday\": self.iso_weekday,\n                \"strftime\": self.__format__,\n                \"toordinal\": self.to_ordinal,\n                \"timetuple\": self.time_tuple,\n            }[name]\n        except KeyError:\n            raise AttributeError(\"Date has no attribute %r\" % name)\n\n    # CLASS METHODS #\n\n    @classmethod\n    def today(cls, tz=None):\n        \"\"\"Get the current date.\n\n        :param tz: timezone or None to get the local :class:`.Date`.\n        :type tz: datetime.tzinfo or None\n\n        :rtype: Date\n\n        :raises OverflowError: if the timestamp is out of the range of values\n            supported by the platform C localtime() function. It\u2019s common for\n            this to be restricted to years from 1970 through 2038.\n        \"\"\"\n        if tz is None:\n            return cls.from_clock_time(Clock().local_time(), UnixEpoch)\n        else:\n            return (\n                DateTime.utc_now()\n                .replace(tzinfo=timezone.utc).astimezone(tz)\n                .date()\n            )\n\n    @classmethod\n    def utc_today(cls):\n        \"\"\"Get the current date as UTC local date.\n\n        :rtype: Date\n        \"\"\"\n        return cls.from_clock_time(Clock().utc_time(), UnixEpoch)\n\n    @classmethod\n    def from_timestamp(cls, timestamp, tz=None):\n        \"\"\":class:`.Date` from a time stamp (seconds since unix epoch).\n\n        :param timestamp: the unix timestamp (seconds since unix epoch).\n        :type timestamp: float\n        :param tz: timezone. Set to None to create a local :class:`.Date`.\n        :type tz: datetime.tzinfo or None\n\n        :rtype: Date\n\n        :raises OverflowError: if the timestamp is out of the range of values\n            supported by the platform C localtime() function. It\u2019s common for\n            this to be restricted to years from 1970 through 2038.\n        \"\"\"\n        return cls.from_native(datetime.fromtimestamp(timestamp, tz))\n\n    @classmethod\n    def utc_from_timestamp(cls, timestamp):\n        \"\"\":class:`.Date` from a time stamp (seconds since unix epoch).\n\n        Returns the `Date` as local date `Date` in UTC.\n\n        :rtype: Date\n        \"\"\"\n        return cls.from_clock_time((timestamp, 0), UnixEpoch)\n\n    @classmethod\n    def from_ordinal(cls, ordinal):\n        \"\"\"\n        The :class:`.Date` that corresponds to the proleptic Gregorian ordinal.\n\n        `0001-01-01` has ordinal 1 and `9999-12-31` has ordinal 3,652,059.\n        Values outside of this range trigger a :exc:`ValueError`.\n        The corresponding instance method for the reverse date-to-ordinal\n        transformation is :meth:`.to_ordinal`.\n        The ordinal 0 has a special semantic and will return :attr:`ZeroDate`.\n\n        :rtype: Date\n\n        :raises ValueError: if the ordinal is outside the range [0, 3652059]\n            (both values included).\n        \"\"\"\n        if ordinal == 0:\n            return ZeroDate\n        if ordinal >= 736695:\n            year = 2018     # Project release year\n            month = 1\n            day = int(ordinal - 736694)\n        elif ordinal >= 719163:\n            year = 1970     # Unix epoch\n            month = 1\n            day = int(ordinal - 719162)\n        else:\n            year = 1\n            month = 1\n            day = int(ordinal)\n        if day < 1 or day > 3652059:\n            # Note: this requires a maximum of 22 bits for storage\n            # Could be transferred in 3 bytes.\n            raise ValueError(\"Ordinal out of range (1..3652059)\")\n        if year < MIN_YEAR or year > MAX_YEAR:\n            raise ValueError(\"Year out of range (%d..%d)\" % (MIN_YEAR, MAX_YEAR))\n        days_in_year = DAYS_IN_YEAR[year]\n        while day > days_in_year:\n            day -= days_in_year\n            year += 1\n            days_in_year = DAYS_IN_YEAR[year]\n        days_in_month = DAYS_IN_MONTH[(year, month)]\n        while day > days_in_month:\n            day -= days_in_month\n            month += 1\n            days_in_month = DAYS_IN_MONTH[(year, month)]\n        year, month, day = _normalize_day(year, month, day)\n        return cls.__new(ordinal, year, month, day)\n\n    @classmethod\n    def parse(cls, s):\n        \"\"\"Parse a string to produce a :class:`.Date`.\n\n        Accepted formats:\n            'Y-M-D'\n\n        :param s: the string to be parsed.\n        :type s: str\n\n        :rtype: Date\n\n        :raises ValueError: if the string could not be parsed.\n        \"\"\"\n        try:\n            numbers = map(int, s.split(\"-\"))\n        except (ValueError, AttributeError):\n            raise ValueError(\"Date string must be in format YYYY-MM-DD\")\n        else:\n            numbers = list(numbers)\n            if len(numbers) == 3:\n                return cls(*numbers)\n            raise ValueError(\"Date string must be in format YYYY-MM-DD\")\n\n    @classmethod\n    def from_iso_format(cls, s):\n        \"\"\"Parse a ISO formatted Date string.\n\n        Accepted formats:\n            'YYYY-MM-DD'\n\n        :param s: the string to be parsed.\n        :type s: str\n\n        :rtype: Date\n\n        :raises ValueError: if the string could not be parsed.\n        \"\"\"\n        m = DATE_ISO_PATTERN.match(s)\n        if m:\n            year = int(m.group(1))\n            month = int(m.group(2))\n            day = int(m.group(3))\n            return cls(year, month, day)\n        raise ValueError(\"Date string must be in format YYYY-MM-DD\")\n\n    @classmethod\n    def from_native(cls, d):\n        \"\"\"Convert from a native Python `datetime.date` value.\n\n        :param d: the date to convert.\n        :type d: datetime.date\n\n        :rtype: Date\n        \"\"\"\n        return Date.from_ordinal(d.toordinal())\n\n    @classmethod\n    def from_clock_time(cls, clock_time, epoch):\n        \"\"\"Convert from a ClockTime relative to a given epoch.\n\n        :param clock_time: the clock time as :class:`.ClockTime` or as tuple of\n            (seconds, nanoseconds)\n        :type clock_time: ClockTime or (float, int)\n        :param epoch: the epoch to which `clock_time` is relative\n        :type epoch: DateTime\n\n        :rtype: Date\n        \"\"\"\n        try:\n            clock_time = ClockTime(*clock_time)\n        except (TypeError, ValueError):\n            raise ValueError(\"Clock time must be a 2-tuple of (s, ns)\")\n        else:\n            ordinal = clock_time.seconds // 86400\n            return Date.from_ordinal(ordinal + epoch.date().to_ordinal())\n\n    @classmethod\n    def is_leap_year(cls, year):\n        \"\"\"Indicates whether or not `year` is a leap year.\n\n        :param year: the year to look up\n        :type year: int\n\n        :rtype: bool\n\n        :raises ValueError: if `year` is out of range:\n            :attr:`MIN_YEAR` <= year <= :attr:`MAX_YEAR`\n        \"\"\"\n        if year < MIN_YEAR or year > MAX_YEAR:\n            raise ValueError(\"Year out of range (%d..%d)\" % (MIN_YEAR, MAX_YEAR))\n        return IS_LEAP_YEAR[year]\n\n    @classmethod\n    def days_in_year(cls, year):\n        \"\"\"Return the number of days in `year`.\n\n        :param year: the year to look up\n        :type year: int\n\n        :rtype: int\n\n        :raises ValueError: if `year` is out of range:\n            :attr:`MIN_YEAR` <= year <= :attr:`MAX_YEAR`\n        \"\"\"\n        if year < MIN_YEAR or year > MAX_YEAR:\n            raise ValueError(\"Year out of range (%d..%d)\" % (MIN_YEAR, MAX_YEAR))\n        return DAYS_IN_YEAR[year]\n\n    @classmethod\n    def days_in_month(cls, year, month):\n        \"\"\"Return the number of days in `month` of `year`.\n\n        :param year: the year to look up\n        :type year: int\n        :param year: the month to look up\n        :type year: int\n\n        :rtype: int\n\n        :raises ValueError: if `year` or `month` is out of range:\n            :attr:`MIN_YEAR` <= year <= :attr:`MAX_YEAR`;\n            1 <= year <= 12\n        \"\"\"\n        if year < MIN_YEAR or year > MAX_YEAR:\n            raise ValueError(\"Year out of range (%d..%d)\" % (MIN_YEAR, MAX_YEAR))\n        if month < 1 or month > 12:\n            raise ValueError(\"Month out of range (1..12)\")\n        return DAYS_IN_MONTH[(year, month)]\n\n    @classmethod\n    def __calc_ordinal(cls, year, month, day):\n        if day < 0:\n            day = cls.days_in_month(year, month) + int(day) + 1\n        # The built-in date class does this faster than a\n        # long-hand pure Python algorithm could\n        return date(year, month, day).toordinal()\n\n    # CLASS ATTRIBUTES #\n\n    min = None\n    \"\"\"The earliest date value possible.\"\"\"\n\n    max = None\n    \"\"\"The latest date value possible.\"\"\"\n\n    resolution = None\n    \"\"\"The minimum resolution supported.\"\"\"\n\n    # INSTANCE ATTRIBUTES #\n\n    __ordinal = 0\n\n    __year = 0\n\n    __month = 0\n\n    __day = 0\n\n    @property\n    def year(self):\n        \"\"\"The year of the date.\n\n        :type: int\n        \"\"\"\n        return self.__year\n\n    @property\n    def month(self):\n        \"\"\"The month of the date.\n\n        :type: int\n        \"\"\"\n        return self.__month\n\n    @property\n    def day(self):\n        \"\"\"The day of the date.\n\n        :type: int\n        \"\"\"\n        if self.__day == 0:\n            return 0\n        if self.__day >= 1:\n            return self.__day\n        return self.days_in_month(self.__year, self.__month) + self.__day + 1\n\n    @property\n    def year_month_day(self):\n        \"\"\"3-tuple of (year, month, day) describing the date.\n\n        :rtype: (int, int, int)\n        \"\"\"\n        return self.year, self.month, self.day\n\n    @property\n    def year_week_day(self):\n        \"\"\"3-tuple of (year, week_of_year, day_of_week) describing the date.\n\n        `day_of_week` will be 1 for Monday and 7 for Sunday.\n\n        :rtype: (int, int, int)\n        \"\"\"\n        ordinal = self.__ordinal\n        year = self.__year\n\n        def day_of_week(o):\n            return ((o - 1) % 7) + 1\n\n        def iso_week_1(y):\n            j4 = Date(y, 1, 4)\n            return j4 + Duration(days=(1 - day_of_week(j4.to_ordinal())))\n\n        if ordinal >= Date(year, 12, 29).to_ordinal():\n            week1 = iso_week_1(year + 1)\n            if ordinal < week1.to_ordinal():\n                week1 = iso_week_1(year)\n            else:\n                year += 1\n        else:\n            week1 = iso_week_1(year)\n            if ordinal < week1.to_ordinal():\n                year -= 1\n                week1 = iso_week_1(year)\n        return (year, int((ordinal - week1.to_ordinal()) / 7 + 1),\n                day_of_week(ordinal))\n\n    @property\n    def year_day(self):\n        \"\"\"2-tuple of (year, day_of_the_year) describing the date.\n\n        This is the number of the day relative to the start of the year,\n        with `1 Jan` corresponding to `1`.\n\n        :rtype: (int, int)\n        \"\"\"\n        return (self.__year,\n                self.toordinal() - Date(self.__year, 1, 1).toordinal() + 1)\n\n    # OPERATIONS #\n\n    def __hash__(self):\n        \"\"\"\"\"\"\n        return hash(self.toordinal())\n\n    def __eq__(self, other):\n        \"\"\"`==` comparison with :class:`.Date` or :class:`datetime.date`.\"\"\"\n        if isinstance(other, (Date, date)):\n            return self.toordinal() == other.toordinal()\n        return False\n\n    def __ne__(self, other):\n        \"\"\"`!=` comparison with :class:`.Date` or :class:`datetime.date`.\"\"\"\n        return not self.__eq__(other)\n\n    def __lt__(self, other):\n        \"\"\"`<` comparison with :class:`.Date` or :class:`datetime.date`.\"\"\"\n        if isinstance(other, (Date, date)):\n            return self.toordinal() < other.toordinal()\n        raise TypeError(\"'<' not supported between instances of 'Date' and %r\" % type(other).__name__)\n\n    def __le__(self, other):\n        \"\"\"`<=` comparison with :class:`.Date` or :class:`datetime.date`.\"\"\"\n        if isinstance(other, (Date, date)):\n            return self.toordinal() <= other.toordinal()\n        raise TypeError(\"'<=' not supported between instances of 'Date' and %r\" % type(other).__name__)\n\n    def __ge__(self, other):\n        \"\"\"`>=` comparison with :class:`.Date` or :class:`datetime.date`.\"\"\"\n        if isinstance(other, (Date, date)):\n            return self.toordinal() >= other.toordinal()\n        raise TypeError(\"'>=' not supported between instances of 'Date' and %r\" % type(other).__name__)\n\n    def __gt__(self, other):\n        \"\"\"`>` comparison with :class:`.Date` or :class:`datetime.date`.\"\"\"\n        if isinstance(other, (Date, date)):\n            return self.toordinal() > other.toordinal()\n        raise TypeError(\"'>' not supported between instances of 'Date' and %r\" % type(other).__name__)\n\n    def __add__(self, other):\n        \"\"\"Add a :class:`.Duration`.\n\n        :rtype: Date\n\n        :raises ValueError: if the added duration has a time component.\n        \"\"\"\n        def add_months(d, months):\n            years, months = symmetric_divmod(months, 12)\n            year = d.__year + years\n            month = d.__month + months\n            while month > 12:\n                year += 1\n                month -= 12\n            while month < 1:\n                year -= 1\n                month += 12\n            d.__year = year\n            d.__month = month\n\n        def add_days(d, days):\n            assert 1 <= d.__day <= 28 or -28 <= d.__day <= -1\n            if d.__day >= 1:\n                new_days = d.__day + days\n                if 1 <= new_days <= 27:\n                    d.__day = new_days\n                    return\n            d0 = Date.from_ordinal(d.__ordinal + days)\n            d.__year, d.__month, d.__day = d0.__year, d0.__month, d0.__day\n\n        if isinstance(other, Duration):\n            if other.seconds or other.nanoseconds:\n                raise ValueError(\"Cannot add a Duration with seconds or \"\n                                 \"nanoseconds to a Date\")\n            if other.months == other.days == 0:\n                return self\n            new_date = self.replace()\n            # Add days before months as the former sometimes\n            # requires the current ordinal to be correct.\n            if other.days:\n                add_days(new_date, other.days)\n            if other.months:\n                add_months(new_date, other.months)\n            new_date.__ordinal = self.__calc_ordinal(new_date.year, new_date.month, new_date.day)\n            return new_date\n        return NotImplemented\n\n    def __sub__(self, other):\n        \"\"\"Subtract a :class:`.Date` or :class:`.Duration`.\n\n        :returns: If a :class:`.Date` is subtracted, the time between the two\n            dates is returned as :class:`.Duration`. If a :class:`.Duration` is\n            subtracted, a new :class:`.Date` is returned.\n        :rtype: Date or Duration\n\n        :raises ValueError: if the added duration has a time component.\n        \"\"\"\n        if isinstance(other, (Date, date)):\n            return Duration(days=(self.toordinal() - other.toordinal()))\n        try:\n            return self.__add__(-other)\n        except TypeError:\n            return NotImplemented\n\n    def __copy__(self):\n        return self.__new(self.__ordinal, self.__year, self.__month, self.__day)\n\n    def __deepcopy__(self, *args, **kwargs):\n        return self.__copy__()\n\n    # INSTANCE METHODS #\n\n    def replace(self, **kwargs):\n        \"\"\"Return a :class:`.Date` with one or more components replaced.\n\n        :Keyword Arguments:\n           * **year** (`int`): overwrite the year -\n             default: `self.year`\n           * **month** (`int`): overwrite the month -\n             default: `self.month`\n           * **day** (`int`): overwrite the day -\n             default: `self.day`\n        \"\"\"\n        return Date(kwargs.get(\"year\", self.__year),\n                    kwargs.get(\"month\", self.__month),\n                    kwargs.get(\"day\", self.__day))\n\n    def time_tuple(self):\n        \"\"\"Convert the date to :class:`time.struct_time`.\n\n        :rtype: time.struct_time\n        \"\"\"\n        _, _, day_of_week = self.year_week_day\n        _, day_of_year = self.year_day\n        return struct_time((self.year, self.month, self.day, 0, 0, 0, day_of_week - 1, day_of_year, -1))\n\n    def to_ordinal(self):\n        \"\"\"The date's proleptic Gregorian ordinal.\n\n        The corresponding class method for the reverse ordinal-to-date\n        transformation is :meth:`.Date.from_ordinal`.\n\n        :rtype: int\n        \"\"\"\n        return self.__ordinal\n\n    def to_clock_time(self, epoch):\n        \"\"\"Convert the date to :class:`ClockTime` relative to `epoch`.\n\n        :param epoch: the epoch to which the date is relative\n        :type epoch: Date\n\n        :rtype: ClockTime\n        \"\"\"\n        try:\n            return ClockTime(86400 * (self.to_ordinal() - epoch.to_ordinal()))\n        except AttributeError:\n            raise TypeError(\"Epoch has no ordinal value\")\n\n    def to_native(self):\n        \"\"\"Convert to a native Python :class:`datetime.date` value.\n\n        :rtype: datetime.date\n        \"\"\"\n        return date.fromordinal(self.to_ordinal())\n\n    def weekday(self):\n        \"\"\"The day of the week where Monday is 0 and Sunday is 6.\n\n        :rtype: int\n        \"\"\"\n        return self.year_week_day[2] - 1\n\n    def iso_weekday(self):\n        \"\"\"The day of the week where Monday is 1 and Sunday is 7.\n\n        :rtype: int\n        \"\"\"\n        return self.year_week_day[2]\n\n    def iso_calendar(self):\n        \"\"\"Alias for :attr:`.year_week_day`\"\"\"\n        return self.year_week_day\n\n    def iso_format(self):\n        \"\"\"Return the :class:`.Date` as ISO formatted string.\n\n        :rtype: str\n        \"\"\"\n        if self.__ordinal == 0:\n            return \"0000-00-00\"\n        return \"%04d-%02d-%02d\" % self.year_month_day\n\n    def __repr__(self):\n        \"\"\"\"\"\"\n        if self.__ordinal == 0:\n            return \"neo4j.time.ZeroDate\"\n        return \"neo4j.time.Date(%r, %r, %r)\" % self.year_month_day\n\n    def __str__(self):\n        \"\"\"\"\"\"\n        return self.iso_format()\n\n    def __format__(self, format_spec):\n        \"\"\"\"\"\"\n        raise NotImplementedError()\n\n\nDate.min = Date.from_ordinal(1)\nDate.max = Date.from_ordinal(3652059)\nDate.resolution = Duration(days=1)\n\n#: A :class:`neo4j.time.Date` instance set to `0000-00-00`.\n#: This has an ordinal value of `0`.\nZeroDate = object.__new__(Date)\n\n\nclass Time(metaclass=TimeType):\n    \"\"\"Time of day.\n\n    The :class:`.Time` class is a nanosecond-precision drop-in replacement for\n    the standard library :class:`datetime.time` class.\n\n    A high degree of API compatibility with the standard library classes is\n    provided.\n\n    :class:`neo4j.time.Time` objects introduce the concept of ``ticks``.\n    This is simply a count of the number of nanoseconds since midnight,\n    in many ways analogous to the :class:`neo4j.time.Date` ordinal.\n    `ticks` values are integers, with a minimum value of `0` and a maximum\n    of `86_399_999_999_999`.\n\n    Local times are represented by :class:`.Time` with no ``tzinfo``.\n\n    :param hour: the hour of the time. Must be in range 0 <= hour < 24.\n    :type hour: int\n    :param minute: the minute of the time. Must be in range 0 <= minute < 60.\n    :type minute: int\n    :param second: the second of the time. Must be in range 0 <= second < 60.\n    :type second: int\n    :param nanosecond: the nanosecond of the time.\n        Must be in range 0 <= nanosecond < 999999999.\n    :type nanosecond: int\n    :param tzinfo: timezone or None to get a local :class:`.Time`.\n    :type tzinfo: datetime.tzinfo or None\n\n    :raises ValueError: if one of the parameters is out of range.\n    \"\"\"\n\n    # CONSTRUCTOR #\n\n    def __new__(cls, hour=0, minute=0, second=0, nanosecond=0, tzinfo=None):\n        hour, minute, second, nanosecond = cls.__normalize_nanosecond(\n            hour, minute, second, nanosecond\n        )\n        ticks = (3600000000000 * hour\n                 + 60000000000 * minute\n                 + 1000000000 * second\n                 + nanosecond)\n        return cls.__new(ticks, hour, minute, second, nanosecond, tzinfo)\n\n    @classmethod\n    def __new(cls, ticks, hour, minute, second, nanosecond, tzinfo):\n        instance = object.__new__(cls)\n        instance.__ticks = int(ticks)\n        instance.__hour = int(hour)\n        instance.__minute = int(minute)\n        instance.__second = int(second)\n        instance.__nanosecond = int(nanosecond)\n        instance.__tzinfo = tzinfo\n        return instance\n\n    def __getattr__(self, name):\n        \"\"\"Map standard library attribute names to local attribute names,\n        for compatibility.\n        \"\"\"\n        try:\n            return {\n                \"isoformat\": self.iso_format,\n                \"utcoffset\": self.utc_offset,\n            }[name]\n        except KeyError:\n            raise AttributeError(\"Date has no attribute %r\" % name)\n\n    # CLASS METHODS #\n\n    @classmethod\n    def now(cls, tz=None):\n        \"\"\"Get the current time.\n\n        :param tz: optional timezone\n        :type tz: datetime.tzinfo\n        :rtype: Time\n\n        :raises OverflowError: if the timestamp is out of the range of values\n            supported by the platform C localtime() function. It\u2019s common for\n            this to be restricted to years from 1970 through 2038.\n        \"\"\"\n        if tz is None:\n            return cls.from_clock_time(Clock().local_time(), UnixEpoch)\n        else:\n            return (\n                DateTime.utc_now()\n                .replace(tzinfo=timezone.utc).astimezone(tz)\n                .timetz()\n            )\n\n    @classmethod\n    def utc_now(cls):\n        \"\"\"Get the current time as UTC local time.\n\n        :rtype: Time\n        \"\"\"\n        return cls.from_clock_time(Clock().utc_time(), UnixEpoch)\n\n    @classmethod\n    def from_iso_format(cls, s):\n        \"\"\"Parse a ISO formatted time string.\n\n        Accepted formats:\n            Local times:\n                'hh'\n                'hh:mm'\n                'hh:mm:ss'\n                'hh:mm:ss.ssss...'\n            Times with timezones (UTC offset):\n                '<local time>+hh:mm'\n                '<local time>+hh:mm:ss'\n                '<local time>+hh:mm:ss.ssss....'\n                '<local time>-hh:mm'\n                '<local time>-hh:mm:ss'\n                '<local time>-hh:mm:ss.ssss....'\n\n                Where the UTC offset will only respect hours and minutes.\n                Seconds and sub-seconds are ignored.\n\n        :param s: String to parse\n        :type s: str\n\n        :rtype: Time\n\n        :raises ValueError: if the string does not match the required format.\n        \"\"\"\n        from pytz import FixedOffset\n        m = TIME_ISO_PATTERN.match(s)\n        if m:\n            hour = int(m.group(1))\n            minute = int(m.group(3) or 0)\n            second = int(m.group(6) or 0)\n            nanosecond = m.group(7)\n            if nanosecond:\n                nanosecond = int(nanosecond[1:10].ljust(9, \"0\"))\n            else:\n                nanosecond = 0\n            if m.group(8) is None:\n                return cls(hour, minute, second, nanosecond)\n            else:\n                offset_multiplier = 1 if m.group(9) == \"+\" else -1\n                offset_hour = int(m.group(10))\n                offset_minute = int(m.group(11))\n                # pytz only supports offsets of minute resolution\n                # so we can ignore this part\n                # offset_second = float(m.group(13) or 0.0)\n                offset = 60 * offset_hour + offset_minute\n                return cls(hour, minute, second, nanosecond,\n                           tzinfo=FixedOffset(offset_multiplier * offset))\n        raise ValueError(\"Time string is not in ISO format\")\n\n    @classmethod", "contexts_below": "    @classmethod\n     def from_native(cls, t):\n         \"\"\"Convert from a native Python :class:`datetime.time` value.\n \n         :param t: time to convert from\n         :type t: datetime.time\n \n         :rtype: Time\n         \"\"\"\n         nanosecond = t.microsecond * 1000\n         return Time(t.hour, t.minute, t.second, nanosecond, t.tzinfo)\n \n     @classmethod\n     def from_clock_time(cls, clock_time, epoch):\n         \"\"\"Convert from a :class:`.ClockTime` relative to a given epoch.\n \n         This method, in contrast to most others of this package, assumes days of\n         exactly 24 hours.\n \n         :param clock_time: the clock time as :class:`.ClockTime` or as tuple of\n             (seconds, nanoseconds)\n         :type clock_time: ClockTime or (float, int)\n         :param epoch: the epoch to which `clock_time` is relative\n         :type epoch: DateTime\n \n         :rtype: Time\n         \"\"\"\n         clock_time = ClockTime(*clock_time)\n         ts = clock_time.seconds % 86400\n         nanoseconds = int(NANO_SECONDS * ts + clock_time.nanoseconds)\n         ticks = (epoch.time().ticks + nanoseconds) % (86400 * NANO_SECONDS)\n         return Time.from_ticks(ticks)\n \n     @classmethod\n     def __normalize_hour(cls, hour):\n         hour = int(hour)\n         if 0 <= hour < 24:\n             return hour\n         raise ValueError(\"Hour out of range (0..23)\")\n \n     @classmethod\n     def __normalize_minute(cls, hour, minute):\n         hour = cls.__normalize_hour(hour)\n         minute = int(minute)\n         if 0 <= minute < 60:\n             return hour, minute\n         raise ValueError(\"Minute out of range (0..59)\")\n \n     @classmethod\n     def __normalize_second(cls, hour, minute, second):\n         hour, minute = cls.__normalize_minute(hour, minute)\n         second = int(second)\n         if 0 <= second < 60:\n             return hour, minute, second\n         raise ValueError(\"Second out of range (0..59)\")\n \n     @classmethod\n     def __normalize_nanosecond(cls, hour, minute, second, nanosecond):\n         hour, minute, second = cls.__normalize_second(hour, minute, second)\n         if 0 <= nanosecond < NANO_SECONDS:\n             return hour, minute, second, nanosecond\n         raise ValueError(\"Nanosecond out of range (0..%s)\" % (NANO_SECONDS - 1))\n \n     # CLASS ATTRIBUTES #\n \n     min = None\n     \"\"\"The earliest time value possible.\"\"\"\n \n     max = None\n     \"\"\"The latest time value possible.\"\"\"\n \n     resolution = None\n     \"\"\"The minimum resolution supported.\"\"\"\n \n     # INSTANCE ATTRIBUTES #\n \n     __ticks = 0\n \n     __hour = 0\n \n     __minute = 0\n \n     __second = 0\n \n     __nanosecond = 0\n \n     __tzinfo = None\n \n     @property\n     def ticks(self):\n         \"\"\"The total number of nanoseconds since midnight.\n \n         :type: int\n         \"\"\"\n         return self.__ticks\n \n     @property\n     def hour(self):\n         \"\"\"The hours of the time.\n \n         :type: int\n         \"\"\"\n         return self.__hour\n \n     @property\n     def minute(self):\n         \"\"\"The minutes of the time.\n \n         :type: int\n         \"\"\"\n         return self.__minute\n \n     @property\n     def second(self):\n         \"\"\"The seconds of the time.\n \n         :type: int\n         \"\"\"\n         return self.__second\n \n     @property\n     def nanosecond(self):\n         \"\"\"The nanoseconds of the time.\n \n         :type: int\n         \"\"\"\n         return self.__nanosecond\n \n     @property\n     def hour_minute_second_nanosecond(self):\n         \"\"\"The time as a tuple of (hour, minute, second, nanosecond).\n \n         :type: (int, int, int, int)\"\"\"\n         return self.__hour, self.__minute, self.__second, self.__nanosecond\n \n     @property\n     def tzinfo(self):\n         \"\"\"The timezone of this time.\n \n         :type: datetime.tzinfo or None\"\"\"\n         return self.__tzinfo\n \n     # OPERATIONS #\n \n     def _get_both_normalized_ticks(self, other, strict=True):\n         if (isinstance(other, (time, Time))\n                 and ((self.utc_offset() is None)\n                      ^ (other.utcoffset() is None))):\n             if strict:\n                 raise TypeError(\"can't compare offset-naive and offset-aware \"\n                                 \"times\")\n             else:\n                 return None, None\n         if isinstance(other, Time):\n             other_ticks = other.__ticks\n         elif isinstance(other, time):\n             other_ticks = int(3600000000000 * other.hour\n                               + 60000000000 * other.minute\n                               + NANO_SECONDS * other.second\n                               + 1000 * other.microsecond)\n         else:\n             return None, None\n         utc_offset = other.utcoffset()\n         if utc_offset is not None:\n             other_ticks -= utc_offset.total_seconds() * NANO_SECONDS\n         self_ticks = self.__ticks\n         utc_offset = self.utc_offset()\n         if utc_offset is not None:\n             self_ticks -= utc_offset.total_seconds() * NANO_SECONDS\n         return self_ticks, other_ticks\n \n     def __hash__(self):\n         \"\"\"\"\"\"\n         if self.__nanosecond % 1000 == 0:\n             return hash(self.to_native())\n         self_ticks = self.__ticks\n         if self.utc_offset() is not None:\n             self_ticks -= self.utc_offset().total_seconds() * NANO_SECONDS\n         return hash(self_ticks)\n \n     def __eq__(self, other):\n         \"\"\"`==` comparison with :class:`.Time` or :class:`datetime.time`.\"\"\"\n         self_ticks, other_ticks = self._get_both_normalized_ticks(other,\n                                                                   strict=False)\n         if self_ticks is None:\n             return False\n         return self_ticks == other_ticks\n \n     def __ne__(self, other):\n         \"\"\"`!=` comparison with :class:`.Time` or :class:`datetime.time`.\"\"\"\n         return not self.__eq__(other)\n \n     def __lt__(self, other):\n         \"\"\"`<` comparison with :class:`.Time` or :class:`datetime.time`.\"\"\"\n         self_ticks, other_ticks = self._get_both_normalized_ticks(other)\n         if self_ticks is None:\n             return NotImplemented\n         return self_ticks < other_ticks\n \n     def __le__(self, other):\n         \"\"\"`<=` comparison with :class:`.Time` or :class:`datetime.time`.\"\"\"\n         self_ticks, other_ticks = self._get_both_normalized_ticks(other)\n         if self_ticks is None:\n             return NotImplemented\n         return self_ticks <= other_ticks\n \n     def __ge__(self, other):\n         \"\"\"`>=` comparison with :class:`.Time` or :class:`datetime.time`.\"\"\"\n         self_ticks, other_ticks = self._get_both_normalized_ticks(other)\n         if self_ticks is None:\n             return NotImplemented\n         return self_ticks >= other_ticks\n \n     def __gt__(self, other):\n         \"\"\"`>` comparison with :class:`.Time` or :class:`datetime.time`.\"\"\"\n         self_ticks, other_ticks = self._get_both_normalized_ticks(other)\n         if self_ticks is None:\n             return NotImplemented\n         return self_ticks > other_ticks\n \n     def __copy__(self):\n         return self.__new(self.__ticks, self.__hour, self.__minute,\n                           self.__second, self.__nanosecond, self.__tzinfo)\n \n     def __deepcopy__(self, *args, **kwargs):\n         return self.__copy__()\n \n     # INSTANCE METHODS #\n \n     def replace(self, **kwargs):\n         \"\"\"Return a :class:`.Time` with one or more components replaced.\n \n         :Keyword Arguments:\n            * **hour** (`int`): overwrite the hour -\n              default: `self.hour`\n            * **minute** (`int`): overwrite the minute -\n              default: `self.minute`\n            * **second** (`int`): overwrite the second -\n              default: `int(self.second)`\n            * **nanosecond** (`int`): overwrite the nanosecond -\n              default: `self.nanosecond`\n            * **tzinfo** (`datetime.tzinfo` or `None`): overwrite the timezone -\n              default: `self.tzinfo`\n \n         :rtype: Time\n         \"\"\"\n         return Time(hour=kwargs.get(\"hour\", self.__hour),\n                     minute=kwargs.get(\"minute\", self.__minute),\n                     second=kwargs.get(\"second\", self.__second),\n                     nanosecond=kwargs.get(\"nanosecond\", self.__nanosecond),\n                     tzinfo=kwargs.get(\"tzinfo\", self.__tzinfo))\n \n     def _utc_offset(self, dt=None):\n         if self.tzinfo is None:\n             return None\n         try:\n             value = self.tzinfo.utcoffset(dt)\n         except TypeError:\n             # For timezone implementations not compatible with the custom\n             # datetime implementations, we can't do better than this.\n             value = self.tzinfo.utcoffset(dt.to_native())\n         if value is None:\n             return None\n         if isinstance(value, timedelta):\n             s = value.total_seconds()\n             if not (-86400 < s < 86400):\n                 raise ValueError(\"utcoffset must be less than a day\")\n             if s % 60 != 0 or value.microseconds != 0:\n                 raise ValueError(\"utcoffset must be a whole number of minutes\")\n             return value\n         raise TypeError(\"utcoffset must be a timedelta\")\n \n     def utc_offset(self):\n         \"\"\"Return the UTC offset of this time.\n \n         :return: None if this is a local time (:attr:`.tzinfo` is None), else\n             returns `self.tzinfo.utcoffset(self)`.\n         :rtype: datetime.timedelta\n \n         :raises ValueError: if `self.tzinfo.utcoffset(self)` is not None and a\n             :class:`timedelta` with a magnitude greater equal 1 day or that is\n             not a whole number of minutes.\n         :raises TypeError: if `self.tzinfo.utcoffset(self)` does return anything but\n             None or a :class:`datetime.timedelta`.\n         \"\"\"\n         return self._utc_offset()\n \n     def dst(self):\n         \"\"\"Get the daylight saving time adjustment (DST).\n \n         :return: None if this is a local time (:attr:`.tzinfo` is None), else\n             returns `self.tzinfo.dst(self)`.\n         :rtype: datetime.timedelta\n \n         :raises ValueError: if `self.tzinfo.dst(self)` is not None and a\n             :class:`timedelta` with a magnitude greater equal 1 day or that is\n             not a whole number of minutes.\n         :raises TypeError: if `self.tzinfo.dst(self)` does return anything but\n             None or a :class:`datetime.timedelta`.\n         \"\"\"\n         if self.tzinfo is None:\n             return None\n         try:\n             value = self.tzinfo.dst(self)\n         except TypeError:\n             # For timezone implementations not compatible with the custom\n             # datetime implementations, we can't do better than this.\n             value = self.tzinfo.dst(self.to_native())\n         if value is None:\n             return None\n         if isinstance(value, timedelta):\n             if value.days != 0:\n                 raise ValueError(\"dst must be less than a day\")\n             if value.seconds % 60 != 0 or value.microseconds != 0:\n                 raise ValueError(\"dst must be a whole number of minutes\")\n             return value\n         raise TypeError(\"dst must be a timedelta\")\n \n     def tzname(self):\n         \"\"\"Get the name of the :class:`.Time`'s timezone.\n \n         :returns: None if the time is local (i.e., has no timezone), else return\n             `self.tzinfo.tzname(self)`\n \n         :rtype: str or None\n         \"\"\"\n         if self.tzinfo is None:\n             return None\n         try:\n             return self.tzinfo.tzname(self)\n         except TypeError:\n             # For timezone implementations not compatible with the custom\n             # datetime implementations, we can't do better than this.\n             return self.tzinfo.tzname(self.to_native())\n \n     def to_clock_time(self):\n         \"\"\"Convert to :class:`.ClockTime`.\n \n         :rtype: ClockTime\n         \"\"\"\n         seconds, nanoseconds = divmod(self.ticks, NANO_SECONDS)\n         return ClockTime(seconds, nanoseconds)\n \n     def to_native(self):\n         \"\"\"Convert to a native Python `datetime.time` value.\n \n         This conversion is lossy as the native time implementation only supports\n         a resolution of microseconds instead of nanoseconds.\n \n         :rtype: datetime.time\n         \"\"\"\n         h, m, s, ns = self.hour_minute_second_nanosecond\n         \u00b5s = round_half_to_even(ns / 1000)\n         tz = self.tzinfo\n         return time(h, m, s, \u00b5s, tz)\n \n     def iso_format(self):\n         \"\"\"Return the :class:`.Time` as ISO formatted string.\n \n         :rtype: str\n         \"\"\"\n         s = \"%02d:%02d:%02d.%09d\" % self.hour_minute_second_nanosecond\n         offset = self.utc_offset()\n         if offset is not None:\n             s += \"%+03d:%02d\" % divmod(offset.total_seconds() // 60, 60)\n         return s\n \n     def __repr__(self):\n         \"\"\"\"\"\"\n         if self.tzinfo is None:\n             return \"neo4j.time.Time(%r, %r, %r, %r)\" % \\\n                    self.hour_minute_second_nanosecond\n         else:\n             return \"neo4j.time.Time(%r, %r, %r, %r, tzinfo=%r)\" % \\\n                    (self.hour_minute_second_nanosecond + (self.tzinfo,))\n \n     def __str__(self):\n         \"\"\"\"\"\"\n         return self.iso_format()\n \n     def __format__(self, format_spec):\n         \"\"\"\"\"\"\n         raise NotImplementedError()\n \n \n Time.min = Time(hour=0, minute=0, second=0, nanosecond=0)\n Time.max = Time(hour=23, minute=59, second=59, nanosecond=999999999)\n Time.resolution = Duration(nanoseconds=1)\n \n #: A :class:`.Time` instance set to `00:00:00`.\n #: This has a :attr:`.ticks` value of `0`.\n Midnight = Time.min\n \n #: A :class:`.Time` instance set to `12:00:00`.\n #: This has a :attr:`.ticks` value of `43200000000000`.\n Midday = Time(hour=12)\n \n \n @total_ordering\n class DateTime(metaclass=DateTimeType):\n     \"\"\"A point in time represented as a date and a time.\n \n     The :class:`.DateTime` class is a nanosecond-precision drop-in replacement\n     for the standard library :class:`datetime.datetime` class.\n \n     As such, it contains both :class:`.Date` and :class:`.Time` information and\n     draws functionality from those individual classes.\n \n     A :class:`.DateTime` object is fully compatible with the Python time zone\n     library `pytz <https://pypi.org/project/pytz/>`_. Functions such as\n     `normalize` and `localize` can be used in the same way as they are with the\n     standard library classes.\n \n     Regular construction of a :class:`.DateTime` object requires at\n     least the `year`, `month` and `day` arguments to be supplied. The\n     optional `hour`, `minute` and `second` arguments default to zero and\n     `tzinfo` defaults to :const:`None`.\n \n     `year`, `month`, and `day` are passed to the constructor of :class:`.Date`.\n     `hour`, `minute`, `second`, `nanosecond`, and `tzinfo` are passed to the\n     constructor of :class:`.Time`. See their documentation for more details.\n \n         >>> dt = DateTime(2018, 4, 30, 12, 34, 56, 789123456); dt\n         neo4j.time.DateTime(2018, 4, 30, 12, 34, 56, 789123456)\n         >>> dt.second\n         56.789123456\n     \"\"\"\n \n     # CONSTRUCTOR #\n \n     def __new__(cls, year, month, day, hour=0, minute=0, second=0, nanosecond=0,\n                 tzinfo=None):\n         return cls.combine(Date(year, month, day),\n                            Time(hour, minute, second, nanosecond, tzinfo))\n \n     def __getattr__(self, name):\n         \"\"\" Map standard library attribute names to local attribute names,\n         for compatibility.\n         \"\"\"\n         try:\n             return {\n                 \"astimezone\": self.as_timezone,\n                 \"isocalendar\": self.iso_calendar,\n                 \"isoformat\": self.iso_format,\n                 \"isoweekday\": self.iso_weekday,\n                 \"strftime\": self.__format__,\n                 \"toordinal\": self.to_ordinal,\n                 \"timetuple\": self.time_tuple,\n                 \"utcoffset\": self.utc_offset,\n                 \"utctimetuple\": self.utc_time_tuple,\n             }[name]\n         except KeyError:\n             raise AttributeError(\"DateTime has no attribute %r\" % name)\n \n     # CLASS METHODS #\n \n     @classmethod\n     def now(cls, tz=None):\n         \"\"\"Get the current date and time.\n \n         :param tz: timezone. Set to None to create a local :class:`.DateTime`.\n         :type tz: datetime.tzinfo` or None\n \n         :rtype: DateTime\n \n         :raises OverflowError: if the timestamp is out of the range of values\n             supported by the platform C localtime() function. It\u2019s common for\n             this to be restricted to years from 1970 through 2038.\n         \"\"\"\n         if tz is None:\n             return cls.from_clock_time(Clock().local_time(), UnixEpoch)\n         else:\n             try:\n                 return tz.fromutc(cls.from_clock_time(\n                     Clock().utc_time(), UnixEpoch\n                 ).replace(tzinfo=tz))\n             except TypeError:\n                 # For timezone implementations not compatible with the custom\n                 # datetime implementations, we can't do better than this.\n                 utc_now = cls.from_clock_time(\n                     Clock().utc_time(), UnixEpoch\n                 )\n                 utc_now_native = utc_now.to_native()\n                 now_native = tz.fromutc(utc_now_native)\n                 now = cls.from_native(now_native)\n                 return now.replace(\n                     nanosecond=(now.nanosecond\n                                 + utc_now.nanosecond\n                                 - utc_now_native.microsecond * 1000)\n                 )\n \n     @classmethod\n     def utc_now(cls):\n         \"\"\"Get the current date and time in UTC\n \n         :rtype: DateTime\n         \"\"\"\n         return cls.from_clock_time(Clock().utc_time(), UnixEpoch)\n \n     @classmethod\n     def from_iso_format(cls, s):\n         \"\"\"Parse a ISO formatted date with time string.\n \n         :param s: String to parse\n         :type s: str\n \n         :rtype: Time\n \n         :raises ValueError: if the string does not match the ISO format.\n         \"\"\"\n         try:\n             return cls.combine(Date.from_iso_format(s[0:10]),\n                                Time.from_iso_format(s[11:]))\n         except ValueError:\n             raise ValueError(\"DateTime string is not in ISO format\")\n \n     @classmethod\n     def from_timestamp(cls, timestamp, tz=None):\n         \"\"\":class:`.DateTime` from a time stamp (seconds since unix epoch).\n \n         :param timestamp: the unix timestamp (seconds since unix epoch).\n         :type timestamp: float\n         :param tz: timezone. Set to None to create a local :class:`.DateTime`.\n         :type tz: datetime.tzinfo or None\n \n         :rtype: DateTime\n \n         :raises OverflowError: if the timestamp is out of the range of values\n             supported by the platform C localtime() function. It\u2019s common for\n             this to be restricted to years from 1970 through 2038.\n         \"\"\"\n         if tz is None:\n             return cls.from_clock_time(\n                 ClockTime(timestamp) + Clock().local_offset(), UnixEpoch\n             )\n         else:\n             return (\n                 cls.utc_from_timestamp(timestamp)\n                 .replace(tzinfo=timezone.utc).astimezone(tz)\n             )\n \n     @classmethod\n     def utc_from_timestamp(cls, timestamp):\n         \"\"\":class:`.DateTime` from a time stamp (seconds since unix epoch).\n \n         Returns the `DateTime` as local date `DateTime` in UTC.\n \n         :rtype: DateTime\n         \"\"\"\n         return cls.from_clock_time((timestamp, 0), UnixEpoch)\n \n     @classmethod\n     def from_ordinal(cls, ordinal):\n         \"\"\":class:`.DateTime` from an ordinal.\n \n         For more info about ordinals see :meth:`.Date.from_ordinal`.\n \n         :rtype: DateTime\n         \"\"\"\n         return cls.combine(Date.from_ordinal(ordinal), Midnight)\n \n     @classmethod\n     def combine(cls, date, time):\n         \"\"\"Combine a :class:`.Date` and a :class:`.Time` to a :class:`DateTime`.\n \n         :param date: the date\n         :type date: Date\n         :param time: the time\n         :type time: Time\n \n         :rtype: DateTime\n \n         :raises AssertionError: if the parameter types don't match.\n         \"\"\"\n         assert isinstance(date, Date)\n         assert isinstance(time, Time)\n         instance = object.__new__(cls)\n         instance.__date = date\n         instance.__time = time\n         return instance\n \n     @classmethod\n     def parse(cls, date_string, format):\n         raise NotImplementedError()\n \n     @classmethod\n     def from_native(cls, dt):\n         \"\"\"Convert from a native Python :class:`datetime.datetime` value.\n \n         :param dt: the datetime to convert\n         :type dt: datetime.datetime\n \n         :rtype: DateTime\n         \"\"\"\n         return cls.combine(Date.from_native(dt.date()), Time.from_native(dt.timetz()))\n \n     @classmethod\n     def from_clock_time(cls, clock_time, epoch):\n         \"\"\"Convert from a :class:`ClockTime` relative to a given epoch.\n \n         :param clock_time: the clock time as :class:`.ClockTime` or as tuple of\n             (seconds, nanoseconds)\n         :type clock_time: ClockTime or (float, int)\n         :param epoch: the epoch to which `clock_time` is relative\n         :type epoch: DateTime\n \n         :rtype: DateTime\n \n         :raises ValueError: if `clock_time` is invalid.\n         \"\"\"\n         try:\n             seconds, nanoseconds = ClockTime(*clock_time)\n         except (TypeError, ValueError):\n             raise ValueError(\"Clock time must be a 2-tuple of (s, ns)\")\n         else:\n             ordinal, seconds = divmod(seconds, 86400)\n             ticks = epoch.time().ticks + seconds * NANO_SECONDS + nanoseconds\n             days, ticks = divmod(ticks, 86400 * NANO_SECONDS)\n             ordinal += days\n             date_ = Date.from_ordinal(ordinal + epoch.date().to_ordinal())\n             time_ = Time.from_ticks(ticks)\n             return cls.combine(date_, time_)\n \n     # CLASS ATTRIBUTES #\n \n     min = None\n     \"\"\"The earliest date time value possible.\"\"\"\n \n     max = None\n     \"\"\"The latest date time value possible.\"\"\"\n \n     resolution = None\n     \"\"\"The minimum resolution supported.\"\"\"\n \n     # INSTANCE ATTRIBUTES #\n \n     @property\n     def year(self):\n         \"\"\"The year of the :class:`.DateTime`.\n \n         See :attr:`.Date.year`.\n         \"\"\"\n         return self.__date.year\n \n     @property\n     def month(self):\n         \"\"\"The year of the :class:`.DateTime`.\n \n         See :attr:`.Date.year`.\"\"\"\n         return self.__date.month\n \n     @property\n     def day(self):\n         \"\"\"The day of the :class:`.DateTime`'s date.\n \n         See :attr:`.Date.day`.\"\"\"\n         return self.__date.day\n \n     @property\n     def year_month_day(self):\n         \"\"\"The year_month_day of the :class:`.DateTime`'s date.\n \n         See :attr:`.Date.year_month_day`.\"\"\"\n         return self.__date.year_month_day\n \n     @property\n     def year_week_day(self):\n         \"\"\"The year_week_day of the :class:`.DateTime`'s date.\n \n         See :attr:`.Date.year_week_day`.\"\"\"\n         return self.__date.year_week_day\n \n     @property\n     def year_day(self):\n         \"\"\"The year_day of the :class:`.DateTime`'s date.\n \n         See :attr:`.Date.year_day`.\"\"\"\n         return self.__date.year_day\n \n     @property\n     def hour(self):\n         \"\"\"The hour of the :class:`.DateTime`'s time.\n \n         See :attr:`.Time.hour`.\"\"\"\n         return self.__time.hour\n \n     @property\n     def minute(self):\n         \"\"\"The minute of the :class:`.DateTime`'s time.\n \n         See :attr:`.Time.minute`.\"\"\"\n         return self.__time.minute\n \n     @property\n     def second(self):\n         \"\"\"The second of the :class:`.DateTime`'s time.\n \n         See :attr:`.Time.second`.\"\"\"\n         return self.__time.second\n \n     @property\n     def nanosecond(self):\n         \"\"\"The nanosecond of the :class:`.DateTime`'s time.\n \n         See :attr:`.Time.nanosecond`.\"\"\"\n         return self.__time.nanosecond\n \n     @property\n     def tzinfo(self):\n         \"\"\"The tzinfo of the :class:`.DateTime`'s time.\n \n         See :attr:`.Time.tzinfo`.\"\"\"\n         return self.__time.tzinfo\n \n     @property\n     def hour_minute_second_nanosecond(self):\n         \"\"\"The hour_minute_second_nanosecond of the :class:`.DateTime`'s time.\n \n         See :attr:`.Time.hour_minute_second_nanosecond`.\"\"\"\n         return self.__time.hour_minute_second_nanosecond\n \n     # OPERATIONS #\n \n     def _get_both_normalized(self, other, strict=True):\n         if (isinstance(other, (datetime, DateTime))\n                 and ((self.utc_offset() is None)\n                      ^ (other.utcoffset() is None))):\n             if strict:\n                 raise TypeError(\"can't compare offset-naive and offset-aware \"\n                                 \"datetimes\")\n             else:\n                 return None, None\n         self_norm = self\n         utc_offset = self.utc_offset()\n         if utc_offset is not None:\n             self_norm -= utc_offset\n         self_norm = self_norm.replace(tzinfo=None)\n         other_norm = other\n         if isinstance(other, (datetime, DateTime)):\n             utc_offset = other.utcoffset()\n             if utc_offset is not None:\n                 other_norm -= utc_offset\n             other_norm = other_norm.replace(tzinfo=None)\n         else:\n             return None, None\n         return self_norm, other_norm\n \n     def __hash__(self):\n         \"\"\"\"\"\"\n         if self.nanosecond % 1000 == 0:\n             return hash(self.to_native())\n         self_norm = self\n         utc_offset = self.utc_offset()\n         if utc_offset is not None:\n             self_norm -= utc_offset\n         return hash(self_norm.date()) ^ hash(self_norm.time())\n \n     def __eq__(self, other):\n         \"\"\"\n         `==` comparison with :class:`.DateTime` or :class:`datetime.datetime`.\n         \"\"\"\n         if not isinstance(other, (datetime, DateTime)):\n             return NotImplemented\n         if self.utc_offset() == other.utcoffset():\n             return self.date() == other.date() and self.time() == other.time()\n         self_norm, other_norm = self._get_both_normalized(other, strict=False)\n         if self_norm is None:\n             return False\n         return self_norm == other_norm\n \n     def __ne__(self, other):\n         \"\"\"\n         `!=` comparison with :class:`.DateTime` or :class:`datetime.datetime`.\n         \"\"\"\n         return not self.__eq__(other)\n \n     def __lt__(self, other):\n         \"\"\"\n         `<` comparison with :class:`.DateTime` or :class:`datetime.datetime`.\n         \"\"\"\n         if not isinstance(other, (datetime, DateTime)):\n             return NotImplemented\n         if self.utc_offset() == other.utcoffset():\n             if self.date() == other.date():\n                 return self.time() < other.time()\n             return self.date() < other.date()\n         self_norm, other_norm = self._get_both_normalized(other)\n         return (self_norm.date() < other_norm.date()\n                 or self_norm.time() < other_norm.time())\n \n     def __le__(self, other):\n         \"\"\"\n         `<=` comparison with :class:`.DateTime` or :class:`datetime.datetime`.\n         \"\"\"\n         if not isinstance(other, (datetime, DateTime)):\n             return NotImplemented\n         if self.utc_offset() == other.utcoffset():\n             if self.date() == other.date():\n                 return self.time() <= other.time()\n             return self.date() <= other.date()\n         self_norm, other_norm = self._get_both_normalized(other)\n         return self_norm <= other_norm\n \n     def __ge__(self, other):\n         \"\"\"\n         `>=` comparison with :class:`.DateTime` or :class:`datetime.datetime`.\n         \"\"\"\n         if not isinstance(other, (datetime, DateTime)):\n             return NotImplemented\n         if self.utc_offset() == other.utcoffset():\n             if self.date() == other.date():\n                 return self.time() >= other.time()\n             return self.date() >= other.date()\n         self_norm, other_norm = self._get_both_normalized(other)\n         return self_norm >= other_norm\n \n     def __gt__(self, other):\n         \"\"\"\n         `>` comparison with :class:`.DateTime` or :class:`datetime.datetime`.\n         \"\"\"\n         if not isinstance(other, (datetime, DateTime)):\n             return NotImplemented\n         if self.utc_offset() == other.utcoffset():\n             if self.date() == other.date():\n                 return self.time() > other.time()\n             return self.date() > other.date()\n         self_norm, other_norm = self._get_both_normalized(other)\n         return (self_norm.date() > other_norm.date()\n                 or self_norm.time() > other_norm.time())\n \n     def __add__(self, other):\n         \"\"\"Add a :class:`datetime.timedelta`.\n \n         :rtype: DateTime\n         \"\"\"\n         if isinstance(other, timedelta):\n             t = (self.to_clock_time()\n                  + ClockTime(86400 * other.days + other.seconds,\n                              other.microseconds * 1000))\n             days, seconds = symmetric_divmod(t.seconds, 86400)\n             date_ = Date.from_ordinal(days + 1)\n             time_ = Time.from_ticks(round_half_to_even(\n                 seconds * NANO_SECONDS + t.nanoseconds\n             ))\n             return self.combine(date_, time_).replace(tzinfo=self.tzinfo)\n         if isinstance(other, Duration):\n             t = (self.to_clock_time()\n                  + ClockTime(other.seconds, other.nanoseconds))\n             days, seconds = symmetric_divmod(t.seconds, 86400)\n             date_ = self.date() + Duration(months=other.months,\n                                            days=days + other.days)\n             time_ = Time.from_ticks(seconds * NANO_SECONDS + t.nanoseconds)\n             return self.combine(date_, time_).replace(tzinfo=self.tzinfo)\n         return NotImplemented\n \n     def __sub__(self, other):\n         \"\"\"Subtract a datetime or a timedelta.\n \n          Supported :class:`.DateTime` (returns :class:`.Duration`),\n          :class:`datetime.datetime` (returns :class:`datetime.timedelta`), and\n          :class:`datetime.timedelta` (returns :class:`.DateTime`).\n \n         :rtype: Duration or datetime.timedelta or DateTime\n         \"\"\"\n         if isinstance(other, DateTime):\n             self_month_ordinal = 12 * (self.year - 1) + self.month\n             other_month_ordinal = 12 * (other.year - 1) + other.month\n             months = self_month_ordinal - other_month_ordinal\n             days = self.day - other.day\n             t = self.time().to_clock_time() - other.time().to_clock_time()\n             return Duration(months=months, days=days, seconds=t.seconds,\n                             nanoseconds=t.nanoseconds)\n         if isinstance(other, datetime):\n             days = self.to_ordinal() - other.toordinal()\n             t = (self.time().to_clock_time()\n                  - ClockTime(\n                        3600 * other.hour + 60 * other.minute + other.second,\n                        other.microsecond * 1000\n                     ))\n             return timedelta(days=days, seconds=t.seconds,\n                              microseconds=(t.nanoseconds // 1000))\n         if isinstance(other, Duration):\n             return self.__add__(-other)\n         if isinstance(other, timedelta):\n             return self.__add__(-other)\n         return NotImplemented\n \n     def __copy__(self):\n         return self.combine(self.__date, self.__time)\n \n     def __deepcopy__(self, *args, **kwargs):\n         return self.__copy__()\n \n     # INSTANCE METHODS #\n \n     def date(self):\n         \"\"\"The date\n \n         :rtype: Date\n         \"\"\"\n         return self.__date\n \n     def time(self):\n         \"\"\"The time without timezone info\n \n         :rtype: Time\n         \"\"\"\n         return self.__time.replace(tzinfo=None)\n \n     def timetz(self):\n         \"\"\"The time with timezone info\n \n         :rtype: Time\n         \"\"\"\n         return self.__time\n \n     def replace(self, **kwargs):\n         \"\"\"Return a :class:`.DateTime` with one or more components replaced.\n \n         See :meth:`.Date.replace` and :meth:`.Time.replace` for available\n         arguments.\n \n         :rtype: DateTime\n         \"\"\"\n         date_ = self.__date.replace(**kwargs)\n         time_ = self.__time.replace(**kwargs)\n         return self.combine(date_, time_)\n \n     def as_timezone(self, tz):\n         \"\"\"Convert this :class:`.DateTime` to another timezone.\n \n         :param tz: the new timezone\n         :type tz: datetime.tzinfo or None\n \n         :return: the same object if `tz` is None. Else, a new :class:`.DateTime`\n             that's the same point in time but in a different timezone.\n         :rtype: DateTime\n         \"\"\"\n         if self.tzinfo is None:\n             return self\n         utc = (self - self.utc_offset()).replace(tzinfo=tz)\n         try:\n             return tz.fromutc(utc)\n         except TypeError:\n             # For timezone implementations not compatible with the custom\n             # datetime implementations, we can't do better than this.\n             native_utc = utc.to_native()\n             native_res = tz.fromutc(native_utc)\n             res = self.from_native(native_res)\n             return res.replace(\n                 nanosecond=(native_res.microsecond * 1000\n                             + self.nanosecond % 1000)\n             )\n \n     def utc_offset(self):\n         \"\"\"Get the date times utc offset.\n \n         See :meth:`.Time.utc_offset`.\n         \"\"\"\n \n         return self.__time._utc_offset(self)\n \n     def dst(self):\n         \"\"\"Get the daylight saving time adjustment (DST).\n \n         See :meth:`.Time.dst`.\n         \"\"\"\n         return self.__time.dst()\n \n     def tzname(self):\n         \"\"\"Get the timezone name.\n \n         See :meth:`.Time.tzname`.\n         \"\"\"\n         return self.__time.tzname()\n \n     def time_tuple(self):\n         raise NotImplementedError()\n \n     def utc_time_tuple(self):\n         raise NotImplementedError()\n \n     def to_ordinal(self):\n         \"\"\"Get the ordinal of the :class:`.DateTime`'s date.\n \n         See :meth:`.Date.to_ordinal`\n         \"\"\"\n         return self.__date.to_ordinal()\n \n     def to_clock_time(self):\n         \"\"\"Convert to :class:`.ClockTime`.\n \n         :rtype: ClockTime\n         \"\"\"\n         total_seconds = 0\n         for year in range(1, self.year):\n             total_seconds += 86400 * DAYS_IN_YEAR[year]\n         for month in range(1, self.month):\n             total_seconds += 86400 * Date.days_in_month(self.year, month)\n         total_seconds += 86400 * (self.day - 1)\n         seconds, nanoseconds = divmod(self.__time.ticks, NANO_SECONDS)\n         return ClockTime(total_seconds + seconds, nanoseconds)\n \n     def to_native(self):\n         \"\"\"Convert to a native Python :class:`datetime.datetime` value.\n \n         This conversion is lossy as the native time implementation only supports\n         a resolution of microseconds instead of nanoseconds.\n \n         :rtype: datetime.datetime\n         \"\"\"\n         y, mo, d = self.year_month_day\n         h, m, s, ns = self.hour_minute_second_nanosecond\n         ms = int(ns / 1000)\n         tz = self.tzinfo\n         return datetime(y, mo, d, h, m, s, ms, tz)\n \n     def weekday(self):\n         \"\"\"Get the weekday.\n \n         See :meth:`.Date.weekday`\n         \"\"\"\n         return self.__date.weekday()\n \n     def iso_weekday(self):\n         \"\"\"Get the ISO weekday.\n \n         See :meth:`.Date.iso_weekday`\n         \"\"\"\n         return self.__date.iso_weekday()\n \n     def iso_calendar(self):\n         \"\"\"Get date as ISO tuple.\n \n         See :meth:`.Date.iso_calendar`\n         \"\"\"\n         return self.__date.iso_calendar()\n \n     def iso_format(self, sep=\"T\"):\n         \"\"\"Return the :class:`.DateTime` as ISO formatted string.\n \n         This method joins `self.date().iso_format()` (see\n         :meth:`.Date.iso_format`) and `self.timetz().iso_format()` (see\n         :meth:`.Time.iso_format`) with `sep` in between.\n \n         :param sep: the separator between the formatted date and time.\n         :type sep: str\n \n         :rtype: str\n         \"\"\"\n         s = \"%s%s%s\" % (self.date().iso_format(), sep,\n                         self.timetz().iso_format())\n         time_tz = self.timetz()\n         offset = time_tz.utc_offset()\n         if offset is not None:\n             # the time component will have taken care of formatting the offset\n             return s\n         offset = self.utc_offset()\n         if offset is not None:\n             s += \"%+03d:%02d\" % divmod(offset.total_seconds() // 60, 60)\n         return s\n \n     def __repr__(self):\n         \"\"\"\"\"\"\n         if self.tzinfo is None:\n             fields = (*self.year_month_day,\n                       *self.hour_minute_second_nanosecond)\n             return \"neo4j.time.DateTime(%r, %r, %r, %r, %r, %r, %r)\" % fields\n         else:\n             fields = (*self.year_month_day,\n                       *self.hour_minute_second_nanosecond, self.tzinfo)\n             return (\"neo4j.time.DateTime(%r, %r, %r, %r, %r, %r, %r, tzinfo=%r)\"\n                     % fields)\n \n     def __str__(self):\n         \"\"\"\"\"\"\n         return self.iso_format()\n \n     def __format__(self, format_spec):\n         \"\"\"\"\"\"\n         raise NotImplementedError()\n \n \n DateTime.min = DateTime.combine(Date.min, Time.min)\n DateTime.max = DateTime.combine(Date.max, Time.max)\n DateTime.resolution = Time.resolution\n \n #: A :class:`.DateTime` instance set to `0000-00-00T00:00:00`.\n #: This has a :class:`.Date` component equal to :attr:`ZeroDate` and a\n Never = DateTime.combine(ZeroDate, Midnight)\n \n #: A :class:`.DateTime` instance set to `1970-01-01T00:00:00`.\n UnixEpoch = DateTime(1970, 1, 1, 0, 0, 0)\n ", "input_code": "@classmethod\ndef from_ticks(cls, ticks, tz=None):\n\"\"\"\nCreate a time from ticks (nanoseconds since midnight).\n\n:param ticks: nanoseconds since midnight\n:type ticks: int\n:param tz: optional timezone\n:type tz: datetime.tzinfo\n\n:rtype: Time\n\n:raises ValueError: if ticks is out of bounds\n    (0 <= ticks < 86400000000000)\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @classmethod\n    def from_ticks(cls, ticks, tz=None):\n        \"\"\"Create a time from ticks (nanoseconds since midnight).\n\n        :param ticks: nanoseconds since midnight\n        :type ticks: int\n        :param tz: optional timezone\n        :type tz: datetime.tzinfo\n\n        :rtype: Time\n\n        :raises ValueError: if ticks is out of bounds\n            (0 <= ticks < 86400000000000)\n        \"\"\"\n        if not isinstance(ticks, int):\n            raise TypeError(\"Ticks must be int\")\n        if 0 <= ticks < 86400000000000:\n            second, nanosecond = divmod(ticks, NANO_SECONDS)\n            minute, second = divmod(second, 60)\n            hour, minute = divmod(minute, 60)\n            return cls.__new(ticks, hour, minute, second, nanosecond, tz)\n        raise ValueError(\"Ticks out of range (0..86400000000000)\")", "signature": "@classmethod\ndef from_ticks(cls, ticks, tz=None):", "completion_path": "neo4j/time/__init__.py"}
{"ce_id": "62e60873d76274f8a4026bd8", "namespace": "62e60873d76274f8a4026bd8", "namespace_real": "neo4j._async.io._bolt.protocol_handlers", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "class", "class_name": "_bolt", "function_name": "protocol_handlers", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport abc\nimport asyncio\nfrom collections import deque\nfrom logging import getLogger\nfrom time import perf_counter\n\nfrom ..._async_compat.network import AsyncBoltSocket\nfrom ..._async_compat.util import AsyncUtil\nfrom ..._codec.hydration import v1 as hydration_v1\nfrom ..._codec.packstream import v1 as packstream_v1\nfrom ..._conf import PoolConfig\nfrom ..._exceptions import (\n    BoltError,\n    BoltHandshakeError,\n    SocketDeadlineExceeded,\n)\nfrom ..._meta import get_user_agent\nfrom ...addressing import Address\nfrom ...api import (\n    ServerInfo,\n    Version,\n)\nfrom ...exceptions import (\n    AuthError,\n    DriverError,\n    IncompleteCommit,\n    ServiceUnavailable,\n    SessionExpired,\n)\nfrom ._common import (\n    AsyncInbox,\n    AsyncOutbox,\n    CommitResponse,\n)\n\n\n# Set up logger\nlog = getLogger(\"neo4j\")\n\n\nclass AsyncBolt:\n    \"\"\" Server connection for Bolt protocol.\n\n    A :class:`.Bolt` should be constructed following a\n    successful .open()\n\n    Bolt handshake and takes the socket over which\n    the handshake was carried out.\n    \"\"\"\n\n    # TODO: let packer/unpacker know of hydration (give them hooks?)\n    # TODO: make sure query parameter dehydration gets clear error message.\n\n    PACKER_CLS = packstream_v1.Packer\n    UNPACKER_CLS = packstream_v1.Unpacker\n    HYDRATION_HANDLER_CLS = hydration_v1.HydrationHandler\n\n    MAGIC_PREAMBLE = b\"\\x60\\x60\\xB0\\x17\"\n\n    PROTOCOL_VERSION = None\n\n    # flag if connection needs RESET to go back to READY state\n    is_reset = False\n\n    # The socket\n    in_use = False\n\n    # When the connection was last put back into the pool\n    idle_since = float(\"-inf\")\n\n    # The socket\n    _closing = False\n    _closed = False\n\n    # The socket\n    _defunct = False\n\n    #: The pool of which this connection is a member\n    pool = None\n\n    # Store the id of the most recent ran query to be able to reduce sent bits by\n    # using the default (-1) to refer to the most recent query when pulling\n    # results for it.\n    most_recent_qid = None\n\n    def __init__(self, unresolved_address, sock, max_connection_lifetime, *,\n                 auth=None, user_agent=None, routing_context=None):\n        self.unresolved_address = unresolved_address\n        self.socket = sock\n        self.local_port = self.socket.getsockname()[1]\n        self.server_info = ServerInfo(Address(sock.getpeername()),\n                                      self.PROTOCOL_VERSION)\n        # so far `connection.recv_timeout_seconds` is the only available\n        # configuration hint that exists. Therefore, all hints can be stored at\n        # connection level. This might change in the future.\n        self.configuration_hints = {}\n        self.patch = {}\n        self.outbox = AsyncOutbox(\n            self.socket, on_error=self._set_defunct_write,\n            packer_cls=self.PACKER_CLS\n        )\n        self.inbox = AsyncInbox(\n            self.socket, on_error=self._set_defunct_read,\n            unpacker_cls=self.UNPACKER_CLS\n        )\n        self.hydration_handler = self.HYDRATION_HANDLER_CLS()\n        self.responses = deque()\n        self._max_connection_lifetime = max_connection_lifetime\n        self._creation_timestamp = perf_counter()\n        self.routing_context = routing_context\n        self.idle_since = perf_counter()\n\n        # Determine the user agent\n        if user_agent:\n            self.user_agent = user_agent\n        else:\n            self.user_agent = get_user_agent()\n\n        # Determine auth details\n        if not auth:\n            self.auth_dict = {}\n        elif isinstance(auth, tuple) and 2 <= len(auth) <= 3:\n            from neo4j import Auth\n            self.auth_dict = vars(Auth(\"basic\", *auth))\n        else:\n            try:\n                self.auth_dict = vars(auth)\n            except (KeyError, TypeError):\n                raise AuthError(\"Cannot determine auth details from %r\" % auth)\n\n        # Check for missing password\n        try:\n            credentials = self.auth_dict[\"credentials\"]\n        except KeyError:\n            pass\n        else:\n            if credentials is None:\n                raise AuthError(\"Password cannot be None\")\n\n    def __del__(self):\n        if not asyncio.iscoroutinefunction(self.close):\n            self.close()\n\n    @property\n    @abc.abstractmethod\n    def supports_multiple_results(self):\n        \"\"\" Boolean flag to indicate if the connection version supports multiple\n        queries to be buffered on the server side (True) or if all results need\n        to be eagerly pulled before sending the next RUN (False).\n        \"\"\"\n        pass\n\n    @property\n    @abc.abstractmethod\n    def supports_multiple_databases(self):\n        \"\"\" Boolean flag to indicate if the connection version supports multiple\n        databases.\n        \"\"\"\n        pass\n\n    @classmethod", "contexts_below": "    @classmethod\n     def version_list(cls, versions, limit=4):\n         \"\"\" Return a list of supported protocol versions in order of\n         preference. The number of protocol versions (or ranges)\n         returned is limited to four.\n         \"\"\"\n         # In fact, 4.3 is the fist version to support ranges. However, the\n         # range support got backported to 4.2. But even if the server is too\n         # old to have the backport, negotiating BOLT 4.1 is no problem as it's\n         # equivalent to 4.2\n         first_with_range_support = Version(4, 2)\n         result = []\n         for version in versions:\n             if (result\n                     and version >= first_with_range_support\n                     and result[-1][0] == version[0]\n                     and result[-1][1][1] == version[1] + 1):\n                 # can use range to encompass this version\n                 result[-1][1][1] = version[1]\n                 continue\n             result.append(Version(version[0], [version[1], version[1]]))\n             if len(result) == 4:\n                 break\n         return result\n \n     @classmethod\n     def get_handshake(cls):\n         \"\"\" Return the supported Bolt versions as bytes.\n         The length is 16 bytes as specified in the Bolt version negotiation.\n         :return: bytes\n         \"\"\"\n         supported_versions = sorted(cls.protocol_handlers().keys(), reverse=True)\n         offered_versions = cls.version_list(supported_versions)\n         return b\"\".join(version.to_bytes() for version in offered_versions).ljust(16, b\"\\x00\")\n \n     @classmethod\n     async def ping(cls, address, *, timeout=None, **config):\n         \"\"\" Attempt to establish a Bolt connection, returning the\n         agreed Bolt protocol version if successful.\n         \"\"\"\n         config = PoolConfig.consume(config)\n         try:\n             s, protocol_version, handshake, data = \\\n                 await AsyncBoltSocket.connect(\n                     address,\n                     timeout=timeout,\n                     custom_resolver=config.resolver,\n                     ssl_context=config.get_ssl_context(),\n                     keep_alive=config.keep_alive,\n                 )\n         except (ServiceUnavailable, SessionExpired, BoltHandshakeError):\n             return None\n         else:\n             await AsyncBoltSocket.close_socket(s)\n             return protocol_version\n \n     @classmethod\n     async def open(\n         cls, address, *, auth=None, timeout=None, routing_context=None,\n         **pool_config\n     ):\n         \"\"\"Open a new Bolt connection to a given server address.\n \n         :param address:\n         :param auth:\n         :param timeout: the connection timeout in seconds\n         :param routing_context: dict containing routing context\n         :param pool_config:\n \n         :return: connected AsyncBolt instance\n \n         :raise BoltHandshakeError:\n             raised if the Bolt Protocol can not negotiate a protocol version.\n         :raise ServiceUnavailable: raised if there was a connection issue.\n         \"\"\"\n         def time_remaining():\n             if timeout is None:\n                 return None\n             t = timeout - (perf_counter() - t0)\n             return t if t > 0 else 0\n \n         t0 = perf_counter()\n         pool_config = PoolConfig.consume(pool_config)\n \n         socket_connection_timeout = pool_config.connection_timeout\n         if socket_connection_timeout is None:\n             socket_connection_timeout = time_remaining()\n         elif timeout is not None:\n             socket_connection_timeout = min(pool_config.connection_timeout,\n                                             time_remaining())\n         s, pool_config.protocol_version, handshake, data = \\\n             await AsyncBoltSocket.connect(\n                 address,\n                 timeout=socket_connection_timeout,\n                 custom_resolver=pool_config.resolver,\n                 ssl_context=pool_config.get_ssl_context(),\n                 keep_alive=pool_config.keep_alive,\n             )\n \n         # Carry out Bolt subclass imports locally to avoid circular dependency\n         # issues.\n         if pool_config.protocol_version == (3, 0):\n             from ._bolt3 import AsyncBolt3\n             bolt_cls = AsyncBolt3\n         # Implementation for 4.0 exists, but there was no space left in the\n         # handshake to offer this version to the server. Hence, the server\n         # should never request us to speak bolt 4.0.\n         # elif pool_config.protocol_version == (4, 0):\n         #     from ._bolt4 import AsyncBolt4x0\n         #     bolt_cls = AsyncBolt4x0\n         elif pool_config.protocol_version == (4, 1):\n             from ._bolt4 import AsyncBolt4x1\n             bolt_cls = AsyncBolt4x1\n         elif pool_config.protocol_version == (4, 2):\n             from ._bolt4 import AsyncBolt4x2\n             bolt_cls = AsyncBolt4x2\n         elif pool_config.protocol_version == (4, 3):\n             from ._bolt4 import AsyncBolt4x3\n             bolt_cls = AsyncBolt4x3\n         elif pool_config.protocol_version == (4, 4):\n             from ._bolt4 import AsyncBolt4x4\n             bolt_cls = AsyncBolt4x4\n         elif pool_config.protocol_version == (5, 0):\n             from ._bolt5 import AsyncBolt5x0\n             bolt_cls = AsyncBolt5x0\n         else:\n             log.debug(\"[#%04X]  S: <CLOSE>\", s.getsockname()[1])\n             AsyncBoltSocket.close_socket(s)\n \n             supported_versions = cls.protocol_handlers().keys()\n             raise BoltHandshakeError(\n                 \"The Neo4J server does not support communication with this \"\n                 \"driver. This driver has support for Bolt protocols \"\n                 \"{}\".format(tuple(map(str, supported_versions))),\n                 address=address, request_data=handshake, response_data=data\n             )\n \n         connection = bolt_cls(\n             address, s, pool_config.max_connection_lifetime, auth=auth,\n             user_agent=pool_config.user_agent, routing_context=routing_context\n         )\n \n         try:\n             connection.socket.set_deadline(time_remaining())\n             try:\n                 await connection.hello()\n             finally:\n                 connection.socket.set_deadline(None)\n         except Exception:\n             await connection.close_non_blocking()\n             raise\n \n         return connection\n \n     @property\n     @abc.abstractmethod\n     def encrypted(self):\n         pass\n \n     @property\n     @abc.abstractmethod\n     def der_encoded_server_certificate(self):\n         pass\n \n     @abc.abstractmethod\n     async def hello(self, dehydration_hooks=None, hydration_hooks=None):\n         \"\"\" Appends a HELLO message to the outgoing queue, sends it and consumes\n          all remaining messages.\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     async def route(\n         self, database=None, imp_user=None, bookmarks=None,\n         dehydration_hooks=None, hydration_hooks=None\n     ):\n         \"\"\" Fetch a routing table from the server for the given\n         `database`. For Bolt 4.3 and above, this appends a ROUTE\n         message; for earlier versions, a procedure call is made via\n         the regular Cypher execution mechanism. In all cases, this is\n         sent to the network, and a response is fetched.\n \n         :param database: database for which to fetch a routing table\n             Requires Bolt 4.0+.\n         :param imp_user: the user to impersonate\n             Requires Bolt 4.4+.\n         :param bookmarks: iterable of bookmark values after which this\n                           transaction should begin\n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     def run(self, query, parameters=None, mode=None, bookmarks=None,\n             metadata=None, timeout=None, db=None, imp_user=None,\n             dehydration_hooks=None, hydration_hooks=None,\n             **handlers):\n         \"\"\" Appends a RUN message to the output queue.\n \n         :param query: Cypher query string\n         :param parameters: dictionary of Cypher parameters\n         :param mode: access mode for routing - \"READ\" or \"WRITE\" (default)\n         :param bookmarks: iterable of bookmark values after which this transaction should begin\n         :param metadata: custom metadata dictionary to attach to the transaction\n         :param timeout: timeout for transaction execution (seconds)\n         :param db: name of the database against which to begin the transaction\n             Requires Bolt 4.0+.\n         :param imp_user: the user to impersonate\n             Requires Bolt 4.4+.\n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         :param handlers: handler functions passed into the returned Response object\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     def discard(self, n=-1, qid=-1, dehydration_hooks=None,\n                 hydration_hooks=None, **handlers):\n         \"\"\" Appends a DISCARD message to the output queue.\n \n         :param n: number of records to discard, default = -1 (ALL)\n         :param qid: query ID to discard for, default = -1 (last query)\n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         :param handlers: handler functions passed into the returned Response object\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     def pull(self, n=-1, qid=-1, dehydration_hooks=None, hydration_hooks=None,\n              **handlers):\n         \"\"\" Appends a PULL message to the output queue.\n \n         :param n: number of records to pull, default = -1 (ALL)\n         :param qid: query ID to pull for, default = -1 (last query)\n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         :param handlers: handler functions passed into the returned Response object\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     def begin(self, mode=None, bookmarks=None, metadata=None, timeout=None,\n               db=None, imp_user=None, dehydration_hooks=None,\n               hydration_hooks=None, **handlers):\n         \"\"\" Appends a BEGIN message to the output queue.\n \n         :param mode: access mode for routing - \"READ\" or \"WRITE\" (default)\n         :param bookmarks: iterable of bookmark values after which this transaction should begin\n         :param metadata: custom metadata dictionary to attach to the transaction\n         :param timeout: timeout for transaction execution (seconds)\n         :param db: name of the database against which to begin the transaction\n             Requires Bolt 4.0+.\n         :param imp_user: the user to impersonate\n             Requires Bolt 4.4+\n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         :param handlers: handler functions passed into the returned Response object\n         :return: Response object\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     def commit(self, dehydration_hooks=None, hydration_hooks=None, **handlers):\n         \"\"\" Appends a COMMIT message to the output queue.\n \n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     def rollback(self, dehydration_hooks=None, hydration_hooks=None, **handlers):\n         \"\"\" Appends a ROLLBACK message to the output queue.\n \n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\"\"\"\n         pass\n \n     @abc.abstractmethod\n     async def reset(self, dehydration_hooks=None, hydration_hooks=None):\n         \"\"\" Appends a RESET message to the outgoing queue, sends it and consumes\n          all remaining messages.\n \n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         \"\"\"\n         pass\n \n     @abc.abstractmethod\n     def goodbye(self, dehydration_hooks=None, hydration_hooks=None):\n         \"\"\"Append a GOODBYE message to the outgoing queue.\n \n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         :param hydration_hooks:\n             Hooks to hydrate types (mapping from type (class) to\n             dehydration function). Dehydration functions receive the value of\n             type understood by packstream and are free to return anything.\n         \"\"\"\n         pass\n \n     def new_hydration_scope(self):\n         return self.hydration_handler.new_hydration_scope()\n \n     def _append(self, signature, fields=(), response=None,\n                 dehydration_hooks=None):\n         \"\"\" Appends a message to the outgoing queue.\n \n         :param signature: the signature of the message\n         :param fields: the fields of the message as a tuple\n         :param response: a response object to handle callbacks\n         :param dehydration_hooks:\n             Hooks to dehydrate types (dict from type (class) to dehydration\n             function). Dehydration functions receive the value and returns an\n             object of type understood by packstream.\n         \"\"\"\n         self.outbox.append_message(signature, fields, dehydration_hooks)\n         self.responses.append(response)\n \n     async def _send_all(self):\n         if await self.outbox.flush():\n             self.idle_since = perf_counter()\n \n     async def send_all(self):\n         \"\"\" Send all queued messages to the server.\n         \"\"\"\n         if self.closed():\n             raise ServiceUnavailable(\n                 \"Failed to write to closed connection {!r} ({!r})\".format(\n                     self.unresolved_address, self.server_info.address\n                 )\n             )\n         if self.defunct():\n             raise ServiceUnavailable(\n                 \"Failed to write to defunct connection {!r} ({!r})\".format(\n                     self.unresolved_address, self.server_info.address\n                 )\n             )\n \n         await self._send_all()\n \n     @abc.abstractmethod\n     async def _process_message(self, tag, fields):\n         \"\"\" Receive at most one message from the server, if available.\n \n         :return: 2-tuple of number of detail messages and number of summary\n                  messages fetched\n         \"\"\"\n         pass\n \n     async def fetch_message(self):\n         if self._closed:\n             raise ServiceUnavailable(\n                 \"Failed to read from closed connection {!r} ({!r})\".format(\n                     self.unresolved_address, self.server_info.address\n                 )\n             )\n         if self._defunct:\n             raise ServiceUnavailable(\n                 \"Failed to read from defunct connection {!r} ({!r})\".format(\n                     self.unresolved_address, self.server_info.address\n                 )\n             )\n         if not self.responses:\n             return 0, 0\n \n         # Receive exactly one message\n         tag, fields = await self.inbox.pop(\n             hydration_hooks=self.responses[0].hydration_hooks\n         )\n         res = await self._process_message(tag, fields)\n         self.idle_since = perf_counter()\n         return res\n \n     async def fetch_all(self):\n         \"\"\" Fetch all outstanding messages.\n \n         :return: 2-tuple of number of detail messages and number of summary\n                  messages fetched\n         \"\"\"\n         detail_count = summary_count = 0\n         while self.responses:\n             response = self.responses[0]\n             while not response.complete:\n                 detail_delta, summary_delta = await self.fetch_message()\n                 detail_count += detail_delta\n                 summary_count += summary_delta\n         return detail_count, summary_count\n \n     async def _set_defunct_read(self, error=None, silent=False):\n         message = \"Failed to read from defunct connection {!r} ({!r})\".format(\n             self.unresolved_address, self.server_info.address\n         )\n         await self._set_defunct(message, error=error, silent=silent)\n \n     async def _set_defunct_write(self, error=None, silent=False):\n         message = \"Failed to write data to connection {!r} ({!r})\".format(\n             self.unresolved_address, self.server_info.address\n         )\n         await self._set_defunct(message, error=error, silent=silent)\n \n     async def _set_defunct(self, message, error=None, silent=False):\n         from ._pool import AsyncBoltPool\n         direct_driver = isinstance(self.pool, AsyncBoltPool)\n \n         if error:\n             log.debug(\"[#%04X]  %r\", self.socket.getsockname()[1], error)\n         log.error(message)\n         # We were attempting to receive data but the connection\n         # has unexpectedly terminated. So, we need to close the\n         # connection from the client side, and remove the address\n         # from the connection pool.\n         self._defunct = True\n         if not self._closing:\n             # If we fail while closing the connection, there is no need to\n             # remove the connection from the pool, nor to try to close the\n             # connection again.\n             await self.close()\n             if self.pool:\n                 await self.pool.deactivate(address=self.unresolved_address)\n         # Iterate through the outstanding responses, and if any correspond\n         # to COMMIT requests then raise an error to signal that we are\n         # unable to confirm that the COMMIT completed successfully.\n         if silent:\n             return\n         for response in self.responses:\n             if isinstance(response, CommitResponse):\n                 if error:\n                     raise IncompleteCommit(message) from error\n                 else:\n                     raise IncompleteCommit(message)\n \n         if direct_driver:\n             if error:\n                 raise ServiceUnavailable(message) from error\n             else:\n                 raise ServiceUnavailable(message)\n         else:\n             if error:\n                 raise SessionExpired(message) from error\n             else:\n                 raise SessionExpired(message)\n \n     def stale(self):\n         return (self._stale\n                 or (0 <= self._max_connection_lifetime\n                     <= perf_counter() - self._creation_timestamp))\n \n     _stale = False\n \n     def set_stale(self):\n         self._stale = True\n \n     async def close(self):\n         \"\"\"Close the connection.\"\"\"\n         if self._closed or self._closing:\n             return\n         self._closing = True\n         if not self._defunct:\n             self.goodbye()\n             try:\n                 await self._send_all()\n             except (OSError, BoltError, DriverError):\n                 pass\n         log.debug(\"[#%04X]  C: <CLOSE>\", self.local_port)\n         try:\n             await self.socket.close()\n         except OSError:\n             pass\n         finally:\n             self._closed = True\n \n     async def close_non_blocking(self):\n         \"\"\"Set the socket to non-blocking and close it.\n \n         This will try to send the `GOODBYE` message (given the socket is not\n         marked as defunct). However, should the write operation require\n         blocking (e.g., a full network buffer), then the socket will be closed\n         immediately (without `GOODBYE` message).\n         \"\"\"\n         if self._closed or self._closing:\n             return\n         self.socket.settimeout(0)\n         await self.close()\n \n     def closed(self):\n         return self._closed\n \n     def defunct(self):\n         return self._defunct\n \n     def is_idle_for(self, timeout):\n         \"\"\"Check if connection has been idle for at least the given timeout.\n \n         :param timeout: timeout in seconds\n         :type timeout: float\n \n         :rtype: bool\n         \"\"\"\n         return perf_counter() - self.idle_since > timeout\n \n \n AsyncBoltSocket.Bolt = AsyncBolt\n ", "input_code": "@classmethod\ndef protocol_handlers(cls, protocol_version=None):\n\"\"\"\nReturn a dictionary of available Bolt protocol handlers,\nkeyed by version tuple. If an explicit protocol version is\nprovided, the dictionary will contain either zero or one items,\ndepending on whether that version is supported. If no protocol\nversion is provided, all available versions will be returned.\n\n:param protocol_version: tuple identifying a specific protocol\n    version (e.g. (3, 5)) or None\n:return: dictionary of version tuple to handler class for all\n    relevant and supported protocol versions\n:raise TypeError: if protocol version is not passed in a tuple\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @classmethod\n    def protocol_handlers(cls, protocol_version=None):\n        \"\"\" Return a dictionary of available Bolt protocol handlers,\n        keyed by version tuple. If an explicit protocol version is\n        provided, the dictionary will contain either zero or one items,\n        depending on whether that version is supported. If no protocol\n        version is provided, all available versions will be returned.\n\n        :param protocol_version: tuple identifying a specific protocol\n            version (e.g. (3, 5)) or None\n        :return: dictionary of version tuple to handler class for all\n            relevant and supported protocol versions\n        :raise TypeError: if protocol version is not passed in a tuple\n        \"\"\"\n\n        # Carry out Bolt subclass imports locally to avoid circular dependency issues.\n        from ._bolt3 import AsyncBolt3\n        from ._bolt4 import (\n            AsyncBolt4x1,\n            AsyncBolt4x2,\n            AsyncBolt4x3,\n            AsyncBolt4x4,\n        )\n        from ._bolt5 import AsyncBolt5x0\n\n        handlers = {\n            AsyncBolt3.PROTOCOL_VERSION: AsyncBolt3,\n            # 4.0 unsupported because no space left in the handshake\n            AsyncBolt4x1.PROTOCOL_VERSION: AsyncBolt4x1,\n            AsyncBolt4x2.PROTOCOL_VERSION: AsyncBolt4x2,\n            AsyncBolt4x3.PROTOCOL_VERSION: AsyncBolt4x3,\n            AsyncBolt4x4.PROTOCOL_VERSION: AsyncBolt4x4,\n            AsyncBolt5x0.PROTOCOL_VERSION: AsyncBolt5x0,\n        }\n\n        if protocol_version is None:\n            return handlers\n\n        if not isinstance(protocol_version, tuple):\n            raise TypeError(\"Protocol version must be specified as a tuple\")\n\n        if protocol_version in handlers:\n            return {protocol_version: handlers[protocol_version]}\n\n        return {}", "signature": "@classmethod\ndef protocol_handlers(cls, protocol_version=None):", "completion_path": "neo4j/_async/io/_bolt.py"}
{"ce_id": "62e60e3bd76274f8a4026d1a", "namespace": "62e60e3bd76274f8a4026d1a", "namespace_real": "neo4j.api.from_raw_values", "real_proj_path": "neo4j---neo4j-python-driver/src/", "type": "class", "class_name": "api", "function_name": "from_raw_values", "contexts_above": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\" Base classes and helpers.\n\"\"\"\n\n\nfrom urllib.parse import (\n    parse_qs,\n    urlparse,\n)\n\nfrom ._meta import deprecated\nfrom .exceptions import ConfigurationError\n\n\nREAD_ACCESS = \"READ\"\nWRITE_ACCESS = \"WRITE\"\n\nDRIVER_BOLT = \"DRIVER_BOLT\"\nDRIVER_NEO4j = \"DRIVER_NEO4J\"\n\nSECURITY_TYPE_NOT_SECURE = \"SECURITY_TYPE_NOT_SECURE\"\nSECURITY_TYPE_SELF_SIGNED_CERTIFICATE = \"SECURITY_TYPE_SELF_SIGNED_CERTIFICATE\"\nSECURITY_TYPE_SECURE = \"SECURITY_TYPE_SECURE\"\n\nURI_SCHEME_BOLT = \"bolt\"\nURI_SCHEME_BOLT_SELF_SIGNED_CERTIFICATE = \"bolt+ssc\"\nURI_SCHEME_BOLT_SECURE = \"bolt+s\"\n\nURI_SCHEME_NEO4J = \"neo4j\"\nURI_SCHEME_NEO4J_SELF_SIGNED_CERTIFICATE = \"neo4j+ssc\"\nURI_SCHEME_NEO4J_SECURE = \"neo4j+s\"\n\nURI_SCHEME_BOLT_ROUTING = \"bolt+routing\"\n\n# TODO: 6.0 - remove TRUST constants\nTRUST_SYSTEM_CA_SIGNED_CERTIFICATES = \"TRUST_SYSTEM_CA_SIGNED_CERTIFICATES\"  # Default\nTRUST_ALL_CERTIFICATES = \"TRUST_ALL_CERTIFICATES\"\n\nSYSTEM_DATABASE = \"system\"\nDEFAULT_DATABASE = None  # Must be a non string hashable value\n\n\n# TODO: This class is not tested\nclass Auth:\n    \"\"\"Container for auth details.\n\n    :param scheme: specifies the type of authentication, examples: \"basic\",\n                   \"kerberos\"\n    :type scheme: str\n    :param principal: specifies who is being authenticated\n    :type principal: str or None\n    :param credentials: authenticates the principal\n    :type credentials: str or None\n    :param realm: specifies the authentication provider\n    :type realm: str or None\n    :param parameters: extra key word parameters passed along to the\n                       authentication provider\n    :type parameters: Dict[str, Any]\n    \"\"\"\n\n    def __init__(self, scheme, principal, credentials, realm=None, **parameters):\n        self.scheme = scheme\n        # Neo4j servers pre 4.4 require the principal field to always be\n        # present. Therefore, we transmit it even if it's an empty sting.\n        if principal is not None:\n            self.principal = principal\n        if credentials:\n            self.credentials = credentials\n        if realm:\n            self.realm = realm\n        if parameters:\n            self.parameters = parameters\n\n\n# For backwards compatibility\nAuthToken = Auth\n\n\ndef basic_auth(user, password, realm=None):\n    \"\"\"Generate a basic auth token for a given user and password.\n\n    This will set the scheme to \"basic\" for the auth token.\n\n    :param user: user name, this will set the\n    :type user: str\n    :param password: current password, this will set the credentials\n    :type password: str\n    :param realm: specifies the authentication provider\n    :type realm: str or None\n\n    :return: auth token for use with :meth:`GraphDatabase.driver` or\n        :meth:`AsyncGraphDatabase.driver`\n    :rtype: :class:`neo4j.Auth`\n    \"\"\"\n    return Auth(\"basic\", user, password, realm)\n\n\ndef kerberos_auth(base64_encoded_ticket):\n    \"\"\"Generate a kerberos auth token with the base64 encoded ticket.\n\n    This will set the scheme to \"kerberos\" for the auth token.\n\n    :param base64_encoded_ticket: a base64 encoded service ticket, this will set\n                                  the credentials\n    :type base64_encoded_ticket: str\n\n    :return: auth token for use with :meth:`GraphDatabase.driver` or\n        :meth:`AsyncGraphDatabase.driver`\n    :rtype: :class:`neo4j.Auth`\n    \"\"\"\n    return Auth(\"kerberos\", \"\", base64_encoded_ticket)\n\n\ndef bearer_auth(base64_encoded_token):\n    \"\"\"Generate an auth token for Single-Sign-On providers.\n\n    This will set the scheme to \"bearer\" for the auth token.\n\n    :param base64_encoded_token: a base64 encoded authentication token generated\n                                 by a Single-Sign-On provider.\n    :type base64_encoded_token: str\n\n    :return: auth token for use with :meth:`GraphDatabase.driver` or\n        :meth:`AsyncGraphDatabase.driver`\n    :rtype: :class:`neo4j.Auth`\n    \"\"\"\n    return Auth(\"bearer\", None, base64_encoded_token)\n\n\ndef custom_auth(principal, credentials, realm, scheme, **parameters):\n    \"\"\"Generate a custom auth token.\n\n    :param principal: specifies who is being authenticated\n    :type principal: str or None\n    :param credentials: authenticates the principal\n    :type credentials: str or None\n    :param realm: specifies the authentication provider\n    :type realm: str or None\n    :param scheme: specifies the type of authentication\n    :type scheme: str or None\n    :param parameters: extra key word parameters passed along to the\n                       authentication provider\n    :type parameters: Dict[str, Any]\n\n    :return: auth token for use with :meth:`GraphDatabase.driver` or\n        :meth:`AsyncGraphDatabase.driver`\n    :rtype: :class:`neo4j.Auth`\n    \"\"\"\n    return Auth(scheme, principal, credentials, realm, **parameters)\n\n\n# TODO 6.0 - remove this class\nclass Bookmark:\n    \"\"\"A Bookmark object contains an immutable list of bookmark string values.\n\n    .. deprecated:: 5.0\n        `Bookmark` will be removed in version 6.0.\n        Use :class:`Bookmarks` instead.\n\n    :param values: ASCII string values\n    \"\"\"\n\n    @deprecated(\"Use the `Bookmarks`` class instead.\")\n    def __init__(self, *values):\n        if values:\n            bookmarks = []\n            for ix in values:\n                try:\n                    if ix:\n                        ix.encode(\"ascii\")\n                        bookmarks.append(ix)\n                except UnicodeEncodeError as e:\n                    raise ValueError(\"The value {} is not ASCII\".format(ix))\n            self._values = frozenset(bookmarks)\n        else:\n            self._values = frozenset()\n\n    def __repr__(self):\n        \"\"\"\n        :return: repr string with sorted values\n        \"\"\"\n        return \"<Bookmark values={{{}}}>\".format(\", \".join([\"'{}'\".format(ix) for ix in sorted(self._values)]))\n\n    def __bool__(self):\n        return bool(self._values)\n\n    @property\n    def values(self):\n        \"\"\"\n        :return: immutable list of bookmark string values\n        :rtype: frozenset\n        \"\"\"\n        return self._values\n\n\nclass Bookmarks:\n    \"\"\"Container for an immutable set of bookmark string values.\n\n    Bookmarks are used to causally chain session.\n    See :meth:`Session.last_bookmarks` or :meth:`AsyncSession.last_bookmarks`\n    for more information.\n\n    Use addition to combine multiple Bookmarks objects::\n\n        bookmarks3 = bookmarks1 + bookmarks2\n    \"\"\"\n\n    def __init__(self):\n        self._raw_values = frozenset()\n\n    def __repr__(self):\n        \"\"\"\n        :return: repr string with sorted values\n        \"\"\"\n        return \"<Bookmarks values={{{}}}>\".format(\n            \", \".join(map(repr, sorted(self._raw_values)))\n        )\n\n    def __bool__(self):\n        return bool(self._raw_values)\n\n    def __add__(self, other):\n        if isinstance(other, Bookmarks):\n            if not other:\n                return self\n            ret = self.__class__()\n            ret._raw_values = self._raw_values | other._raw_values\n            return ret\n        return NotImplemented\n\n    @property\n    def raw_values(self):\n        \"\"\"The raw bookmark values.\n\n        You should not need to access them unless you want to serialize\n        bookmarks.\n\n        :return: immutable list of bookmark string values\n        :rtype: frozenset[str]\n        \"\"\"\n        return self._raw_values\n\n    @classmethod", "contexts_below": "\n class ServerInfo:\n     \"\"\" Represents a package of information relating to a Neo4j server.\n     \"\"\"\n \n     def __init__(self, address, protocol_version):\n         self._address = address\n         self._protocol_version = protocol_version\n         self._metadata = {}\n \n     @property\n     def address(self):\n         \"\"\" Network address of the remote server.\n         \"\"\"\n         return self._address\n \n     @property\n     def protocol_version(self):\n         \"\"\" Bolt protocol version with which the remote server\n         communicates. This is returned as a :class:`.Version`\n         object, which itself extends a simple 2-tuple of\n         (major, minor) integers.\n         \"\"\"\n         return self._protocol_version\n \n     @property\n     def agent(self):\n         \"\"\" Server agent string by which the remote server identifies\n         itself.\n         \"\"\"\n         return self._metadata.get(\"server\")\n \n     @property\n     @deprecated(\"The connection id is considered internal information \"\n                 \"and will no longer be exposed in future versions.\")\n     def connection_id(self):\n         \"\"\" Unique identifier for the remote server connection.\n         \"\"\"\n         return self._metadata.get(\"connection_id\")\n \n     def update(self, metadata):\n         \"\"\" Update server information with extra metadata. This is\n         typically drawn from the metadata received after successful\n         connection initialisation.\n         \"\"\"\n         self._metadata.update(metadata)\n \n \n class Version(tuple):\n \n     def __new__(cls, *v):\n         return super().__new__(cls, v)\n \n     def __repr__(self):\n         return \"{}{}\".format(self.__class__.__name__, super().__repr__())\n \n     def __str__(self):\n         return \".\".join(map(str, self))\n \n     def to_bytes(self):\n         b = bytearray(4)\n         for i, v in enumerate(self):\n             if not 0 <= i < 2:\n                 raise ValueError(\"Too many version components\")\n             if isinstance(v, list):\n                 b[-i - 1] = int(v[0] % 0x100)\n                 b[-i - 2] = int((v[0] - v[-1]) % 0x100)\n             else:\n                 b[-i - 1] = int(v % 0x100)\n         return bytes(b)\n \n     @classmethod\n     def from_bytes(cls, b):\n         b = bytearray(b)\n         if len(b) != 4:\n             raise ValueError(\"Byte representation must be exactly four bytes\")\n         if b[0] != 0 or b[1] != 0:\n             raise ValueError(\"First two bytes must contain zero\")\n         return Version(b[-1], b[-2])\n \n \n def parse_neo4j_uri(uri):\n     parsed = urlparse(uri)\n \n     if parsed.username:\n         raise ConfigurationError(\"Username is not supported in the URI\")\n \n     if parsed.password:\n         raise ConfigurationError(\"Password is not supported in the URI\")\n \n     if parsed.scheme == URI_SCHEME_BOLT_ROUTING:\n         raise ConfigurationError(\"Uri scheme {!r} have been renamed. Use {!r}\".format(parsed.scheme, URI_SCHEME_NEO4J))\n     elif parsed.scheme == URI_SCHEME_BOLT:\n         driver_type = DRIVER_BOLT\n         security_type = SECURITY_TYPE_NOT_SECURE\n     elif parsed.scheme == URI_SCHEME_BOLT_SELF_SIGNED_CERTIFICATE:\n         driver_type = DRIVER_BOLT\n         security_type = SECURITY_TYPE_SELF_SIGNED_CERTIFICATE\n     elif parsed.scheme == URI_SCHEME_BOLT_SECURE:\n         driver_type = DRIVER_BOLT\n         security_type = SECURITY_TYPE_SECURE\n     elif parsed.scheme == URI_SCHEME_NEO4J:\n         driver_type = DRIVER_NEO4j\n         security_type = SECURITY_TYPE_NOT_SECURE\n     elif parsed.scheme == URI_SCHEME_NEO4J_SELF_SIGNED_CERTIFICATE:\n         driver_type = DRIVER_NEO4j\n         security_type = SECURITY_TYPE_SELF_SIGNED_CERTIFICATE\n     elif parsed.scheme == URI_SCHEME_NEO4J_SECURE:\n         driver_type = DRIVER_NEO4j\n         security_type = SECURITY_TYPE_SECURE\n     else:\n         raise ConfigurationError(\"URI scheme {!r} is not supported. Supported URI schemes are {}. Examples: bolt://host[:port] or neo4j://host[:port][?routing_context]\".format(\n             parsed.scheme,\n             [\n                 URI_SCHEME_BOLT,\n                 URI_SCHEME_BOLT_SELF_SIGNED_CERTIFICATE,\n                 URI_SCHEME_BOLT_SECURE,\n                 URI_SCHEME_NEO4J,\n                 URI_SCHEME_NEO4J_SELF_SIGNED_CERTIFICATE,\n                 URI_SCHEME_NEO4J_SECURE\n             ]\n         ))\n \n     return driver_type, security_type, parsed\n \n \n def check_access_mode(access_mode):\n     if access_mode is None:\n         return WRITE_ACCESS\n     if access_mode not in (READ_ACCESS, WRITE_ACCESS):\n         msg = \"Unsupported access mode {}\".format(access_mode)\n         raise ConfigurationError(msg)\n \n     return access_mode\n \n \n def parse_routing_context(query):\n     \"\"\" Parse the query portion of a URI to generate a routing context dictionary.\n     \"\"\"\n     if not query:\n         return {}\n \n     context = {}\n     parameters = parse_qs(query, True)\n     for key in parameters:\n         value_list = parameters[key]\n         if len(value_list) != 1:\n             raise ConfigurationError(\"Duplicated query parameters with key '%s', value '%s' found in query string '%s'\" % (key, value_list, query))\n         value = value_list[0]\n         if not value:\n             raise ConfigurationError(\"Invalid parameters:'%s=%s' in query string '%s'.\" % (key, value, query))\n         context[key] = value\n \n     return context\n ", "input_code": "@classmethod\ndef from_raw_values(cls, values):\n\"\"\"\nCreate a Bookmarks object from a list of raw bookmark string values.\n\nYou should not need to use this method unless you want to deserialize\nbookmarks.\n\n:param values: ASCII string values (raw bookmarks)\n:type values: Iterable[str]\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @classmethod\n    def from_raw_values(cls, values):\n        \"\"\"Create a Bookmarks object from a list of raw bookmark string values.\n\n        You should not need to use this method unless you want to deserialize\n        bookmarks.\n\n        :param values: ASCII string values (raw bookmarks)\n        :type values: Iterable[str]\n        \"\"\"\n        obj = cls()\n        bookmarks = []\n        for value in values:\n            if not isinstance(value, str):\n                raise TypeError(\"Raw bookmark values must be str. \"\n                                \"Found {}\".format(type(value)))\n            try:\n                value.encode(\"ascii\")\n            except UnicodeEncodeError as e:\n                raise ValueError(f\"The value {value} is not ASCII\") from e\n            bookmarks.append(value)\n        obj._raw_values = frozenset(bookmarks)\n        return obj", "signature": "@classmethod\ndef from_raw_values(cls, values):", "completion_path": "neo4j/api.py"}
{"ce_id": "62b87b199a0c4fa8b80b354c", "namespace": "62b87b199a0c4fa8b80b354c", "namespace_real": "lena.core.split._get_seq_with_type", "real_proj_path": "ynikitenko---lena/", "type": "function", "class_name": null, "function_name": "_get_seq_with_type", "contexts_above": "\"\"\"Split data flow and run analysis in parallel.\"\"\"\nimport copy\nimport itertools\n\nfrom . import fill_compute_seq\nfrom . import check_sequence_type as ct\nfrom . import fill_request_seq\nfrom . import sequence\nfrom . import exceptions\nfrom . import source\nfrom . import meta\n\n", "contexts_below": "\n class Split(object):\n     \"\"\"Split data flow and run analysis in parallel.\"\"\"\n \n     def __init__(self, seqs, bufsize=1000, copy_buf=True):\n         \"\"\"*seqs* must be a list of Sequence, Source, FillComputeSeq\n         or FillRequestSeq sequences.\n         If *seqs* is empty, *Split* acts as an empty *Sequence* and\n         yields all values it receives.\n \n         *bufsize* is the size of the buffer for the input flow.\n         If *bufsize* is ``None``,\n         whole input flow is materialized in the buffer.\n         *bufsize* must be a natural number or ``None``.\n \n         *copy_buf* sets whether the buffer should be copied\n         during :meth:`run`.\n         This is important if different sequences can change input data\n         and thus interfere with each other.\n \n         Common type:\n             If each sequence from *seqs* has a common type,\n             *Split* creates methods corresponding to this type.\n             For example, if each sequence is *FillCompute*,\n             *Split* creates methods *fill* and *compute*\n             and can be used as a *FillCompute* sequence.\n             *fill* fills all its subsequences (with copies\n             if *copy_buf* is True), and *compute*\n             yields values from all sequences in turn\n             (as would also do *request* or *Source.__call__*).\n \n         In case of wrong initialization arguments, :exc:`.LenaTypeError`\n         or :exc:`.LenaValueError` is raised.\n         \"\"\"\n         # todo: copy_buf must be always True. Isn't that?\n         if not isinstance(seqs, list):\n             raise exceptions.LenaTypeError(\n                 \"seqs must be a list of sequences, \"\n                 \"{} provided\".format(seqs)\n             )\n         seqs = [meta.alter_sequence(seq) for seq in seqs]\n         self._sequences = []\n         self._seq_types = []\n \n         for sequence in seqs:\n             try:\n                 seq, seq_type = _get_seq_with_type(sequence, bufsize)\n             except exceptions.LenaTypeError:\n                 raise exceptions.LenaTypeError(\n                     \"unknown argument type. Must be one of \"\n                     \"FillComputeSeq, FillRequestSeq or Source, \"\n                     \"{} provided\".format(sequence)\n                 )\n             self._sequences.append(seq)\n             self._seq_types.append(seq_type)\n \n         different_seq_types = set(self._seq_types)\n         self._n_seq_types = len(different_seq_types)\n         if self._n_seq_types == 1:\n             seq_type = different_seq_types.pop()\n             # todo: probably remove run to avoid duplication?\n             if seq_type == \"fill_compute\":\n                 self.fill = self._fill\n                 self.compute = self._compute\n             elif seq_type == \"fill_request\":\n                 self.fill = self._fill\n                 self.request = self._request\n             elif seq_type == \"source\":\n                 pass\n         elif self._n_seq_types == 0:\n             self.run = self._empty_run\n \n         self._copy_buf = bool(copy_buf)\n \n         if bufsize is not None:\n             if bufsize != int(bufsize) or bufsize < 1:\n                 raise exceptions.LenaValueError(\n                     \"bufsize should be a natural number \"\n                     \"or None, {} provided\".format(bufsize)\n                 )\n         self._bufsize = bufsize\n \n     def __call__(self):\n         \"\"\"Each initialization sequence generates flow.\n         After its flow is empty, next sequence is called, etc.\n \n         This method is available only if each self sequence is a\n         :class:`.Source`,\n         otherwise runtime :exc:`.LenaAttributeError` is raised.\n         \"\"\"\n         if self._n_seq_types != 1 or not ct.is_source(self._sequences[0]):\n             raise exceptions.LenaAttributeError(\n                 \"Split has no method '__call__'. It should contain \"\n                 \"only Source sequences to be callable\"\n             )\n         # todo: use itertools.chain and check performance difference\n         for seq in self._sequences:\n             for result in seq():\n                 yield result\n \n     def _fill(self, val):\n         for seq in self._sequences[:-1]:\n             if self._copy_buf:\n                 seq.fill(copy.deepcopy(val))\n             else:\n                 seq.fill(val)\n         self._sequences[-1].fill(val)\n \n     def _compute(self):\n         for seq in self._sequences:\n             for val in seq.compute():\n                 yield val\n \n     def _request(self):\n         for seq in self._sequences:\n             for val in seq.request():\n                 yield val\n \n     def _empty_run(self, flow):\n         \"\"\"If self sequence is empty, yield all flow unchanged.\"\"\"\n         for val in flow:\n             yield val\n \n     def run(self, flow):\n         \"\"\"Iterate input *flow* and yield results.\n \n         The *flow* is divided into subslices of *bufsize*.\n         Each subslice is processed by sequences\n         in the order of their initializer list.\n \n         If a sequence is a *Source*,\n         it doesn't accept the incoming *flow*,\n         but produces its own complete flow\n         and becomes inactive (is not called any more).\n \n         A *FillRequestSeq* is filled with the buffer contents.\n         After the buffer is finished,\n         it yields all values from *request()*.\n \n         A *FillComputeSeq* is filled with values from each buffer,\n         but yields values from *compute* only after the whole *flow*\n         is finished.\n \n         A *Sequence* is called with *run(buffer)*\n         instead of the whole flow. The results are yielded\n         for each buffer (and also if the *flow* was empty).\n         If the whole flow must be analysed at once,\n         don't use such a sequence in *Split*.\n \n         If the *flow* was empty, each *call*, *compute*,\n         *request* or *run* is called nevertheless.\n \n         If *copy_buf* is True,\n         then the buffer for each sequence except the last one is a deep copy\n         of the current buffer.\n         \"\"\"\n         active_seqs = self._sequences[:]\n         active_seq_types = self._seq_types[:]\n \n         n_of_active_seqs = len(active_seqs)\n         ind = 0\n         flow = iter(flow)\n         flow_was_empty = True\n         while True:\n             ## iterate on flow\n             # If stop is None, then iteration continues\n             # until the iterator is exhausted, if at all\n             # https://docs.python.org/3/library/itertools.html#itertools.islice\n             orig_buf = list(itertools.islice(flow, self._bufsize))\n             if orig_buf:\n                 flow_was_empty = False\n             else:\n                 break\n \n             # iterate on active sequences\n             ind = 0\n             while ind < n_of_active_seqs:\n                 if self._copy_buf and n_of_active_seqs - ind > 1:\n                     # last sequence doesn't need a copy of the buffer\n                     buf = copy.deepcopy(orig_buf)\n                 else:\n                     buf = orig_buf\n                 seq = active_seqs[ind]\n                 seq_type = active_seq_types[ind]\n \n                 if seq_type == \"source\":\n                     for val in seq():\n                         yield val\n                     del active_seqs[ind]\n                     del active_seq_types[ind]\n                     n_of_active_seqs -= 1\n                     continue\n                 elif seq_type == \"fill_compute\":\n                     stopped = False\n                     for val in buf:\n                         try:\n                             seq.fill(val)\n                         except exceptions.LenaStopFill:\n                             stopped = True\n                             break\n                     if stopped:\n                         for result in seq.compute():\n                             yield result\n                         # we don't have goto in Python,\n                         # so we have to repeat this\n                         # each time we break double cycle.\n                         del active_seqs[ind]\n                         del active_seq_types[ind]\n                         n_of_active_seqs -= 1\n                         continue\n                 elif seq_type == \"fill_request\":\n                     stopped = False\n                     for val in buf:\n                         try:\n                             seq.fill(val)\n                         except exceptions.LenaStopFill:\n                             stopped = True\n                             break\n                     # FillRequest yields each time after buffer is filled\n                     for result in seq.request():\n                         yield result\n                     if stopped:\n                         del active_seqs[ind]\n                         del active_seq_types[ind]\n                         n_of_active_seqs -= 1\n                         continue\n                 elif seq_type == \"sequence\":\n                     # run buf as a whole flow.\n                     # this may be very wrong if seq has internal state,\n                     # e.g. contains a Cache\n                     for res in seq.run(buf):\n                         yield res\n                 # this is not needed, because can't be tested.\n                 # else:\n                 #     raise exceptions.LenaRuntimeError(\n                 #         \"unknown sequence type {}\".format(seq_type)\n                 #     )\n \n                 ind += 1\n                 # end internal while on sequences\n             # end while on flow\n \n         # yield computed data\n         for seq, seq_type in zip(active_seqs, active_seq_types):\n             if seq_type == \"source\":\n                 # otherwise it is a logic error\n                 assert flow_was_empty\n                 for val in seq():\n                     yield val\n             elif seq_type == \"fill_compute\":\n                 for val in seq.compute():\n                     yield val\n             elif seq_type == \"fill_request\":\n                 # otherwise FillRequest yielded after each buffer\n                 if flow_was_empty:\n                     for val in seq.request():\n                         yield val\n             elif seq_type == \"sequence\":\n                 if flow_was_empty:\n                     for val in seq.run([]):\n                         yield val\n ", "input_code": "def _get_seq_with_type(seq, bufsize=None):\n\"\"\"\nReturn a (sequence, type) pair.\nSequence is derived from *seq*\n(or is *seq*, if that is of a sequence type).\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _get_seq_with_type(seq, bufsize=None):\n    \"\"\"Return a (sequence, type) pair.\n    Sequence is derived from *seq*\n    (or is *seq*, if that is of a sequence type).\n    \"\"\"\n    seq_type = \"\"\n    if isinstance(seq, source.Source):\n        seq_type = \"source\"\n    elif isinstance(seq, fill_compute_seq.FillComputeSeq):\n        seq_type = \"fill_compute\"\n    elif isinstance(seq, fill_request_seq.FillRequestSeq):\n        seq_type = \"fill_request\"\n    elif isinstance(seq, sequence.Sequence):\n        seq_type = \"sequence\"\n\n    if seq_type:\n        # append later\n        pass\n    ## If no explicit type is given, check seq's methods\n    elif ct.is_fill_compute_seq(seq):\n        seq_type = \"fill_compute\"\n        if not ct.is_fill_compute_el(seq):\n            seq = fill_compute_seq.FillComputeSeq(*seq)\n    elif ct.is_fill_request_seq(seq):\n        seq_type = \"fill_request\"\n        if not ct.is_fill_request_el(seq):\n            seq = fill_request_seq.FillRequestSeq(\n                *seq, bufsize=bufsize,\n                # if we have a FillRequest element inside,\n                # it decides itself when to reset.\n                reset=False,\n                # todo: change the interface, because\n                # no difference with buffer_output: we fill\n                # without a buffer\n                buffer_input=True\n            )\n    # Source is not checked,\n    # because it must be Source explicitly.\n    else:\n        try:\n            if isinstance(seq, tuple):\n                seq = sequence.Sequence(*seq)\n            else:\n                seq = sequence.Sequence(seq)\n        except exceptions.LenaTypeError:\n            raise exceptions.LenaTypeError(\n                \"unknown argument type. Must be a \"\n                \"FillComputeSeq, FillRequestSeq or Source, \"\n                \"{} provided\".format(seq)\n            )\n        else:\n            seq_type = \"sequence\"\n    return (seq, seq_type)", "signature": "def _get_seq_with_type(seq, bufsize=None):", "completion_path": "lena/core/split.py"}
{"ce_id": "62b87b4f9a0c4fa8b80b3581", "namespace": "62b87b4f9a0c4fa8b80b3581", "namespace_real": "lena.structures.histogram.scale", "real_proj_path": "ynikitenko---lena/", "type": "class", "class_name": "histogram", "function_name": "scale", "contexts_above": "\"\"\"Histogram structure *histogram* and element *Histogram*.\"\"\"\nimport copy\n\nimport lena.context\nimport lena.core\nimport lena.flow\nimport lena.math\nfrom . import hist_functions as hf\n\n\nclass histogram():\n    \"\"\"A multidimensional histogram.\n\n    Arbitrary dimension, variable bin size and weights are supported.\n    Lower bin edge is included, upper edge is excluded.\n    Underflow and overflow values are skipped.\n    Bin content can be of arbitrary type,\n    which is defined during initialization.\n\n    Examples:\n\n    >>> # a two-dimensional histogram\n    >>> hist = histogram([[0, 1, 2], [0, 1, 2]])\n    >>> hist.fill([0, 1])\n    >>> hist.bins\n    [[0, 1], [0, 0]]\n    >>> values = [[0, 0], [1, 0], [1, 1]]\n    >>> # fill the histogram with values\n    >>> for v in values:\n    ...     hist.fill(v)\n    >>> hist.bins\n    [[1, 1], [1, 1]]\n    \"\"\"\n    # Note the differences from existing packages.\n    # Numpy 1.16 (numpy.histogram): all but the last\n    # (righthand-most) bin is half-open.\n    # This histogram class has bin limits as in ROOT\n    # (but without overflow and underflow).\n\n    # Numpy: the first element of the range must be less than or equal to the second.\n    # This histogram requires strictly increasing edges.\n    # https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html\n    # https://root.cern.ch/root/htmldoc/guides/users-guide/Histograms.html#bin-numbering\n\n    def __init__(self, edges, bins=None, initial_value=0):\n        \"\"\"*edges* is a sequence of one-dimensional arrays,\n        each containing strictly increasing bin edges.\n\n        Histogram's bins by default\n        are initialized with *initial_value*.\n        It can be any object that supports addition with *weight*\n        during *fill* (but that is not necessary\n        if you don't plan to fill the histogram).\n        If the *initial_value* is compound and requires special copying,\n        create initial bins yourself (see :func:`.init_bins`).\n\n        A histogram can be created from existing *bins* and *edges*.\n        In this case a simple check of the shape of *bins* is done\n        (raising :exc:`.LenaValueError` if failed).\n\n        **Attributes**\n\n        :attr:`edges` is a list of edges on each dimension.\n        Edges mark the borders of the bin.\n        Edges along each dimension are one-dimensional lists,\n        and the multidimensional bin is the result of all intersections\n        of one-dimensional edges.\n        For example, a 3-dimensional histogram has edges of the form\n        *[x_edges, y_edges, z_edges]*,\n        and the 0th bin has borders\n        *((x[0], x[1]), (y[0], y[1]), (z[0], z[1]))*.\n\n        Index in the edges is a tuple, where a given position corresponds\n        to a dimension, and the content at that position\n        to the bin along that dimension.\n        For example, index *(0, 1, 3)* corresponds to the bin\n        with lower edges *(x[0], y[1], z[3])*.\n\n        :attr:`bins` is a list of nested lists.\n        Same index as for edges can be used to get bin content:\n        bin at *(0, 1, 3)* can be obtained as *bins[0][1][3]*.\n        Most nested arrays correspond to highest\n        (further from x) coordinates.\n        For example, for a 3-dimensional histogram bins equal to\n        *[[[1, 1], [0, 0]], [[0, 0], [0, 0]]]*\n        mean that the only filled bins are those\n        where x and y indices are 0, and z index is 0 and 1.\n\n        :attr:`dim` is the dimension of a histogram\n        (length of its *edges* for a multidimensional histogram).\n\n        If subarrays of *edges* are not increasing\n        or if any of them has length less than 2,\n        :exc:`.LenaValueError` is raised.\n\n        .. admonition:: Programmer's note\n\n            one- and multidimensional histograms\n            have different *bins* and *edges* format.\n            To be unified, 1-dimensional edges should be\n            nested in a list (like *[[1, 2, 3]]*).\n            Instead, they are simply the x-edges list,\n            because it is more intuitive and one-dimensional histograms\n            are used more often.\n            To unify the interface for bins and edges in your code,\n            use :func:`.unify_1_md` function.\n        \"\"\"\n        # todo: allow creation of *edges* from tuples\n        # (without lena.math.mesh). Allow bin_size in this case.\n        hf.check_edges_increasing(edges)\n        self.edges = edges\n        self._scale = None\n\n        if hasattr(edges[0], \"__iter__\"):\n            self.dim = len(edges)\n        else:\n            self.dim = 1\n\n        # todo: add a kwarg no_check=False to disable bins testing\n        if bins is None:\n            self.bins = hf.init_bins(self.edges, initial_value)\n        else:\n            self.bins = bins\n            # We can't make scale for an arbitrary histogram,\n            # because it may contain compound values.\n            # self._scale = self.make_scale()\n            wrong_bins_error = lena.core.LenaValueError(\n                \"bins of incorrect shape given, {}\".format(bins)\n            )\n            if self.dim == 1:\n                if len(bins) != len(edges) - 1:\n                    raise wrong_bins_error\n            else:\n                if len(bins) != len(edges[0]) - 1:\n                    raise wrong_bins_error\n        if self.dim > 1:\n            self.ranges = [(axis[0], axis[-1]) for axis in edges]\n            self.nbins =  [len(axis) - 1 for axis in edges]\n        else:\n            self.ranges = [(edges[0], edges[-1])]\n            self.nbins = [len(edges)-1]\n\n    def __eq__(self, other):\n        \"\"\"Two histograms are equal, if and only if they have\n        equal bins and equal edges.\n\n        If *other* is not a :class:`.histogram`, return ``False``.\n\n        Note that floating numbers should be compared\n        approximately (using :func:`math.isclose`).\n        \"\"\"\n        if not isinstance(other, histogram):\n            # in Python comparison between different types is allowed\n            return False\n        return self.bins == other.bins and self.edges == other.edges\n\n    def fill(self, coord, weight=1):\n        \"\"\"Fill histogram at *coord* with the given *weight*.\n\n        Coordinates outside the histogram edges are ignored.\n        \"\"\"\n        indices = hf.get_bin_on_value(coord, self.edges)\n        subarr = self.bins\n        for ind in indices[:-1]:\n            # underflow\n            if ind < 0:\n                return\n            try:\n                subarr = subarr[ind]\n            # overflow\n            except IndexError:\n                return\n        ind = indices[-1]\n        # underflow\n        if ind < 0:\n            return\n\n        # fill\n        try:\n            subarr[ind] += weight\n        except IndexError:\n            return\n\n    def __repr__(self):\n        return \"histogram({}, bins={})\".format(self.edges, self.bins)\n", "contexts_below": "    def _update_context(self, context):\n         \"\"\"Update *context* with the properties of this histogram.\n \n         *context.histogram* is updated with \"dim\", \"nbins\"\n         and \"ranges\" with values for this histogram.\n         If this histogram has a computed scale, it is also added\n         to the context.\n \n         Called on \"destruction\" of the histogram structure (for example,\n         in :class:`.ToCSV`). See graph._update_context for more details.\n         \"\"\"\n \n         hist_context = {\n             \"dim\": self.dim,\n             \"nbins\": self.nbins,\n             \"ranges\": self.ranges\n         }\n \n         if self._scale is not None:\n             hist_context[\"scale\"] = self._scale\n \n         lena.context.update_recursively(context, {\"histogram\": hist_context})\n \n \n class Histogram():\n     \"\"\"An element to produce histograms.\"\"\"\n \n     def __init__(self, edges, bins=None, make_bins=None, initial_value=0):\n         \"\"\"*edges*, *bins* and *initial_value* have the same meaning\n         as during creation of a :class:`histogram`.\n \n         *make_bins* is a function without arguments\n         that creates new bins\n         (it will be called during :meth:`__init__` and :meth:`reset`).\n         *initial_value* in this case is ignored, but bin check is made.\n         If both *bins* and *make_bins* are provided,\n         :exc:`.LenaTypeError` is raised.\n         \"\"\"\n         self._hist = histogram(edges, bins)\n \n         if make_bins is not None and bins is not None:\n             raise lena.core.LenaTypeError(\n                 \"either initial bins or make_bins must be provided, \"\n                 \"not both: {} and {}\".format(bins, make_bins)\n             )\n \n         # may be None\n         self._initial_bins = copy.deepcopy(bins)\n \n         # todo: bins, make_bins, initial_value look redundant\n         # and may be reconsidered when really using reset().\n         if make_bins:\n             bins = make_bins()\n         self._make_bins = make_bins\n \n         self._cur_context = {}\n \n     def fill(self, value):\n         \"\"\"Fill the histogram with *value*.\n \n         *value* can be a *(data, context)* pair. \n         Values outside the histogram edges are ignored.\n         \"\"\"\n         data, self._cur_context = lena.flow.get_data_context(value)\n         self._hist.fill(data)\n         # filling with weight is only allowed in histogram structure\n         # self._hist.fill(data, weight)\n \n     def compute(self):\n         \"\"\"Yield histogram with context.\"\"\"\n         yield (self._hist, self._cur_context)\n \n     def reset(self):\n         \"\"\"Reset the histogram.\n \n         Current context is reset to an empty dict.\n         Bins are reinitialized with the *initial_value*\n         or with *make_bins()* (depending on the initialization).\n         \"\"\"\n         if self._make_bins is not None:\n             self.bins = self._make_bins()\n         elif self._initial_bins is not None:\n             self.bins = copy.deepcopy(self._initial_bins)\n         else:\n             self.bins = hf.init_bins(self.edges, self._initial_value)\n \n         self._cur_context = {}\n ", "input_code": "def scale(self, other=None, recompute=False):\n\"\"\"\nCompute or set scale (integral of the histogram).\n\nIf *other* is ``None``, return scale of this histogram.\nIf its scale was not computed before,\nit is computed and stored for subsequent use\n(unless explicitly asked to *recompute*).\nNote that after changing (filling) the histogram\none must explicitly recompute the scale\nif it was computed before.\n\nIf a float *other* is provided, rescale self to *other*.\n\nHistograms with scale equal to zero can't be rescaled.\n:exc:`.LenaValueError` is raised if one tries to do that.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def scale(self, other=None, recompute=False):\n        \"\"\"Compute or set scale (integral of the histogram).\n\n        If *other* is ``None``, return scale of this histogram.\n        If its scale was not computed before,\n        it is computed and stored for subsequent use\n        (unless explicitly asked to *recompute*).\n        Note that after changing (filling) the histogram\n        one must explicitly recompute the scale\n        if it was computed before.\n\n        If a float *other* is provided, rescale self to *other*.\n\n        Histograms with scale equal to zero can't be rescaled.\n        :exc:`.LenaValueError` is raised if one tries to do that.\n        \"\"\"\n        # see graph.scale comments why this is called simply \"scale\"\n        # (not set_scale, get_scale, etc.)\n        if other is None:\n            # return scale\n            if self._scale is None or recompute:\n                self._scale = hf.integral(\n                    *hf.unify_1_md(self.bins, self.edges)\n                )\n            return self._scale\n        else:\n            # rescale from other\n            scale = self.scale()\n            if scale == 0:\n                raise lena.core.LenaValueError(\n                    \"can not rescale histogram with zero scale\"\n                )\n            self.bins = lena.math.md_map(lambda binc: binc*float(other) / scale,\n                                         self.bins)\n            self._scale = other\n            return None", "signature": "def scale(self, other=None, recompute=False):", "completion_path": "lena/structures/histogram.py"}
{"ce_id": "62b87b519a0c4fa8b80b3583", "namespace": "62b87b519a0c4fa8b80b3583", "namespace_real": "lena.structures.graph.scale", "real_proj_path": "ynikitenko---lena/", "type": "class", "class_name": "graph", "function_name": "scale", "contexts_above": "\"\"\"A graph is a function at given coordinates.\"\"\"\nimport copy\nimport functools\nimport operator\nimport re\nimport warnings\n\nimport lena.core\nimport lena.context\nimport lena.flow\n\n\nclass graph():\n    \"\"\"Numeric arrays of equal size.\"\"\"\n\n    def __init__(self, coords, field_names=(\"x\", \"y\"), scale=None):\n        \"\"\"This structure generally corresponds\n        to the graph of a function\n        and represents arrays of coordinates and the function values\n        of arbitrary dimensions.\n\n        *coords* is a list of one-dimensional\n        coordinate and value sequences (usually lists).\n        There is little to no distinction between them,\n        and \"values\" can also be called \"coordinates\".\n\n        *field_names* provide the meaning of these arrays.\n        For example, a 3-dimensional graph could be distinguished\n        from a 2-dimensional graph with errors by its fields\n        (\"x\", \"y\", \"z\") versus (\"x\", \"y\", \"error_y\").\n        Field names don't affect drawing graphs:\n        for that :class:`~Variable`-s should be used.\n        Default field names,\n        provided for the most used 2-dimensional graphs,\n        are \"x\" and \"y\".\n\n        *field_names* can be a string separated by whitespace\n        and/or commas or a tuple of strings, such as (\"x\", \"y\").\n        *field_names* must have as many elements\n        as *coords* and each field name must be unique.\n        Otherwise field names are arbitrary.\n        Error fields must go after all other coordinates.\n        Name of a coordinate error is \"error\\\\_\"\n        appended by coordinate name. Further error details\n        are appended after '_'. They could be arbitrary depending\n        on the problem: \"low\", \"high\", \"low_90%_cl\", etc. Example:\n        (\"E\", \"time\", \"error_E_low\", \"error_time\").\n\n        *scale* of the graph is a kind of its norm. It could be\n        the integral of the function or its other property.\n        A scale of a normalised probability density\n        function would be one.\n        An initialized *scale* is required if one needs\n        to renormalise the graph in :meth:`scale`\n        (for example, to plot it with other graphs).\n\n        Coordinates of a function graph would usually be arrays\n        of increasing values, which is not required here.\n        Neither is it checked that coordinates indeed\n        contain one-dimensional numeric values.\n        However, non-standard graphs\n        will likely lead to errors during plotting\n        and will require more programmer's work and caution,\n        so use them only if you understand what you are doing.\n\n        A graph can be iterated yielding tuples of numbers\n        for each point.\n\n        **Attributes**\n\n        :attr:`coords` is a list \\\n            of one-dimensional lists of coordinates.\n\n        :attr:`field_names`\n\n        :attr:`dim` is the dimension of the graph,\n        that is of all its coordinates without errors.\n\n        In case of incorrect initialization arguments,\n        :exc:`~.LenaTypeError` or :exc:`~.LenaValueError` is raised.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if not coords:\n            raise lena.core.LenaValueError(\n                \"coords must be a non-empty sequence \"\n                \"of coordinate sequences\"\n            )\n\n        # require coords to be of the same size\n        pt_len = len(coords[0])\n        for arr in coords[1:]:\n            if len(arr) != pt_len:\n                raise lena.core.LenaValueError(\n                    \"coords must have subsequences of equal lengths\"\n                )\n\n        # Unicode (Python 2) field names would be just bad,\n        # so we don't check for it here.\n        if isinstance(field_names, str):\n            # split(', ') won't work.\n            # From https://stackoverflow.com/a/44785447/952234:\n            # \\s stands for whitespace.\n            field_names = tuple(re.findall(r'[^,\\s]+', field_names))\n        elif not isinstance(field_names, tuple):\n            # todo: why field_names are a tuple,\n            # while coords are a list?\n            # It might be non-Pythonic to require a tuple\n            # (to prohibit a list), but it's important\n            # for comparisons and uniformity\n            raise lena.core.LenaTypeError(\n                \"field_names must be a string or a tuple\"\n            )\n\n        if len(field_names) != len(coords):\n            raise lena.core.LenaValueError(\n                \"field_names must have must have the same size as coords\"\n            )\n\n        if len(set(field_names)) != len(field_names):\n            raise lena.core.LenaValueError(\n                \"field_names contains duplicates\"\n            )\n\n        self.coords = coords\n        self._scale = scale\n\n        # field_names are better than fields,\n        # because they are unambigous (as in namedtuple).\n        self.field_names = field_names\n\n        # decided to use \"error_x_low\" (like in ROOT).\n        # Other versions were x_error (looked better than x_err),\n        # but x_err_low looked much better than x_error_low).\n        try:\n            parsed_error_names = self._parse_error_names(field_names)\n        except lena.core.LenaValueError as err:\n            raise err\n            # in Python 3\n            # raise err from None\n        self._parsed_error_names = parsed_error_names\n\n        dim = len(field_names) - len(parsed_error_names)\n        self._coord_names = field_names[:dim]\n        self.dim = dim\n\n        # todo: add subsequences of coords as attributes\n        # with field names.\n        # In case if someone wants to create a graph of another function\n        # at the same coordinates.\n        # Should a) work when we rescale the graph\n        #        b) not interfere with other fields and methods\n\n        # Probably we won't add methods __del__(n), __add__(*coords),\n        # since it might change the scale.\n\n    def __eq__(self, other):\n        \"\"\"Two graphs are equal, if and only if they have\n        equal coordinates, field names and scales.\n\n        If *other* is not a :class:`.graph`, return ``False``.\n\n        Note that floating numbers should be compared\n        approximately (using :func:`math.isclose`).\n        Therefore this comparison may give false negatives.\n        \"\"\"\n        if not isinstance(other, graph):\n            # in Python comparison between different types is allowed\n            return False\n        return (self.coords == other.coords and self._scale == other._scale\n                and self.field_names == other.field_names)\n\n    def _get_err_indices(self, coord_name):\n        \"\"\"Get error indices corresponding to a coordinate.\"\"\"\n        err_indices = []\n        dim = self.dim\n        for ind, err in enumerate(self._parsed_error_names):\n            if err[1] == coord_name:\n                err_indices.append(ind+dim)\n        return err_indices\n\n    def __iter__(self):\n        \"\"\"Iterate graph coords one by one.\"\"\"\n        for val in zip(*self.coords):\n            yield val\n\n    def __repr__(self):\n        return \"\"\"graph({}, field_names={}, scale={})\"\"\".format(\n            self.coords, self.field_names, self._scale\n        )\n", "contexts_below": "    def _parse_error_names(self, field_names):\n         # field_names is a parameter for easier testing,\n         # usually object's field_names are used.\n         errors = []\n \n         # collect all error fields and check that they are\n         # strictly after other fields\n         in_error_fields = False\n         # there is at least one field\n         last_coord_ind = 0\n         for ind, field in enumerate(field_names):\n             if field.startswith(\"error_\"):\n                 in_error_fields = True\n                 errors.append((field, ind))\n             else:\n                 last_coord_ind = ind\n                 if in_error_fields:\n                     raise lena.core.LenaValueError(\n                         \"errors must go after coordinate fields\"\n                     )\n \n         coords = set(field_names[:last_coord_ind+1])\n         parsed_errors = []\n \n         for err, ind in errors:\n             err_coords = []\n             for coord in coords:\n                 err_main = err[6:]  # all after \"error_\"\n                 if err_main == coord or err_main.startswith(coord + \"_\"):\n                     err_coords.append(coord)\n                     err_tail = err_main[len(coord)+1:]\n             if not err_coords:\n                 raise lena.core.LenaValueError(\n                     \"no coordinate corresponding to {} given\".format(err)\n                 )\n             elif len(err_coords) > 1:\n                 raise lena.core.LenaValueError(\n                     \"ambiguous error \" + err +\\\n                     \" corresponding to several coordinates given\"\n                 )\n             # \"error\" may be redundant, but it is explicit.\n             parsed_errors.append((\"error\", err_coords[0], err_tail, ind))\n \n         return parsed_errors\n \n     def _update_context(self, context):\n         \"\"\"Update *context* with the properties of this graph.\n \n         *context.error* is appended with indices of errors.\n         Example subcontext for a graph with fields \"E,t,error_E_low\":\n         {\"error\": {\"x_low\": {\"index\": 2}}}.\n         Note that error names are called \"x\", \"y\" and \"z\"\n         (this corresponds to first three coordinates,\n         if they are present), which allows to simplify plotting.\n         Existing values are not removed\n         from *context.value* and its subcontexts.\n \n         Called on \"destruction\" of the graph (for example,\n         in :class:`.ToCSV`). By destruction we mean conversion\n         to another structure (like text) in the flow.\n         The graph object is not really destroyed in this process.\n         \"\"\"\n         # this method is private, because we encourage users to yield\n         # graphs into the flow and process them with ToCSV element\n         # (not manually).\n \n         if not self._parsed_error_names:\n             # no error fields present\n             return\n \n         dim = self.dim\n \n         xyz_coord_names = self._coord_names[:3]\n         for name, coord_name in zip([\"x\", \"y\", \"z\"], xyz_coord_names):\n             for err in self._parsed_error_names:\n                 if err[1] == coord_name:\n                     error_ind = err[3]\n                     if err[2]:\n                         # add error suffix\n                         error_name = name + \"_\" + err[2]\n                     else:\n                         error_name = name\n                     lena.context.update_recursively(\n                         context,\n                         \"error.{}.index\".format(error_name),\n                         # error can correspond both to variable and\n                         # value, so we put it outside value.\n                         # \"value.error.{}.index\".format(error_name),\n                         error_ind\n                     )\n \n \n # used in deprecated Graph\n def _rescale_value(rescale, value):\n     return rescale * lena.flow.get_data(value)\n \n \n class Graph(object):\n     \"\"\"\n     .. deprecated:: 0.5\n        use :class:`graph`.\n        This class may be used in the future,\n        but with a changed interface.\n \n     Function at given coordinates (arbitraty dimensions).\n \n     Graph points can be set during the initialization and\n     during :meth:`fill`. It can be rescaled (producing a new :class:`Graph`).\n     A point is a tuple of *(coordinate, value)*, where both *coordinate*\n     and *value* can be tuples of numbers.\n     *Coordinate* corresponds to a point in N-dimensional space,\n     while *value* is some function's value at this point\n     (the function can take a value in M-dimensional space).\n     Coordinate and value dimensions must be the same for all points.\n \n     One can get graph points as :attr:`Graph.points` attribute.\n     They will be sorted each time before return\n     if *sort* was set to ``True``.\n     An attempt to change points\n     (use :attr:`Graph.points` on the left of '=')\n     will raise Python's :exc:`AttributeError`.\n     \"\"\"\n \n     def __init__(self, points=None, context=None, scale=None, sort=True):\n         \"\"\"*points* is an array of *(coordinate, value)* tuples.\n \n         *context* is the same as the most recent context\n         during *fill*. Use it to provide a context\n         when initializing a :class:`Graph` from existing points.\n \n         *scale* sets the scale of the graph.\n         It is used during plotting if rescaling is needed.\n \n         Graph coordinates are sorted by default.\n         This is usually needed to plot graphs of functions.\n         If you need to keep the order of insertion, set *sort* to ``False``.\n \n         By default, sorting is done using standard Python\n         lists and functions. You can disable *sort* and provide your own\n         sorting container for *points*.\n         Some implementations are compared\n         `here <http://www.grantjenks.com/docs/sortedcontainers/performance.html>`_.\n         Note that a rescaled graph uses a default list.\n \n         Note that :class:`Graph` does not reduce data.\n         All filled values will be stored in it.\n         To reduce data, use histograms.\n         \"\"\"\n         warnings.warn(\"Graph is deprecated since Lena 0.5. Use graph.\",\n                       DeprecationWarning, stacklevel=2)\n \n         self._points = points if points is not None else []\n         # todo: add some sanity checks for points\n         self._scale = scale\n         self._init_context = {\"scale\": scale}\n         if context is None:\n             self._cur_context = {}\n         elif not isinstance(context, dict):\n             raise lena.core.LenaTypeError(\n                 \"context must be a dict, {} provided\".format(context)\n             )\n         else:\n             self._cur_context = context\n         self._sort = sort\n \n         # todo: probably, scale from context is not needed.\n \n         ## probably this function is not needed.\n         ## it can't be copied, graphs won't be possible to compare.\n         # *rescale_value* is a function, which can be used to scale\n         # complex graph values.\n         # It must accept a rescale parameter and the value at a data point.\n         # By default, it is multiplication of rescale and the value\n         # (which must be a number).\n         # if rescale_value is None:\n         #     self._rescale_value = _rescale_value\n         self._rescale_value = _rescale_value\n         self._update()\n \n     def fill(self, value):\n         \"\"\"Fill the graph with *value*.\n \n         *Value* can be a *(data, context)* tuple.\n         *Data* part must be a *(coordinates, value)* pair,\n         where both coordinates and value are also tuples.\n         For example, *value* can contain the principal number\n         and its precision.\n         \"\"\"\n         point, self._cur_context = lena.flow.get_data_context(value)\n         # coords, val = point\n         self._points.append(point)\n \n     def request(self):\n         \"\"\"Yield graph with context.\n \n         If *sort* was initialized ``True``, graph points will be sorted.\n         \"\"\"\n         # If flow contained *scale* it the context, it is set now.\n         self._update()\n         yield (self, self._context)\n \n     # compute method shouldn't be in this class,\n     # because it is a pure FillRequest.\n     # def compute(self):\n     #     \"\"\"Yield graph with context (as in :meth:`request`),\n     #     and :meth:`reset`.\"\"\"\n     #     self._update()\n     #     yield (self, self._context)\n     #     self.reset()\n \n     @property\n     def points(self):\n         \"\"\"Get graph points (read only).\"\"\"\n         # sort points before giving them\n         self._update()\n         return self._points\n \n     def reset(self):\n         \"\"\"Reset points to an empty list\n         and current context to an empty dict.\n         \"\"\"\n         self._points = []\n         self._cur_context = {}\n \n     def __repr__(self):\n         self._update()\n         return (\"Graph(points={}, scale={}, sort={})\"\n                 .format(self._points, self._scale, self._sort))\n \n     def scale(self, other=None):\n         \"\"\"Get or set the scale.\n \n         Graph's scale comes from an external source.\n         For example, if the graph was computed from a function,\n         this may be its integral passed via context during :meth:`fill`.\n         Once the scale is set, it is stored in the graph.\n         If one attempts to use scale which was not set,\n         :exc:`.LenaAttributeError` is raised.\n \n         If *other* is None, return the scale.\n \n         If a ``float`` *other* is provided, rescale to *other*.\n         A new graph with the scale equal to *other*\n         is returned, the original one remains unchanged.\n         Note that in this case its *points* will be a simple list\n         and new graph *sort* parameter will be ``True``.\n \n         Graphs with scale equal to zero can't be rescaled. \n         Attempts to do that raise :exc:`.LenaValueError`.\n         \"\"\"\n         if other is None:\n             # return scale\n             self._update()\n             if self._scale is None:\n                 raise lena.core.LenaAttributeError(\n                     \"scale must be explicitly set before using that\"\n                 )\n             return self._scale\n         else:\n             # rescale from other\n             scale = self.scale()\n             if scale == 0:\n                 raise lena.core.LenaValueError(\n                     \"can't rescale graph with 0 scale\"\n                 )\n \n             # new_init_context = copy.deepcopy(self._init_context)\n             # new_init_context.update({\"scale\": other})\n \n             rescale = float(other) / scale\n             new_points = []\n             for coord, val in self._points:\n                 # probably not needed, because tuples are immutable:\n                 # make a deep copy so that new values\n                 # are completely independent from old ones.\n                 new_points.append((coord, self._rescale_value(rescale, val)))\n             # todo: should it inherit context?\n             # Probably yes, but watch out scale.\n             new_graph = Graph(points=new_points, scale=other,\n                               sort=self._sort)\n             return new_graph\n \n     def to_csv(self, separator=\",\", header=None):\n         \"\"\".. deprecated:: 0.5 in Lena 0.5 to_csv is not used.\n               Iterables are converted to tables.\n \n         Convert graph's points to CSV.\n \n         *separator* delimits values, the default is comma.\n \n         *header*, if not ``None``, is the first string of the output\n         (new line is added automatically).\n \n         Since a graph can be multidimensional,\n         for each point first its coordinate is converted to string\n         (separated by *separator*), then each part of its value.\n \n         To convert :class:`Graph` to CSV inside a Lena sequence,\n         use :class:`lena.output.ToCSV`.\n         \"\"\"\n         if self._sort:\n             self._update()\n \n         def unpack_pt(pt):\n             coord = pt[0]\n             value = pt[1]\n             if isinstance(coord, tuple):\n                 unpacked = list(coord)\n             else:\n                 unpacked = [coord]\n             if isinstance(value, tuple):\n                 unpacked += list(value)\n             else:\n                 unpacked.append(value)\n             return unpacked\n \n         def pt_to_str(pt, separ):\n             return separ.join([str(val) for val in unpack_pt(pt)])\n \n         if header is not None:\n             # if one needs an empty header line, they may provide \"\"\n             lines = header + \"\\n\"\n         else:\n             lines = \"\"\n         lines += \"\\n\".join([pt_to_str(pt, separator) for pt in self.points])\n \n         return lines\n \n     #     *context* will be added to graph context.\n     #     If it contains \"scale\", :meth:`scale` method will be available.\n     #     Otherwise, if \"scale\" is contained in the context\n     #     during :meth:`fill`, it will be used.\n     #     In this case it is assumed that this scale\n     #     is same for all values (only the last filled context is checked).\n     #     Context from flow takes precedence over the initialized one.\n \n     def _update(self):\n         \"\"\"Sort points if needed, update context.\"\"\"\n         # todo: probably remove this context_scale?\n         context_scale = self._cur_context.get(\"scale\")\n         if context_scale is not None:\n             # this complex check is fine with rescale,\n             # because that returns a new graph (this scale unchanged).\n             if self._scale is not None and self._scale != context_scale:\n                 raise lena.core.LenaRuntimeError(\n                     \"Initialization and context scale differ, \"\n                     \"{} and {} from context {}\"\n                     .format(self._scale, context_scale, self._cur_context)\n                 )\n             self._scale = context_scale\n         if self._sort:\n             self._points = sorted(self._points)\n \n         self._context = copy.deepcopy(self._cur_context)\n         self._context.update(self._init_context)\n         # why this? Not *graph.scale*?\n         self._context.update({\"scale\": self._scale})\n         # self._context.update(lena.context.make_context(self, \"_scale\"))\n \n         # todo: make this check during fill. Probably initialize self._dim\n         # with kwarg dim. (dim of coordinates or values?)\n         if self._points:\n             # check points correctness\n             points = self._points\n             def coord_dim(coord):\n                 if not hasattr(coord, \"__len__\"):\n                     return 1\n                 return len(coord)\n             first_coord = points[0][0]\n             dim = coord_dim(first_coord)\n             same_dim = all(coord_dim(point[0]) == dim for point in points)\n             if not same_dim:\n                 raise lena.core.LenaValueError(\n                     \"coordinates tuples must have same dimension, \"\n                     \"{} given\".format(points)\n                 )\n             self.dim = dim\n             self._context[\"dim\"] = self.dim\n \n     def __eq__(self, other):\n         if not isinstance(other, Graph):\n             return False\n         if self.points != other.points:\n             return False\n         if self._scale is None and other._scale is None:\n             return True\n         try:\n             result = self.scale() == other.scale()\n         except lena.core.LenaAttributeError:\n             # one scale couldn't be computed\n             return False\n         else:\n             return result\n ", "input_code": "def scale(self, other=None):\n\"\"\"\nGet or set the scale of the graph.\n\nIf *other* is ``None``, return the scale of this graph.\n\nIf a numeric *other* is provided, rescale to that value.\nIf the graph has unknown or zero scale,\nrescaling that will raise :exc:`~.LenaValueError`.\n\nTo get meaningful results, graph's fields are used.\nOnly the last coordinate is rescaled.\nFor example, if the graph has *x* and *y* coordinates,\nthen *y* will be rescaled, and for a 3-dimensional graph\n*z* will be rescaled.\nAll errors are rescaled together with their coordinate.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def scale(self, other=None):\n        \"\"\"Get or set the scale of the graph.\n\n        If *other* is ``None``, return the scale of this graph.\n\n        If a numeric *other* is provided, rescale to that value.\n        If the graph has unknown or zero scale,\n        rescaling that will raise :exc:`~.LenaValueError`.\n\n        To get meaningful results, graph's fields are used.\n        Only the last coordinate is rescaled.\n        For example, if the graph has *x* and *y* coordinates,\n        then *y* will be rescaled, and for a 3-dimensional graph\n        *z* will be rescaled.\n        All errors are rescaled together with their coordinate.\n        \"\"\"\n        # this method is called scale() for uniformity with histograms\n        # And this looks really good: explicit for computations\n        # (not a subtle graph.scale, like a constant field (which is,\n        #  however, the case in graph - but not in other structures))\n        # and easy to remember (set_scale? rescale? change_scale_to?..)\n\n        # We modify the graph in place,\n        # because that would be redundant (not optimal)\n        # to create a new graph\n        # if we only want to change the scale of the existing one.\n\n        if other is None:\n            return self._scale\n\n        if not self._scale:\n            raise lena.core.LenaValueError(\n                \"can't rescale a graph with zero or unknown scale\"\n            )\n\n        last_coord_ind = self.dim - 1\n        last_coord_name = self.field_names[last_coord_ind]\n\n        last_coord_indices = ([last_coord_ind] +\n                self._get_err_indices(last_coord_name)\n        )\n\n        # In Python 2 3/2 is 1, so we want to be safe;\n        # the downside is that integer-valued graphs\n        # will become floating, but that is doubtfully an issue.\n        # Remove when/if dropping support for Python 2.\n        rescale = float(other) / self._scale\n\n        mul = operator.mul\n        partial = functools.partial\n\n        # a version with lambda is about 50% slower:\n        # timeit.timeit('[*map(lambda val: val*2, vals)]', \\\n        #     setup='vals = list(range(45)); from operator import mul; \\\n        #     from functools import partial')\n        # 3.159\n        # same setup for\n        # timeit.timeit('[*map(partial(mul, 2), vals)]',...):\n        # 2.075\n        # \n        # [*map(...)] is very slightly faster than list(map(...)),\n        # but it's unavailable in Python 2 (and anyway less readable).\n\n        # rescale arrays of values and errors\n        for ind, arr in enumerate(self.coords):\n            if ind in last_coord_indices:\n                # Python lists are faster than arrays,\n                # https://stackoverflow.com/a/62399645/952234\n                # (because each time taking a value from an array\n                #  creates a Python object)\n                self.coords[ind] = list(map(partial(mul, rescale),\n                                            arr))\n\n        self._scale = other\n\n        # as suggested in PEP 8\n        return None", "signature": "def scale(self, other=None):", "completion_path": "lena/structures/graph.py"}
{"ce_id": "62b87b869a0c4fa8b80b35e1", "namespace": "62b87b869a0c4fa8b80b35e1", "namespace_real": "lena.structures.hist_functions.hist_to_graph", "real_proj_path": "ynikitenko---lena/", "type": "function", "class_name": null, "function_name": "hist_to_graph", "contexts_above": "\"\"\"Functions for histograms.\n\nThese functions are used for low-level work\nwith histograms and their contents.\nThey are not needed for normal usage.\n\"\"\"\nimport collections\nimport copy\nimport itertools\nimport operator\nimport re\nimport sys\nif sys.version_info.major == 3:\n    from functools import reduce as _reduce\nelse:\n    _reduce = reduce\n\nimport lena.core\nfrom .graph import graph as _graph\n\n\nclass HistCell(collections.namedtuple(\"HistCell\", (\"edges, bin, index\"))):\n    \"\"\"A namedtuple with fields *edges, bin, index*.\"\"\"\n    # from Aaron Hall's answer https://stackoverflow.com/a/28568351/952234\n    __slots__ = ()\n\n\ndef cell_to_string(\n        cell_edges, var_context=None, coord_names=None,\n        coord_fmt=\"{}_lte_{}_lt_{}\", coord_join=\"_\", reverse=False):\n    \"\"\"Transform cell edges into a string.\n\n    *cell_edges* is a tuple of pairs *(lower bound, upper bound)*\n    for each coordinate.\n\n    *coord_names* is a list of coordinates names.\n\n    *coord_fmt* is a string,\n    which defines how to format individual coordinates.\n\n    *coord_join* is a string, which joins coordinate pairs.\n\n    If *reverse* is True, coordinates are joined in reverse order.\n    \"\"\"\n    # todo: do we really need var_context?\n    # todo: even if so, why isn't that a {}? Is that dangerous?\n    if coord_names is None:\n        if var_context is None:\n            coord_names = [\n                \"coord{}\".format(ind) for ind in range(len(cell_edges))\n            ]\n        else:\n            if \"combine\" in var_context:\n                coord_names = [var[\"name\"]\n                               for var in var_context[\"combine\"]]\n            else:\n                coord_names = [var_context[\"name\"]]\n    if len(cell_edges) != len(coord_names):\n        raise lena.core.LenaValueError(\n            \"coord_names must have same length as cell_edges, \"\n            \"{} and {} given\".format(coord_names, cell_edges)\n        )\n    coord_strings = [coord_fmt.format(edge[0], coord_names[ind], edge[1])\n                     for (ind, edge) in enumerate(cell_edges)]\n    if reverse:\n        coord_strings = reversed(coord_strings)\n    coord_str = coord_join.join(coord_strings)\n    return coord_str\n\n\ndef _check_edges_increasing_1d(arr):\n    if len(arr) <= 1:\n        raise lena.core.LenaValueError(\"size of edges should be more than one,\"\n                                       \" {} provided\".format(arr))\n    increasing = (tup[0] < tup[1] for tup in zip(arr, arr[1:]))\n    if not all(increasing):\n        raise lena.core.LenaValueError(\n            \"expected strictly increasing values, \"\n            \"{} provided\".format(arr)\n        )\n\n\ndef check_edges_increasing(edges):\n    \"\"\"Assure that multidimensional *edges* are increasing.\n\n    If length of *edges* or its subarray is less than 2\n    or if some subarray of *edges*\n    contains not strictly increasing values,\n    :exc:`.LenaValueError` is raised.\n    \"\"\"\n    if not len(edges):\n        raise lena.core.LenaValueError(\"edges must be non-empty\")\n    elif not hasattr(edges[0], '__iter__'):\n        _check_edges_increasing_1d(edges)\n        return\n    for arr in edges:\n        if len(arr) <= 1:\n            raise lena.core.LenaValueError(\n                \"size of edges should be more than one. \"\n                \"{} provided\".format(arr)\n            )\n        _check_edges_increasing_1d(arr)\n\n\ndef get_bin_edges(index, edges):\n    \"\"\"Return edges of the bin for the given *edges* of a histogram.\n\n    In one-dimensional case *index* must be an integer and a tuple\n    of *(x_low_edge, x_high_edge)* for that bin is returned.\n\n    In a multidimensional case *index* is a container of numeric indices\n    in each dimension.\n    A list of bin edges in each dimension is returned.\"\"\"\n    # todo: maybe give up this 1- and multidimensional unification\n    # and write separate functions for each case.\n    if not hasattr(edges[0], '__iter__'):\n        # 1-dimensional edges\n        if hasattr(index, '__iter__'):\n            index = index[0]\n        return (edges[index], edges[index+1])\n    # multidimensional edges\n    return [(edges[coord][i], edges[coord][i+1])\n            for coord, i in enumerate(index)]\n\n\ndef get_bin_on_index(index, bins):\n    \"\"\"Return bin corresponding to multidimensional *index*.\n\n    *index* can be a number or a list/tuple.\n    If *index* length is less than dimension of *bins*,\n    a subarray of *bins* is returned.\n\n    In case of an index error, :exc:`.LenaIndexError` is raised.\n\n    Example:\n\n    >>> from lena.structures import histogram, get_bin_on_index\n    >>> hist = histogram([0, 1], [0])\n    >>> get_bin_on_index(0, hist.bins)\n    0\n    >>> get_bin_on_index((0, 1), [[0, 1], [0, 0]])\n    1\n    >>> get_bin_on_index(0, [[0, 1], [0, 0]])\n    [0, 1]\n    \"\"\"\n    if not isinstance(index, (list, tuple)):\n        index = [index]\n    subarr = bins\n    for ind in index:\n        try:\n            subarr = subarr[ind]\n        except IndexError:\n            raise lena.core.LenaIndexError(\n                \"bad index: {}, bins = {}\".format(index, bins)\n            )\n    return subarr\n\n\ndef get_bin_on_value_1d(val, arr):\n    \"\"\"Return index for value in one-dimensional array.\n\n    *arr* must contain strictly increasing values\n    (not necessarily equidistant),\n    it is not checked.\n\n    \"Linear binary search\" is used,\n    that is our array search by default assumes\n    the array to be split on equidistant steps.\n\n    Example:\n\n    >>> from lena.structures import get_bin_on_value_1d\n    >>> arr = [0, 1, 4, 5, 7, 10]\n    >>> get_bin_on_value_1d(0, arr)\n    0\n    >>> get_bin_on_value_1d(4.5, arr)\n    2\n    >>> # upper range is excluded\n    >>> get_bin_on_value_1d(10, arr)\n    5\n    >>> # underflow\n    >>> get_bin_on_value_1d(-10, arr)\n    -1\n    \"\"\"\n    # may also use numpy.searchsorted\n    # https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.searchsorted.html\n    ind_min = 0\n    ind_max = len(arr) - 1\n    while True:\n        if ind_max - ind_min <= 1:\n            # lower bound is close\n            if val < arr[ind_min]:\n                return ind_min - 1\n            # upper bound is open\n            elif val >= arr[ind_max]:\n                return ind_max\n            else:\n                return ind_min\n        if val == arr[ind_min]:\n            return ind_min\n        if val < arr[ind_min]:\n            return ind_min - 1\n        elif val >= arr[ind_max]:\n            return ind_max\n        else:\n            shift = int(\n                (ind_max - ind_min) * (\n                    float(val - arr[ind_min]) / (arr[ind_max] - arr[ind_min])\n                ))\n            ind_guess = ind_min + shift\n\n            if ind_min == ind_guess:\n                ind_min += 1\n                continue\n            # ind_max is always more that ind_guess,\n            # because val < arr[ind_max] (see the formula for shift).\n            # This branch is not needed and can't be tested.\n            # But for the sake of numerical inaccuracies, let us keep this\n            # so that we never get into an infinite loop.\n            elif ind_max == ind_guess:\n                ind_max -= 1\n                continue\n\n            if val < arr[ind_guess]:\n                ind_max = ind_guess\n            else:\n                ind_min = ind_guess\n\n\ndef get_bin_on_value(arg, edges):\n    \"\"\"Get the bin index for *arg* in a multidimensional array *edges*.\n\n    *arg* is a 1-dimensional array of numbers\n    (or a number for 1-dimensional *edges*),\n    and corresponds to a point in N-dimensional space.\n\n    *edges* is an array of N-1 dimensional arrays (lists or tuples) of numbers.\n    Each 1-dimensional subarray consists of increasing numbers.\n\n    *arg* and *edges* must have the same length\n    (otherwise :exc:`.LenaValueError` is raised).\n    *arg* and *edges* must be iterable and support *len()*.\n\n    Return list of indices in *edges* corresponding to *arg*.\n\n    If any coordinate is out of its corresponding edge range,\n    its index will be ``-1`` for underflow\n    or ``len(edge)-1`` for overflow.\n\n    Examples:\n\n    >>> from lena.structures import get_bin_on_value\n    >>> edges = [[1, 2, 3], [1, 3.5]]\n    >>> get_bin_on_value((1.5, 2), edges)\n    [0, 0]\n    >>> get_bin_on_value((1.5, 0), edges)\n    [0, -1]\n    >>> # the upper edge is excluded\n    >>> get_bin_on_value((3, 2), edges)\n    [2, 0]\n    >>> # one-dimensional edges\n    >>> edges = [1, 2, 3]\n    >>> get_bin_on_value(2, edges)\n    [1]\n    \"\"\"\n    # arg is a one-dimensional index\n    if not isinstance(arg, (tuple, list)):\n        return [get_bin_on_value_1d(arg, edges)]\n    # arg is a multidimensional index\n    if len(arg) != len(edges):\n        raise lena.core.LenaValueError(\n            \"argument should have same dimension as edges. \"\n            \"arg = {}, edges = {}\".format(arg, edges)\n        )\n    indices = []\n    for ind, array in enumerate(edges):\n        cur_bin = get_bin_on_value_1d(arg[ind], array)\n        indices.append(cur_bin)\n    return indices\n\n\ndef get_example_bin(struct):\n    \"\"\"Return bin with zero index on each axis of the histogram bins.\n\n    For example, if the histogram is two-dimensional, return hist[0][0].\n\n    *struct* can be a :class:`.histogram`\n    or an array of bins.\n    \"\"\"\n    if isinstance(struct, lena.structures.histogram):\n        return lena.structures.get_bin_on_index([0] * struct.dim, struct.bins)\n    else:\n        bins = struct\n        while isinstance(bins, list):\n            bins = bins[0]\n        return bins\n\n", "contexts_below": "\n def init_bins(edges, value=0, deepcopy=False):\n     \"\"\"Initialize cells of the form *edges* with the given *value*.\n \n     Return bins filled with copies of *value*.\n \n     *Value* must be copyable, usual numbers will suit.\n     If the value is mutable, use *deepcopy =* ``True``\n     (or the content of cells will be identical).\n \n     Examples:\n \n     >>> edges = [[0, 1], [0, 1]]\n     >>> # one cell\n     >>> init_bins(edges)\n     [[0]]\n     >>> # no need to use floats,\n     >>> # because integers will automatically be cast to floats\n     >>> # when used together\n     >>> init_bins(edges, 0.0)\n     [[0.0]]\n     >>> init_bins([[0, 1, 2], [0, 1, 2]])\n     [[0, 0], [0, 0]]\n     >>> init_bins([0, 1, 2])\n     [0, 0]\n     \"\"\"\n     nbins = len(edges) - 1\n     if not isinstance(edges[0], (list, tuple)):\n         # edges is one-dimensional\n         if deepcopy:\n             return [copy.deepcopy(value) for _ in range(nbins)]\n         else:\n             return [value] * nbins\n     for ind, arr in enumerate(edges):\n         if ind == nbins:\n             if deepcopy:\n                 return [copy.deepcopy(value) for _ in range(len(arr)-1)]\n             else:\n                 return list([value] * (len(arr)-1))\n         bins = []\n         for _ in range(len(arr)-1):\n             bins.append(init_bins(edges[ind+1:], value, deepcopy))\n         return bins\n \n \n def integral(bins, edges):\n     \"\"\"Compute integral (scale for a histogram).\n \n     *bins* contain values, and *edges* form the mesh\n     for the integration.\n     Their format is defined in :class:`.histogram` description.\n     \"\"\"\n     total = 0\n     for ind, bin_content in iter_bins(bins):\n         bin_lengths = [\n             edges[coord][i+1] - edges[coord][i]\n             for coord, i in enumerate(ind)\n         ]\n         # product\n         vol = _reduce(operator.mul, bin_lengths, 1)\n         cell_integral = vol * bin_content\n         total += cell_integral\n     return total\n \n \n def iter_bins(bins):\n     \"\"\"Iterate on *bins*. Yield *(index, bin content)*.\n \n     Edges with higher index are iterated first\n     (that is z, then y, then x for a 3-dimensional histogram).\n     \"\"\"\n     # if not isinstance(bins, (list, tuple)):\n     if not hasattr(bins, '__iter__'):\n         # cell\n         yield ((), bins)\n     else:\n         for ind, _ in enumerate(bins):\n             for sub_ind, val in iter_bins(bins[ind]):\n                 yield (((ind,) + sub_ind), val)\n \n \n def iter_bins_with_edges(bins, edges):\n     \"\"\"Generate *(bin content, bin edges)* pairs.\n \n     Bin edges is a tuple, such that\n     its item at index i is *(lower bound, upper bound)*\n     of the bin at i-th coordinate.\n \n     Examples:\n \n     >>> from lena.math import mesh\n     >>> list(iter_bins_with_edges([0, 1, 2], edges=mesh((0, 3), 3)))\n     [(0, ((0, 1.0),)), (1, ((1.0, 2.0),)), (2, ((2.0, 3),))]\n     >>>\n     >>> # 2-dimensional histogram\n     >>> list(iter_bins_with_edges(\n     ...     bins=[[2]], edges=mesh(((0, 1), (0, 1)), (1, 1))\n     ... ))\n     [(2, ((0, 1), (0, 1)))]\n \n     .. versionadded:: 0.5\n        made public.\n     \"\"\"\n     # todo: only a list or also a tuple, an array?\n     if not isinstance(edges[0], list):\n         edges = [edges]\n     bins_sizes = [len(edge)-1 for edge in edges]\n     indices = [list(range(nbins)) for nbins in bins_sizes]\n     for index in itertools.product(*indices):\n         bin_ = lena.structures.get_bin_on_index(index, bins)\n         edges_low = []\n         edges_high = []\n         for var, var_ind in enumerate(index):\n             edges_low.append(edges[var][var_ind])\n             edges_high.append(edges[var][var_ind+1])\n         yield (bin_, tuple(zip(edges_low, edges_high)))\n \n \n def iter_cells(hist, ranges=None, coord_ranges=None):\n     \"\"\"Iterate cells of a histogram *hist*, possibly in a subrange.\n \n     For each bin, yield a :class:`HistCell`\n     containing *bin edges, bin content* and *bin index*.\n     The order of iteration is the same as for :func:`iter_bins`.\n \n     *ranges* are the ranges of bin indices to be used\n     for each coordinate\n     (the lower value is included, the upper value is excluded).\n \n     *coord_ranges* set real coordinate ranges based on histogram edges.\n     Obviously, they can be not exactly bin edges.\n     If one of the ranges for the given coordinate\n     is outside the histogram edges,\n     then only existing histogram edges within the range are selected.\n     If the coordinate range is completely outside histogram edges,\n     nothing is yielded.\n     If a lower or upper *coord_range*\n     falls within a bin, this bin is yielded.\n     Note that if a coordinate range falls on a bin edge,\n     the number of generated bins can be unstable\n     because of limited float precision.\n \n     *ranges* and *coord_ranges* are tuples of tuples of limits\n     in corresponding dimensions. \n     For one-dimensional histogram it must be a tuple \n     containing a tuple, for example\n     *((None, None),)*.\n \n     ``None`` as an upper or lower *range* means no limit\n     (*((None, None),)* is equivalent to *((0, len(bins)),)*\n     for a 1-dimensional histogram).\n \n     If a *range* index is lower than 0 or higher than possible index,\n     :exc:`.LenaValueError` is raised.\n     If both *coord_ranges* and *ranges* are provided,\n     :exc:`.LenaTypeError` is raised.\n     \"\"\"\n     # for bin_ind, bin_ in iter_bins(hist.bins):\n     #     yield HistCell(get_bin_edges(bin_ind, hist.edges), bin_, bin_ind)\n     # if bins and edges are calculated each time, save the result now\n     bins, edges = hist.bins, hist.edges\n     # todo: hist.edges must be same\n     # for 1- and multidimensional histograms.\n     if hist.dim == 1:\n         edges = (edges,)\n \n     if coord_ranges is not None:\n         if ranges is not None:\n             raise lena.core.LenaTypeError(\n                 \"only ranges or coord_ranges can be provided, not both\"\n             )\n         ranges = []\n         if not isinstance(coord_ranges[0], (tuple, list)):\n             coord_ranges = (coord_ranges, )\n         for coord, coord_range in enumerate(coord_ranges):\n             # todo: (dis?)allow None as an infinite range.\n             # todo: raise or transpose unordered coordinates?\n             # todo: change the order of function arguments.\n             lower_bin_ind = get_bin_on_value_1d(coord_range[0], edges[coord])\n             if lower_bin_ind == -1:\n                  lower_bin_ind = 0\n             upper_bin_ind = get_bin_on_value_1d(coord_range[1], edges[coord])\n             max_ind = len(edges[coord])\n             if upper_bin_ind == max_ind:\n                  upper_bin_ind -= 1\n             if lower_bin_ind >= max_ind or upper_bin_ind <= 0:\n                  # histogram edges are outside the range.\n                  return\n             ranges.append((lower_bin_ind, upper_bin_ind))\n \n     if not ranges:\n         ranges = ((None, None),) * hist.dim\n \n     real_ind_ranges = []\n     for coord, coord_range in enumerate(ranges):\n         low, up = coord_range\n         if low is None:\n             low = 0\n         else:\n             # negative indices should not be supported\n             if low < 0:\n                 raise lena.core.LenaValueError(\n                     \"low must be not less than 0 if provided\"\n                 )\n         max_ind = len(edges[coord]) - 1\n         if up is None:\n             up = max_ind\n         else:\n             # huge indices should not be supported as well.\n             if up > max_ind:\n                 raise lena.core.LenaValueError(\n                     \"up must not be greater than len(edges)-1, if provided\"\n                 )\n         real_ind_ranges.append(list(range(low, up)))\n \n     indices = list(itertools.product(*real_ind_ranges))\n     for ind in indices:\n         yield HistCell(get_bin_edges(ind, edges),\n                        get_bin_on_index(ind, bins),\n                        ind)\n \n \n def make_hist_context(hist, context):\n     \"\"\"Update a deep copy of *context* with the context\n     of a :class:`.histogram` *hist*.\n \n     .. deprecated:: 0.5\n        histogram context is updated automatically\n        during conversion in :class:`~.output.ToCSV`.\n        Use histogram._update_context explicitly if needed.\n     \"\"\"\n     # absolutely unnecessary.\n     context = copy.deepcopy(context)\n \n     hist_context = {\n         \"histogram\": {\n             \"dim\": hist.dim,\n             \"nbins\": hist.nbins,\n             \"ranges\": hist.ranges\n         }\n     }\n     context.update(hist_context)\n     # just bad.\n     return context\n \n \n def unify_1_md(bins, edges):\n     \"\"\"Unify 1- and multidimensional bins and edges.\n \n     Return a tuple of *(bins, edges)*.  \n     Bins and multidimensional *edges* return unchanged,\n     while one-dimensional *edges* are inserted into a list.\n     \"\"\"\n     if hasattr(edges[0], '__iter__'):\n     # if isinstance(edges[0], (list, tuple)):\n         return (bins, edges)\n     else:\n         return (bins, [edges])\n ", "input_code": "def hist_to_graph(hist, make_value=None, get_coordinate='left', field_names=('x', 'y'), scale=None):\n\"\"\"\nConvert a :class:`.histogram` to a :class:`.graph`.\n\n*make_value* is a function to set the value of a graph's point.\nBy default it is bin content.\n*make_value* accepts a single value (bin content) without context.\n\nThis option could be used to create graph's error bars.\nFor example, to create a graph with errors\nfrom a histogram where bins contain\na named tuple with fields *mean*, *mean_error* and a context\none could use\n\n>>> make_value = lambda bin_: (bin_.mean, bin_.mean_error)\n\n*get_coordinate* defines what the coordinate\nof a graph point created from a histogram bin will be.\nIt can be \"left\" (default), \"right\" and \"middle\".\n\n*field_names* set field names of the graph. Their number\nmust be the same as the dimension of the result.\nFor a *make_value* above they would be\n*(\"x\", \"y_mean\", \"y_mean_error\")*.\n\n*scale* becomes the graph's scale (unknown by default).\nIf it is ``True``, it uses the histogram scale.\n\n*hist* must contain only numeric bins (without context)\nor *make_value* must remove context when creating a numeric graph.\n\nReturn the resulting graph.\n\"\"\"\n", "indent_space": "                  ", "ground_truth": "def hist_to_graph(hist, make_value=None, get_coordinate=\"left\",\n                  field_names=(\"x\", \"y\"), scale=None):\n    \"\"\"Convert a :class:`.histogram` to a :class:`.graph`.\n\n    *make_value* is a function to set the value of a graph's point.\n    By default it is bin content.\n    *make_value* accepts a single value (bin content) without context.\n\n    This option could be used to create graph's error bars.\n    For example, to create a graph with errors\n    from a histogram where bins contain\n    a named tuple with fields *mean*, *mean_error* and a context\n    one could use\n\n    >>> make_value = lambda bin_: (bin_.mean, bin_.mean_error)\n\n    *get_coordinate* defines what the coordinate\n    of a graph point created from a histogram bin will be.\n    It can be \"left\" (default), \"right\" and \"middle\".\n\n    *field_names* set field names of the graph. Their number\n    must be the same as the dimension of the result.\n    For a *make_value* above they would be\n    *(\"x\", \"y_mean\", \"y_mean_error\")*.\n\n    *scale* becomes the graph's scale (unknown by default).\n    If it is ``True``, it uses the histogram scale.\n\n    *hist* must contain only numeric bins (without context)\n    or *make_value* must remove context when creating a numeric graph.\n\n    Return the resulting graph.\n    \"\"\"\n    ## Could have allowed get_coordinate to be callable\n    # (for generality), but 1) first find a use case,\n    # 2) histogram bins could be adjusted in the first place.\n    # -- don't understand 2.\n    if get_coordinate == \"left\":\n        get_coord = lambda edges: tuple(coord[0] for coord in edges)\n    elif get_coordinate == \"right\":\n        get_coord = lambda edges: tuple(coord[1] for coord in edges)\n    # *middle* between the two edges, not the *center* of the bin\n    # as a whole (because the graph corresponds to a point)\n    elif get_coordinate == \"middle\":\n        get_coord = lambda edges: tuple(0.5*(coord[0] + coord[1])\n                                        for coord in edges)\n    else:\n        raise lena.core.LenaValueError(\n            'get_coordinate must be one of \"left\", \"right\" or \"middle\"; '\n            '\"{}\" provided'.format(get_coordinate)\n        )\n\n    # todo: make_value may be bad design.\n    # Maybe allow to change the graph in the sequence.\n    # However, make_value allows not to recreate a graph\n    # or its coordinates (if that is not needed).\n\n    if isinstance(field_names, str):\n        # copied from graph.__init__\n        field_names = tuple(re.findall(r'[^,\\s]+', field_names))\n    elif not isinstance(field_names, tuple):\n        raise lena.core.LenaTypeError(\n            \"field_names must be a string or a tuple\"\n        )\n    coords = [[] for _ in field_names]\n\n    chain = itertools.chain\n\n    if scale is True:\n        scale = hist.scale()\n\n    for value, edges in iter_bins_with_edges(hist.bins, hist.edges):\n        coord = get_coord(edges)\n\n        # Since we never use contexts here, it will be optimal\n        # to ignore them completely (remove them elsewhere).\n        # bin_value = lena.flow.get_data(value)\n        bin_value = value\n\n        if make_value is None:\n            graph_value = bin_value\n        else:\n            graph_value = make_value(bin_value)\n\n        # for iteration below\n        if not hasattr(graph_value, \"__iter__\"):\n            graph_value = (graph_value,)\n\n        # add each coordinate to respective array\n        for arr, coord_ in zip(coords, chain(coord, graph_value)):\n            arr.append(coord_)\n\n    return _graph(coords, field_names=field_names, scale=scale)", "signature": "def hist_to_graph(hist, make_value=None, get_coordinate='left', field_names=('x', 'y'), scale=None):", "completion_path": "lena/structures/hist_functions.py"}
{"ce_id": "62b8b4baeb7e40a82d2d1136", "namespace": "62b8b4baeb7e40a82d2d1136", "namespace_real": "src.zope.interface.verify._verify", "real_proj_path": "pexip---os-zope/", "type": "function", "class_name": null, "function_name": "_verify", "contexts_above": "##############################################################################\n#\n# Copyright (c) 2001, 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"Verify interface implementations\n\"\"\"\nfrom __future__ import print_function\nimport inspect\nimport sys\nfrom types import FunctionType\nfrom types import MethodType\n\nfrom zope.interface._compat import PYPY2\n\nfrom zope.interface.exceptions import BrokenImplementation\nfrom zope.interface.exceptions import BrokenMethodImplementation\nfrom zope.interface.exceptions import DoesNotImplement\nfrom zope.interface.exceptions import Invalid\nfrom zope.interface.exceptions import MultipleInvalid\n\nfrom zope.interface.interface import fromMethod, fromFunction, Method\n\n__all__ = [\n    'verifyObject',\n    'verifyClass',\n]\n\n# This will be monkey-patched when running under Zope 2, so leave this\n# here:\nMethodTypes = (MethodType, )\n\n", "contexts_below": "def _verify_element(iface, name, desc, candidate, vtype):\n     # Here the `desc` is either an `Attribute` or `Method` instance\n     try:\n         attr = getattr(candidate, name)\n     except AttributeError:\n         if (not isinstance(desc, Method)) and vtype == 'c':\n             # We can't verify non-methods on classes, since the\n             # class may provide attrs in it's __init__.\n             return\n         # TODO: On Python 3, this should use ``raise...from``\n         raise BrokenImplementation(iface, desc, candidate)\n \n     if not isinstance(desc, Method):\n         # If it's not a method, there's nothing else we can test\n         return\n \n     if inspect.ismethoddescriptor(attr) or inspect.isbuiltin(attr):\n         # The first case is what you get for things like ``dict.pop``\n         # on CPython (e.g., ``verifyClass(IFullMapping, dict))``). The\n         # second case is what you get for things like ``dict().pop`` on\n         # CPython (e.g., ``verifyObject(IFullMapping, dict()))``.\n         # In neither case can we get a signature, so there's nothing\n         # to verify. Even the inspect module gives up and raises\n         # ValueError: no signature found. The ``__text_signature__`` attribute\n         # isn't typically populated either.\n         #\n         # Note that on PyPy 2 or 3 (up through 7.3 at least), these are\n         # not true for things like ``dict.pop`` (but might be true for C extensions?)\n         return\n \n     if isinstance(attr, FunctionType):\n         if sys.version_info[0] >= 3 and isinstance(candidate, type) and vtype == 'c':\n             # This is an \"unbound method\" in Python 3.\n             # Only unwrap this if we're verifying implementedBy;\n             # otherwise we can unwrap @staticmethod on classes that directly\n             # provide an interface.\n             meth = fromFunction(attr, iface, name=name,\n                                 imlevel=1)\n         else:\n             # Nope, just a normal function\n             meth = fromFunction(attr, iface, name=name)\n     elif (isinstance(attr, MethodTypes)\n           and type(attr.__func__) is FunctionType):\n         meth = fromMethod(attr, iface, name)\n     elif isinstance(attr, property) and vtype == 'c':\n         # Without an instance we cannot be sure it's not a\n         # callable.\n         # TODO: This should probably check inspect.isdatadescriptor(),\n         # a more general form than ``property``\n         return\n \n     else:\n         if not callable(attr):\n             raise BrokenMethodImplementation(desc, \"implementation is not a method\",\n                                              attr, iface, candidate)\n         # sigh, it's callable, but we don't know how to introspect it, so\n         # we have to give it a pass.\n         return\n \n     # Make sure that the required and implemented method signatures are\n     # the same.\n     mess = _incompat(desc.getSignatureInfo(), meth.getSignatureInfo())\n     if mess:\n         if PYPY2 and _pypy2_false_positive(mess, candidate, vtype):\n             return\n         raise BrokenMethodImplementation(desc, mess, attr, iface, candidate)\n \n \n \n def verifyClass(iface, candidate, tentative=False):\n     \"\"\"\n     Verify that the *candidate* might correctly provide *iface*.\n     \"\"\"\n     return _verify(iface, candidate, tentative, vtype='c')\n \n def verifyObject(iface, candidate, tentative=False):\n     return _verify(iface, candidate, tentative, vtype='o')\n \n verifyObject.__doc__ = _verify.__doc__\n \n _MSG_TOO_MANY = 'implementation requires too many arguments'\n _KNOWN_PYPY2_FALSE_POSITIVES = frozenset((\n     _MSG_TOO_MANY,\n ))\n \n \n def _pypy2_false_positive(msg, candidate, vtype):\n     # On PyPy2, builtin methods and functions like\n     # ``dict.pop`` that take pseudo-optional arguments\n     # (those with no default, something you can't express in Python 2\n     # syntax; CPython uses special internal APIs to implement these methods)\n     # return false failures because PyPy2 doesn't expose any way\n     # to detect this pseudo-optional status. PyPy3 doesn't have this problem\n     # because of __defaults_count__, and CPython never gets here because it\n     # returns true for ``ismethoddescriptor`` or ``isbuiltin``.\n     #\n     # We can't catch all such cases, but we can handle the common ones.\n     #\n     if msg not in _KNOWN_PYPY2_FALSE_POSITIVES:\n         return False\n \n     known_builtin_types = vars(__builtins__).values()\n     candidate_type = candidate if vtype == 'c' else type(candidate)\n     if candidate_type in known_builtin_types:\n         return True\n \n     return False\n \n \n def _incompat(required, implemented):\n     #if (required['positional'] !=\n     #    implemented['positional'][:len(required['positional'])]\n     #    and implemented['kwargs'] is None):\n     #    return 'imlementation has different argument names'\n     if len(implemented['required']) > len(required['required']):\n         return _MSG_TOO_MANY\n     if ((len(implemented['positional']) < len(required['positional']))\n         and not implemented['varargs']):\n         return \"implementation doesn't allow enough arguments\"\n     if required['kwargs'] and not implemented['kwargs']:\n         return \"implementation doesn't support keyword arguments\"\n     if required['varargs'] and not implemented['varargs']:\n         return \"implementation doesn't support variable arguments\"\n ", "input_code": "def _verify(iface, candidate, tentative=False, vtype=None):\n\"\"\"\nVerify that *candidate* might correctly provide *iface*.\n\nThis involves:\n\n- Making sure the candidate claims that it provides the\n  interface using ``iface.providedBy`` (unless *tentative* is `True`,\n  in which case this step is skipped). This means that the candidate's class\n  declares that it `implements <zope.interface.implementer>` the interface,\n  or the candidate itself declares that it `provides <zope.interface.provider>`\n  the interface\n\n- Making sure the candidate defines all the necessary methods\n\n- Making sure the methods have the correct signature (to the\n  extent possible)\n\n- Making sure the candidate defines all the necessary attributes\n\n:return bool: Returns a true value if everything that could be\n   checked passed.\n:raises zope.interface.Invalid: If any of the previous\n   conditions does not hold.\n\n.. versionchanged:: 5.0\n    If multiple methods or attributes are invalid, all such errors\n    are collected and reported. Previously, only the first error was reported.\n    As a special case, if only one such error is present, it is raised\n    alone, like before.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _verify(iface, candidate, tentative=False, vtype=None):\n    \"\"\"\n    Verify that *candidate* might correctly provide *iface*.\n\n    This involves:\n\n    - Making sure the candidate claims that it provides the\n      interface using ``iface.providedBy`` (unless *tentative* is `True`,\n      in which case this step is skipped). This means that the candidate's class\n      declares that it `implements <zope.interface.implementer>` the interface,\n      or the candidate itself declares that it `provides <zope.interface.provider>`\n      the interface\n\n    - Making sure the candidate defines all the necessary methods\n\n    - Making sure the methods have the correct signature (to the\n      extent possible)\n\n    - Making sure the candidate defines all the necessary attributes\n\n    :return bool: Returns a true value if everything that could be\n       checked passed.\n    :raises zope.interface.Invalid: If any of the previous\n       conditions does not hold.\n\n    .. versionchanged:: 5.0\n        If multiple methods or attributes are invalid, all such errors\n        are collected and reported. Previously, only the first error was reported.\n        As a special case, if only one such error is present, it is raised\n        alone, like before.\n    \"\"\"\n\n    if vtype == 'c':\n        tester = iface.implementedBy\n    else:\n        tester = iface.providedBy\n\n    excs = []\n    if not tentative and not tester(candidate):\n        excs.append(DoesNotImplement(iface, candidate))\n\n    for name, desc in iface.namesAndDescriptions(all=True):\n        try:\n            _verify_element(iface, name, desc, candidate, vtype)\n        except Invalid as e:\n            excs.append(e)\n\n    if excs:\n        if len(excs) == 1:\n            raise excs[0]\n        raise MultipleInvalid(iface, candidate, excs)\n\n    return True", "signature": "def _verify(iface, candidate, tentative=False, vtype=None):", "completion_path": "src/zope/interface/verify.py"}
{"ce_id": "62b8b4baeb7e40a82d2d1137", "namespace": "62b8b4baeb7e40a82d2d1137", "namespace_real": "src.zope.interface.verify.verifyObject", "real_proj_path": "pexip---os-zope/", "type": "function", "class_name": null, "function_name": "verifyObject", "contexts_above": "##############################################################################\n#\n# Copyright (c) 2001, 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"Verify interface implementations\n\"\"\"\nfrom __future__ import print_function\nimport inspect\nimport sys\nfrom types import FunctionType\nfrom types import MethodType\n\nfrom zope.interface._compat import PYPY2\n\nfrom zope.interface.exceptions import BrokenImplementation\nfrom zope.interface.exceptions import BrokenMethodImplementation\nfrom zope.interface.exceptions import DoesNotImplement\nfrom zope.interface.exceptions import Invalid\nfrom zope.interface.exceptions import MultipleInvalid\n\nfrom zope.interface.interface import fromMethod, fromFunction, Method\n\n__all__ = [\n    'verifyObject',\n    'verifyClass',\n]\n\n# This will be monkey-patched when running under Zope 2, so leave this\n# here:\nMethodTypes = (MethodType, )\n\n\ndef _verify(iface, candidate, tentative=False, vtype=None):\n    \"\"\"\n    Verify that *candidate* might correctly provide *iface*.\n\n    This involves:\n\n    - Making sure the candidate claims that it provides the\n      interface using ``iface.providedBy`` (unless *tentative* is `True`,\n      in which case this step is skipped). This means that the candidate's class\n      declares that it `implements <zope.interface.implementer>` the interface,\n      or the candidate itself declares that it `provides <zope.interface.provider>`\n      the interface\n\n    - Making sure the candidate defines all the necessary methods\n\n    - Making sure the methods have the correct signature (to the\n      extent possible)\n\n    - Making sure the candidate defines all the necessary attributes\n\n    :return bool: Returns a true value if everything that could be\n       checked passed.\n    :raises zope.interface.Invalid: If any of the previous\n       conditions does not hold.\n\n    .. versionchanged:: 5.0\n        If multiple methods or attributes are invalid, all such errors\n        are collected and reported. Previously, only the first error was reported.\n        As a special case, if only one such error is present, it is raised\n        alone, like before.\n    \"\"\"\n\n    if vtype == 'c':\n        tester = iface.implementedBy\n    else:\n        tester = iface.providedBy\n\n    excs = []\n    if not tentative and not tester(candidate):\n        excs.append(DoesNotImplement(iface, candidate))\n\n    for name, desc in iface.namesAndDescriptions(all=True):\n        try:\n            _verify_element(iface, name, desc, candidate, vtype)\n        except Invalid as e:\n            excs.append(e)\n\n    if excs:\n        if len(excs) == 1:\n            raise excs[0]\n        raise MultipleInvalid(iface, candidate, excs)\n\n    return True\n\ndef _verify_element(iface, name, desc, candidate, vtype):\n    # Here the `desc` is either an `Attribute` or `Method` instance\n    try:\n        attr = getattr(candidate, name)\n    except AttributeError:\n        if (not isinstance(desc, Method)) and vtype == 'c':\n            # We can't verify non-methods on classes, since the\n            # class may provide attrs in it's __init__.\n            return\n        # TODO: On Python 3, this should use ``raise...from``\n        raise BrokenImplementation(iface, desc, candidate)\n\n    if not isinstance(desc, Method):\n        # If it's not a method, there's nothing else we can test\n        return\n\n    if inspect.ismethoddescriptor(attr) or inspect.isbuiltin(attr):\n        # The first case is what you get for things like ``dict.pop``\n        # on CPython (e.g., ``verifyClass(IFullMapping, dict))``). The\n        # second case is what you get for things like ``dict().pop`` on\n        # CPython (e.g., ``verifyObject(IFullMapping, dict()))``.\n        # In neither case can we get a signature, so there's nothing\n        # to verify. Even the inspect module gives up and raises\n        # ValueError: no signature found. The ``__text_signature__`` attribute\n        # isn't typically populated either.\n        #\n        # Note that on PyPy 2 or 3 (up through 7.3 at least), these are\n        # not true for things like ``dict.pop`` (but might be true for C extensions?)\n        return\n\n    if isinstance(attr, FunctionType):\n        if sys.version_info[0] >= 3 and isinstance(candidate, type) and vtype == 'c':\n            # This is an \"unbound method\" in Python 3.\n            # Only unwrap this if we're verifying implementedBy;\n            # otherwise we can unwrap @staticmethod on classes that directly\n            # provide an interface.\n            meth = fromFunction(attr, iface, name=name,\n                                imlevel=1)\n        else:\n            # Nope, just a normal function\n            meth = fromFunction(attr, iface, name=name)\n    elif (isinstance(attr, MethodTypes)\n          and type(attr.__func__) is FunctionType):\n        meth = fromMethod(attr, iface, name)\n    elif isinstance(attr, property) and vtype == 'c':\n        # Without an instance we cannot be sure it's not a\n        # callable.\n        # TODO: This should probably check inspect.isdatadescriptor(),\n        # a more general form than ``property``\n        return\n\n    else:\n        if not callable(attr):\n            raise BrokenMethodImplementation(desc, \"implementation is not a method\",\n                                             attr, iface, candidate)\n        # sigh, it's callable, but we don't know how to introspect it, so\n        # we have to give it a pass.\n        return\n\n    # Make sure that the required and implemented method signatures are\n    # the same.\n    mess = _incompat(desc.getSignatureInfo(), meth.getSignatureInfo())\n    if mess:\n        if PYPY2 and _pypy2_false_positive(mess, candidate, vtype):\n            return\n        raise BrokenMethodImplementation(desc, mess, attr, iface, candidate)\n\n\n\ndef verifyClass(iface, candidate, tentative=False):\n    \"\"\"\n    Verify that the *candidate* might correctly provide *iface*.\n    \"\"\"\n    return _verify(iface, candidate, tentative, vtype='c')\n", "contexts_below": "verifyObject.__doc__ = _verify.__doc__\n \n _MSG_TOO_MANY = 'implementation requires too many arguments'\n _KNOWN_PYPY2_FALSE_POSITIVES = frozenset((\n     _MSG_TOO_MANY,\n ))\n \n \n def _pypy2_false_positive(msg, candidate, vtype):\n     # On PyPy2, builtin methods and functions like\n     # ``dict.pop`` that take pseudo-optional arguments\n     # (those with no default, something you can't express in Python 2\n     # syntax; CPython uses special internal APIs to implement these methods)\n     # return false failures because PyPy2 doesn't expose any way\n     # to detect this pseudo-optional status. PyPy3 doesn't have this problem\n     # because of __defaults_count__, and CPython never gets here because it\n     # returns true for ``ismethoddescriptor`` or ``isbuiltin``.\n     #\n     # We can't catch all such cases, but we can handle the common ones.\n     #\n     if msg not in _KNOWN_PYPY2_FALSE_POSITIVES:\n         return False\n \n     known_builtin_types = vars(__builtins__).values()\n     candidate_type = candidate if vtype == 'c' else type(candidate)\n     if candidate_type in known_builtin_types:\n         return True\n \n     return False\n \n \n def _incompat(required, implemented):\n     #if (required['positional'] !=\n     #    implemented['positional'][:len(required['positional'])]\n     #    and implemented['kwargs'] is None):\n     #    return 'imlementation has different argument names'\n     if len(implemented['required']) > len(required['required']):\n         return _MSG_TOO_MANY\n     if ((len(implemented['positional']) < len(required['positional']))\n         and not implemented['varargs']):\n         return \"implementation doesn't allow enough arguments\"\n     if required['kwargs'] and not implemented['kwargs']:\n         return \"implementation doesn't support keyword arguments\"\n     if required['varargs'] and not implemented['varargs']:\n         return \"implementation doesn't support variable arguments\"\n ", "input_code": "def verifyObject(iface, candidate, tentative=False):\n\"\"\"\nVerify that *candidate* might correctly provide *iface*.\n\nThis involves:\n\n- Making sure the candidate claims that it provides the\n  interface using ``iface.providedBy`` (unless *tentative* is `True`,\n  in which case this step is skipped). This means that the candidate's class\n  declares that it `implements <zope.interface.implementer>` the interface,\n  or the candidate itself declares that it `provides <zope.interface.provider>`\n  the interface\n\n- Making sure the candidate defines all the necessary methods\n\n- Making sure the methods have the correct signature (to the\n  extent possible)\n\n- Making sure the candidate defines all the necessary attributes\n\n:return bool: Returns a true value if everything that could be\n   checked passed.\n:raises zope.interface.Invalid: If any of the previous\n   conditions does not hold.\n\n.. versionchanged:: 5.0\n    If multiple methods or attributes are invalid, all such errors\n    are collected and reported. Previously, only the first error was reported.\n    As a special case, if only one such error is present, it is raised\n    alone, like before.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def verifyObject(iface, candidate, tentative=False):\n    return _verify(iface, candidate, tentative, vtype='o')", "signature": "def verifyObject(iface, candidate, tentative=False):", "completion_path": "src/zope/interface/verify.py"}
{"ce_id": "62b8b4c1eb7e40a82d2d1139", "namespace": "62b8b4c1eb7e40a82d2d1139", "namespace_real": "src.zope.interface.verify.verifyClass", "real_proj_path": "pexip---os-zope/", "type": "function", "class_name": null, "function_name": "verifyClass", "contexts_above": "##############################################################################\n#\n# Copyright (c) 2001, 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"Verify interface implementations\n\"\"\"\nfrom __future__ import print_function\nimport inspect\nimport sys\nfrom types import FunctionType\nfrom types import MethodType\n\nfrom zope.interface._compat import PYPY2\n\nfrom zope.interface.exceptions import BrokenImplementation\nfrom zope.interface.exceptions import BrokenMethodImplementation\nfrom zope.interface.exceptions import DoesNotImplement\nfrom zope.interface.exceptions import Invalid\nfrom zope.interface.exceptions import MultipleInvalid\n\nfrom zope.interface.interface import fromMethod, fromFunction, Method\n\n__all__ = [\n    'verifyObject',\n    'verifyClass',\n]\n\n# This will be monkey-patched when running under Zope 2, so leave this\n# here:\nMethodTypes = (MethodType, )\n\n\ndef _verify(iface, candidate, tentative=False, vtype=None):\n    \"\"\"\n    Verify that *candidate* might correctly provide *iface*.\n\n    This involves:\n\n    - Making sure the candidate claims that it provides the\n      interface using ``iface.providedBy`` (unless *tentative* is `True`,\n      in which case this step is skipped). This means that the candidate's class\n      declares that it `implements <zope.interface.implementer>` the interface,\n      or the candidate itself declares that it `provides <zope.interface.provider>`\n      the interface\n\n    - Making sure the candidate defines all the necessary methods\n\n    - Making sure the methods have the correct signature (to the\n      extent possible)\n\n    - Making sure the candidate defines all the necessary attributes\n\n    :return bool: Returns a true value if everything that could be\n       checked passed.\n    :raises zope.interface.Invalid: If any of the previous\n       conditions does not hold.\n\n    .. versionchanged:: 5.0\n        If multiple methods or attributes are invalid, all such errors\n        are collected and reported. Previously, only the first error was reported.\n        As a special case, if only one such error is present, it is raised\n        alone, like before.\n    \"\"\"\n\n    if vtype == 'c':\n        tester = iface.implementedBy\n    else:\n        tester = iface.providedBy\n\n    excs = []\n    if not tentative and not tester(candidate):\n        excs.append(DoesNotImplement(iface, candidate))\n\n    for name, desc in iface.namesAndDescriptions(all=True):\n        try:\n            _verify_element(iface, name, desc, candidate, vtype)\n        except Invalid as e:\n            excs.append(e)\n\n    if excs:\n        if len(excs) == 1:\n            raise excs[0]\n        raise MultipleInvalid(iface, candidate, excs)\n\n    return True\n\ndef _verify_element(iface, name, desc, candidate, vtype):\n    # Here the `desc` is either an `Attribute` or `Method` instance\n    try:\n        attr = getattr(candidate, name)\n    except AttributeError:\n        if (not isinstance(desc, Method)) and vtype == 'c':\n            # We can't verify non-methods on classes, since the\n            # class may provide attrs in it's __init__.\n            return\n        # TODO: On Python 3, this should use ``raise...from``\n        raise BrokenImplementation(iface, desc, candidate)\n\n    if not isinstance(desc, Method):\n        # If it's not a method, there's nothing else we can test\n        return\n\n    if inspect.ismethoddescriptor(attr) or inspect.isbuiltin(attr):\n        # The first case is what you get for things like ``dict.pop``\n        # on CPython (e.g., ``verifyClass(IFullMapping, dict))``). The\n        # second case is what you get for things like ``dict().pop`` on\n        # CPython (e.g., ``verifyObject(IFullMapping, dict()))``.\n        # In neither case can we get a signature, so there's nothing\n        # to verify. Even the inspect module gives up and raises\n        # ValueError: no signature found. The ``__text_signature__`` attribute\n        # isn't typically populated either.\n        #\n        # Note that on PyPy 2 or 3 (up through 7.3 at least), these are\n        # not true for things like ``dict.pop`` (but might be true for C extensions?)\n        return\n\n    if isinstance(attr, FunctionType):\n        if sys.version_info[0] >= 3 and isinstance(candidate, type) and vtype == 'c':\n            # This is an \"unbound method\" in Python 3.\n            # Only unwrap this if we're verifying implementedBy;\n            # otherwise we can unwrap @staticmethod on classes that directly\n            # provide an interface.\n            meth = fromFunction(attr, iface, name=name,\n                                imlevel=1)\n        else:\n            # Nope, just a normal function\n            meth = fromFunction(attr, iface, name=name)\n    elif (isinstance(attr, MethodTypes)\n          and type(attr.__func__) is FunctionType):\n        meth = fromMethod(attr, iface, name)\n    elif isinstance(attr, property) and vtype == 'c':\n        # Without an instance we cannot be sure it's not a\n        # callable.\n        # TODO: This should probably check inspect.isdatadescriptor(),\n        # a more general form than ``property``\n        return\n\n    else:\n        if not callable(attr):\n            raise BrokenMethodImplementation(desc, \"implementation is not a method\",\n                                             attr, iface, candidate)\n        # sigh, it's callable, but we don't know how to introspect it, so\n        # we have to give it a pass.\n        return\n\n    # Make sure that the required and implemented method signatures are\n    # the same.\n    mess = _incompat(desc.getSignatureInfo(), meth.getSignatureInfo())\n    if mess:\n        if PYPY2 and _pypy2_false_positive(mess, candidate, vtype):\n            return\n        raise BrokenMethodImplementation(desc, mess, attr, iface, candidate)\n\n\n", "contexts_below": "def verifyObject(iface, candidate, tentative=False):\n     return _verify(iface, candidate, tentative, vtype='o')\n \n verifyObject.__doc__ = _verify.__doc__\n \n _MSG_TOO_MANY = 'implementation requires too many arguments'\n _KNOWN_PYPY2_FALSE_POSITIVES = frozenset((\n     _MSG_TOO_MANY,\n ))\n \n \n def _pypy2_false_positive(msg, candidate, vtype):\n     # On PyPy2, builtin methods and functions like\n     # ``dict.pop`` that take pseudo-optional arguments\n     # (those with no default, something you can't express in Python 2\n     # syntax; CPython uses special internal APIs to implement these methods)\n     # return false failures because PyPy2 doesn't expose any way\n     # to detect this pseudo-optional status. PyPy3 doesn't have this problem\n     # because of __defaults_count__, and CPython never gets here because it\n     # returns true for ``ismethoddescriptor`` or ``isbuiltin``.\n     #\n     # We can't catch all such cases, but we can handle the common ones.\n     #\n     if msg not in _KNOWN_PYPY2_FALSE_POSITIVES:\n         return False\n \n     known_builtin_types = vars(__builtins__).values()\n     candidate_type = candidate if vtype == 'c' else type(candidate)\n     if candidate_type in known_builtin_types:\n         return True\n \n     return False\n \n \n def _incompat(required, implemented):\n     #if (required['positional'] !=\n     #    implemented['positional'][:len(required['positional'])]\n     #    and implemented['kwargs'] is None):\n     #    return 'imlementation has different argument names'\n     if len(implemented['required']) > len(required['required']):\n         return _MSG_TOO_MANY\n     if ((len(implemented['positional']) < len(required['positional']))\n         and not implemented['varargs']):\n         return \"implementation doesn't allow enough arguments\"\n     if required['kwargs'] and not implemented['kwargs']:\n         return \"implementation doesn't support keyword arguments\"\n     if required['varargs'] and not implemented['varargs']:\n         return \"implementation doesn't support variable arguments\"\n ", "input_code": "def verifyClass(iface, candidate, tentative=False):\n\"\"\"\nVerify that the *candidate* might correctly provide *iface*.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def verifyClass(iface, candidate, tentative=False):\n    \"\"\"\n    Verify that the *candidate* might correctly provide *iface*.\n    \"\"\"\n    return _verify(iface, candidate, tentative, vtype='c')", "signature": "def verifyClass(iface, candidate, tentative=False):", "completion_path": "src/zope/interface/verify.py"}
{"ce_id": "62b8b559eb7e40a82d2d11f6", "namespace": "62b8b559eb7e40a82d2d11f6", "namespace_real": "src.zope.interface.advice.determineMetaclass", "real_proj_path": "pexip---os-zope/", "type": "function", "class_name": null, "function_name": "determineMetaclass", "contexts_above": "##############################################################################\n#\n# Copyright (c) 2003 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"Class advice.\n\nThis module was adapted from 'protocols.advice', part of the Python\nEnterprise Application Kit (PEAK).  Please notify the PEAK authors\n(pje@telecommunity.com and tsarna@sarna.org) if bugs are found or\nZope-specific changes are required, so that the PEAK version of this module\ncan be kept in sync.\n\nPEAK is a Python application framework that interoperates with (but does\nnot require) Zope 3 and Twisted.  It provides tools for manipulating UML\nmodels, object-relational persistence, aspect-oriented programming, and more.\nVisit the PEAK home page at http://peak.telecommunity.com for more information.\n\"\"\"\n\nfrom types import FunctionType\ntry:\n    from types import ClassType\nexcept ImportError:\n    __python3 = True\nelse:\n    __python3 = False\n\n__all__ = [\n    'addClassAdvisor',\n    'determineMetaclass',\n    'getFrameInfo',\n    'isClassAdvisor',\n    'minimalBases',\n]\n\nimport sys\n\ndef getFrameInfo(frame):\n    \"\"\"Return (kind,module,locals,globals) for a frame\n\n    'kind' is one of \"exec\", \"module\", \"class\", \"function call\", or \"unknown\".\n    \"\"\"\n\n    f_locals = frame.f_locals\n    f_globals = frame.f_globals\n\n    sameNamespace = f_locals is f_globals\n    hasModule = '__module__' in f_locals\n    hasName = '__name__' in f_globals\n\n    sameName = hasModule and hasName\n    sameName = sameName and f_globals['__name__']==f_locals['__module__']\n\n    module = hasName and sys.modules.get(f_globals['__name__']) or None\n\n    namespaceIsModule = module and module.__dict__ is f_globals\n\n    if not namespaceIsModule:\n        # some kind of funky exec\n        kind = \"exec\"\n    elif sameNamespace and not hasModule:\n        kind = \"module\"\n    elif sameName and not sameNamespace:\n        kind = \"class\"\n    elif not sameNamespace:\n        kind = \"function call\"\n    else: # pragma: no cover\n        # How can you have f_locals is f_globals, and have '__module__' set?\n        # This is probably module-level code, but with a '__module__' variable.\n        kind = \"unknown\"\n    return kind, module, f_locals, f_globals\n\n\ndef addClassAdvisor(callback, depth=2):\n    \"\"\"Set up 'callback' to be passed the containing class upon creation\n\n    This function is designed to be called by an \"advising\" function executed\n    in a class suite.  The \"advising\" function supplies a callback that it\n    wishes to have executed when the containing class is created.  The\n    callback will be given one argument: the newly created containing class.\n    The return value of the callback will be used in place of the class, so\n    the callback should return the input if it does not wish to replace the\n    class.\n\n    The optional 'depth' argument to this function determines the number of\n    frames between this function and the targeted class suite.  'depth'\n    defaults to 2, since this skips this function's frame and one calling\n    function frame.  If you use this function from a function called directly\n    in the class suite, the default will be correct, otherwise you will need\n    to determine the correct depth yourself.\n\n    This function works by installing a special class factory function in\n    place of the '__metaclass__' of the containing class.  Therefore, only\n    callbacks *after* the last '__metaclass__' assignment in the containing\n    class will be executed.  Be sure that classes using \"advising\" functions\n    declare any '__metaclass__' *first*, to ensure all callbacks are run.\"\"\"\n    # This entire approach is invalid under Py3K.  Don't even try to fix\n    # the coverage for this block there. :(\n    if __python3: # pragma: no cover\n        raise TypeError('Class advice impossible in Python3')\n\n    frame = sys._getframe(depth)\n    kind, module, caller_locals, caller_globals = getFrameInfo(frame)\n\n    # This causes a problem when zope interfaces are used from doctest.\n    # In these cases, kind == \"exec\".\n    #\n    #if kind != \"class\":\n    #    raise SyntaxError(\n    #        \"Advice must be in the body of a class statement\"\n    #    )\n\n    previousMetaclass = caller_locals.get('__metaclass__')\n    if __python3:   # pragma: no cover\n        defaultMetaclass  = caller_globals.get('__metaclass__', type)\n    else:\n        defaultMetaclass  = caller_globals.get('__metaclass__', ClassType)\n\n\n    def advise(name, bases, cdict):\n\n        if '__metaclass__' in cdict:\n            del cdict['__metaclass__']\n\n        if previousMetaclass is None:\n            if bases:\n                # find best metaclass or use global __metaclass__ if no bases\n                meta = determineMetaclass(bases)\n            else:\n                meta = defaultMetaclass\n\n        elif isClassAdvisor(previousMetaclass):\n            # special case: we can't compute the \"true\" metaclass here,\n            # so we need to invoke the previous metaclass and let it\n            # figure it out for us (and apply its own advice in the process)\n            meta = previousMetaclass\n\n        else:\n            meta = determineMetaclass(bases, previousMetaclass)\n\n        newClass = meta(name,bases,cdict)\n\n        # this lets the callback replace the class completely, if it wants to\n        return callback(newClass)\n\n    # introspection data only, not used by inner function\n    advise.previousMetaclass = previousMetaclass\n    advise.callback = callback\n\n    # install the advisor\n    caller_locals['__metaclass__'] = advise\n\n\ndef isClassAdvisor(ob):\n    \"\"\"True if 'ob' is a class advisor function\"\"\"\n    return isinstance(ob,FunctionType) and hasattr(ob,'previousMetaclass')\n\n", "contexts_below": "\n def minimalBases(classes):\n     \"\"\"Reduce a list of base classes to its ordered minimum equivalent\"\"\"\n \n     if not __python3: # pragma: no cover\n         classes = [c for c in classes if c is not ClassType]\n     candidates = []\n \n     for m in classes:\n         for n in classes:\n             if issubclass(n,m) and m is not n:\n                 break\n         else:\n             # m has no subclasses in 'classes'\n             if m in candidates:\n                 candidates.remove(m)    # ensure that we're later in the list\n             candidates.append(m)\n \n     return candidates\n ", "input_code": "def determineMetaclass(bases, explicit_mc=None):\n\"\"\"\nDetermine metaclass from 1+ bases and optional explicit __metaclass__\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def determineMetaclass(bases, explicit_mc=None):\n    \"\"\"Determine metaclass from 1+ bases and optional explicit __metaclass__\"\"\"\n\n    meta = [getattr(b,'__class__',type(b)) for b in bases]\n\n    if explicit_mc is not None:\n        # The explicit metaclass needs to be verified for compatibility\n        # as well, and allowed to resolve the incompatible bases, if any\n        meta.append(explicit_mc)\n\n    if len(meta)==1:\n        # easy case\n        return meta[0]\n\n    candidates = minimalBases(meta) # minimal set of metaclasses\n\n    if not candidates: # pragma: no cover\n        # they're all \"classic\" classes\n        assert(not __python3) # This should not happen under Python 3\n        return ClassType\n\n    elif len(candidates)>1:\n        # We could auto-combine, but for now we won't...\n        raise TypeError(\"Incompatible metatypes\",bases)\n\n    # Just one, return it\n    return candidates[0]", "signature": "def determineMetaclass(bases, explicit_mc=None):", "completion_path": "src/zope/interface/advice.py"}
{"ce_id": "62b8d22a48ba5a41d1c3f47d", "namespace": "62b8d22a48ba5a41d1c3f47d", "namespace_real": "cachetools.cache.pop", "real_proj_path": "pexip---os-python-cachetools/", "type": "class", "class_name": "cache", "function_name": "pop", "contexts_above": "from collections.abc import MutableMapping\n\n\nclass _DefaultSize(object):\n\n    __slots__ = ()\n\n    def __getitem__(self, _):\n        return 1\n\n    def __setitem__(self, _, value):\n        assert value == 1\n\n    def pop(self, _):\n        return 1\n\n\nclass Cache(MutableMapping):\n    \"\"\"Mutable mapping to serve as a simple cache or cache base class.\"\"\"\n\n    __marker = object()\n\n    __size = _DefaultSize()\n\n    def __init__(self, maxsize, getsizeof=None):\n        if getsizeof:\n            self.getsizeof = getsizeof\n        if self.getsizeof is not Cache.getsizeof:\n            self.__size = dict()\n        self.__data = dict()\n        self.__currsize = 0\n        self.__maxsize = maxsize\n\n    def __repr__(self):\n        return '%s(%r, maxsize=%r, currsize=%r)' % (\n            self.__class__.__name__,\n            list(self.__data.items()),\n            self.__maxsize,\n            self.__currsize,\n        )\n\n    def __getitem__(self, key):\n        try:\n            return self.__data[key]\n        except KeyError:\n            return self.__missing__(key)\n\n    def __setitem__(self, key, value):\n        maxsize = self.__maxsize\n        size = self.getsizeof(value)\n        if size > maxsize:\n            raise ValueError('value too large')\n        if key not in self.__data or self.__size[key] < size:\n            while self.__currsize + size > maxsize:\n                self.popitem()\n        if key in self.__data:\n            diffsize = size - self.__size[key]\n        else:\n            diffsize = size\n        self.__data[key] = value\n        self.__size[key] = size\n        self.__currsize += diffsize\n\n    def __delitem__(self, key):\n        size = self.__size.pop(key)\n        del self.__data[key]\n        self.__currsize -= size\n\n    def __contains__(self, key):\n        return key in self.__data\n\n    def __missing__(self, key):\n        raise KeyError(key)\n\n    def __iter__(self):\n        return iter(self.__data)\n\n    def __len__(self):\n        return len(self.__data)\n\n    def get(self, key, default=None):\n        if key in self:\n            return self[key]\n        else:\n            return default\n", "contexts_below": "    def setdefault(self, key, default=None):\n         if key in self:\n             value = self[key]\n         else:\n             self[key] = value = default\n         return value\n \n     @property\n     def maxsize(self):\n         \"\"\"The maximum size of the cache.\"\"\"\n         return self.__maxsize\n \n     @property\n     def currsize(self):\n         \"\"\"The current size of the cache.\"\"\"\n         return self.__currsize\n \n     @staticmethod\n     def getsizeof(value):\n         \"\"\"Return the size of a cache element's value.\"\"\"\n         return 1\n ", "input_code": "def pop(self, key, default=__marker):\n\"\"\"\nD.pop(k[,d]) -> v, remove specified key and return the corresponding value.\nIf key is not found, d is returned if given, otherwise KeyError is raised.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def pop(self, key, default=__marker):\n        if key in self:\n            value = self[key]\n            del self[key]\n        elif default is self.__marker:\n            raise KeyError(key)\n        else:\n            value = default\n        return value", "signature": "def pop(self, key, default=__marker):", "completion_path": "cachetools/cache.py"}
{"ce_id": "62b8d23748ba5a41d1c3f497", "namespace": "62b8d23748ba5a41d1c3f497", "namespace_real": "cachetools.lfu.popitem", "real_proj_path": "pexip---os-python-cachetools/", "type": "class", "class_name": "lfu", "function_name": "popitem", "contexts_above": "import collections\n\nfrom .cache import Cache\n\n\nclass LFUCache(Cache):\n    \"\"\"Least Frequently Used (LFU) cache implementation.\"\"\"\n\n    def __init__(self, maxsize, getsizeof=None):\n        Cache.__init__(self, maxsize, getsizeof)\n        self.__counter = collections.Counter()\n\n    def __getitem__(self, key, cache_getitem=Cache.__getitem__):\n        value = cache_getitem(self, key)\n        if key in self:  # __missing__ may not store item\n            self.__counter[key] -= 1\n        return value\n\n    def __setitem__(self, key, value, cache_setitem=Cache.__setitem__):\n        cache_setitem(self, key, value)\n        self.__counter[key] -= 1\n\n    def __delitem__(self, key, cache_delitem=Cache.__delitem__):\n        cache_delitem(self, key)\n        del self.__counter[key]\n", "contexts_below": "", "input_code": "def popitem(self):\n\"\"\"\nRemove and return the `(key, value)` pair least frequently used.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def popitem(self):\n        \"\"\"Remove and return the `(key, value)` pair least frequently used.\"\"\"\n        try:\n            (key, _), = self.__counter.most_common(1)\n        except ValueError:\n            raise KeyError('%s is empty' % type(self).__name__) from None\n        else:\n            return (key, self.pop(key))", "signature": "def popitem(self):", "completion_path": "cachetools/lfu.py"}
{"ce_id": "62b8d23a48ba5a41d1c3f499", "namespace": "62b8d23a48ba5a41d1c3f499", "namespace_real": "cachetools.lru.popitem", "real_proj_path": "pexip---os-python-cachetools/", "type": "class", "class_name": "lru", "function_name": "popitem", "contexts_above": "import collections\n\nfrom .cache import Cache\n\n\nclass LRUCache(Cache):\n    \"\"\"Least Recently Used (LRU) cache implementation.\"\"\"\n\n    def __init__(self, maxsize, getsizeof=None):\n        Cache.__init__(self, maxsize, getsizeof)\n        self.__order = collections.OrderedDict()\n\n    def __getitem__(self, key, cache_getitem=Cache.__getitem__):\n        value = cache_getitem(self, key)\n        if key in self:  # __missing__ may not store item\n            self.__update(key)\n        return value\n\n    def __setitem__(self, key, value, cache_setitem=Cache.__setitem__):\n        cache_setitem(self, key, value)\n        self.__update(key)\n\n    def __delitem__(self, key, cache_delitem=Cache.__delitem__):\n        cache_delitem(self, key)\n        del self.__order[key]\n", "contexts_below": "    def __update(self, key):\n         try:\n             self.__order.move_to_end(key)\n         except KeyError:\n             self.__order[key] = None\n ", "input_code": "def popitem(self):\n\"\"\"\nRemove and return the `(key, value)` pair least recently used.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def popitem(self):\n        \"\"\"Remove and return the `(key, value)` pair least recently used.\"\"\"\n        try:\n            key = next(iter(self.__order))\n        except StopIteration:\n            raise KeyError('%s is empty' % type(self).__name__) from None\n        else:\n            return (key, self.pop(key))", "signature": "def popitem(self):", "completion_path": "cachetools/lru.py"}
{"ce_id": "62b8d23c48ba5a41d1c3f49b", "namespace": "62b8d23c48ba5a41d1c3f49b", "namespace_real": "cachetools.mru.popitem", "real_proj_path": "pexip---os-python-cachetools/", "type": "class", "class_name": "mru", "function_name": "popitem", "contexts_above": "import collections\n\nfrom cachetools.cache import Cache\n\n\nclass MRUCache(Cache):\n    \"\"\"Most Recently Used (MRU) cache implementation.\"\"\"\n\n    def __init__(self, maxsize, getsizeof=None):\n        Cache.__init__(self, maxsize, getsizeof)\n        self.__order = collections.OrderedDict()\n\n    def __getitem__(self, key, cache_getitem=Cache.__getitem__):\n        value = cache_getitem(self, key)\n        if key in self:  # __missing__ may not store item\n            self.__update(key)\n        return value\n\n    def __setitem__(self, key, value, cache_setitem=Cache.__setitem__):\n        cache_setitem(self, key, value)\n        self.__update(key)\n\n    def __delitem__(self, key, cache_delitem=Cache.__delitem__):\n        cache_delitem(self, key)\n        del self.__order[key]\n", "contexts_below": "    def __update(self, key):\n         try:\n             self.__order.move_to_end(key, last=False)\n         except KeyError:\n             self.__order[key] = None\n ", "input_code": "def popitem(self):\n\"\"\"\nRemove and return the `(key, value)` pair most recently used.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def popitem(self):\n        \"\"\"Remove and return the `(key, value)` pair most recently used.\"\"\"\n        try:\n            key = next(iter(self.__order))\n        except StopIteration:\n            raise KeyError('%s is empty' % type(self).__name__) from None\n        else:\n            return (key, self.pop(key))", "signature": "def popitem(self):", "completion_path": "cachetools/mru.py"}
{"ce_id": "62b8d23e48ba5a41d1c3f49e", "namespace": "62b8d23e48ba5a41d1c3f49e", "namespace_real": "cachetools.rr.popitem", "real_proj_path": "pexip---os-python-cachetools/", "type": "class", "class_name": "rr", "function_name": "popitem", "contexts_above": "import random\n\nfrom .cache import Cache\n\n\n# random.choice cannot be pickled in Python 2.7\ndef _choice(seq):\n    return random.choice(seq)\n\n\nclass RRCache(Cache):\n    \"\"\"Random Replacement (RR) cache implementation.\"\"\"\n\n    def __init__(self, maxsize, choice=random.choice, getsizeof=None):\n        Cache.__init__(self, maxsize, getsizeof)\n        # TODO: use None as default, assing to self.choice directly?\n        if choice is random.choice:\n            self.__choice = _choice\n        else:\n            self.__choice = choice\n\n    @property\n    def choice(self):\n        \"\"\"The `choice` function used by the cache.\"\"\"\n        return self.__choice\n", "contexts_below": "", "input_code": "def popitem(self):\n\"\"\"\nRemove and return a random `(key, value)` pair.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def popitem(self):\n        \"\"\"Remove and return a random `(key, value)` pair.\"\"\"\n        try:\n            key = self.__choice(list(self))\n        except IndexError:\n            raise KeyError('%s is empty' % type(self).__name__) from None\n        else:\n            return (key, self.pop(key))", "signature": "def popitem(self):", "completion_path": "cachetools/rr.py"}
{"ce_id": "62b43425903eeb48555d3ea1", "namespace": "62b43425903eeb48555d3ea1", "namespace_real": "sqlparams.__init__._create_in_regex", "real_proj_path": "cpburnz---python-sql-parameters/", "type": "class", "class_name": "__init__", "function_name": "_create_in_regex", "contexts_above": "\"\"\"\n:mod:`sqlparams` is a utility package for converting between various SQL\nparameter styles.\n\"\"\"\n\nimport re\nfrom typing import (\n\tAny,\n\tAnyStr,\n\tDict,\n\tIterable,\n\tList,\n\tOptional,\n\tPattern,\n\tSequence,\n\tTuple,\n\tType,\n\tUnion)\n\nfrom . import _converting\nfrom . import _styles\nfrom ._util import _is_iterable\n\nfrom ._meta import (\n\t__author__,\n\t__copyright__,\n\t__credits__,\n\t__license__,\n\t__version__,\n)\n\n_BYTES_ENCODING = 'latin1'\n\"\"\"\nThe encoding to use when parsing a byte query string.\n\"\"\"\n\n_STYLES = {}\n\"\"\"\nMaps parameter style by name.\n\"\"\"\n\n\nclass SQLParams(object):\n\t\"\"\"\n\tThe :class:`.SQLParams` class is used to support named parameters in\n\tSQL queries where they are not otherwise supported (e.g., pyodbc).\n\tThis is done by converting from one parameter style query to another\n\tparameter style query.\n\n\tBy default, when converting to a numeric or ordinal style any\n\t:class:`tuple` parameter will be expanded into \"(?,?,...)\" to support\n\tthe widely used \"IN {tuple}\" SQL expression without leaking any\n\tunescaped values.\n\t\"\"\"\n\n\tdef __init__(\n\t\tself,\n\t\tin_style: str,\n\t\tout_style: str,\n\t\tescape_char: Union[str, bool, None] = None,\n\t\texpand_tuples: Optional[bool] = None,\n\t) -> None:\n\t\t\"\"\"\n\t\tInstantiates the :class:`.SQLParams` instance.\n\n\t\t*in_style* (:class:`str`) is the parameter style that will be used\n\t\tin an SQL query before being parsed and converted to :attr:`.SQLParams.out_style`.\n\n\t\t*out_style* (:class:`str`) is the parameter style that the SQL query\n\t\twill be converted to.\n\n\t\t*escape_char* (:class:`str`, :class:`bool`, or :data:`None`) is the\n\t\tescape character used to prevent matching a in-style parameter. If\n\t\t:data:`True`, use the default escape character (repeat the initial\n\t\tcharacter to escape it; e.g., \"%%\"). If :data:`False`, do not use an\n\t\tescape character. Default is :data:`None` for :data:`False`.\n\n\t\t*expand_tuples* (:class:`bool` or :data:`None`) is whether to\n\t\texpand tuples into a sequence of parameters. Default is :data:`None`\n\t\tto let it be determined by *out_style* (to maintain backward\n\t\tcompatibility). If *out_style* is a numeric or ordinal style, expand\n\t\ttuples by default (:data:`True`). If *out_style* is a named style,\n\t\tdo not expand tuples by default (:data:`False`).\n\n\t\tThe following parameter styles are supported by both *in_style* and\n\t\t*out_style*:\n\n\t\t-\tFor all named styles the parameter keys must be valid `Python identifiers`_.\n\t\t\tThey cannot start with a digit. This is to help prevent\n\t\t\tincorrectly matching common strings such as datetimes.\n\n\t\t\tNamed styles:\n\n\t\t\t-\t\"named\" indicates parameters will use the named style::\n\n\t\t\t\t\t... WHERE name = :name\n\n\t\t\t-\t\"named_dollar\" indicates parameters will use the named dollar\n\t\t\t\tsign style::\n\n\t\t\t\t\t... WHERE name = $name\n\n\t\t\t\t.. NOTE:: This is not defined by `PEP 249`_.\n\n\t\t\t-\t\"pyformat\" indicates parameters will use the named Python\n\t\t\t\textended format style::\n\n\t\t\t\t\t... WHERE name = %(name)s\n\n\t\t\t\t.. NOTE:: Strictly speaking, `PEP 249`_ only specifies\n\t\t\t\t   \"%(name)s\" for the \"pyformat\" parameter style so only that\n\t\t\t\t   form (without any other conversions or flags) is supported.\n\n\t\t-\tAll numeric styles start at :data:`1`. When using a\n\t\t\t:class:`~collections.abc.Sequence` for the parameters, the 1st\n\t\t\tparameter (e.g., \":1\") will correspond to the 1st element of the\n\t\t\tsequence (i.e., index :data:`0`). When using a :class:`~collections.abc.Mapping`\n\t\t\tfor the parameters, the 1st parameter (e.g., \":1\") will correspond\n\t\t\tto the matching key (i.e., :data:`1` or :data:`\"1\"`).\n\n\t\t\tNumeric styles:\n\n\t\t\t-\t\"numeric\" indicates parameters will use the numeric style::\n\n\t\t\t\t\t... WHERE name = :1\n\n\t\t\t-\t\"numeric_dollar\" indicates parameters will use the numeric\n\t\t\t\tdollar sign style (starts at :data:`1`)::\n\n\t\t\t\t\t... WHERE name = $1\n\n\t\t\t\t.. NOTE:: This is not defined by `PEP 249`_.\n\n\t\t- Ordinal styles:\n\n\t\t\t-\t\"format\" indicates parameters will use the ordinal Python format\n\t\t\t\tstyle::\n\n\t\t\t\t\t... WHERE name = %s\n\n\t\t\t\t.. NOTE:: Strictly speaking, `PEP 249`_ only specifies \"%s\" for\n\t\t\t\t   the \"format\" parameter styles so only that form (without any\n\t\t\t\t   other conversions or flags) is supported.\n\n\t\t\t-\t\"qmark\" indicates parameters will use the ordinal question mark\n\t\t\t\tstyle::\n\n\t\t\t\t\t... WHERE name = ?\n\n\t\t.. _`PEP 249`: http://www.python.org/dev/peps/pep-0249/\n\n\t\t.. _`Python identifiers`: https://docs.python.org/3/reference/lexical_analysis.html#identifiers\n\t\t\"\"\"\n\n\t\tself._converter: _converting._Converter = None\n\t\t\"\"\"\n\t\t*_converter* (:class:`._converting._Converter`) is the parameter\n\t\tconverter to use.\n\t\t\"\"\"\n\n\t\tself._escape_char: Optional[str] = None\n\t\t\"\"\"\n\t\t*_escape_char* (:class:`str` or :data:`None`) is the escape\n\t\tcharacter used to prevent matching a in-style parameter.\n\t\t\"\"\"\n\n\t\tself._expand_tuples: bool = None\n\t\t\"\"\"\n\t\t*_expand_tuples* (:class:`bool`) is whether to convert tuples into a\n\t\tsequence of parameters.\n\t\t\"\"\"\n\n\t\tself._in_obj: _styles._Style = None\n\t\t\"\"\"\n\t\t*_in_obj* (:class:`._styles._Style`) is the in-style parameter object.\n\t\t\"\"\"\n\n\t\tself._in_regex: Pattern = None\n\t\t\"\"\"\n\t\t*_in_regex* (:class:`re.Pattern`) is the regular expression used to\n\t\textract the in-style parameters.\n\t\t\"\"\"\n\n\t\tself._in_style: str = None\n\t\t\"\"\"\n\t\t*_in_style* (:class:`str`) is the parameter style that will be used\n\t\tin an SQL query before being parsed and converted to :attr:`.SQLParams.out_style`.\n\t\t\"\"\"\n\n\t\tself._out_obj: _styles._Style = None\n\t\t\"\"\"\n\t\t*_out_obj* (:class:`._styles._Style`) is the out-style parameter object.\n\t\t\"\"\"\n\n\t\tself._out_style: str = None\n\t\t\"\"\"\n\t\t*_out_style* (:class:`str`) is the parameter style that the SQL query\n\t\twill be converted to.\n\t\t\"\"\"\n\n\t\tif not isinstance(in_style, str):\n\t\t\traise TypeError(\"in_style:{!r} is not a string.\".format(in_style))\n\n\t\tif not isinstance(out_style, str):\n\t\t\traise TypeError(\"out_style:{!r} is not a string.\".format(out_style))\n\n\t\tself._in_style = in_style\n\t\tself._out_style = out_style\n\n\t\tself._in_obj = _styles._STYLES[self._in_style]\n\t\tself._out_obj = _styles._STYLES[self._out_style]\n\n\t\tif escape_char is True:\n\t\t\tuse_char = self._in_obj.escape_char\n\t\telif not escape_char:\n\t\t\tuse_char = None\n\t\telif isinstance(escape_char, str):\n\t\t\tuse_char = escape_char\n\t\telse:\n\t\t\traise TypeError(\"escape_char:{!r} is not a string or bool.\")\n\n\t\tif expand_tuples is None:\n\t\t\texpand_tuples = not isinstance(self._out_obj, _styles._NamedStyle)\n\n\t\tself._escape_char = use_char\n\t\tself._expand_tuples = bool(expand_tuples)\n\n\t\tself._in_regex = self._create_in_regex()\n\t\tself._converter = self._create_converter()\n\n\tdef __repr__(self) -> str:\n\t\t\"\"\"\n\t\tReturns the canonical string representation (:class:`str`) of this\n\t\tinstance.\n\t\t\"\"\"\n\t\treturn \"{}.{}({!r}, {!r})\".format(self.__class__.__module__, self.__class__.__name__, self._in_style, self._out_style)\n\n\tdef _create_converter(self) -> _converting._Converter:\n\t\t\"\"\"\n\t\tCreate the parameter style converter.\n\n\t\tReturns the parameter style converter (:class:`._converting._Converter`).\n\t\t\"\"\"\n\t\tassert self._in_regex is not None, self._in_regex\n\t\tassert self._out_obj is not None, self._out_obj\n\n\t\t# Determine converter class.\n\t\tconverter_class: Type[_converting._Converter]\n\t\tif isinstance(self._in_obj, _styles._NamedStyle):\n\t\t\tif isinstance(self._out_obj, _styles._NamedStyle):\n\t\t\t\tconverter_class = _converting._NamedToNamedConverter\n\t\t\telif isinstance(self._out_obj, _styles._NumericStyle):\n\t\t\t\tconverter_class = _converting._NamedToNumericConverter\n\t\t\telif isinstance(self._out_obj, _styles._OrdinalStyle):\n\t\t\t\tconverter_class = _converting._NamedToOrdinalConverter\n\t\t\telse:\n\t\t\t\traise TypeError(\"out_style:{!r} maps to an unexpected type: {!r}\".format(self._out_style, self._out_obj))\n\n\t\telif isinstance(self._in_obj, _styles._NumericStyle):\n\t\t\tif isinstance(self._out_obj, _styles._NamedStyle):\n\t\t\t\tconverter_class = _converting._NumericToNamedConverter\n\t\t\telif isinstance(self._out_obj, _styles._NumericStyle):\n\t\t\t\tconverter_class = _converting._NumericToNumericConverter\n\t\t\telif isinstance(self._out_obj, _styles._OrdinalStyle):\n\t\t\t\tconverter_class = _converting._NumericToOrdinalConverter\n\t\t\telse:\n\t\t\t\traise TypeError(\"out_style:{!r} maps to an unexpected type: {!r}\".format(self._out_style, self._out_obj))\n\n\t\telif isinstance(self._in_obj, _styles._OrdinalStyle):\n\t\t\tif isinstance(self._out_obj, _styles._NamedStyle):\n\t\t\t\tconverter_class = _converting._OrdinalToNamedConverter\n\t\t\telif isinstance(self._out_obj, _styles._NumericStyle):\n\t\t\t\tconverter_class = _converting._OrdinalToNumericConverter\n\t\t\telif isinstance(self._out_obj, _styles._OrdinalStyle):\n\t\t\t\tconverter_class = _converting._OrdinalToOrdinalConverter\n\t\t\telse:\n\t\t\t\traise TypeError(\"out_style:{!r} maps to an unexpected type: {!r}\".format(self._out_style, self._out_obj))\n\n\t\telse:\n\t\t\traise TypeError(\"in_style:{!r} maps to an unexpected type: {!r}\".format(self._in_style, self._in_obj))\n\n\t\t# Create converter.\n\t\tconverter = converter_class(\n\t\t\tescape_char=self._escape_char,\n\t\t\texpand_tuples=self._expand_tuples,\n\t\t\tin_regex=self._in_regex,\n\t\t\tin_style=self._in_obj,\n\t\t\tout_style=self._out_obj,\n\t\t)\n\t\treturn converter\n", "contexts_below": "\t@property\n \tdef escape_char(self) -> Optional[str]:\n \t\t\"\"\"\n \t\t*escape_char* (:class:`str` or :data:`None`) is the escape character\n \t\tused to prevent matching a in-style parameter.\n \t\t\"\"\"\n \t\treturn self._escape_char\n \n \t@property\n \tdef expand_tuples(self) -> bool:\n \t\t\"\"\"\n \t\t*expand_tuples* (:class:`bool`) is whether to convert tuples into a\n \t\tsequence of parameters.\n \t\t\"\"\"\n \t\treturn self._expand_tuples\n \n \tdef format(\n \t\tself,\n \t\tsql: AnyStr,\n \t\tparams: Union[Dict[Union[str, int], Any], Sequence[Any]],\n \t) -> Tuple[AnyStr, Union[Dict[Union[str, int], Any], Sequence[Any]]]:\n \t\t\"\"\"\n \t\tConvert the SQL query to use the out-style parameters instead of\n \t\tthe in-style parameters.\n \n \t\t*sql* (:class:`str` or :class:`bytes`) is the SQL query.\n \n \t\t*params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\n \t\tcontains the set of in-style parameters. It maps each parameter\n \t\t(:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\n \t\tis a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\n \t\tIf :attr:`.SQLParams.in_style` is an ordinal parameter style, then\n \t\t*params* must be a :class:`~collections.abc.Sequence`.\n \n \t\tReturns a :class:`tuple` containing:\n \n \t\t-\tThe formatted SQL query (:class:`str` or :class:`bytes`).\n \n \t\t-\tThe set of converted out-style parameters (:class:`dict` or\n \t\t\t:class:`list`).\n \t\t\"\"\"\n \t\t# Normalize query encoding to simplify processing.\n \t\tif isinstance(sql, str):\n \t\t\tuse_sql = sql\n \t\t\tstring_type = str\n \t\telif isinstance(sql, bytes):\n \t\t\tuse_sql = sql.decode(_BYTES_ENCODING)\n \t\t\tstring_type = bytes\n \t\telse:\n \t\t\traise TypeError(\"sql:{!r} is not a unicode or byte string.\".format(sql))\n \n \t\t# Replace in-style with out-style parameters.\n \t\tuse_sql, out_params = self._converter.convert(use_sql, params)\n \n \t\t# Make sure the query is returned as the proper string type.\n \t\tif string_type is bytes:\n \t\t\tout_sql = use_sql.encode(_BYTES_ENCODING)\n \t\telse:\n \t\t\tout_sql = use_sql\n \n \t\t# Return converted SQL and out-parameters.\n \t\treturn out_sql, out_params\n \n \tdef formatmany(\n \t\tself,\n \t\tsql: AnyStr,\n \t\tmany_params: Union[Iterable[Dict[Union[str, int], Any]], Iterable[Sequence[Any]]],\n \t) -> Tuple[AnyStr, Union[List[Dict[Union[str, int], Any]], List[Sequence[Any]]]]:\n \t\t\"\"\"\n \t\tConvert the SQL query to use the out-style parameters instead of the\n \t\tin-style parameters.\n \n \t\t*sql* (:class:`str` or :class:`bytes`) is the SQL query.\n \n \t\t*many_params* (:class:`~collections.abc.Iterable`) contains each set\n \t\tof in-style parameters (*params*).\n \n \t\t-\t*params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\n \t\t\tcontains the set of in-style parameters. It maps each parameter\n \t\t\t(:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\n \t\t\tis a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\n \t\t\tIf :attr:`.SQLParams.in_style` is an ordinal parameter style. then\n \t\t\t*params* must be a :class:`~collections.abc.Sequence`.\n \n \t\tReturns a :class:`tuple` containing:\n \n \t\t-\tThe formatted SQL query (:class:`str` or :class:`bytes`).\n \n \t\t-\tA :class:`list` containing each set of converted out-style\n \t\t\tparameters (:class:`dict` or :class:`list`).\n \t\t\"\"\"\n \t\t# Normalize query encoding to simplify processing.\n \t\tif isinstance(sql, str):\n \t\t\tuse_sql = sql\n \t\t\tstring_type = str\n \t\telif isinstance(sql, bytes):\n \t\t\tuse_sql = sql.decode(_BYTES_ENCODING)\n \t\t\tstring_type = bytes\n \t\telse:\n \t\t\traise TypeError(\"sql:{!r} is not a unicode or byte string.\".format(sql))\n \n \t\tif not _is_iterable(many_params):\n \t\t\traise TypeError(\"many_params:{!r} is not iterable.\".format(many_params))\n \n \t\t# Replace in-style with out-style parameters.\n \t\tuse_sql, many_out_params = self._converter.convert_many(use_sql, many_params)\n \n \t\t# Make sure the query is returned as the proper string type.\n \t\tif string_type is bytes:\n \t\t\tout_sql = use_sql.encode(_BYTES_ENCODING)\n \t\telse:\n \t\t\tout_sql = use_sql\n \n \t\t# Return converted SQL and out-parameters.\n \t\treturn out_sql, many_out_params\n \n \t@property\n \tdef in_style(self) -> str:\n \t\t\"\"\"\n \t\t*in_style* (:class:`str`) is the parameter style to expect in an SQL\n \t\tquery when being parsed.\n \t\t\"\"\"\n \t\treturn self._in_style\n \n \t@property\n \tdef out_style(self) -> str:\n \t\t\"\"\"\n \t\t*out_style* (:class:`str`) is the parameter style that the SQL query\n \t\twill be converted to.\n \t\t\"\"\"\n \t\treturn self._out_style\n ", "input_code": "def _create_in_regex(self) -> Pattern:\n\"\"\"\nCreate the in-style parameter regular expression.\n\nReturns the in-style parameter regular expression (:class:`re.Pattern`).\n\"\"\"\n", "indent_space": "", "ground_truth": "\tdef _create_in_regex(self) -> Pattern:\n\t\t\"\"\"\n\t\tCreate the in-style parameter regular expression.\n\n\t\tReturns the in-style parameter regular expression (:class:`re.Pattern`).\n\t\t\"\"\"\n\t\tregex_parts = []\n\n\t\tif self._in_obj.escape_char != \"%\" and self._out_obj.escape_char == \"%\":\n\t\t\tregex_parts.append(\"(?P<out_percent>%)\")\n\n\t\tif self._escape_char:\n\t\t\t# Escaping is enabled.\n\t\t\tescape = self._in_obj.escape_regex.format(char=re.escape(self._escape_char))\n\t\t\tregex_parts.append(escape)\n\n\t\tregex_parts.append(self._in_obj.param_regex)\n\n\t\treturn re.compile(\"|\".join(regex_parts))", "signature": "def _create_in_regex(self) -> Pattern:", "completion_path": "sqlparams/__init__.py"}
{"ce_id": "62b43426903eeb48555d3ea2", "namespace": "62b43426903eeb48555d3ea2", "namespace_real": "sqlparams.__init__._create_converter", "real_proj_path": "cpburnz---python-sql-parameters/", "type": "class", "class_name": "__init__", "function_name": "_create_converter", "contexts_above": "\"\"\"\n:mod:`sqlparams` is a utility package for converting between various SQL\nparameter styles.\n\"\"\"\n\nimport re\nfrom typing import (\n\tAny,\n\tAnyStr,\n\tDict,\n\tIterable,\n\tList,\n\tOptional,\n\tPattern,\n\tSequence,\n\tTuple,\n\tType,\n\tUnion)\n\nfrom . import _converting\nfrom . import _styles\nfrom ._util import _is_iterable\n\nfrom ._meta import (\n\t__author__,\n\t__copyright__,\n\t__credits__,\n\t__license__,\n\t__version__,\n)\n\n_BYTES_ENCODING = 'latin1'\n\"\"\"\nThe encoding to use when parsing a byte query string.\n\"\"\"\n\n_STYLES = {}\n\"\"\"\nMaps parameter style by name.\n\"\"\"\n\n\nclass SQLParams(object):\n\t\"\"\"\n\tThe :class:`.SQLParams` class is used to support named parameters in\n\tSQL queries where they are not otherwise supported (e.g., pyodbc).\n\tThis is done by converting from one parameter style query to another\n\tparameter style query.\n\n\tBy default, when converting to a numeric or ordinal style any\n\t:class:`tuple` parameter will be expanded into \"(?,?,...)\" to support\n\tthe widely used \"IN {tuple}\" SQL expression without leaking any\n\tunescaped values.\n\t\"\"\"\n\n\tdef __init__(\n\t\tself,\n\t\tin_style: str,\n\t\tout_style: str,\n\t\tescape_char: Union[str, bool, None] = None,\n\t\texpand_tuples: Optional[bool] = None,\n\t) -> None:\n\t\t\"\"\"\n\t\tInstantiates the :class:`.SQLParams` instance.\n\n\t\t*in_style* (:class:`str`) is the parameter style that will be used\n\t\tin an SQL query before being parsed and converted to :attr:`.SQLParams.out_style`.\n\n\t\t*out_style* (:class:`str`) is the parameter style that the SQL query\n\t\twill be converted to.\n\n\t\t*escape_char* (:class:`str`, :class:`bool`, or :data:`None`) is the\n\t\tescape character used to prevent matching a in-style parameter. If\n\t\t:data:`True`, use the default escape character (repeat the initial\n\t\tcharacter to escape it; e.g., \"%%\"). If :data:`False`, do not use an\n\t\tescape character. Default is :data:`None` for :data:`False`.\n\n\t\t*expand_tuples* (:class:`bool` or :data:`None`) is whether to\n\t\texpand tuples into a sequence of parameters. Default is :data:`None`\n\t\tto let it be determined by *out_style* (to maintain backward\n\t\tcompatibility). If *out_style* is a numeric or ordinal style, expand\n\t\ttuples by default (:data:`True`). If *out_style* is a named style,\n\t\tdo not expand tuples by default (:data:`False`).\n\n\t\tThe following parameter styles are supported by both *in_style* and\n\t\t*out_style*:\n\n\t\t-\tFor all named styles the parameter keys must be valid `Python identifiers`_.\n\t\t\tThey cannot start with a digit. This is to help prevent\n\t\t\tincorrectly matching common strings such as datetimes.\n\n\t\t\tNamed styles:\n\n\t\t\t-\t\"named\" indicates parameters will use the named style::\n\n\t\t\t\t\t... WHERE name = :name\n\n\t\t\t-\t\"named_dollar\" indicates parameters will use the named dollar\n\t\t\t\tsign style::\n\n\t\t\t\t\t... WHERE name = $name\n\n\t\t\t\t.. NOTE:: This is not defined by `PEP 249`_.\n\n\t\t\t-\t\"pyformat\" indicates parameters will use the named Python\n\t\t\t\textended format style::\n\n\t\t\t\t\t... WHERE name = %(name)s\n\n\t\t\t\t.. NOTE:: Strictly speaking, `PEP 249`_ only specifies\n\t\t\t\t   \"%(name)s\" for the \"pyformat\" parameter style so only that\n\t\t\t\t   form (without any other conversions or flags) is supported.\n\n\t\t-\tAll numeric styles start at :data:`1`. When using a\n\t\t\t:class:`~collections.abc.Sequence` for the parameters, the 1st\n\t\t\tparameter (e.g., \":1\") will correspond to the 1st element of the\n\t\t\tsequence (i.e., index :data:`0`). When using a :class:`~collections.abc.Mapping`\n\t\t\tfor the parameters, the 1st parameter (e.g., \":1\") will correspond\n\t\t\tto the matching key (i.e., :data:`1` or :data:`\"1\"`).\n\n\t\t\tNumeric styles:\n\n\t\t\t-\t\"numeric\" indicates parameters will use the numeric style::\n\n\t\t\t\t\t... WHERE name = :1\n\n\t\t\t-\t\"numeric_dollar\" indicates parameters will use the numeric\n\t\t\t\tdollar sign style (starts at :data:`1`)::\n\n\t\t\t\t\t... WHERE name = $1\n\n\t\t\t\t.. NOTE:: This is not defined by `PEP 249`_.\n\n\t\t- Ordinal styles:\n\n\t\t\t-\t\"format\" indicates parameters will use the ordinal Python format\n\t\t\t\tstyle::\n\n\t\t\t\t\t... WHERE name = %s\n\n\t\t\t\t.. NOTE:: Strictly speaking, `PEP 249`_ only specifies \"%s\" for\n\t\t\t\t   the \"format\" parameter styles so only that form (without any\n\t\t\t\t   other conversions or flags) is supported.\n\n\t\t\t-\t\"qmark\" indicates parameters will use the ordinal question mark\n\t\t\t\tstyle::\n\n\t\t\t\t\t... WHERE name = ?\n\n\t\t.. _`PEP 249`: http://www.python.org/dev/peps/pep-0249/\n\n\t\t.. _`Python identifiers`: https://docs.python.org/3/reference/lexical_analysis.html#identifiers\n\t\t\"\"\"\n\n\t\tself._converter: _converting._Converter = None\n\t\t\"\"\"\n\t\t*_converter* (:class:`._converting._Converter`) is the parameter\n\t\tconverter to use.\n\t\t\"\"\"\n\n\t\tself._escape_char: Optional[str] = None\n\t\t\"\"\"\n\t\t*_escape_char* (:class:`str` or :data:`None`) is the escape\n\t\tcharacter used to prevent matching a in-style parameter.\n\t\t\"\"\"\n\n\t\tself._expand_tuples: bool = None\n\t\t\"\"\"\n\t\t*_expand_tuples* (:class:`bool`) is whether to convert tuples into a\n\t\tsequence of parameters.\n\t\t\"\"\"\n\n\t\tself._in_obj: _styles._Style = None\n\t\t\"\"\"\n\t\t*_in_obj* (:class:`._styles._Style`) is the in-style parameter object.\n\t\t\"\"\"\n\n\t\tself._in_regex: Pattern = None\n\t\t\"\"\"\n\t\t*_in_regex* (:class:`re.Pattern`) is the regular expression used to\n\t\textract the in-style parameters.\n\t\t\"\"\"\n\n\t\tself._in_style: str = None\n\t\t\"\"\"\n\t\t*_in_style* (:class:`str`) is the parameter style that will be used\n\t\tin an SQL query before being parsed and converted to :attr:`.SQLParams.out_style`.\n\t\t\"\"\"\n\n\t\tself._out_obj: _styles._Style = None\n\t\t\"\"\"\n\t\t*_out_obj* (:class:`._styles._Style`) is the out-style parameter object.\n\t\t\"\"\"\n\n\t\tself._out_style: str = None\n\t\t\"\"\"\n\t\t*_out_style* (:class:`str`) is the parameter style that the SQL query\n\t\twill be converted to.\n\t\t\"\"\"\n\n\t\tif not isinstance(in_style, str):\n\t\t\traise TypeError(\"in_style:{!r} is not a string.\".format(in_style))\n\n\t\tif not isinstance(out_style, str):\n\t\t\traise TypeError(\"out_style:{!r} is not a string.\".format(out_style))\n\n\t\tself._in_style = in_style\n\t\tself._out_style = out_style\n\n\t\tself._in_obj = _styles._STYLES[self._in_style]\n\t\tself._out_obj = _styles._STYLES[self._out_style]\n\n\t\tif escape_char is True:\n\t\t\tuse_char = self._in_obj.escape_char\n\t\telif not escape_char:\n\t\t\tuse_char = None\n\t\telif isinstance(escape_char, str):\n\t\t\tuse_char = escape_char\n\t\telse:\n\t\t\traise TypeError(\"escape_char:{!r} is not a string or bool.\")\n\n\t\tif expand_tuples is None:\n\t\t\texpand_tuples = not isinstance(self._out_obj, _styles._NamedStyle)\n\n\t\tself._escape_char = use_char\n\t\tself._expand_tuples = bool(expand_tuples)\n\n\t\tself._in_regex = self._create_in_regex()\n\t\tself._converter = self._create_converter()\n\n\tdef __repr__(self) -> str:\n\t\t\"\"\"\n\t\tReturns the canonical string representation (:class:`str`) of this\n\t\tinstance.\n\t\t\"\"\"\n\t\treturn \"{}.{}({!r}, {!r})\".format(self.__class__.__module__, self.__class__.__name__, self._in_style, self._out_style)\n", "contexts_below": "\tdef _create_in_regex(self) -> Pattern:\n \t\t\"\"\"\n \t\tCreate the in-style parameter regular expression.\n \n \t\tReturns the in-style parameter regular expression (:class:`re.Pattern`).\n \t\t\"\"\"\n \t\tregex_parts = []\n \n \t\tif self._in_obj.escape_char != \"%\" and self._out_obj.escape_char == \"%\":\n \t\t\tregex_parts.append(\"(?P<out_percent>%)\")\n \n \t\tif self._escape_char:\n \t\t\t# Escaping is enabled.\n \t\t\tescape = self._in_obj.escape_regex.format(char=re.escape(self._escape_char))\n \t\t\tregex_parts.append(escape)\n \n \t\tregex_parts.append(self._in_obj.param_regex)\n \n \t\treturn re.compile(\"|\".join(regex_parts))\n \n \t@property\n \tdef escape_char(self) -> Optional[str]:\n \t\t\"\"\"\n \t\t*escape_char* (:class:`str` or :data:`None`) is the escape character\n \t\tused to prevent matching a in-style parameter.\n \t\t\"\"\"\n \t\treturn self._escape_char\n \n \t@property\n \tdef expand_tuples(self) -> bool:\n \t\t\"\"\"\n \t\t*expand_tuples* (:class:`bool`) is whether to convert tuples into a\n \t\tsequence of parameters.\n \t\t\"\"\"\n \t\treturn self._expand_tuples\n \n \tdef format(\n \t\tself,\n \t\tsql: AnyStr,\n \t\tparams: Union[Dict[Union[str, int], Any], Sequence[Any]],\n \t) -> Tuple[AnyStr, Union[Dict[Union[str, int], Any], Sequence[Any]]]:\n \t\t\"\"\"\n \t\tConvert the SQL query to use the out-style parameters instead of\n \t\tthe in-style parameters.\n \n \t\t*sql* (:class:`str` or :class:`bytes`) is the SQL query.\n \n \t\t*params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\n \t\tcontains the set of in-style parameters. It maps each parameter\n \t\t(:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\n \t\tis a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\n \t\tIf :attr:`.SQLParams.in_style` is an ordinal parameter style, then\n \t\t*params* must be a :class:`~collections.abc.Sequence`.\n \n \t\tReturns a :class:`tuple` containing:\n \n \t\t-\tThe formatted SQL query (:class:`str` or :class:`bytes`).\n \n \t\t-\tThe set of converted out-style parameters (:class:`dict` or\n \t\t\t:class:`list`).\n \t\t\"\"\"\n \t\t# Normalize query encoding to simplify processing.\n \t\tif isinstance(sql, str):\n \t\t\tuse_sql = sql\n \t\t\tstring_type = str\n \t\telif isinstance(sql, bytes):\n \t\t\tuse_sql = sql.decode(_BYTES_ENCODING)\n \t\t\tstring_type = bytes\n \t\telse:\n \t\t\traise TypeError(\"sql:{!r} is not a unicode or byte string.\".format(sql))\n \n \t\t# Replace in-style with out-style parameters.\n \t\tuse_sql, out_params = self._converter.convert(use_sql, params)\n \n \t\t# Make sure the query is returned as the proper string type.\n \t\tif string_type is bytes:\n \t\t\tout_sql = use_sql.encode(_BYTES_ENCODING)\n \t\telse:\n \t\t\tout_sql = use_sql\n \n \t\t# Return converted SQL and out-parameters.\n \t\treturn out_sql, out_params\n \n \tdef formatmany(\n \t\tself,\n \t\tsql: AnyStr,\n \t\tmany_params: Union[Iterable[Dict[Union[str, int], Any]], Iterable[Sequence[Any]]],\n \t) -> Tuple[AnyStr, Union[List[Dict[Union[str, int], Any]], List[Sequence[Any]]]]:\n \t\t\"\"\"\n \t\tConvert the SQL query to use the out-style parameters instead of the\n \t\tin-style parameters.\n \n \t\t*sql* (:class:`str` or :class:`bytes`) is the SQL query.\n \n \t\t*many_params* (:class:`~collections.abc.Iterable`) contains each set\n \t\tof in-style parameters (*params*).\n \n \t\t-\t*params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\n \t\t\tcontains the set of in-style parameters. It maps each parameter\n \t\t\t(:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\n \t\t\tis a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\n \t\t\tIf :attr:`.SQLParams.in_style` is an ordinal parameter style. then\n \t\t\t*params* must be a :class:`~collections.abc.Sequence`.\n \n \t\tReturns a :class:`tuple` containing:\n \n \t\t-\tThe formatted SQL query (:class:`str` or :class:`bytes`).\n \n \t\t-\tA :class:`list` containing each set of converted out-style\n \t\t\tparameters (:class:`dict` or :class:`list`).\n \t\t\"\"\"\n \t\t# Normalize query encoding to simplify processing.\n \t\tif isinstance(sql, str):\n \t\t\tuse_sql = sql\n \t\t\tstring_type = str\n \t\telif isinstance(sql, bytes):\n \t\t\tuse_sql = sql.decode(_BYTES_ENCODING)\n \t\t\tstring_type = bytes\n \t\telse:\n \t\t\traise TypeError(\"sql:{!r} is not a unicode or byte string.\".format(sql))\n \n \t\tif not _is_iterable(many_params):\n \t\t\traise TypeError(\"many_params:{!r} is not iterable.\".format(many_params))\n \n \t\t# Replace in-style with out-style parameters.\n \t\tuse_sql, many_out_params = self._converter.convert_many(use_sql, many_params)\n \n \t\t# Make sure the query is returned as the proper string type.\n \t\tif string_type is bytes:\n \t\t\tout_sql = use_sql.encode(_BYTES_ENCODING)\n \t\telse:\n \t\t\tout_sql = use_sql\n \n \t\t# Return converted SQL and out-parameters.\n \t\treturn out_sql, many_out_params\n \n \t@property\n \tdef in_style(self) -> str:\n \t\t\"\"\"\n \t\t*in_style* (:class:`str`) is the parameter style to expect in an SQL\n \t\tquery when being parsed.\n \t\t\"\"\"\n \t\treturn self._in_style\n \n \t@property\n \tdef out_style(self) -> str:\n \t\t\"\"\"\n \t\t*out_style* (:class:`str`) is the parameter style that the SQL query\n \t\twill be converted to.\n \t\t\"\"\"\n \t\treturn self._out_style\n ", "input_code": "def _create_converter(self) -> _converting._Converter:\n\"\"\"\nCreate the parameter style converter.\n\nReturns the parameter style converter (:class:`._converting._Converter`).\n\"\"\"\n", "indent_space": "", "ground_truth": "\tdef _create_converter(self) -> _converting._Converter:\n\t\t\"\"\"\n\t\tCreate the parameter style converter.\n\n\t\tReturns the parameter style converter (:class:`._converting._Converter`).\n\t\t\"\"\"\n\t\tassert self._in_regex is not None, self._in_regex\n\t\tassert self._out_obj is not None, self._out_obj\n\n\t\t# Determine converter class.\n\t\tconverter_class: Type[_converting._Converter]\n\t\tif isinstance(self._in_obj, _styles._NamedStyle):\n\t\t\tif isinstance(self._out_obj, _styles._NamedStyle):\n\t\t\t\tconverter_class = _converting._NamedToNamedConverter\n\t\t\telif isinstance(self._out_obj, _styles._NumericStyle):\n\t\t\t\tconverter_class = _converting._NamedToNumericConverter\n\t\t\telif isinstance(self._out_obj, _styles._OrdinalStyle):\n\t\t\t\tconverter_class = _converting._NamedToOrdinalConverter\n\t\t\telse:\n\t\t\t\traise TypeError(\"out_style:{!r} maps to an unexpected type: {!r}\".format(self._out_style, self._out_obj))\n\n\t\telif isinstance(self._in_obj, _styles._NumericStyle):\n\t\t\tif isinstance(self._out_obj, _styles._NamedStyle):\n\t\t\t\tconverter_class = _converting._NumericToNamedConverter\n\t\t\telif isinstance(self._out_obj, _styles._NumericStyle):\n\t\t\t\tconverter_class = _converting._NumericToNumericConverter\n\t\t\telif isinstance(self._out_obj, _styles._OrdinalStyle):\n\t\t\t\tconverter_class = _converting._NumericToOrdinalConverter\n\t\t\telse:\n\t\t\t\traise TypeError(\"out_style:{!r} maps to an unexpected type: {!r}\".format(self._out_style, self._out_obj))\n\n\t\telif isinstance(self._in_obj, _styles._OrdinalStyle):\n\t\t\tif isinstance(self._out_obj, _styles._NamedStyle):\n\t\t\t\tconverter_class = _converting._OrdinalToNamedConverter\n\t\t\telif isinstance(self._out_obj, _styles._NumericStyle):\n\t\t\t\tconverter_class = _converting._OrdinalToNumericConverter\n\t\t\telif isinstance(self._out_obj, _styles._OrdinalStyle):\n\t\t\t\tconverter_class = _converting._OrdinalToOrdinalConverter\n\t\t\telse:\n\t\t\t\traise TypeError(\"out_style:{!r} maps to an unexpected type: {!r}\".format(self._out_style, self._out_obj))\n\n\t\telse:\n\t\t\traise TypeError(\"in_style:{!r} maps to an unexpected type: {!r}\".format(self._in_style, self._in_obj))\n\n\t\t# Create converter.\n\t\tconverter = converter_class(\n\t\t\tescape_char=self._escape_char,\n\t\t\texpand_tuples=self._expand_tuples,\n\t\t\tin_regex=self._in_regex,\n\t\t\tin_style=self._in_obj,\n\t\t\tout_style=self._out_obj,\n\t\t)\n\t\treturn converter", "signature": "def _create_converter(self) -> _converting._Converter:", "completion_path": "sqlparams/__init__.py"}
{"ce_id": "62b8966c755ee91dce50a154", "namespace": "62b8966c755ee91dce50a154", "namespace_real": "dateutil.parser.isoparser.isoparse", "real_proj_path": "pexip---os-python-dateutil/", "type": "class", "class_name": "isoparser", "function_name": "isoparse", "contexts_above": "# -*- coding: utf-8 -*-\n\"\"\"\nThis module offers a parser for ISO-8601 strings\n\nIt is intended to support all valid date, time and datetime formats per the\nISO-8601 specification.\n\n..versionadded:: 2.7.0\n\"\"\"\nfrom datetime import datetime, timedelta, time, date\nimport calendar\nfrom dateutil import tz\n\nfrom functools import wraps\n\nimport re\nimport six\n\n__all__ = [\"isoparse\", \"isoparser\"]\n\n\ndef _takes_ascii(f):\n    @wraps(f)\n    def func(self, str_in, *args, **kwargs):\n        # If it's a stream, read the whole thing\n        str_in = getattr(str_in, 'read', lambda: str_in)()\n\n        # If it's unicode, turn it into bytes, since ISO-8601 only covers ASCII\n        if isinstance(str_in, six.text_type):\n            # ASCII is the same in UTF-8\n            try:\n                str_in = str_in.encode('ascii')\n            except UnicodeEncodeError as e:\n                msg = 'ISO-8601 strings should contain only ASCII characters'\n                six.raise_from(ValueError(msg), e)\n\n        return f(self, str_in, *args, **kwargs)\n\n    return func\n\n\nclass isoparser(object):\n    def __init__(self, sep=None):\n        \"\"\"\n        :param sep:\n            A single character that separates date and time portions. If\n            ``None``, the parser will accept any single character.\n            For strict ISO-8601 adherence, pass ``'T'``.\n        \"\"\"\n        if sep is not None:\n            if (len(sep) != 1 or ord(sep) >= 128 or sep in '0123456789'):\n                raise ValueError('Separator must be a single, non-numeric ' +\n                                 'ASCII character')\n\n            sep = sep.encode('ascii')\n\n        self._sep = sep\n\n    @_takes_ascii", "contexts_below": "    @_takes_ascii\n     def parse_isodate(self, datestr):\n         \"\"\"\n         Parse the date portion of an ISO string.\n \n         :param datestr:\n             The string portion of an ISO string, without a separator\n \n         :return:\n             Returns a :class:`datetime.date` object\n         \"\"\"\n         components, pos = self._parse_isodate(datestr)\n         if pos < len(datestr):\n             raise ValueError('String contains unknown ISO ' +\n                              'components: {}'.format(datestr))\n         return date(*components)\n \n     @_takes_ascii\n     def parse_isotime(self, timestr):\n         \"\"\"\n         Parse the time portion of an ISO string.\n \n         :param timestr:\n             The time portion of an ISO string, without a separator\n \n         :return:\n             Returns a :class:`datetime.time` object\n         \"\"\"\n         components = self._parse_isotime(timestr)\n         if components[0] == 24:\n             components[0] = 0\n         return time(*components)\n \n     @_takes_ascii\n     def parse_tzstr(self, tzstr, zero_as_utc=True):\n         \"\"\"\n         Parse a valid ISO time zone string.\n \n         See :func:`isoparser.isoparse` for details on supported formats.\n \n         :param tzstr:\n             A string representing an ISO time zone offset\n \n         :param zero_as_utc:\n             Whether to return :class:`dateutil.tz.tzutc` for zero-offset zones\n \n         :return:\n             Returns :class:`dateutil.tz.tzoffset` for offsets and\n             :class:`dateutil.tz.tzutc` for ``Z`` and (if ``zero_as_utc`` is\n             specified) offsets equivalent to UTC.\n         \"\"\"\n         return self._parse_tzstr(tzstr, zero_as_utc=zero_as_utc)\n \n     # Constants\n     _DATE_SEP = b'-'\n     _TIME_SEP = b':'\n     _FRACTION_REGEX = re.compile(b'[\\\\.,]([0-9]+)')\n \n     def _parse_isodate(self, dt_str):\n         try:\n             return self._parse_isodate_common(dt_str)\n         except ValueError:\n             return self._parse_isodate_uncommon(dt_str)\n \n     def _parse_isodate_common(self, dt_str):\n         len_str = len(dt_str)\n         components = [1, 1, 1]\n \n         if len_str < 4:\n             raise ValueError('ISO string too short')\n \n         # Year\n         components[0] = int(dt_str[0:4])\n         pos = 4\n         if pos >= len_str:\n             return components, pos\n \n         has_sep = dt_str[pos:pos + 1] == self._DATE_SEP\n         if has_sep:\n             pos += 1\n \n         # Month\n         if len_str - pos < 2:\n             raise ValueError('Invalid common month')\n \n         components[1] = int(dt_str[pos:pos + 2])\n         pos += 2\n \n         if pos >= len_str:\n             if has_sep:\n                 return components, pos\n             else:\n                 raise ValueError('Invalid ISO format')\n \n         if has_sep:\n             if dt_str[pos:pos + 1] != self._DATE_SEP:\n                 raise ValueError('Invalid separator in ISO string')\n             pos += 1\n \n         # Day\n         if len_str - pos < 2:\n             raise ValueError('Invalid common day')\n         components[2] = int(dt_str[pos:pos + 2])\n         return components, pos + 2\n \n     def _parse_isodate_uncommon(self, dt_str):\n         if len(dt_str) < 4:\n             raise ValueError('ISO string too short')\n \n         # All ISO formats start with the year\n         year = int(dt_str[0:4])\n \n         has_sep = dt_str[4:5] == self._DATE_SEP\n \n         pos = 4 + has_sep       # Skip '-' if it's there\n         if dt_str[pos:pos + 1] == b'W':\n             # YYYY-?Www-?D?\n             pos += 1\n             weekno = int(dt_str[pos:pos + 2])\n             pos += 2\n \n             dayno = 1\n             if len(dt_str) > pos:\n                 if (dt_str[pos:pos + 1] == self._DATE_SEP) != has_sep:\n                     raise ValueError('Inconsistent use of dash separator')\n \n                 pos += has_sep\n \n                 dayno = int(dt_str[pos:pos + 1])\n                 pos += 1\n \n             base_date = self._calculate_weekdate(year, weekno, dayno)\n         else:\n             # YYYYDDD or YYYY-DDD\n             if len(dt_str) - pos < 3:\n                 raise ValueError('Invalid ordinal day')\n \n             ordinal_day = int(dt_str[pos:pos + 3])\n             pos += 3\n \n             if ordinal_day < 1 or ordinal_day > (365 + calendar.isleap(year)):\n                 raise ValueError('Invalid ordinal day' +\n                                  ' {} for year {}'.format(ordinal_day, year))\n \n             base_date = date(year, 1, 1) + timedelta(days=ordinal_day - 1)\n \n         components = [base_date.year, base_date.month, base_date.day]\n         return components, pos\n \n     def _calculate_weekdate(self, year, week, day):\n         \"\"\"\n         Calculate the day of corresponding to the ISO year-week-day calendar.\n \n         This function is effectively the inverse of\n         :func:`datetime.date.isocalendar`.\n \n         :param year:\n             The year in the ISO calendar\n \n         :param week:\n             The week in the ISO calendar - range is [1, 53]\n \n         :param day:\n             The day in the ISO calendar - range is [1 (MON), 7 (SUN)]\n \n         :return:\n             Returns a :class:`datetime.date`\n         \"\"\"\n         if not 0 < week < 54:\n             raise ValueError('Invalid week: {}'.format(week))\n \n         if not 0 < day < 8:     # Range is 1-7\n             raise ValueError('Invalid weekday: {}'.format(day))\n \n         # Get week 1 for the specific year:\n         jan_4 = date(year, 1, 4)   # Week 1 always has January 4th in it\n         week_1 = jan_4 - timedelta(days=jan_4.isocalendar()[2] - 1)\n \n         # Now add the specific number of weeks and days to get what we want\n         week_offset = (week - 1) * 7 + (day - 1)\n         return week_1 + timedelta(days=week_offset)\n \n     def _parse_isotime(self, timestr):\n         len_str = len(timestr)\n         components = [0, 0, 0, 0, None]\n         pos = 0\n         comp = -1\n \n         if len(timestr) < 2:\n             raise ValueError('ISO time too short')\n \n         has_sep = len_str >= 3 and timestr[2:3] == self._TIME_SEP\n \n         while pos < len_str and comp < 5:\n             comp += 1\n \n             if timestr[pos:pos + 1] in b'-+Zz':\n                 # Detect time zone boundary\n                 components[-1] = self._parse_tzstr(timestr[pos:])\n                 pos = len_str\n                 break\n \n             if comp < 3:\n                 # Hour, minute, second\n                 components[comp] = int(timestr[pos:pos + 2])\n                 pos += 2\n                 if (has_sep and pos < len_str and\n                         timestr[pos:pos + 1] == self._TIME_SEP):\n                     pos += 1\n \n             if comp == 3:\n                 # Fraction of a second\n                 frac = self._FRACTION_REGEX.match(timestr[pos:])\n                 if not frac:\n                     continue\n \n                 us_str = frac.group(1)[:6]  # Truncate to microseconds\n                 components[comp] = int(us_str) * 10**(6 - len(us_str))\n                 pos += len(frac.group())\n \n         if pos < len_str:\n             raise ValueError('Unused components in ISO string')\n \n         if components[0] == 24:\n             # Standard supports 00:00 and 24:00 as representations of midnight\n             if any(component != 0 for component in components[1:4]):\n                 raise ValueError('Hour may only be 24 at 24:00:00.000')\n \n         return components\n \n     def _parse_tzstr(self, tzstr, zero_as_utc=True):\n         if tzstr == b'Z' or tzstr == b'z':\n             return tz.UTC\n \n         if len(tzstr) not in {3, 5, 6}:\n             raise ValueError('Time zone offset must be 1, 3, 5 or 6 characters')\n \n         if tzstr[0:1] == b'-':\n             mult = -1\n         elif tzstr[0:1] == b'+':\n             mult = 1\n         else:\n             raise ValueError('Time zone offset requires sign')\n \n         hours = int(tzstr[1:3])\n         if len(tzstr) == 3:\n             minutes = 0\n         else:\n             minutes = int(tzstr[(4 if tzstr[3:4] == self._TIME_SEP else 3):])\n \n         if zero_as_utc and hours == 0 and minutes == 0:\n             return tz.UTC\n         else:\n             if minutes > 59:\n                 raise ValueError('Invalid minutes in time zone offset')\n \n             if hours > 23:\n                 raise ValueError('Invalid hours in time zone offset')\n \n             return tz.tzoffset(None, mult * (hours * 60 + minutes) * 60)\n \n \n DEFAULT_ISOPARSER = isoparser()\n isoparse = DEFAULT_ISOPARSER.isoparse\n ", "input_code": "@_takes_ascii\ndef isoparse(self, dt_str):\n\"\"\"\nParse an ISO-8601 datetime string into a :class:`datetime.datetime`.\n\nAn ISO-8601 datetime string consists of a date portion, followed\noptionally by a time portion - the date and time portions are separated\nby a single character separator, which is ``T`` in the official\nstandard. Incomplete date formats (such as ``YYYY-MM``) may *not* be\ncombined with a time portion.\n\nSupported date formats are:\n\nCommon:\n\n- ``YYYY``\n- ``YYYY-MM`` or ``YYYYMM``\n- ``YYYY-MM-DD`` or ``YYYYMMDD``\n\nUncommon:\n\n- ``YYYY-Www`` or ``YYYYWww`` - ISO week (day defaults to 0)\n- ``YYYY-Www-D`` or ``YYYYWwwD`` - ISO week and day\n\nThe ISO week and day numbering follows the same logic as\n:func:`datetime.date.isocalendar`.\n\nSupported time formats are:\n\n- ``hh``\n- ``hh:mm`` or ``hhmm``\n- ``hh:mm:ss`` or ``hhmmss``\n- ``hh:mm:ss.ssssss`` (Up to 6 sub-second digits)\n\nMidnight is a special case for `hh`, as the standard supports both\n00:00 and 24:00 as a representation. The decimal separator can be\neither a dot or a comma.\n\n\n.. caution::\n\n    Support for fractional components other than seconds is part of the\n    ISO-8601 standard, but is not currently implemented in this parser.\n\nSupported time zone offset formats are:\n\n- `Z` (UTC)\n- `\u00b1HH:MM`\n- `\u00b1HHMM`\n- `\u00b1HH`\n\nOffsets will be represented as :class:`dateutil.tz.tzoffset` objects,\nwith the exception of UTC, which will be represented as\n:class:`dateutil.tz.tzutc`. Time zone offsets equivalent to UTC (such\nas `+00:00`) will also be represented as :class:`dateutil.tz.tzutc`.\n\n:param dt_str:\n    A string or stream containing only an ISO-8601 datetime string\n\n:return:\n    Returns a :class:`datetime.datetime` representing the string.\n    Unspecified components default to their lowest value.\n\n.. warning::\n\n    As of version 2.7.0, the strictness of the parser should not be\n    considered a stable part of the contract. Any valid ISO-8601 string\n    that parses correctly with the default settings will continue to\n    parse correctly in future versions, but invalid strings that\n    currently fail (e.g. ``2017-01-01T00:00+00:00:00``) are not\n    guaranteed to continue failing in future versions if they encode\n    a valid date.\n\n.. versionadded:: 2.7.0\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @_takes_ascii\n    def isoparse(self, dt_str):\n        \"\"\"\n        Parse an ISO-8601 datetime string into a :class:`datetime.datetime`.\n\n        An ISO-8601 datetime string consists of a date portion, followed\n        optionally by a time portion - the date and time portions are separated\n        by a single character separator, which is ``T`` in the official\n        standard. Incomplete date formats (such as ``YYYY-MM``) may *not* be\n        combined with a time portion.\n\n        Supported date formats are:\n\n        Common:\n\n        - ``YYYY``\n        - ``YYYY-MM`` or ``YYYYMM``\n        - ``YYYY-MM-DD`` or ``YYYYMMDD``\n\n        Uncommon:\n\n        - ``YYYY-Www`` or ``YYYYWww`` - ISO week (day defaults to 0)\n        - ``YYYY-Www-D`` or ``YYYYWwwD`` - ISO week and day\n\n        The ISO week and day numbering follows the same logic as\n        :func:`datetime.date.isocalendar`.\n\n        Supported time formats are:\n\n        - ``hh``\n        - ``hh:mm`` or ``hhmm``\n        - ``hh:mm:ss`` or ``hhmmss``\n        - ``hh:mm:ss.ssssss`` (Up to 6 sub-second digits)\n\n        Midnight is a special case for `hh`, as the standard supports both\n        00:00 and 24:00 as a representation. The decimal separator can be\n        either a dot or a comma.\n\n\n        .. caution::\n\n            Support for fractional components other than seconds is part of the\n            ISO-8601 standard, but is not currently implemented in this parser.\n\n        Supported time zone offset formats are:\n\n        - `Z` (UTC)\n        - `\u00b1HH:MM`\n        - `\u00b1HHMM`\n        - `\u00b1HH`\n\n        Offsets will be represented as :class:`dateutil.tz.tzoffset` objects,\n        with the exception of UTC, which will be represented as\n        :class:`dateutil.tz.tzutc`. Time zone offsets equivalent to UTC (such\n        as `+00:00`) will also be represented as :class:`dateutil.tz.tzutc`.\n\n        :param dt_str:\n            A string or stream containing only an ISO-8601 datetime string\n\n        :return:\n            Returns a :class:`datetime.datetime` representing the string.\n            Unspecified components default to their lowest value.\n\n        .. warning::\n\n            As of version 2.7.0, the strictness of the parser should not be\n            considered a stable part of the contract. Any valid ISO-8601 string\n            that parses correctly with the default settings will continue to\n            parse correctly in future versions, but invalid strings that\n            currently fail (e.g. ``2017-01-01T00:00+00:00:00``) are not\n            guaranteed to continue failing in future versions if they encode\n            a valid date.\n\n        .. versionadded:: 2.7.0\n        \"\"\"\n        components, pos = self._parse_isodate(dt_str)\n\n        if len(dt_str) > pos:\n            if self._sep is None or dt_str[pos:pos + 1] == self._sep:\n                components += self._parse_isotime(dt_str[pos + 1:])\n            else:\n                raise ValueError('String contains unknown ISO components')\n\n        if len(components) > 3 and components[3] == 24:\n            components[3] = 0\n            return datetime(*components) + timedelta(days=1)\n\n        return datetime(*components)", "signature": "@_takes_ascii\ndef isoparse(self, dt_str):", "completion_path": "dateutil/parser/isoparser.py"}
{"ce_id": "62b896de755ee91dce50a183", "namespace": "62b896de755ee91dce50a183", "namespace_real": "dateutil.parser._parser.parse", "real_proj_path": "pexip---os-python-dateutil/", "type": "class", "class_name": "_parser", "function_name": "parse", "contexts_above": "# -*- coding: utf-8 -*-\n\"\"\"\nThis module offers a generic date/time string parser which is able to parse\nmost known formats to represent a date and/or time.\n\nThis module attempts to be forgiving with regards to unlikely input formats,\nreturning a datetime object even for dates which are ambiguous. If an element\nof a date/time stamp is omitted, the following rules are applied:\n\n- If AM or PM is left unspecified, a 24-hour clock is assumed, however, an hour\n  on a 12-hour clock (``0 <= hour <= 12``) *must* be specified if AM or PM is\n  specified.\n- If a time zone is omitted, a timezone-naive datetime is returned.\n\nIf any other elements are missing, they are taken from the\n:class:`datetime.datetime` object passed to the parameter ``default``. If this\nresults in a day number exceeding the valid number of days per month, the\nvalue falls back to the end of the month.\n\nAdditional resources about date/time string formats can be found below:\n\n- `A summary of the international standard date and time notation\n  <http://www.cl.cam.ac.uk/~mgk25/iso-time.html>`_\n- `W3C Date and Time Formats <http://www.w3.org/TR/NOTE-datetime>`_\n- `Time Formats (Planetary Rings Node) <https://pds-rings.seti.org:443/tools/time_formats.html>`_\n- `CPAN ParseDate module\n  <http://search.cpan.org/~muir/Time-modules-2013.0912/lib/Time/ParseDate.pm>`_\n- `Java SimpleDateFormat Class\n  <https://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html>`_\n\"\"\"\nfrom __future__ import unicode_literals\n\nimport datetime\nimport re\nimport string\nimport time\nimport warnings\n\nfrom calendar import monthrange\nfrom io import StringIO\n\nimport six\nfrom six import integer_types, text_type\n\nfrom decimal import Decimal\n\nfrom warnings import warn\n\nfrom .. import relativedelta\nfrom .. import tz\n\n__all__ = [\"parse\", \"parserinfo\", \"ParserError\"]\n\n\n# TODO: pandas.core.tools.datetimes imports this explicitly.  Might be worth\n# making public and/or figuring out if there is something we can\n# take off their plate.\nclass _timelex(object):\n    # Fractional seconds are sometimes split by a comma\n    _split_decimal = re.compile(\"([.,])\")\n\n    def __init__(self, instream):\n        if six.PY2:\n            # In Python 2, we can't duck type properly because unicode has\n            # a 'decode' function, and we'd be double-decoding\n            if isinstance(instream, (bytes, bytearray)):\n                instream = instream.decode()\n        else:\n            if getattr(instream, 'decode', None) is not None:\n                instream = instream.decode()\n\n        if isinstance(instream, text_type):\n            instream = StringIO(instream)\n        elif getattr(instream, 'read', None) is None:\n            raise TypeError('Parser must be a string or character stream, not '\n                            '{itype}'.format(itype=instream.__class__.__name__))\n\n        self.instream = instream\n        self.charstack = []\n        self.tokenstack = []\n        self.eof = False\n\n    def get_token(self):\n        \"\"\"\n        This function breaks the time string into lexical units (tokens), which\n        can be parsed by the parser. Lexical units are demarcated by changes in\n        the character set, so any continuous string of letters is considered\n        one unit, any continuous string of numbers is considered one unit.\n\n        The main complication arises from the fact that dots ('.') can be used\n        both as separators (e.g. \"Sep.20.2009\") or decimal points (e.g.\n        \"4:30:21.447\"). As such, it is necessary to read the full context of\n        any dot-separated strings before breaking it into tokens; as such, this\n        function maintains a \"token stack\", for when the ambiguous context\n        demands that multiple tokens be parsed at once.\n        \"\"\"\n        if self.tokenstack:\n            return self.tokenstack.pop(0)\n\n        seenletters = False\n        token = None\n        state = None\n\n        while not self.eof:\n            # We only realize that we've reached the end of a token when we\n            # find a character that's not part of the current token - since\n            # that character may be part of the next token, it's stored in the\n            # charstack.\n            if self.charstack:\n                nextchar = self.charstack.pop(0)\n            else:\n                nextchar = self.instream.read(1)\n                while nextchar == '\\x00':\n                    nextchar = self.instream.read(1)\n\n            if not nextchar:\n                self.eof = True\n                break\n            elif not state:\n                # First character of the token - determines if we're starting\n                # to parse a word, a number or something else.\n                token = nextchar\n                if self.isword(nextchar):\n                    state = 'a'\n                elif self.isnum(nextchar):\n                    state = '0'\n                elif self.isspace(nextchar):\n                    token = ' '\n                    break  # emit token\n                else:\n                    break  # emit token\n            elif state == 'a':\n                # If we've already started reading a word, we keep reading\n                # letters until we find something that's not part of a word.\n                seenletters = True\n                if self.isword(nextchar):\n                    token += nextchar\n                elif nextchar == '.':\n                    token += nextchar\n                    state = 'a.'\n                else:\n                    self.charstack.append(nextchar)\n                    break  # emit token\n            elif state == '0':\n                # If we've already started reading a number, we keep reading\n                # numbers until we find something that doesn't fit.\n                if self.isnum(nextchar):\n                    token += nextchar\n                elif nextchar == '.' or (nextchar == ',' and len(token) >= 2):\n                    token += nextchar\n                    state = '0.'\n                else:\n                    self.charstack.append(nextchar)\n                    break  # emit token\n            elif state == 'a.':\n                # If we've seen some letters and a dot separator, continue\n                # parsing, and the tokens will be broken up later.\n                seenletters = True\n                if nextchar == '.' or self.isword(nextchar):\n                    token += nextchar\n                elif self.isnum(nextchar) and token[-1] == '.':\n                    token += nextchar\n                    state = '0.'\n                else:\n                    self.charstack.append(nextchar)\n                    break  # emit token\n            elif state == '0.':\n                # If we've seen at least one dot separator, keep going, we'll\n                # break up the tokens later.\n                if nextchar == '.' or self.isnum(nextchar):\n                    token += nextchar\n                elif self.isword(nextchar) and token[-1] == '.':\n                    token += nextchar\n                    state = 'a.'\n                else:\n                    self.charstack.append(nextchar)\n                    break  # emit token\n\n        if (state in ('a.', '0.') and (seenletters or token.count('.') > 1 or\n                                       token[-1] in '.,')):\n            l = self._split_decimal.split(token)\n            token = l[0]\n            for tok in l[1:]:\n                if tok:\n                    self.tokenstack.append(tok)\n\n        if state == '0.' and token.count('.') == 0:\n            token = token.replace(',', '.')\n\n        return token\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        token = self.get_token()\n        if token is None:\n            raise StopIteration\n\n        return token\n\n    def next(self):\n        return self.__next__()  # Python 2.x support\n\n    @classmethod\n    def split(cls, s):\n        return list(cls(s))\n\n    @classmethod\n    def isword(cls, nextchar):\n        \"\"\" Whether or not the next character is part of a word \"\"\"\n        return nextchar.isalpha()\n\n    @classmethod\n    def isnum(cls, nextchar):\n        \"\"\" Whether the next character is part of a number \"\"\"\n        return nextchar.isdigit()\n\n    @classmethod\n    def isspace(cls, nextchar):\n        \"\"\" Whether the next character is whitespace \"\"\"\n        return nextchar.isspace()\n\n\nclass _resultbase(object):\n\n    def __init__(self):\n        for attr in self.__slots__:\n            setattr(self, attr, None)\n\n    def _repr(self, classname):\n        l = []\n        for attr in self.__slots__:\n            value = getattr(self, attr)\n            if value is not None:\n                l.append(\"%s=%s\" % (attr, repr(value)))\n        return \"%s(%s)\" % (classname, \", \".join(l))\n\n    def __len__(self):\n        return (sum(getattr(self, attr) is not None\n                    for attr in self.__slots__))\n\n    def __repr__(self):\n        return self._repr(self.__class__.__name__)\n\n\nclass parserinfo(object):\n    \"\"\"\n    Class which handles what inputs are accepted. Subclass this to customize\n    the language and acceptable values for each parameter.\n\n    :param dayfirst:\n        Whether to interpret the first value in an ambiguous 3-integer date\n        (e.g. 01/05/09) as the day (``True``) or month (``False``). If\n        ``yearfirst`` is set to ``True``, this distinguishes between YDM\n        and YMD. Default is ``False``.\n\n    :param yearfirst:\n        Whether to interpret the first value in an ambiguous 3-integer date\n        (e.g. 01/05/09) as the year. If ``True``, the first number is taken\n        to be the year, otherwise the last number is taken to be the year.\n        Default is ``False``.\n    \"\"\"\n\n    # m from a.m/p.m, t from ISO T separator\n    JUMP = [\" \", \".\", \",\", \";\", \"-\", \"/\", \"'\",\n            \"at\", \"on\", \"and\", \"ad\", \"m\", \"t\", \"of\",\n            \"st\", \"nd\", \"rd\", \"th\"]\n\n    WEEKDAYS = [(\"Mon\", \"Monday\"),\n                (\"Tue\", \"Tuesday\"),     # TODO: \"Tues\"\n                (\"Wed\", \"Wednesday\"),\n                (\"Thu\", \"Thursday\"),    # TODO: \"Thurs\"\n                (\"Fri\", \"Friday\"),\n                (\"Sat\", \"Saturday\"),\n                (\"Sun\", \"Sunday\")]\n    MONTHS = [(\"Jan\", \"January\"),\n              (\"Feb\", \"February\"),      # TODO: \"Febr\"\n              (\"Mar\", \"March\"),\n              (\"Apr\", \"April\"),\n              (\"May\", \"May\"),\n              (\"Jun\", \"June\"),\n              (\"Jul\", \"July\"),\n              (\"Aug\", \"August\"),\n              (\"Sep\", \"Sept\", \"September\"),\n              (\"Oct\", \"October\"),\n              (\"Nov\", \"November\"),\n              (\"Dec\", \"December\")]\n    HMS = [(\"h\", \"hour\", \"hours\"),\n           (\"m\", \"minute\", \"minutes\"),\n           (\"s\", \"second\", \"seconds\")]\n    AMPM = [(\"am\", \"a\"),\n            (\"pm\", \"p\")]\n    UTCZONE = [\"UTC\", \"GMT\", \"Z\", \"z\"]\n    PERTAIN = [\"of\"]\n    TZOFFSET = {}\n    # TODO: ERA = [\"AD\", \"BC\", \"CE\", \"BCE\", \"Stardate\",\n    #              \"Anno Domini\", \"Year of Our Lord\"]\n\n    def __init__(self, dayfirst=False, yearfirst=False):\n        self._jump = self._convert(self.JUMP)\n        self._weekdays = self._convert(self.WEEKDAYS)\n        self._months = self._convert(self.MONTHS)\n        self._hms = self._convert(self.HMS)\n        self._ampm = self._convert(self.AMPM)\n        self._utczone = self._convert(self.UTCZONE)\n        self._pertain = self._convert(self.PERTAIN)\n\n        self.dayfirst = dayfirst\n        self.yearfirst = yearfirst\n\n        self._year = time.localtime().tm_year\n        self._century = self._year // 100 * 100\n\n    def _convert(self, lst):\n        dct = {}\n        for i, v in enumerate(lst):\n            if isinstance(v, tuple):\n                for v in v:\n                    dct[v.lower()] = i\n            else:\n                dct[v.lower()] = i\n        return dct\n\n    def jump(self, name):\n        return name.lower() in self._jump\n\n    def weekday(self, name):\n        try:\n            return self._weekdays[name.lower()]\n        except KeyError:\n            pass\n        return None\n\n    def month(self, name):\n        try:\n            return self._months[name.lower()] + 1\n        except KeyError:\n            pass\n        return None\n\n    def hms(self, name):\n        try:\n            return self._hms[name.lower()]\n        except KeyError:\n            return None\n\n    def ampm(self, name):\n        try:\n            return self._ampm[name.lower()]\n        except KeyError:\n            return None\n\n    def pertain(self, name):\n        return name.lower() in self._pertain\n\n    def utczone(self, name):\n        return name.lower() in self._utczone\n\n    def tzoffset(self, name):\n        if name in self._utczone:\n            return 0\n\n        return self.TZOFFSET.get(name)\n\n    def convertyear(self, year, century_specified=False):\n        \"\"\"\n        Converts two-digit years to year within [-50, 49]\n        range of self._year (current local time)\n        \"\"\"\n\n        # Function contract is that the year is always positive\n        assert year >= 0\n\n        if year < 100 and not century_specified:\n            # assume current century to start\n            year += self._century\n\n            if year >= self._year + 50:  # if too far in future\n                year -= 100\n            elif year < self._year - 50:  # if too far in past\n                year += 100\n\n        return year\n\n    def validate(self, res):\n        # move to info\n        if res.year is not None:\n            res.year = self.convertyear(res.year, res.century_specified)\n\n        if ((res.tzoffset == 0 and not res.tzname) or\n             (res.tzname == 'Z' or res.tzname == 'z')):\n            res.tzname = \"UTC\"\n            res.tzoffset = 0\n        elif res.tzoffset != 0 and res.tzname and self.utczone(res.tzname):\n            res.tzoffset = 0\n        return True\n\n\nclass _ymd(list):\n    def __init__(self, *args, **kwargs):\n        super(self.__class__, self).__init__(*args, **kwargs)\n        self.century_specified = False\n        self.dstridx = None\n        self.mstridx = None\n        self.ystridx = None\n\n    @property\n    def has_year(self):\n        return self.ystridx is not None\n\n    @property\n    def has_month(self):\n        return self.mstridx is not None\n\n    @property\n    def has_day(self):\n        return self.dstridx is not None\n\n    def could_be_day(self, value):\n        if self.has_day:\n            return False\n        elif not self.has_month:\n            return 1 <= value <= 31\n        elif not self.has_year:\n            # Be permissive, assume leap year\n            month = self[self.mstridx]\n            return 1 <= value <= monthrange(2000, month)[1]\n        else:\n            month = self[self.mstridx]\n            year = self[self.ystridx]\n            return 1 <= value <= monthrange(year, month)[1]\n\n    def append(self, val, label=None):\n        if hasattr(val, '__len__'):\n            if val.isdigit() and len(val) > 2:\n                self.century_specified = True\n                if label not in [None, 'Y']:  # pragma: no cover\n                    raise ValueError(label)\n                label = 'Y'\n        elif val > 100:\n            self.century_specified = True\n            if label not in [None, 'Y']:  # pragma: no cover\n                raise ValueError(label)\n            label = 'Y'\n\n        super(self.__class__, self).append(int(val))\n\n        if label == 'M':\n            if self.has_month:\n                raise ValueError('Month is already set')\n            self.mstridx = len(self) - 1\n        elif label == 'D':\n            if self.has_day:\n                raise ValueError('Day is already set')\n            self.dstridx = len(self) - 1\n        elif label == 'Y':\n            if self.has_year:\n                raise ValueError('Year is already set')\n            self.ystridx = len(self) - 1\n\n    def _resolve_from_stridxs(self, strids):\n        \"\"\"\n        Try to resolve the identities of year/month/day elements using\n        ystridx, mstridx, and dstridx, if enough of these are specified.\n        \"\"\"\n        if len(self) == 3 and len(strids) == 2:\n            # we can back out the remaining stridx value\n            missing = [x for x in range(3) if x not in strids.values()]\n            key = [x for x in ['y', 'm', 'd'] if x not in strids]\n            assert len(missing) == len(key) == 1\n            key = key[0]\n            val = missing[0]\n            strids[key] = val\n\n        assert len(self) == len(strids)  # otherwise this should not be called\n        out = {key: self[strids[key]] for key in strids}\n        return (out.get('y'), out.get('m'), out.get('d'))\n\n    def resolve_ymd(self, yearfirst, dayfirst):\n        len_ymd = len(self)\n        year, month, day = (None, None, None)\n\n        strids = (('y', self.ystridx),\n                  ('m', self.mstridx),\n                  ('d', self.dstridx))\n\n        strids = {key: val for key, val in strids if val is not None}\n        if (len(self) == len(strids) > 0 or\n                (len(self) == 3 and len(strids) == 2)):\n            return self._resolve_from_stridxs(strids)\n\n        mstridx = self.mstridx\n\n        if len_ymd > 3:\n            raise ValueError(\"More than three YMD values\")\n        elif len_ymd == 1 or (mstridx is not None and len_ymd == 2):\n            # One member, or two members with a month string\n            if mstridx is not None:\n                month = self[mstridx]\n                # since mstridx is 0 or 1, self[mstridx-1] always\n                # looks up the other element\n                other = self[mstridx - 1]\n            else:\n                other = self[0]\n\n            if len_ymd > 1 or mstridx is None:\n                if other > 31:\n                    year = other\n                else:\n                    day = other\n\n        elif len_ymd == 2:\n            # Two members with numbers\n            if self[0] > 31:\n                # 99-01\n                year, month = self\n            elif self[1] > 31:\n                # 01-99\n                month, year = self\n            elif dayfirst and self[1] <= 12:\n                # 13-01\n                day, month = self\n            else:\n                # 01-13\n                month, day = self\n\n        elif len_ymd == 3:\n            # Three members\n            if mstridx == 0:\n                if self[1] > 31:\n                    # Apr-2003-25\n                    month, year, day = self\n                else:\n                    month, day, year = self\n            elif mstridx == 1:\n                if self[0] > 31 or (yearfirst and self[2] <= 31):\n                    # 99-Jan-01\n                    year, month, day = self\n                else:\n                    # 01-Jan-01\n                    # Give precedence to day-first, since\n                    # two-digit years is usually hand-written.\n                    day, month, year = self\n\n            elif mstridx == 2:\n                # WTF!?\n                if self[1] > 31:\n                    # 01-99-Jan\n                    day, year, month = self\n                else:\n                    # 99-01-Jan\n                    year, day, month = self\n\n            else:\n                if (self[0] > 31 or\n                    self.ystridx == 0 or\n                        (yearfirst and self[1] <= 12 and self[2] <= 31)):\n                    # 99-01-01\n                    if dayfirst and self[2] <= 12:\n                        year, day, month = self\n                    else:\n                        year, month, day = self\n                elif self[0] > 12 or (dayfirst and self[1] <= 12):\n                    # 13-01-01\n                    day, month, year = self\n                else:\n                    # 01-13-01\n                    month, day, year = self\n\n        return year, month, day\n\n\nclass parser(object):\n    def __init__(self, info=None):\n        self.info = info or parserinfo()\n", "contexts_below": "    class _result(_resultbase):\n         __slots__ = [\"year\", \"month\", \"day\", \"weekday\",\n                      \"hour\", \"minute\", \"second\", \"microsecond\",\n                      \"tzname\", \"tzoffset\", \"ampm\",\"any_unused_tokens\"]\n \n     def _parse(self, timestr, dayfirst=None, yearfirst=None, fuzzy=False,\n                fuzzy_with_tokens=False):\n         \"\"\"\n         Private method which performs the heavy lifting of parsing, called from\n         ``parse()``, which passes on its ``kwargs`` to this function.\n \n         :param timestr:\n             The string to parse.\n \n         :param dayfirst:\n             Whether to interpret the first value in an ambiguous 3-integer date\n             (e.g. 01/05/09) as the day (``True``) or month (``False``). If\n             ``yearfirst`` is set to ``True``, this distinguishes between YDM\n             and YMD. If set to ``None``, this value is retrieved from the\n             current :class:`parserinfo` object (which itself defaults to\n             ``False``).\n \n         :param yearfirst:\n             Whether to interpret the first value in an ambiguous 3-integer date\n             (e.g. 01/05/09) as the year. If ``True``, the first number is taken\n             to be the year, otherwise the last number is taken to be the year.\n             If this is set to ``None``, the value is retrieved from the current\n             :class:`parserinfo` object (which itself defaults to ``False``).\n \n         :param fuzzy:\n             Whether to allow fuzzy parsing, allowing for string like \"Today is\n             January 1, 2047 at 8:21:00AM\".\n \n         :param fuzzy_with_tokens:\n             If ``True``, ``fuzzy`` is automatically set to True, and the parser\n             will return a tuple where the first element is the parsed\n             :class:`datetime.datetime` datetimestamp and the second element is\n             a tuple containing the portions of the string which were ignored:\n \n             .. doctest::\n \n                 >>> from dateutil.parser import parse\n                 >>> parse(\"Today is January 1, 2047 at 8:21:00AM\", fuzzy_with_tokens=True)\n                 (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))\n \n         \"\"\"\n         if fuzzy_with_tokens:\n             fuzzy = True\n \n         info = self.info\n \n         if dayfirst is None:\n             dayfirst = info.dayfirst\n \n         if yearfirst is None:\n             yearfirst = info.yearfirst\n \n         res = self._result()\n         l = _timelex.split(timestr)         # Splits the timestr into tokens\n \n         skipped_idxs = []\n \n         # year/month/day list\n         ymd = _ymd()\n \n         len_l = len(l)\n         i = 0\n         try:\n             while i < len_l:\n \n                 # Check if it's a number\n                 value_repr = l[i]\n                 try:\n                     value = float(value_repr)\n                 except ValueError:\n                     value = None\n \n                 if value is not None:\n                     # Numeric token\n                     i = self._parse_numeric_token(l, i, info, ymd, res, fuzzy)\n \n                 # Check weekday\n                 elif info.weekday(l[i]) is not None:\n                     value = info.weekday(l[i])\n                     res.weekday = value\n \n                 # Check month name\n                 elif info.month(l[i]) is not None:\n                     value = info.month(l[i])\n                     ymd.append(value, 'M')\n \n                     if i + 1 < len_l:\n                         if l[i + 1] in ('-', '/'):\n                             # Jan-01[-99]\n                             sep = l[i + 1]\n                             ymd.append(l[i + 2])\n \n                             if i + 3 < len_l and l[i + 3] == sep:\n                                 # Jan-01-99\n                                 ymd.append(l[i + 4])\n                                 i += 2\n \n                             i += 2\n \n                         elif (i + 4 < len_l and l[i + 1] == l[i + 3] == ' ' and\n                               info.pertain(l[i + 2])):\n                             # Jan of 01\n                             # In this case, 01 is clearly year\n                             if l[i + 4].isdigit():\n                                 # Convert it here to become unambiguous\n                                 value = int(l[i + 4])\n                                 year = str(info.convertyear(value))\n                                 ymd.append(year, 'Y')\n                             else:\n                                 # Wrong guess\n                                 pass\n                                 # TODO: not hit in tests\n                             i += 4\n \n                 # Check am/pm\n                 elif info.ampm(l[i]) is not None:\n                     value = info.ampm(l[i])\n                     val_is_ampm = self._ampm_valid(res.hour, res.ampm, fuzzy)\n \n                     if val_is_ampm:\n                         res.hour = self._adjust_ampm(res.hour, value)\n                         res.ampm = value\n \n                     elif fuzzy:\n                         skipped_idxs.append(i)\n \n                 # Check for a timezone name\n                 elif self._could_be_tzname(res.hour, res.tzname, res.tzoffset, l[i]):\n                     res.tzname = l[i]\n                     res.tzoffset = info.tzoffset(res.tzname)\n \n                     # Check for something like GMT+3, or BRST+3. Notice\n                     # that it doesn't mean \"I am 3 hours after GMT\", but\n                     # \"my time +3 is GMT\". If found, we reverse the\n                     # logic so that timezone parsing code will get it\n                     # right.\n                     if i + 1 < len_l and l[i + 1] in ('+', '-'):\n                         l[i + 1] = ('+', '-')[l[i + 1] == '+']\n                         res.tzoffset = None\n                         if info.utczone(res.tzname):\n                             # With something like GMT+3, the timezone\n                             # is *not* GMT.\n                             res.tzname = None\n \n                 # Check for a numbered timezone\n                 elif res.hour is not None and l[i] in ('+', '-'):\n                     signal = (-1, 1)[l[i] == '+']\n                     len_li = len(l[i + 1])\n \n                     # TODO: check that l[i + 1] is integer?\n                     if len_li == 4:\n                         # -0300\n                         hour_offset = int(l[i + 1][:2])\n                         min_offset = int(l[i + 1][2:])\n                     elif i + 2 < len_l and l[i + 2] == ':':\n                         # -03:00\n                         hour_offset = int(l[i + 1])\n                         min_offset = int(l[i + 3])  # TODO: Check that l[i+3] is minute-like?\n                         i += 2\n                     elif len_li <= 2:\n                         # -[0]3\n                         hour_offset = int(l[i + 1][:2])\n                         min_offset = 0\n                     else:\n                         raise ValueError(timestr)\n \n                     res.tzoffset = signal * (hour_offset * 3600 + min_offset * 60)\n \n                     # Look for a timezone name between parenthesis\n                     if (i + 5 < len_l and\n                             info.jump(l[i + 2]) and l[i + 3] == '(' and\n                             l[i + 5] == ')' and\n                             3 <= len(l[i + 4]) and\n                             self._could_be_tzname(res.hour, res.tzname,\n                                                   None, l[i + 4])):\n                         # -0300 (BRST)\n                         res.tzname = l[i + 4]\n                         i += 4\n \n                     i += 1\n \n                 # Check jumps\n                 elif not (info.jump(l[i]) or fuzzy):\n                     raise ValueError(timestr)\n \n                 else:\n                     skipped_idxs.append(i)\n                 i += 1\n \n             # Process year/month/day\n             year, month, day = ymd.resolve_ymd(yearfirst, dayfirst)\n \n             res.century_specified = ymd.century_specified\n             res.year = year\n             res.month = month\n             res.day = day\n \n         except (IndexError, ValueError):\n             return None, None\n \n         if not info.validate(res):\n             return None, None\n \n         if fuzzy_with_tokens:\n             skipped_tokens = self._recombine_skipped(l, skipped_idxs)\n             return res, tuple(skipped_tokens)\n         else:\n             return res, None\n \n     def _parse_numeric_token(self, tokens, idx, info, ymd, res, fuzzy):\n         # Token is a number\n         value_repr = tokens[idx]\n         try:\n             value = self._to_decimal(value_repr)\n         except Exception as e:\n             six.raise_from(ValueError('Unknown numeric token'), e)\n \n         len_li = len(value_repr)\n \n         len_l = len(tokens)\n \n         if (len(ymd) == 3 and len_li in (2, 4) and\n             res.hour is None and\n             (idx + 1 >= len_l or\n              (tokens[idx + 1] != ':' and\n               info.hms(tokens[idx + 1]) is None))):\n             # 19990101T23[59]\n             s = tokens[idx]\n             res.hour = int(s[:2])\n \n             if len_li == 4:\n                 res.minute = int(s[2:])\n \n         elif len_li == 6 or (len_li > 6 and tokens[idx].find('.') == 6):\n             # YYMMDD or HHMMSS[.ss]\n             s = tokens[idx]\n \n             if not ymd and '.' not in tokens[idx]:\n                 ymd.append(s[:2])\n                 ymd.append(s[2:4])\n                 ymd.append(s[4:])\n             else:\n                 # 19990101T235959[.59]\n \n                 # TODO: Check if res attributes already set.\n                 res.hour = int(s[:2])\n                 res.minute = int(s[2:4])\n                 res.second, res.microsecond = self._parsems(s[4:])\n \n         elif len_li in (8, 12, 14):\n             # YYYYMMDD\n             s = tokens[idx]\n             ymd.append(s[:4], 'Y')\n             ymd.append(s[4:6])\n             ymd.append(s[6:8])\n \n             if len_li > 8:\n                 res.hour = int(s[8:10])\n                 res.minute = int(s[10:12])\n \n                 if len_li > 12:\n                     res.second = int(s[12:])\n \n         elif self._find_hms_idx(idx, tokens, info, allow_jump=True) is not None:\n             # HH[ ]h or MM[ ]m or SS[.ss][ ]s\n             hms_idx = self._find_hms_idx(idx, tokens, info, allow_jump=True)\n             (idx, hms) = self._parse_hms(idx, tokens, info, hms_idx)\n             if hms is not None:\n                 # TODO: checking that hour/minute/second are not\n                 # already set?\n                 self._assign_hms(res, value_repr, hms)\n \n         elif idx + 2 < len_l and tokens[idx + 1] == ':':\n             # HH:MM[:SS[.ss]]\n             res.hour = int(value)\n             value = self._to_decimal(tokens[idx + 2])  # TODO: try/except for this?\n             (res.minute, res.second) = self._parse_min_sec(value)\n \n             if idx + 4 < len_l and tokens[idx + 3] == ':':\n                 res.second, res.microsecond = self._parsems(tokens[idx + 4])\n \n                 idx += 2\n \n             idx += 2\n \n         elif idx + 1 < len_l and tokens[idx + 1] in ('-', '/', '.'):\n             sep = tokens[idx + 1]\n             ymd.append(value_repr)\n \n             if idx + 2 < len_l and not info.jump(tokens[idx + 2]):\n                 if tokens[idx + 2].isdigit():\n                     # 01-01[-01]\n                     ymd.append(tokens[idx + 2])\n                 else:\n                     # 01-Jan[-01]\n                     value = info.month(tokens[idx + 2])\n \n                     if value is not None:\n                         ymd.append(value, 'M')\n                     else:\n                         raise ValueError()\n \n                 if idx + 3 < len_l and tokens[idx + 3] == sep:\n                     # We have three members\n                     value = info.month(tokens[idx + 4])\n \n                     if value is not None:\n                         ymd.append(value, 'M')\n                     else:\n                         ymd.append(tokens[idx + 4])\n                     idx += 2\n \n                 idx += 1\n             idx += 1\n \n         elif idx + 1 >= len_l or info.jump(tokens[idx + 1]):\n             if idx + 2 < len_l and info.ampm(tokens[idx + 2]) is not None:\n                 # 12 am\n                 hour = int(value)\n                 res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 2]))\n                 idx += 1\n             else:\n                 # Year, month or day\n                 ymd.append(value)\n             idx += 1\n \n         elif info.ampm(tokens[idx + 1]) is not None and (0 <= value < 24):\n             # 12am\n             hour = int(value)\n             res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 1]))\n             idx += 1\n \n         elif ymd.could_be_day(value):\n             ymd.append(value)\n \n         elif not fuzzy:\n             raise ValueError()\n \n         return idx\n \n     def _find_hms_idx(self, idx, tokens, info, allow_jump):\n         len_l = len(tokens)\n \n         if idx+1 < len_l and info.hms(tokens[idx+1]) is not None:\n             # There is an \"h\", \"m\", or \"s\" label following this token.  We take\n             # assign the upcoming label to the current token.\n             # e.g. the \"12\" in 12h\"\n             hms_idx = idx + 1\n \n         elif (allow_jump and idx+2 < len_l and tokens[idx+1] == ' ' and\n               info.hms(tokens[idx+2]) is not None):\n             # There is a space and then an \"h\", \"m\", or \"s\" label.\n             # e.g. the \"12\" in \"12 h\"\n             hms_idx = idx + 2\n \n         elif idx > 0 and info.hms(tokens[idx-1]) is not None:\n             # There is a \"h\", \"m\", or \"s\" preceding this token.  Since neither\n             # of the previous cases was hit, there is no label following this\n             # token, so we use the previous label.\n             # e.g. the \"04\" in \"12h04\"\n             hms_idx = idx-1\n \n         elif (1 < idx == len_l-1 and tokens[idx-1] == ' ' and\n               info.hms(tokens[idx-2]) is not None):\n             # If we are looking at the final token, we allow for a\n             # backward-looking check to skip over a space.\n             # TODO: Are we sure this is the right condition here?\n             hms_idx = idx - 2\n \n         else:\n             hms_idx = None\n \n         return hms_idx\n \n     def _assign_hms(self, res, value_repr, hms):\n         # See GH issue #427, fixing float rounding\n         value = self._to_decimal(value_repr)\n \n         if hms == 0:\n             # Hour\n             res.hour = int(value)\n             if value % 1:\n                 res.minute = int(60*(value % 1))\n \n         elif hms == 1:\n             (res.minute, res.second) = self._parse_min_sec(value)\n \n         elif hms == 2:\n             (res.second, res.microsecond) = self._parsems(value_repr)\n \n     def _could_be_tzname(self, hour, tzname, tzoffset, token):\n         return (hour is not None and\n                 tzname is None and\n                 tzoffset is None and\n                 len(token) <= 5 and\n                 (all(x in string.ascii_uppercase for x in token)\n                  or token in self.info.UTCZONE))\n \n     def _ampm_valid(self, hour, ampm, fuzzy):\n         \"\"\"\n         For fuzzy parsing, 'a' or 'am' (both valid English words)\n         may erroneously trigger the AM/PM flag. Deal with that\n         here.\n         \"\"\"\n         val_is_ampm = True\n \n         # If there's already an AM/PM flag, this one isn't one.\n         if fuzzy and ampm is not None:\n             val_is_ampm = False\n \n         # If AM/PM is found and hour is not, raise a ValueError\n         if hour is None:\n             if fuzzy:\n                 val_is_ampm = False\n             else:\n                 raise ValueError('No hour specified with AM or PM flag.')\n         elif not 0 <= hour <= 12:\n             # If AM/PM is found, it's a 12 hour clock, so raise\n             # an error for invalid range\n             if fuzzy:\n                 val_is_ampm = False\n             else:\n                 raise ValueError('Invalid hour specified for 12-hour clock.')\n \n         return val_is_ampm\n \n     def _adjust_ampm(self, hour, ampm):\n         if hour < 12 and ampm == 1:\n             hour += 12\n         elif hour == 12 and ampm == 0:\n             hour = 0\n         return hour\n \n     def _parse_min_sec(self, value):\n         # TODO: Every usage of this function sets res.second to the return\n         # value. Are there any cases where second will be returned as None and\n         # we *don't* want to set res.second = None?\n         minute = int(value)\n         second = None\n \n         sec_remainder = value % 1\n         if sec_remainder:\n             second = int(60 * sec_remainder)\n         return (minute, second)\n \n     def _parse_hms(self, idx, tokens, info, hms_idx):\n         # TODO: Is this going to admit a lot of false-positives for when we\n         # just happen to have digits and \"h\", \"m\" or \"s\" characters in non-date\n         # text?  I guess hex hashes won't have that problem, but there's plenty\n         # of random junk out there.\n         if hms_idx is None:\n             hms = None\n             new_idx = idx\n         elif hms_idx > idx:\n             hms = info.hms(tokens[hms_idx])\n             new_idx = hms_idx\n         else:\n             # Looking backwards, increment one.\n             hms = info.hms(tokens[hms_idx]) + 1\n             new_idx = idx\n \n         return (new_idx, hms)\n \n     # ------------------------------------------------------------------\n     # Handling for individual tokens.  These are kept as methods instead\n     #  of functions for the sake of customizability via subclassing.\n \n     def _parsems(self, value):\n         \"\"\"Parse a I[.F] seconds value into (seconds, microseconds).\"\"\"\n         if \".\" not in value:\n             return int(value), 0\n         else:\n             i, f = value.split(\".\")\n             return int(i), int(f.ljust(6, \"0\")[:6])\n \n     def _to_decimal(self, val):\n         try:\n             decimal_value = Decimal(val)\n             # See GH 662, edge case, infinite value should not be converted\n             #  via `_to_decimal`\n             if not decimal_value.is_finite():\n                 raise ValueError(\"Converted decimal value is infinite or NaN\")\n         except Exception as e:\n             msg = \"Could not convert %s to decimal\" % val\n             six.raise_from(ValueError(msg), e)\n         else:\n             return decimal_value\n \n     # ------------------------------------------------------------------\n     # Post-Parsing construction of datetime output.  These are kept as\n     #  methods instead of functions for the sake of customizability via\n     #  subclassing.\n \n     def _build_tzinfo(self, tzinfos, tzname, tzoffset):\n         if callable(tzinfos):\n             tzdata = tzinfos(tzname, tzoffset)\n         else:\n             tzdata = tzinfos.get(tzname)\n         # handle case where tzinfo is paased an options that returns None\n         # eg tzinfos = {'BRST' : None}\n         if isinstance(tzdata, datetime.tzinfo) or tzdata is None:\n             tzinfo = tzdata\n         elif isinstance(tzdata, text_type):\n             tzinfo = tz.tzstr(tzdata)\n         elif isinstance(tzdata, integer_types):\n             tzinfo = tz.tzoffset(tzname, tzdata)\n         else:\n             raise TypeError(\"Offset must be tzinfo subclass, tz string, \"\n                             \"or int offset.\")\n         return tzinfo\n \n     def _build_tzaware(self, naive, res, tzinfos):\n         if (callable(tzinfos) or (tzinfos and res.tzname in tzinfos)):\n             tzinfo = self._build_tzinfo(tzinfos, res.tzname, res.tzoffset)\n             aware = naive.replace(tzinfo=tzinfo)\n             aware = self._assign_tzname(aware, res.tzname)\n \n         elif res.tzname and res.tzname in time.tzname:\n             aware = naive.replace(tzinfo=tz.tzlocal())\n \n             # Handle ambiguous local datetime\n             aware = self._assign_tzname(aware, res.tzname)\n \n             # This is mostly relevant for winter GMT zones parsed in the UK\n             if (aware.tzname() != res.tzname and\n                     res.tzname in self.info.UTCZONE):\n                 aware = aware.replace(tzinfo=tz.UTC)\n \n         elif res.tzoffset == 0:\n             aware = naive.replace(tzinfo=tz.UTC)\n \n         elif res.tzoffset:\n             aware = naive.replace(tzinfo=tz.tzoffset(res.tzname, res.tzoffset))\n \n         elif not res.tzname and not res.tzoffset:\n             # i.e. no timezone information was found.\n             aware = naive\n \n         elif res.tzname:\n             # tz-like string was parsed but we don't know what to do\n             # with it\n             warnings.warn(\"tzname {tzname} identified but not understood.  \"\n                           \"Pass `tzinfos` argument in order to correctly \"\n                           \"return a timezone-aware datetime.  In a future \"\n                           \"version, this will raise an \"\n                           \"exception.\".format(tzname=res.tzname),\n                           category=UnknownTimezoneWarning)\n             aware = naive\n \n         return aware\n \n     def _build_naive(self, res, default):\n         repl = {}\n         for attr in (\"year\", \"month\", \"day\", \"hour\",\n                      \"minute\", \"second\", \"microsecond\"):\n             value = getattr(res, attr)\n             if value is not None:\n                 repl[attr] = value\n \n         if 'day' not in repl:\n             # If the default day exceeds the last day of the month, fall back\n             # to the end of the month.\n             cyear = default.year if res.year is None else res.year\n             cmonth = default.month if res.month is None else res.month\n             cday = default.day if res.day is None else res.day\n \n             if cday > monthrange(cyear, cmonth)[1]:\n                 repl['day'] = monthrange(cyear, cmonth)[1]\n \n         naive = default.replace(**repl)\n \n         if res.weekday is not None and not res.day:\n             naive = naive + relativedelta.relativedelta(weekday=res.weekday)\n \n         return naive\n \n     def _assign_tzname(self, dt, tzname):\n         if dt.tzname() != tzname:\n             new_dt = tz.enfold(dt, fold=1)\n             if new_dt.tzname() == tzname:\n                 return new_dt\n \n         return dt\n \n     def _recombine_skipped(self, tokens, skipped_idxs):\n         \"\"\"\n         >>> tokens = [\"foo\", \" \", \"bar\", \" \", \"19June2000\", \"baz\"]\n         >>> skipped_idxs = [0, 1, 2, 5]\n         >>> _recombine_skipped(tokens, skipped_idxs)\n         [\"foo bar\", \"baz\"]\n         \"\"\"\n         skipped_tokens = []\n         for i, idx in enumerate(sorted(skipped_idxs)):\n             if i > 0 and idx - 1 == skipped_idxs[i - 1]:\n                 skipped_tokens[-1] = skipped_tokens[-1] + tokens[idx]\n             else:\n                 skipped_tokens.append(tokens[idx])\n \n         return skipped_tokens\n \n \n DEFAULTPARSER = parser()\n \n \n def parse(timestr, parserinfo=None, **kwargs):\n     \"\"\"\n \n     Parse a string in one of the supported formats, using the\n     ``parserinfo`` parameters.\n \n     :param timestr:\n         A string containing a date/time stamp.\n \n     :param parserinfo:\n         A :class:`parserinfo` object containing parameters for the parser.\n         If ``None``, the default arguments to the :class:`parserinfo`\n         constructor are used.\n \n     The ``**kwargs`` parameter takes the following keyword arguments:\n \n     :param default:\n         The default datetime object, if this is a datetime object and not\n         ``None``, elements specified in ``timestr`` replace elements in the\n         default object.\n \n     :param ignoretz:\n         If set ``True``, time zones in parsed strings are ignored and a naive\n         :class:`datetime` object is returned.\n \n     :param tzinfos:\n         Additional time zone names / aliases which may be present in the\n         string. This argument maps time zone names (and optionally offsets\n         from those time zones) to time zones. This parameter can be a\n         dictionary with timezone aliases mapping time zone names to time\n         zones or a function taking two parameters (``tzname`` and\n         ``tzoffset``) and returning a time zone.\n \n         The timezones to which the names are mapped can be an integer\n         offset from UTC in seconds or a :class:`tzinfo` object.\n \n         .. doctest::\n            :options: +NORMALIZE_WHITESPACE\n \n             >>> from dateutil.parser import parse\n             >>> from dateutil.tz import gettz\n             >>> tzinfos = {\"BRST\": -7200, \"CST\": gettz(\"America/Chicago\")}\n             >>> parse(\"2012-01-19 17:21:00 BRST\", tzinfos=tzinfos)\n             datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))\n             >>> parse(\"2012-01-19 17:21:00 CST\", tzinfos=tzinfos)\n             datetime.datetime(2012, 1, 19, 17, 21,\n                               tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))\n \n         This parameter is ignored if ``ignoretz`` is set.\n \n     :param dayfirst:\n         Whether to interpret the first value in an ambiguous 3-integer date\n         (e.g. 01/05/09) as the day (``True``) or month (``False``). If\n         ``yearfirst`` is set to ``True``, this distinguishes between YDM and\n         YMD. If set to ``None``, this value is retrieved from the current\n         :class:`parserinfo` object (which itself defaults to ``False``).\n \n     :param yearfirst:\n         Whether to interpret the first value in an ambiguous 3-integer date\n         (e.g. 01/05/09) as the year. If ``True``, the first number is taken to\n         be the year, otherwise the last number is taken to be the year. If\n         this is set to ``None``, the value is retrieved from the current\n         :class:`parserinfo` object (which itself defaults to ``False``).\n \n     :param fuzzy:\n         Whether to allow fuzzy parsing, allowing for string like \"Today is\n         January 1, 2047 at 8:21:00AM\".\n \n     :param fuzzy_with_tokens:\n         If ``True``, ``fuzzy`` is automatically set to True, and the parser\n         will return a tuple where the first element is the parsed\n         :class:`datetime.datetime` datetimestamp and the second element is\n         a tuple containing the portions of the string which were ignored:\n \n         .. doctest::\n \n             >>> from dateutil.parser import parse\n             >>> parse(\"Today is January 1, 2047 at 8:21:00AM\", fuzzy_with_tokens=True)\n             (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))\n \n     :return:\n         Returns a :class:`datetime.datetime` object or, if the\n         ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the\n         first element being a :class:`datetime.datetime` object, the second\n         a tuple containing the fuzzy tokens.\n \n     :raises ValueError:\n         Raised for invalid or unknown string format, if the provided\n         :class:`tzinfo` is not in a valid format, or if an invalid date\n         would be created.\n \n     :raises OverflowError:\n         Raised if the parsed date exceeds the largest valid C integer on\n         your system.\n     \"\"\"\n     if parserinfo:\n         return parser(parserinfo).parse(timestr, **kwargs)\n     else:\n         return DEFAULTPARSER.parse(timestr, **kwargs)\n \n \n class _tzparser(object):\n \n     class _result(_resultbase):\n \n         __slots__ = [\"stdabbr\", \"stdoffset\", \"dstabbr\", \"dstoffset\",\n                      \"start\", \"end\"]\n \n         class _attr(_resultbase):\n             __slots__ = [\"month\", \"week\", \"weekday\",\n                          \"yday\", \"jyday\", \"day\", \"time\"]\n \n         def __repr__(self):\n             return self._repr(\"\")\n \n         def __init__(self):\n             _resultbase.__init__(self)\n             self.start = self._attr()\n             self.end = self._attr()\n \n     def parse(self, tzstr):\n         res = self._result()\n         l = [x for x in re.split(r'([,:.]|[a-zA-Z]+|[0-9]+)',tzstr) if x]\n         used_idxs = list()\n         try:\n \n             len_l = len(l)\n \n             i = 0\n             while i < len_l:\n                 # BRST+3[BRDT[+2]]\n                 j = i\n                 while j < len_l and not [x for x in l[j]\n                                          if x in \"0123456789:,-+\"]:\n                     j += 1\n                 if j != i:\n                     if not res.stdabbr:\n                         offattr = \"stdoffset\"\n                         res.stdabbr = \"\".join(l[i:j])\n                     else:\n                         offattr = \"dstoffset\"\n                         res.dstabbr = \"\".join(l[i:j])\n \n                     for ii in range(j):\n                         used_idxs.append(ii)\n                     i = j\n                     if (i < len_l and (l[i] in ('+', '-') or l[i][0] in\n                                        \"0123456789\")):\n                         if l[i] in ('+', '-'):\n                             # Yes, that's right.  See the TZ variable\n                             # documentation.\n                             signal = (1, -1)[l[i] == '+']\n                             used_idxs.append(i)\n                             i += 1\n                         else:\n                             signal = -1\n                         len_li = len(l[i])\n                         if len_li == 4:\n                             # -0300\n                             setattr(res, offattr, (int(l[i][:2]) * 3600 +\n                                                    int(l[i][2:]) * 60) * signal)\n                         elif i + 1 < len_l and l[i + 1] == ':':\n                             # -03:00\n                             setattr(res, offattr,\n                                     (int(l[i]) * 3600 +\n                                      int(l[i + 2]) * 60) * signal)\n                             used_idxs.append(i)\n                             i += 2\n                         elif len_li <= 2:\n                             # -[0]3\n                             setattr(res, offattr,\n                                     int(l[i][:2]) * 3600 * signal)\n                         else:\n                             return None\n                         used_idxs.append(i)\n                         i += 1\n                     if res.dstabbr:\n                         break\n                 else:\n                     break\n \n \n             if i < len_l:\n                 for j in range(i, len_l):\n                     if l[j] == ';':\n                         l[j] = ','\n \n                 assert l[i] == ','\n \n                 i += 1\n \n             if i >= len_l:\n                 pass\n             elif (8 <= l.count(',') <= 9 and\n                   not [y for x in l[i:] if x != ','\n                        for y in x if y not in \"0123456789+-\"]):\n                 # GMT0BST,3,0,30,3600,10,0,26,7200[,3600]\n                 for x in (res.start, res.end):\n                     x.month = int(l[i])\n                     used_idxs.append(i)\n                     i += 2\n                     if l[i] == '-':\n                         value = int(l[i + 1]) * -1\n                         used_idxs.append(i)\n                         i += 1\n                     else:\n                         value = int(l[i])\n                     used_idxs.append(i)\n                     i += 2\n                     if value:\n                         x.week = value\n                         x.weekday = (int(l[i]) - 1) % 7\n                     else:\n                         x.day = int(l[i])\n                     used_idxs.append(i)\n                     i += 2\n                     x.time = int(l[i])\n                     used_idxs.append(i)\n                     i += 2\n                 if i < len_l:\n                     if l[i] in ('-', '+'):\n                         signal = (-1, 1)[l[i] == \"+\"]\n                         used_idxs.append(i)\n                         i += 1\n                     else:\n                         signal = 1\n                     used_idxs.append(i)\n                     res.dstoffset = (res.stdoffset + int(l[i]) * signal)\n \n                 # This was a made-up format that is not in normal use\n                 warn(('Parsed time zone \"%s\"' % tzstr) +\n                      'is in a non-standard dateutil-specific format, which ' +\n                      'is now deprecated; support for parsing this format ' +\n                      'will be removed in future versions. It is recommended ' +\n                      'that you switch to a standard format like the GNU ' +\n                      'TZ variable format.', tz.DeprecatedTzFormatWarning)\n             elif (l.count(',') == 2 and l[i:].count('/') <= 2 and\n                   not [y for x in l[i:] if x not in (',', '/', 'J', 'M',\n                                                      '.', '-', ':')\n                        for y in x if y not in \"0123456789\"]):\n                 for x in (res.start, res.end):\n                     if l[i] == 'J':\n                         # non-leap year day (1 based)\n                         used_idxs.append(i)\n                         i += 1\n                         x.jyday = int(l[i])\n                     elif l[i] == 'M':\n                         # month[-.]week[-.]weekday\n                         used_idxs.append(i)\n                         i += 1\n                         x.month = int(l[i])\n                         used_idxs.append(i)\n                         i += 1\n                         assert l[i] in ('-', '.')\n                         used_idxs.append(i)\n                         i += 1\n                         x.week = int(l[i])\n                         if x.week == 5:\n                             x.week = -1\n                         used_idxs.append(i)\n                         i += 1\n                         assert l[i] in ('-', '.')\n                         used_idxs.append(i)\n                         i += 1\n                         x.weekday = (int(l[i]) - 1) % 7\n                     else:\n                         # year day (zero based)\n                         x.yday = int(l[i]) + 1\n \n                     used_idxs.append(i)\n                     i += 1\n \n                     if i < len_l and l[i] == '/':\n                         used_idxs.append(i)\n                         i += 1\n                         # start time\n                         len_li = len(l[i])\n                         if len_li == 4:\n                             # -0300\n                             x.time = (int(l[i][:2]) * 3600 +\n                                       int(l[i][2:]) * 60)\n                         elif i + 1 < len_l and l[i + 1] == ':':\n                             # -03:00\n                             x.time = int(l[i]) * 3600 + int(l[i + 2]) * 60\n                             used_idxs.append(i)\n                             i += 2\n                             if i + 1 < len_l and l[i + 1] == ':':\n                                 used_idxs.append(i)\n                                 i += 2\n                                 x.time += int(l[i])\n                         elif len_li <= 2:\n                             # -[0]3\n                             x.time = (int(l[i][:2]) * 3600)\n                         else:\n                             return None\n                         used_idxs.append(i)\n                         i += 1\n \n                     assert i == len_l or l[i] == ','\n \n                     i += 1\n \n                 assert i >= len_l\n \n         except (IndexError, ValueError, AssertionError):\n             return None\n \n         unused_idxs = set(range(len_l)).difference(used_idxs)\n         res.any_unused_tokens = not {l[n] for n in unused_idxs}.issubset({\",\",\":\"})\n         return res\n \n \n DEFAULTTZPARSER = _tzparser()\n \n \n def _parsetz(tzstr):\n     return DEFAULTTZPARSER.parse(tzstr)\n \n \n class ParserError(ValueError):\n     \"\"\"Error class for representing failure to parse a datetime string.\"\"\"\n     def __str__(self):\n         try:\n             return self.args[0] % self.args[1:]\n         except (TypeError, IndexError):\n             return super(ParserError, self).__str__()\n \n         def __repr__(self):\n             return \"%s(%s)\" % (self.__class__.__name__, str(self))\n \n \n class UnknownTimezoneWarning(RuntimeWarning):\n     \"\"\"Raised when the parser finds a timezone it cannot parse into a tzinfo\"\"\"\n # vim:ts=4:sw=4:et\n ", "input_code": "def parse(self, timestr, default=None, ignoretz=False, tzinfos=None, **kwargs):\n\"\"\"\nParse the date/time string into a :class:`datetime.datetime` object.\n\n:param timestr:\n    Any date/time string using the supported formats.\n\n:param default:\n    The default datetime object, if this is a datetime object and not\n    ``None``, elements specified in ``timestr`` replace elements in the\n    default object.\n\n:param ignoretz:\n    If set ``True``, time zones in parsed strings are ignored and a\n    naive :class:`datetime.datetime` object is returned.\n\n:param tzinfos:\n    Additional time zone names / aliases which may be present in the\n    string. This argument maps time zone names (and optionally offsets\n    from those time zones) to time zones. This parameter can be a\n    dictionary with timezone aliases mapping time zone names to time\n    zones or a function taking two parameters (``tzname`` and\n    ``tzoffset``) and returning a time zone.\n\n    The timezones to which the names are mapped can be an integer\n    offset from UTC in seconds or a :class:`tzinfo` object.\n\n    .. doctest::\n       :options: +NORMALIZE_WHITESPACE\n\n        >>> from dateutil.parser import parse\n        >>> from dateutil.tz import gettz\n        >>> tzinfos = {\"BRST\": -7200, \"CST\": gettz(\"America/Chicago\")}\n        >>> parse(\"2012-01-19 17:21:00 BRST\", tzinfos=tzinfos)\n        datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))\n        >>> parse(\"2012-01-19 17:21:00 CST\", tzinfos=tzinfos)\n        datetime.datetime(2012, 1, 19, 17, 21,\n                          tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))\n\n    This parameter is ignored if ``ignoretz`` is set.\n\n:param \\*\\*kwargs:\n    Keyword arguments as passed to ``_parse()``.\n\n:return:\n    Returns a :class:`datetime.datetime` object or, if the\n    ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the\n    first element being a :class:`datetime.datetime` object, the second\n    a tuple containing the fuzzy tokens.\n\n:raises ParserError:\n    Raised for invalid or unknown string format, if the provided\n    :class:`tzinfo` is not in a valid format, or if an invalid date\n    would be created.\n\n:raises TypeError:\n    Raised for non-string or character stream input.\n\n:raises OverflowError:\n    Raised if the parsed date exceeds the largest valid C integer on\n    your system.\n\"\"\"\n", "indent_space": "              ", "ground_truth": "    def parse(self, timestr, default=None,\n              ignoretz=False, tzinfos=None, **kwargs):\n        \"\"\"\n        Parse the date/time string into a :class:`datetime.datetime` object.\n\n        :param timestr:\n            Any date/time string using the supported formats.\n\n        :param default:\n            The default datetime object, if this is a datetime object and not\n            ``None``, elements specified in ``timestr`` replace elements in the\n            default object.\n\n        :param ignoretz:\n            If set ``True``, time zones in parsed strings are ignored and a\n            naive :class:`datetime.datetime` object is returned.\n\n        :param tzinfos:\n            Additional time zone names / aliases which may be present in the\n            string. This argument maps time zone names (and optionally offsets\n            from those time zones) to time zones. This parameter can be a\n            dictionary with timezone aliases mapping time zone names to time\n            zones or a function taking two parameters (``tzname`` and\n            ``tzoffset``) and returning a time zone.\n\n            The timezones to which the names are mapped can be an integer\n            offset from UTC in seconds or a :class:`tzinfo` object.\n\n            .. doctest::\n               :options: +NORMALIZE_WHITESPACE\n\n                >>> from dateutil.parser import parse\n                >>> from dateutil.tz import gettz\n                >>> tzinfos = {\"BRST\": -7200, \"CST\": gettz(\"America/Chicago\")}\n                >>> parse(\"2012-01-19 17:21:00 BRST\", tzinfos=tzinfos)\n                datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))\n                >>> parse(\"2012-01-19 17:21:00 CST\", tzinfos=tzinfos)\n                datetime.datetime(2012, 1, 19, 17, 21,\n                                  tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))\n\n            This parameter is ignored if ``ignoretz`` is set.\n\n        :param \\\\*\\\\*kwargs:\n            Keyword arguments as passed to ``_parse()``.\n\n        :return:\n            Returns a :class:`datetime.datetime` object or, if the\n            ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the\n            first element being a :class:`datetime.datetime` object, the second\n            a tuple containing the fuzzy tokens.\n\n        :raises ParserError:\n            Raised for invalid or unknown string format, if the provided\n            :class:`tzinfo` is not in a valid format, or if an invalid date\n            would be created.\n\n        :raises TypeError:\n            Raised for non-string or character stream input.\n\n        :raises OverflowError:\n            Raised if the parsed date exceeds the largest valid C integer on\n            your system.\n        \"\"\"\n\n        if default is None:\n            default = datetime.datetime.now().replace(hour=0, minute=0,\n                                                      second=0, microsecond=0)\n\n        res, skipped_tokens = self._parse(timestr, **kwargs)\n\n        if res is None:\n            raise ParserError(\"Unknown string format: %s\", timestr)\n\n        if len(res) == 0:\n            raise ParserError(\"String does not contain a date: %s\", timestr)\n\n        try:\n            ret = self._build_naive(res, default)\n        except ValueError as e:\n            six.raise_from(ParserError(e.args[0] + \": %s\", timestr), e)\n\n        if not ignoretz:\n            ret = self._build_tzaware(ret, res, tzinfos)\n\n        if kwargs.get('fuzzy_with_tokens', False):\n            return ret, skipped_tokens\n        else:\n            return ret", "signature": "def parse(self, timestr, default=None, ignoretz=False, tzinfos=None, **kwargs):", "completion_path": "dateutil/parser/_parser.py"}
{"ce_id": "62b8a4a4755ee91dce50a3d3", "namespace": "62b8a4a4755ee91dce50a3d3", "namespace_real": "dateutil.tz._common.fromutc", "real_proj_path": "pexip---os-python-dateutil/", "type": "class", "class_name": "_common", "function_name": "fromutc", "contexts_above": "from six import PY2\n\nfrom functools import wraps\n\nfrom datetime import datetime, timedelta, tzinfo\n\n\nZERO = timedelta(0)\n\n__all__ = ['tzname_in_python2', 'enfold']\n\n\ndef tzname_in_python2(namefunc):\n    \"\"\"Change unicode output into bytestrings in Python 2\n\n    tzname() API changed in Python 3. It used to return bytes, but was changed\n    to unicode strings\n    \"\"\"\n    if PY2:\n        @wraps(namefunc)\n        def adjust_encoding(*args, **kwargs):\n            name = namefunc(*args, **kwargs)\n            if name is not None:\n                name = name.encode()\n\n            return name\n\n        return adjust_encoding\n    else:\n        return namefunc\n\n\n# The following is adapted from Alexander Belopolsky's tz library\n# https://github.com/abalkin/tz\nif hasattr(datetime, 'fold'):\n    # This is the pre-python 3.6 fold situation\n    def enfold(dt, fold=1):\n        \"\"\"\n        Provides a unified interface for assigning the ``fold`` attribute to\n        datetimes both before and after the implementation of PEP-495.\n\n        :param fold:\n            The value for the ``fold`` attribute in the returned datetime. This\n            should be either 0 or 1.\n\n        :return:\n            Returns an object for which ``getattr(dt, 'fold', 0)`` returns\n            ``fold`` for all versions of Python. In versions prior to\n            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a\n            subclass of :py:class:`datetime.datetime` with the ``fold``\n            attribute added, if ``fold`` is 1.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        return dt.replace(fold=fold)\n\nelse:\n    class _DatetimeWithFold(datetime):\n        \"\"\"\n        This is a class designed to provide a PEP 495-compliant interface for\n        Python versions before 3.6. It is used only for dates in a fold, so\n        the ``fold`` attribute is fixed at ``1``.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        __slots__ = ()\n\n        def replace(self, *args, **kwargs):\n            \"\"\"\n            Return a datetime with the same attributes, except for those\n            attributes given new values by whichever keyword arguments are\n            specified. Note that tzinfo=None can be specified to create a naive\n            datetime from an aware datetime with no conversion of date and time\n            data.\n\n            This is reimplemented in ``_DatetimeWithFold`` because pypy3 will\n            return a ``datetime.datetime`` even if ``fold`` is unchanged.\n            \"\"\"\n            argnames = (\n                'year', 'month', 'day', 'hour', 'minute', 'second',\n                'microsecond', 'tzinfo'\n            )\n\n            for arg, argname in zip(args, argnames):\n                if argname in kwargs:\n                    raise TypeError('Duplicate argument: {}'.format(argname))\n\n                kwargs[argname] = arg\n\n            for argname in argnames:\n                if argname not in kwargs:\n                    kwargs[argname] = getattr(self, argname)\n\n            dt_class = self.__class__ if kwargs.get('fold', 1) else datetime\n\n            return dt_class(**kwargs)\n\n        @property\n        def fold(self):\n            return 1\n\n    def enfold(dt, fold=1):\n        \"\"\"\n        Provides a unified interface for assigning the ``fold`` attribute to\n        datetimes both before and after the implementation of PEP-495.\n\n        :param fold:\n            The value for the ``fold`` attribute in the returned datetime. This\n            should be either 0 or 1.\n\n        :return:\n            Returns an object for which ``getattr(dt, 'fold', 0)`` returns\n            ``fold`` for all versions of Python. In versions prior to\n            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a\n            subclass of :py:class:`datetime.datetime` with the ``fold``\n            attribute added, if ``fold`` is 1.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        if getattr(dt, 'fold', 0) == fold:\n            return dt\n\n        args = dt.timetuple()[:6]\n        args += (dt.microsecond, dt.tzinfo)\n\n        if fold:\n            return _DatetimeWithFold(*args)\n        else:\n            return datetime(*args)\n\n\ndef _validate_fromutc_inputs(f):\n    \"\"\"\n    The CPython version of ``fromutc`` checks that the input is a ``datetime``\n    object and that ``self`` is attached as its ``tzinfo``.\n    \"\"\"\n    @wraps(f)\n    def fromutc(self, dt):\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        return f(self, dt)\n\n    return fromutc\n\n\nclass _tzinfo(tzinfo):\n    \"\"\"\n    Base class for all ``dateutil`` ``tzinfo`` objects.\n    \"\"\"\n\n    def is_ambiguous(self, dt):\n        \"\"\"\n        Whether or not the \"wall time\" of a given datetime is ambiguous in this\n        zone.\n\n        :param dt:\n            A :py:class:`datetime.datetime`, naive or time zone aware.\n\n\n        :return:\n            Returns ``True`` if ambiguous, ``False`` otherwise.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n\n        dt = dt.replace(tzinfo=self)\n\n        wall_0 = enfold(dt, fold=0)\n        wall_1 = enfold(dt, fold=1)\n\n        same_offset = wall_0.utcoffset() == wall_1.utcoffset()\n        same_dt = wall_0.replace(tzinfo=None) == wall_1.replace(tzinfo=None)\n\n        return same_dt and not same_offset\n\n    def _fold_status(self, dt_utc, dt_wall):\n        \"\"\"\n        Determine the fold status of a \"wall\" datetime, given a representation\n        of the same datetime as a (naive) UTC datetime. This is calculated based\n        on the assumption that ``dt.utcoffset() - dt.dst()`` is constant for all\n        datetimes, and that this offset is the actual number of hours separating\n        ``dt_utc`` and ``dt_wall``.\n\n        :param dt_utc:\n            Representation of the datetime as UTC\n\n        :param dt_wall:\n            Representation of the datetime as \"wall time\". This parameter must\n            either have a `fold` attribute or have a fold-naive\n            :class:`datetime.tzinfo` attached, otherwise the calculation may\n            fail.\n        \"\"\"\n        if self.is_ambiguous(dt_wall):\n            delta_wall = dt_wall - dt_utc\n            _fold = int(delta_wall == (dt_utc.utcoffset() - dt_utc.dst()))\n        else:\n            _fold = 0\n\n        return _fold\n\n    def _fold(self, dt):\n        return getattr(dt, 'fold', 0)\n\n    def _fromutc(self, dt):\n        \"\"\"\n        Given a timezone-aware datetime in a given timezone, calculates a\n        timezone-aware datetime in a new timezone.\n\n        Since this is the one time that we *know* we have an unambiguous\n        datetime object, we take this opportunity to determine whether the\n        datetime is ambiguous and in a \"fold\" state (e.g. if it's the first\n        occurrence, chronologically, of the ambiguous datetime).\n\n        :param dt:\n            A timezone-aware :class:`datetime.datetime` object.\n        \"\"\"\n\n        # Re-implement the algorithm from Python's datetime.py\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # The original datetime.py code assumes that `dst()` defaults to\n        # zero during ambiguous times. PEP 495 inverts this presumption, so\n        # for pre-PEP 495 versions of python, we need to tweak the algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n\n        dt += delta\n        # Set fold=1 so we can default to being in the fold for\n        # ambiguous dates.\n        dtdst = enfold(dt, fold=1).dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                             \"results; cannot convert\")\n        return dt + dtdst\n\n    @_validate_fromutc_inputs", "contexts_below": "\n class tzrangebase(_tzinfo):\n     \"\"\"\n     This is an abstract base class for time zones represented by an annual\n     transition into and out of DST. Child classes should implement the following\n     methods:\n \n         * ``__init__(self, *args, **kwargs)``\n         * ``transitions(self, year)`` - this is expected to return a tuple of\n           datetimes representing the DST on and off transitions in standard\n           time.\n \n     A fully initialized ``tzrangebase`` subclass should also provide the\n     following attributes:\n         * ``hasdst``: Boolean whether or not the zone uses DST.\n         * ``_dst_offset`` / ``_std_offset``: :class:`datetime.timedelta` objects\n           representing the respective UTC offsets.\n         * ``_dst_abbr`` / ``_std_abbr``: Strings representing the timezone short\n           abbreviations in DST and STD, respectively.\n         * ``_hasdst``: Whether or not the zone has DST.\n \n     .. versionadded:: 2.6.0\n     \"\"\"\n     def __init__(self):\n         raise NotImplementedError('tzrangebase is an abstract base class')\n \n     def utcoffset(self, dt):\n         isdst = self._isdst(dt)\n \n         if isdst is None:\n             return None\n         elif isdst:\n             return self._dst_offset\n         else:\n             return self._std_offset\n \n     def dst(self, dt):\n         isdst = self._isdst(dt)\n \n         if isdst is None:\n             return None\n         elif isdst:\n             return self._dst_base_offset\n         else:\n             return ZERO\n \n     @tzname_in_python2\n     def tzname(self, dt):\n         if self._isdst(dt):\n             return self._dst_abbr\n         else:\n             return self._std_abbr\n \n     def fromutc(self, dt):\n         \"\"\" Given a datetime in UTC, return local time \"\"\"\n         if not isinstance(dt, datetime):\n             raise TypeError(\"fromutc() requires a datetime argument\")\n \n         if dt.tzinfo is not self:\n             raise ValueError(\"dt.tzinfo is not self\")\n \n         # Get transitions - if there are none, fixed offset\n         transitions = self.transitions(dt.year)\n         if transitions is None:\n             return dt + self.utcoffset(dt)\n \n         # Get the transition times in UTC\n         dston, dstoff = transitions\n \n         dston -= self._std_offset\n         dstoff -= self._std_offset\n \n         utc_transitions = (dston, dstoff)\n         dt_utc = dt.replace(tzinfo=None)\n \n         isdst = self._naive_isdst(dt_utc, utc_transitions)\n \n         if isdst:\n             dt_wall = dt + self._dst_offset\n         else:\n             dt_wall = dt + self._std_offset\n \n         _fold = int(not isdst and self.is_ambiguous(dt_wall))\n \n         return enfold(dt_wall, fold=_fold)\n \n     def is_ambiguous(self, dt):\n         \"\"\"\n         Whether or not the \"wall time\" of a given datetime is ambiguous in this\n         zone.\n \n         :param dt:\n             A :py:class:`datetime.datetime`, naive or time zone aware.\n \n \n         :return:\n             Returns ``True`` if ambiguous, ``False`` otherwise.\n \n         .. versionadded:: 2.6.0\n         \"\"\"\n         if not self.hasdst:\n             return False\n \n         start, end = self.transitions(dt.year)\n \n         dt = dt.replace(tzinfo=None)\n         return (end <= dt < end + self._dst_base_offset)\n \n     def _isdst(self, dt):\n         if not self.hasdst:\n             return False\n         elif dt is None:\n             return None\n \n         transitions = self.transitions(dt.year)\n \n         if transitions is None:\n             return False\n \n         dt = dt.replace(tzinfo=None)\n \n         isdst = self._naive_isdst(dt, transitions)\n \n         # Handle ambiguous dates\n         if not isdst and self.is_ambiguous(dt):\n             return not self._fold(dt)\n         else:\n             return isdst\n \n     def _naive_isdst(self, dt, transitions):\n         dston, dstoff = transitions\n \n         dt = dt.replace(tzinfo=None)\n \n         if dston < dstoff:\n             isdst = dston <= dt < dstoff\n         else:\n             isdst = not dstoff <= dt < dston\n \n         return isdst\n \n     @property\n     def _dst_base_offset(self):\n         return self._dst_offset - self._std_offset\n \n     __hash__ = None\n \n     def __ne__(self, other):\n         return not (self == other)\n \n     def __repr__(self):\n         return \"%s(...)\" % self.__class__.__name__\n \n     __reduce__ = object.__reduce__\n ", "input_code": "@_validate_fromutc_inputs\ndef fromutc(self, dt):\n\"\"\"\nGiven a timezone-aware datetime in a given timezone, calculates a\ntimezone-aware datetime in a new timezone.\n\nSince this is the one time that we *know* we have an unambiguous\ndatetime object, we take this opportunity to determine whether the\ndatetime is ambiguous and in a \"fold\" state (e.g. if it's the first\noccurrence, chronologically, of the ambiguous datetime).\n\n:param dt:\n    A timezone-aware :class:`datetime.datetime` object.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @_validate_fromutc_inputs\n    def fromutc(self, dt):\n        \"\"\"\n        Given a timezone-aware datetime in a given timezone, calculates a\n        timezone-aware datetime in a new timezone.\n\n        Since this is the one time that we *know* we have an unambiguous\n        datetime object, we take this opportunity to determine whether the\n        datetime is ambiguous and in a \"fold\" state (e.g. if it's the first\n        occurrence, chronologically, of the ambiguous datetime).\n\n        :param dt:\n            A timezone-aware :class:`datetime.datetime` object.\n        \"\"\"\n        dt_wall = self._fromutc(dt)\n\n        # Calculate the fold status given the two datetimes.\n        _fold = self._fold_status(dt, dt_wall)\n\n        # Set the default fold value for ambiguous dates\n        return enfold(dt_wall, fold=_fold)", "signature": "@_validate_fromutc_inputs\ndef fromutc(self, dt):", "completion_path": "dateutil/tz/_common.py"}
{"ce_id": "62b8a7b2755ee91dce50a4a7", "namespace": "62b8a7b2755ee91dce50a4a7", "namespace_real": "dateutil.utils.default_tzinfo", "real_proj_path": "pexip---os-python-dateutil/", "type": "function", "class_name": null, "function_name": "default_tzinfo", "contexts_above": "# -*- coding: utf-8 -*-\n\"\"\"\nThis module offers general convenience and utility functions for dealing with\ndatetimes.\n\n.. versionadded:: 2.7.0\n\"\"\"\nfrom __future__ import unicode_literals\n\nfrom datetime import datetime, time\n\n\ndef today(tzinfo=None):\n    \"\"\"\n    Returns a :py:class:`datetime` representing the current day at midnight\n\n    :param tzinfo:\n        The time zone to attach (also used to determine the current day).\n\n    :return:\n        A :py:class:`datetime.datetime` object representing the current day\n        at midnight.\n    \"\"\"\n\n    dt = datetime.now(tzinfo)\n    return datetime.combine(dt.date(), time(0, tzinfo=tzinfo))\n\n", "contexts_below": "\n def within_delta(dt1, dt2, delta):\n     \"\"\"\n     Useful for comparing two datetimes that may a negilible difference\n     to be considered equal.\n     \"\"\"\n     delta = abs(delta)\n     difference = dt1 - dt2\n     return -delta <= difference <= delta\n ", "input_code": "def default_tzinfo(dt, tzinfo):\n\"\"\"\nSets the ``tzinfo`` parameter on naive datetimes only\n\nThis is useful for example when you are provided a datetime that may have\neither an implicit or explicit time zone, such as when parsing a time zone\nstring.\n\n.. doctest::\n\n    >>> from dateutil.tz import tzoffset\n    >>> from dateutil.parser import parse\n    >>> from dateutil.utils import default_tzinfo\n    >>> dflt_tz = tzoffset(\"EST\", -18000)\n    >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))\n    2014-01-01 12:30:00+00:00\n    >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))\n    2014-01-01 12:30:00-05:00\n\n:param dt:\n    The datetime on which to replace the time zone\n\n:param tzinfo:\n    The :py:class:`datetime.tzinfo` subclass instance to assign to\n    ``dt`` if (and only if) it is naive.\n\n:return:\n    Returns an aware :py:class:`datetime.datetime`.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def default_tzinfo(dt, tzinfo):\n    \"\"\"\n    Sets the ``tzinfo`` parameter on naive datetimes only\n\n    This is useful for example when you are provided a datetime that may have\n    either an implicit or explicit time zone, such as when parsing a time zone\n    string.\n\n    .. doctest::\n\n        >>> from dateutil.tz import tzoffset\n        >>> from dateutil.parser import parse\n        >>> from dateutil.utils import default_tzinfo\n        >>> dflt_tz = tzoffset(\"EST\", -18000)\n        >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))\n        2014-01-01 12:30:00+00:00\n        >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))\n        2014-01-01 12:30:00-05:00\n\n    :param dt:\n        The datetime on which to replace the time zone\n\n    :param tzinfo:\n        The :py:class:`datetime.tzinfo` subclass instance to assign to\n        ``dt`` if (and only if) it is naive.\n\n    :return:\n        Returns an aware :py:class:`datetime.datetime`.\n    \"\"\"\n    if dt.tzinfo is not None:\n        return dt\n    else:\n        return dt.replace(tzinfo=tzinfo)", "signature": "def default_tzinfo(dt, tzinfo):", "completion_path": "dateutil/utils.py"}
{"ce_id": "6305f9991d275c6667163c50", "namespace": "6305f9991d275c6667163c50", "namespace_real": "src.lithium.testcases.set_cut_chars", "real_proj_path": "MozillaSecurity---lithium/", "type": "class", "class_name": "testcases", "function_name": "set_cut_chars", "contexts_above": "# coding=utf-8\n# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at https://mozilla.org/MPL/2.0/.\n\"\"\"Lithium Testcase definitions.\n\nA testcase is a file to be reduced, split in a certain way (eg. bytes, lines).\n\"\"\"\n\nimport abc\nimport argparse\nimport logging\nimport os.path\nimport re\nfrom pathlib import Path\nfrom typing import List, Optional, Pattern, Tuple, Union\n\nfrom .util import LithiumError\n\nDEFAULT = \"line\"\nLOG = logging.getLogger(__name__)\n\n\nclass Testcase(abc.ABC):\n    \"\"\"Lithium testcase base class.\"\"\"\n\n    atom: str\n    \"\"\"description of the units this testcase splits into\"\"\"\n\n    def __init__(self) -> None:\n        self.before: bytes = b\"\"\n        self.after: bytes = b\"\"\n        self.parts: List[bytes] = []\n        # bool array with same length as `parts`\n        # parts with a matchine `False` in `reducible` should\n        # not be removed by the Strategy\n        self.reducible: List[bool] = []\n        self.filename: Optional[str] = None\n        self.extension: Optional[str] = None\n\n    def __len__(self) -> int:\n        \"\"\"Length of the testcase in terms of parts to be reduced.\n\n        Returns:\n            length of parts\n        \"\"\"\n        return len(self.parts) - self.reducible.count(False)\n\n    def _slice_xlat(\n        self, start: Optional[int] = None, stop: Optional[int] = None\n    ) -> Tuple[int, int]:\n        # translate slice bounds within `[0, len(self))` (excluding non-reducible parts)\n        # to bounds within `self.parts`\n        len_self = len(self)\n\n        def _clamp(bound: Optional[int], default: int) -> int:\n            if bound is None:\n                return default\n            if bound < 0:\n                return max(len_self + bound, 0)\n            if bound > len_self:\n                return len_self\n            return bound\n\n        start = _clamp(start, 0)\n        stop = _clamp(stop, len_self)\n\n        opts = [i for i in range(len(self.parts)) if self.reducible[i]]\n        opts = [0] + opts[1:] + [len(self.parts)]\n\n        return opts[start], opts[stop]\n\n    def rmslice(self, start: int, stop: int) -> None:\n        \"\"\"Remove a slice of the testcase between `self.parts[start:stop]`, preserving\n        non-reducible parts.\n\n        Slice indices are between 0 and len(self), which may not be = len(self.parts)\n        if any parts are marked non-reducible.\n\n        Args:\n            start: Slice start index\n            stop: Slice stop index\n        \"\"\"\n        start, stop = self._slice_xlat(start, stop)\n        keep = [\n            x\n            for i, x in enumerate(self.parts[start:stop])\n            if not self.reducible[start + i]\n        ]\n        self.parts = self.parts[:start] + keep + self.parts[stop:]\n        self.reducible = (\n            self.reducible[:start] + ([False] * len(keep)) + self.reducible[stop:]\n        )\n\n    def copy(self) -> \"Testcase\":\n        \"\"\"Duplicate the current object.\n\n        Returns:\n            type(self): A new object with the same type & contents of the original.\n        \"\"\"\n        new = type(self)()\n        new.before = self.before\n        new.after = self.after\n        new.parts = self.parts[:]\n        new.reducible = self.reducible[:]\n        new.filename = self.filename\n        new.extension = self.extension\n        return new\n\n    def load(self, path: Union[Path, str]) -> None:\n        \"\"\"Load and split a testcase from disk.\n\n        Args:\n            path: Location on disk of testcase to read.\n\n        Raises:\n            LithiumError: DDBEGIN/DDEND token mismatch.\n        \"\"\"\n        self.__init__()  # type: ignore[misc]\n        self.filename = str(path)\n        self.extension = os.path.splitext(self.filename)[1]\n\n        with open(self.filename, \"rb\") as fileobj:\n            text = fileobj.read().decode(\"utf-8\", errors=\"surrogateescape\")\n\n            lines = [\n                line.encode(\"utf-8\", errors=\"surrogateescape\")\n                for line in text.splitlines(keepends=True)\n            ]\n\n        before = []\n        while lines:\n            line = lines.pop(0)\n            before.append(line)\n            if line.find(b\"DDBEGIN\") != -1:\n                self.before = b\"\".join(before)\n                del before\n                break\n            if line.find(b\"DDEND\") != -1:\n                raise LithiumError(\n                    \"The testcase (%s) has a line containing 'DDEND' \"\n                    \"without a line containing 'DDBEGIN' before it.\" % (self.filename,)\n                )\n        else:\n            # no DDBEGIN/END, `before` contains the whole testcase\n            self.split_parts(b\"\".join(before))\n            return\n\n        between = []\n        while lines:\n            line = lines.pop(0)\n            if line.find(b\"DDEND\") != -1:\n                self.after = line + b\"\".join(lines)\n                break\n\n            between.append(line)\n        else:\n            raise LithiumError(\n                \"The testcase (%s) has a line containing 'DDBEGIN' \"\n                \"but no line containing 'DDEND'.\" % (self.filename,)\n            )\n        self.split_parts(b\"\".join(between))\n\n    @staticmethod\n    def add_arguments(parser: argparse.ArgumentParser) -> None:\n        \"\"\"Add any testcase specific arguments.\n\n        Args:\n            parser: argparse object to add arguments to.\n        \"\"\"\n\n    def handle_args(self, args: argparse.Namespace) -> None:\n        \"\"\"Handle arguments after they have been parsed.\n\n        Args:\n            args: parsed argparse arguments.\n        \"\"\"\n\n    @abc.abstractmethod\n    def split_parts(self, data: bytes) -> None:\n        \"\"\"Should take testcase data and update `self.parts`.\n\n        Args:\n            data: Input read from the testcase file\n                  (between DDBEGIN/END, if present).\n        \"\"\"\n\n    def dump(self, path: Optional[Union[Path, str]] = None) -> None:\n        \"\"\"Write the testcase to the filesystem.\n\n        Args:\n            path: Output path (default: self.filename)\n        \"\"\"\n        if path is None:\n            assert self.filename is not None\n            path = self.filename\n        else:\n            path = str(path)\n        with open(path, \"wb\") as fileobj:\n            fileobj.write(self.before)\n            fileobj.writelines(self.parts)\n            fileobj.write(self.after)\n\n\nclass TestcaseLine(Testcase):\n    \"\"\"Testcase file split by lines.\"\"\"\n\n    atom = \"line\"\n    args = (\"-l\", \"--lines\")\n    arg_help = \"Treat the file as a sequence of lines.\"\n\n    def split_parts(self, data: bytes) -> None:\n        \"\"\"Take input data and add lines to `parts` to be reduced.\n\n        Args:\n            data: Input data read from the testcase file.\n        \"\"\"\n        orig = len(self.parts)\n        self.parts.extend(\n            line.encode(\"utf-8\", errors=\"surrogateescape\")\n            for line in data.decode(\"utf-8\", errors=\"surrogateescape\").splitlines(\n                keepends=True\n            )\n        )\n        added = len(self.parts) - orig\n        self.reducible.extend([True] * added)\n\n\nclass TestcaseChar(Testcase):\n    \"\"\"Testcase file split by bytes.\"\"\"\n\n    atom = \"char\"\n    args = (\"-c\", \"--char\")\n    arg_help = \"Treat the file as a sequence of bytes.\"\n\n    def load(self, path: Union[Path, str]) -> None:\n        super().load(path)\n        if (self.before or self.after) and self.parts:\n            # Move the line break at the end of the last line out of the reducible\n            # part so the \"DDEND\" line doesn't get combined with another line.\n            self.parts.pop()\n            self.reducible.pop()\n            self.after = b\"\\n\" + self.after\n\n    def split_parts(self, data: bytes) -> None:\n        orig = len(self.parts)\n        self.parts.extend(data[i : i + 1] for i in range(len(data)))\n        added = len(self.parts) - orig\n        self.reducible.extend([True] * added)\n\n\nclass TestcaseJsStr(Testcase):\n    \"\"\"Testcase type for splitting JS strings byte-wise.\n\n    Escapes are also kept together and treated as a single token for reduction.\n    ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference\n        /Global_Objects/String#Escape_notation\n    \"\"\"\n\n    atom = \"jsstr char\"\n    args = (\"-j\", \"--js\")\n    arg_help = (\n        \"Same as --char but only operate within JS strings, keeping escapes intact.\"\n    )\n\n    def split_parts(self, data: bytes) -> None:\n        instr = None\n        chars: List[int] = []\n\n        while True:\n            last = 0\n            while True:\n                if instr:\n                    match = re.match(\n                        br\"(\\\\u[0-9A-Fa-f]{4}|\\\\x[0-9A-Fa-f]{2}|\"\n                        br\"\\\\u\\{[0-9A-Fa-f]+\\}|\\\\.|.)\",\n                        data[last:],\n                        re.DOTALL,\n                    )\n                    if not match:\n                        break\n                    chars.append(len(self.parts))\n                    if match.group(0) == instr:\n                        instr = None\n                        chars.pop()\n                else:\n                    match = re.search(br\"\"\"['\"]\"\"\", data[last:])\n                    if not match:\n                        break\n                    instr = match.group(0)\n                self.parts.append(data[last : last + match.end(0)])\n                last += match.end(0)\n\n            if last != len(data):\n                self.parts.append(data[last:])\n\n            if instr is None:\n                break\n\n            # we hit EOF while looking for end of string, we need to rewind to the state\n            # before we matched on that quote character and try again.\n\n            idx = None\n            for idx in reversed(range(len(self.parts))):\n                if self.parts[idx].endswith(instr) and idx not in chars:\n                    break\n            else:\n                raise RuntimeError(\"error while backtracking from unmatched \" + instr)\n            self.parts, data = self.parts[: idx + 1], b\"\".join(self.parts[idx + 1 :])\n            chars = [c for c in chars if c < idx]\n            instr = None\n\n        # beginning and end are special because we can put them in\n        # self.before/self.after\n        if chars:\n            # merge everything before first char (pre chars[0]) into self.before\n            offset = chars[0]\n            if offset:\n                header, self.parts = b\"\".join(self.parts[:offset]), self.parts[offset:]\n                self.before = self.before + header\n                # update chars which is a list of offsets into self.parts\n                chars = [c - offset for c in chars]\n\n            # merge everything after last char (post chars[-1]) into self.after\n            offset = chars[-1] + 1\n            if offset < len(self.parts):\n                self.parts, footer = self.parts[:offset], b\"\".join(self.parts[offset:])\n                self.after = footer + self.after\n\n        # now scan for chars with a gap > 2 between, which means we can merge\n        # the goal is to take a string like this:\n        #   parts = [a x x x b c]\n        #   chars = [0       4 5]\n        # and merge it into this:\n        #   parts = [a xxx b c]\n        #   chars = [0     2 3]\n        for i in range(len(chars) - 1):\n            char1, char2 = chars[i], chars[i + 1]\n            if (char2 - char1) > 2:\n                self.parts[char1 + 1 : char2] = [\n                    b\"\".join(self.parts[char1 + 1 : char2])\n                ]\n                offset = char2 - char1 - 2  # num of parts we eliminated\n                chars[i + 1 :] = [c - offset for c in chars[i + 1 :]]\n\n        # default to everything non-reducible\n        # mark every char index as reducible, so it can be removed\n        self.reducible = [False] * len(self.parts)\n        for idx in chars:\n            self.reducible[idx] = True\n\n\nclass TestcaseSymbol(Testcase):\n    \"\"\"Testcase type for splitting a file before/after a set of delimiters.\"\"\"\n\n    atom = \"symbol-delimiter\"\n    DEFAULT_CUT_AFTER = b\"?=;{[\\n\"\n    DEFAULT_CUT_BEFORE = b\"]}:\"\n    args = (\"-s\", \"--symbol\")\n    arg_help = (\n        \"Treat the file as a sequence of strings separated by tokens. \"\n        \"The characters by which the strings are delimited are defined by \"\n        \"the --cut-before, and --cut-after options.\"\n    )\n\n    def __init__(self) -> None:\n        super().__init__()\n        self._cutter: Optional[Pattern[bytes]] = None\n        self.set_cut_chars(self.DEFAULT_CUT_BEFORE, self.DEFAULT_CUT_AFTER)\n", "contexts_below": "    def split_parts(self, data: bytes) -> None:\n         assert self._cutter is not None\n         for statement in self._cutter.finditer(data):\n             if statement.group(0):\n                 self.parts.append(statement.group(0))\n                 self.reducible.append(True)\n \n     def handle_args(self, args: argparse.Namespace) -> None:\n         self.set_cut_chars(args.cut_before, args.cut_after)\n \n     @classmethod\n     def add_arguments(cls, parser: argparse.ArgumentParser) -> None:\n         grp_add = parser.add_argument_group(\n             description=\"Additional options for the symbol-delimiter testcase type.\"\n         )\n         grp_add.add_argument(\n             \"--cut-before\",\n             default=cls.DEFAULT_CUT_BEFORE,\n             help=\"See --symbol. default: \" + cls.DEFAULT_CUT_BEFORE.decode(\"ascii\"),\n         )\n         grp_add.add_argument(\n             \"--cut-after\",\n             default=cls.DEFAULT_CUT_AFTER,\n             help=\"See --symbol. default: \" + cls.DEFAULT_CUT_AFTER.decode(\"ascii\"),\n         )\n \n \n class TestcaseAttrs(Testcase):\n     \"\"\"Testcase file split by anything that looks like an XML attribute.\"\"\"\n \n     atom = \"attribute\"\n     args = (\"-a\", \"--attrs\")\n     arg_help = \"Delimit a file by XML attributes.\"\n     TAG_PATTERN = br\"<\\s*[A-Za-z][A-Za-z-]*\"\n     ATTR_PATTERN = br\"((\\s+|^)[A-Za-z][A-Za-z0-9:-]*(=|>|\\s)|\\s*>)\"\n \n     def split_parts(self, data: bytes) -> None:\n         in_tag = False\n         while data:\n             if in_tag:\n                 # we're in what looks like an element definition `<tag ...`\n                 # look for attributes, or the end `>`\n                 match = re.match(self.ATTR_PATTERN, data)\n \n                 if match is None:\n                     # before bailing out of the tag, try consuming up to the next space\n                     # and resuming the search\n                     match = re.search(self.ATTR_PATTERN, data, flags=re.MULTILINE)\n                     if match is not None and match.group(0).strip() != b\">\":\n                         LOG.debug(\"skipping unrecognized data (%r)\", match)\n                         self.parts.append(data[: match.start(0)])\n                         self.reducible.append(False)\n                         data = data[match.start(0) :]\n                         continue\n \n                 if match is None or match.group(0).strip() == b\">\":\n                     in_tag = False\n                     LOG.debug(\n                         \"no attribute found (%r) in %r..., looking for other tags\",\n                         match,\n                         data[:20],\n                     )\n                     if match is not None:\n                         self.parts.append(data[: match.end(0)])\n                         self.reducible.append(False)\n                         data = data[match.end(0) :]\n                     continue\n \n                 # got an attribute\n                 if not match.group(0).endswith(b\"=\"):\n                     # value-less attribute, accept and continue\n                     #\n                     # only consume up to `match.end()-1` because we don't want the\n                     # `\\s` or `>` that occurred after the attribute. we need to match\n                     # that for the next attribute / element end\n                     LOG.debug(\"value-less attribute\")\n                     self.parts.append(data[: match.end(0) - 1])\n                     self.reducible.append(True)\n                     data = data[match.end(0) - 1 :]\n                     continue\n                 # attribute has a value, need to find it's end\n                 attr_parts = [match.group(0)]\n                 data = data[match.end(0) :]\n                 if data[0:1] in {b\"'\", b'\"'}:\n                     # quote delimited string value, look for the end quote\n                     attr_parts.append(data[0:1])\n                     data = data[1:]\n                     end_match = re.search(attr_parts[-1], data)\n                     incl_end = True\n                 else:\n                     end_match = re.search(br\"(\\s|>)\", data)\n                     incl_end = False\n                 if end_match is None:\n                     # EOF looking for end quote\n                     data = b\"\".join(attr_parts) + data\n                     LOG.debug(\"EOF looking for attr end quote\")\n                     in_tag = False\n                     continue\n                 end = end_match.end(0)\n                 if not incl_end:\n                     end -= 1\n                 attr_parts.append(data[:end])\n                 data = data[end:]\n                 self.parts.append(b\"\".join(attr_parts))\n                 self.reducible.append(True)\n                 LOG.debug(\"found attribute: %r\", self.parts[-1])\n             else:\n                 match = re.search(self.TAG_PATTERN, data)\n                 if match is None:\n                     break\n                 LOG.debug(\"entering tag: %s\", match.group(0))\n                 in_tag = True\n                 self.parts.append(data[: match.end(0)])\n                 self.reducible.append(False)\n                 data = data[match.end(0) :]\n         if data:\n             LOG.debug(\"remaining data: %s\", match and match.group(0))\n             self.parts.append(data)\n             self.reducible.append(False)\n ", "input_code": "def set_cut_chars(self, before: bytes, after: bytes) -> None:\n\"\"\"\nSet the bytes used to delimit slice points.\n\nArgs:\n    before: Split file before these delimiters.\n    after: Split file after these delimiters.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def set_cut_chars(self, before: bytes, after: bytes) -> None:\n        \"\"\"Set the bytes used to delimit slice points.\n\n        Args:\n            before: Split file before these delimiters.\n            after: Split file after these delimiters.\n        \"\"\"\n        self._cutter = re.compile(\n            b\"[\"\n            + before\n            + b\"]?\"\n            + b\"[^\"\n            + before\n            + after\n            + b\"]*\"\n            + b\"(?:[\"\n            + after\n            + b\"]|$|(?=[\"\n            + before\n            + b\"]))\"\n        )", "signature": "def set_cut_chars(self, before: bytes, after: bytes) -> None:", "completion_path": "src/lithium/testcases.py"}
{"ce_id": "6306292052e177c0ba469f09", "namespace": "6306292052e177c0ba469f09", "namespace_real": "federation.protocols.diaspora.protocol.identify_request", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "identify_request", "contexts_above": "import json\nimport logging\nfrom base64 import urlsafe_b64decode\nfrom typing import Callable, Tuple, Union, Dict\nfrom urllib.parse import unquote\n\nfrom Crypto.PublicKey.RSA import RsaKey\nfrom lxml import etree\n\nfrom federation.entities.mixins import BaseEntity\nfrom federation.exceptions import EncryptedMessageError, NoSenderKeyFoundError\nfrom federation.protocols.diaspora.encrypted import EncryptedPayload\nfrom federation.protocols.diaspora.magic_envelope import MagicEnvelope\nfrom federation.types import UserType, RequestType\nfrom federation.utils.diaspora import fetch_public_key\nfrom federation.utils.text import decode_if_bytes, encode_if_text, validate_handle\n\nlogger = logging.getLogger(\"federation\")\n\nPROTOCOL_NAME = \"diaspora\"\nPROTOCOL_NS = \"https://joindiaspora.com/protocol\"\nMAGIC_ENV_TAG = \"{http://salmon-protocol.org/ns/magic-env}env\"\n\n\ndef identify_id(id: str) -> bool:\n    \"\"\"\n    Try to identify if this ID is a Diaspora ID.\n    \"\"\"\n    return validate_handle(id)\n\n\n# noinspection PyBroadException", "contexts_below": "\n class Protocol:\n     \"\"\"Diaspora protocol parts\n \n     Original legacy implementation mostly taken from Pyaspora (https://github.com/lukeross/pyaspora).\n     \"\"\"\n     content = None\n     doc = None\n     get_contact_key = None\n     user = None\n     sender_handle = None\n \n     def get_json_payload_magic_envelope(self, payload):\n         \"\"\"Encrypted JSON payload\"\"\"\n         private_key = self._get_user_key()\n         return EncryptedPayload.decrypt(payload=payload, private_key=private_key)\n \n     def store_magic_envelope_doc(self, payload):\n         \"\"\"Get the Magic Envelope, trying JSON first.\"\"\"\n         try:\n             json_payload = json.loads(decode_if_bytes(payload))\n         except ValueError:\n             # XML payload\n             xml = unquote(decode_if_bytes(payload))\n             xml = xml.lstrip().encode(\"utf-8\")\n             logger.debug(\"diaspora.protocol.store_magic_envelope_doc: xml payload: %s\", xml)\n             self.doc = etree.fromstring(xml)\n         else:\n             logger.debug(\"diaspora.protocol.store_magic_envelope_doc: json payload: %s\", json_payload)\n             self.doc = self.get_json_payload_magic_envelope(json_payload)\n \n     def receive(\n             self,\n             request: RequestType,\n             user: UserType = None,\n             sender_key_fetcher: Callable[[str], str] = None,\n             skip_author_verification: bool = False) -> Tuple[str, str]:\n         \"\"\"Receive a payload.\n \n         For testing purposes, `skip_author_verification` can be passed. Authorship will not be verified.\"\"\"\n         self.user = user\n         self.get_contact_key = sender_key_fetcher\n         self.store_magic_envelope_doc(request.body)\n         # Open payload and get actual message\n         self.content = self.get_message_content()\n         # Get sender handle\n         self.sender_handle = self.get_sender()\n         # Verify the message is from who it claims to be\n         if not skip_author_verification:\n             self.verify_signature()\n         return self.sender_handle, self.content\n \n     def _get_user_key(self):\n         if not getattr(self.user, \"private_key\", None):\n             raise EncryptedMessageError(\"Cannot decrypt private message without user key\")\n         return self.user.rsa_private_key\n \n     def get_sender(self):\n         return MagicEnvelope.get_sender(self.doc)\n \n     def get_message_content(self):\n         \"\"\"\n         Given the Slap XML, extract out the payload.\n         \"\"\"\n         body = self.doc.find(\n             \".//{http://salmon-protocol.org/ns/magic-env}data\").text\n \n         body = urlsafe_b64decode(body.encode(\"ascii\"))\n \n         logger.debug(\"diaspora.protocol.get_message_content: %s\", body)\n         return body\n \n     def verify_signature(self):\n         \"\"\"\n         Verify the signed XML elements to have confidence that the claimed\n         author did actually generate this message.\n         \"\"\"\n         if self.get_contact_key:\n             sender_key = self.get_contact_key(self.sender_handle)\n         else:\n             sender_key = fetch_public_key(self.sender_handle)\n         if not sender_key:\n             raise NoSenderKeyFoundError(\"Could not find a sender contact to retrieve key\")\n         MagicEnvelope(doc=self.doc, public_key=sender_key, verify=True)\n \n     def build_send(self, entity: BaseEntity, from_user: UserType, to_user_key: RsaKey = None) -> Union[str, Dict]:\n         \"\"\"\n         Build POST data for sending out to remotes.\n \n         :param entity: The outbound ready entity for this protocol.\n         :param from_user: The user sending this payload. Must have ``private_key`` and ``id`` properties.\n         :param to_user_key: (Optional) Public key of user we're sending a private payload to.\n         :returns: dict or string depending on if private or public payload.\n         \"\"\"\n         if entity.outbound_doc is not None:\n             # Use pregenerated outbound document\n             xml = entity.outbound_doc\n         else:\n             xml = entity.to_xml()\n         me = MagicEnvelope(etree.tostring(xml), private_key=from_user.rsa_private_key, author_handle=from_user.handle)\n         rendered = me.render()\n         if to_user_key:\n             return EncryptedPayload.encrypt(rendered, to_user_key)\n         return rendered\n ", "input_code": "def identify_request(request: RequestType):\n\"\"\"\nTry to identify whether this is a Diaspora request.\n\nTry first public message. Then private message. The check if this is a legacy payload.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def identify_request(request: RequestType):\n    \"\"\"Try to identify whether this is a Diaspora request.\n\n    Try first public message. Then private message. The check if this is a legacy payload.\n    \"\"\"\n    # Private encrypted JSON payload\n    try:\n        data = json.loads(decode_if_bytes(request.body))\n        if \"encrypted_magic_envelope\" in data:\n            return True\n    except Exception:\n        pass\n    # Public XML payload\n    try:\n        xml = etree.fromstring(encode_if_text(request.body))\n        if xml.tag == MAGIC_ENV_TAG:\n            return True\n    except Exception:\n        pass\n    return False", "signature": "def identify_request(request: RequestType):", "completion_path": "federation/protocols/diaspora/protocol.py"}
{"ce_id": "6306292152e177c0ba469f0d", "namespace": "6306292152e177c0ba469f0d", "namespace_real": "federation.protocols.matrix.protocol.identify_request", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "identify_request", "contexts_above": "import json\nimport logging\nimport re\nfrom typing import Callable, Tuple, List, Dict\n\nfrom federation.entities.matrix.entities import MatrixEntityMixin\nfrom federation.types import UserType, RequestType\nfrom federation.utils.text import decode_if_bytes\n\nlogger = logging.getLogger('federation')\n\nPROTOCOL_NAME = \"activitypub\"\n\n\ndef identify_id(identifier: str) -> bool:\n    \"\"\"\n    Try to identify whether this is a Matrix identifier.\n\n    TODO fix, not entirely correct..\n    \"\"\"\n    return re.match(r'^[@#!].*:.*$', identifier, flags=re.IGNORECASE) is not None\n\n", "contexts_below": "\n class Protocol:\n     actor = None\n     get_contact_key = None\n     payload = None\n     request = None\n     user = None\n \n     # noinspection PyUnusedLocal\n     @staticmethod\n     def build_send(entity: MatrixEntityMixin, *args, **kwargs) -> List[Dict]:\n         \"\"\"\n         Build POST data for sending out to the homeserver.\n \n         :param entity: The outbound ready entity for this protocol.\n         :returns: list of payloads\n         \"\"\"\n         return entity.payloads()\n \n     def extract_actor(self):\n         # TODO TBD\n         pass\n \n     def receive(\n             self,\n             request: RequestType,\n             user: UserType = None,\n             sender_key_fetcher: Callable[[str], str] = None,\n             skip_author_verification: bool = False) -> Tuple[str, dict]:\n         \"\"\"\n         Receive a request.\n \n         Matrix appservices will deliver 1+ events at a time.\n         \"\"\"\n         # TODO TBD\n         return self.actor, self.payload\n ", "input_code": "def identify_request(request: RequestType) -> bool:\n\"\"\"\nTry to identify whether this is a Matrix request\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def identify_request(request: RequestType) -> bool:\n    \"\"\"\n    Try to identify whether this is a Matrix request\n    \"\"\"\n    # noinspection PyBroadException\n    try:\n        data = json.loads(decode_if_bytes(request.body))\n        if \"events\" in data:\n            return True\n    except Exception:\n        pass\n    return False", "signature": "def identify_request(request: RequestType) -> bool:", "completion_path": "federation/protocols/matrix/protocol.py"}
{"ce_id": "6306292252e177c0ba469f11", "namespace": "6306292252e177c0ba469f11", "namespace_real": "federation.entities.diaspora.utils.format_dt", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "format_dt", "contexts_above": "from dateutil.tz import tzlocal, tzutc\nfrom lxml import etree\n\n\ndef ensure_timezone(dt, tz=None):\n    \"\"\"\n    Make sure the datetime <dt> has a timezone set, using timezone <tz> if it\n    doesn't. <tz> defaults to the local timezone.\n    \"\"\"\n    if dt.tzinfo is None:\n        return dt.replace(tzinfo=tz or tzlocal())\n    else:\n        return dt\n\n", "contexts_below": "\n def struct_to_xml(node, struct):\n     \"\"\"\n     Turn a list of dicts into XML nodes with tag names taken from the dict\n     keys and element text taken from dict values. This is a list of dicts\n     so that the XML nodes can be ordered in the XML output.\n     \"\"\"\n     for obj in struct:\n         for k, v in obj.items():\n             etree.SubElement(node, k).text = v\n \n \n def get_full_xml_representation(entity, private_key):\n     \"\"\"Get full XML representation of an entity.\n \n     This contains the <XML><post>..</post></XML> wrapper.\n \n     Accepts either a Base entity or a Diaspora entity.\n \n     Author `private_key` must be given so that certain entities can be signed.\n     \"\"\"\n     from federation.entities.diaspora.mappers import get_outbound_entity\n     diaspora_entity = get_outbound_entity(entity, private_key)\n     xml = diaspora_entity.to_xml()\n     return \"<XML><post>%s</post></XML>\" % etree.tostring(xml).decode(\"utf-8\")\n \n \n def add_element_to_doc(doc, tag, value):\n     \"\"\"Set text value of an etree.Element of tag, appending a new element with given tag if it doesn't exist.\"\"\"\n     element = doc.find(\".//%s\" % tag)\n     if element is None:\n         element = etree.SubElement(doc, tag)\n     element.text = value\n ", "input_code": "def format_dt(dt):\n\"\"\"\nFormat a datetime in the way that D* nodes expect.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def format_dt(dt):\n    \"\"\"\n    Format a datetime in the way that D* nodes expect.\n    \"\"\"\n    return ensure_timezone(dt).astimezone(tzutc()).strftime(\n        '%Y-%m-%dT%H:%M:%SZ'\n    )", "signature": "def format_dt(dt):", "completion_path": "federation/entities/diaspora/utils.py"}
{"ce_id": "6306292352e177c0ba469f1d", "namespace": "6306292352e177c0ba469f1d", "namespace_real": "federation.utils.text.find_tags", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "find_tags", "contexts_above": "import re\nfrom typing import Set, Tuple\nfrom urllib.parse import urlparse\n\nimport bleach\nfrom bleach import callbacks\n\nILLEGAL_TAG_CHARS = \"!#$%^&*+.,@\u00a3/()=?`'\\\\{[]}~;:\\\"\u2019\u201d\u2014\\xa0\"\n\n\ndef decode_if_bytes(text):\n    try:\n        return text.decode(\"utf-8\")\n    except AttributeError:\n        return text\n\n\ndef encode_if_text(text):\n    try:\n        return bytes(text, encoding=\"utf-8\")\n    except TypeError:\n        return text\n\n", "contexts_below": "\n def get_path_from_url(url: str) -> str:\n     \"\"\"\n     Return only the path part of an URL.\n     \"\"\"\n     parsed = urlparse(url)\n     return parsed.path\n \n \n def process_text_links(text):\n     \"\"\"Process links in text, adding some attributes and linkifying textual links.\"\"\"\n     link_callbacks = [callbacks.nofollow, callbacks.target_blank]\n \n     def link_attributes(attrs, new=False):\n         \"\"\"Run standard callbacks except for internal links.\"\"\"\n         href_key = (None, \"href\")\n         if attrs.get(href_key).startswith(\"/\"):\n             return attrs\n \n         # Run the standard callbacks\n         for callback in link_callbacks:\n             attrs = callback(attrs, new)\n         return attrs\n \n     return bleach.linkify(\n         text,\n         callbacks=[link_attributes],\n         parse_email=False,\n         skip_tags=[\"code\"],\n     )\n \n \n def test_tag(tag: str) -> bool:\n     \"\"\"Test a word whether it could be accepted as a tag.\"\"\"\n     if not tag:\n         return False\n     for char in ILLEGAL_TAG_CHARS:\n         if char in tag:\n             return False\n     return True\n \n \n def validate_handle(handle):\n     \"\"\"\n     Very basic handle validation as per\n     https://diaspora.github.io/diaspora_federation/federation/types.html#diaspora-id\n     \"\"\"\n     return re.match(r\"[a-z0-9\\-_.]+@[^@/]+\\.[^@/]+\", handle, flags=re.IGNORECASE) is not None\n \n \n def with_slash(url):\n     if url.endswith('/'):\n         return url\n     return f\"{url}/\"\n ", "input_code": "def find_tags(text: str, replacer: callable=None) -> Tuple[Set, str]:\n\"\"\"\nFind tags in text.\n\nTries to ignore tags inside code blocks.\n\nOptionally, if passed a \"replacer\", will also replace the tag word with the result\nof the replacer function called with the tag word.\n\nReturns a set of tags and the original or replaced text.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def find_tags(text: str, replacer: callable = None) -> Tuple[Set, str]:\n    \"\"\"Find tags in text.\n\n    Tries to ignore tags inside code blocks.\n\n    Optionally, if passed a \"replacer\", will also replace the tag word with the result\n    of the replacer function called with the tag word.\n\n    Returns a set of tags and the original or replaced text.\n    \"\"\"\n    found_tags = set()\n    # <br> and <p> tags cause issues in us finding words - add some spacing around them\n    new_text = text.replace(\"<br>\", \" <br> \").replace(\"<p>\", \" <p> \").replace(\"</p>\", \" </p> \")\n    lines = new_text.splitlines(keepends=True)\n    final_lines = []\n    code_block = False\n    final_text = None\n    # Check each line separately\n    for line in lines:\n        final_words = []\n        if line[0:3] == \"```\":\n            code_block = not code_block\n        if line.find(\"#\") == -1 or line[0:4] == \"    \" or code_block:\n            # Just add the whole line\n            final_lines.append(line)\n            continue\n        # Check each word separately\n        words = line.split(\" \")\n        for word in words:\n            if word.find('#') > -1:\n                candidate = word.strip().strip(\"([]),.!?:*_%/\")\n                if candidate.find('<') > -1 or candidate.find('>') > -1:\n                    # Strip html\n                    candidate = bleach.clean(word, strip=True)\n                # Now split with slashes\n                candidates = candidate.split(\"/\")\n                to_replace = []\n                for candidate in candidates:\n                    if candidate.startswith(\"#\"):\n                        candidate = candidate.strip(\"#\")\n                        if test_tag(candidate.lower()):\n                            found_tags.add(candidate.lower())\n                            to_replace.append(candidate)\n                if replacer:\n                    tag_word = word\n                    try:\n                        for counter, replacee in enumerate(to_replace, 1):\n                            tag_word = tag_word.replace(\"#%s\" % replacee, replacer(replacee))\n                    except Exception:\n                        pass\n                    final_words.append(tag_word)\n                else:\n                    final_words.append(word)\n            else:\n                final_words.append(word)\n        final_lines.append(\" \".join(final_words))\n    if replacer:\n        final_text = \"\".join(final_lines)\n    if final_text:\n        final_text = final_text.replace(\" <br> \", \"<br>\").replace(\" <p> \", \"<p>\").replace(\" </p> \", \"</p>\")\n    return found_tags, final_text or text", "signature": "def find_tags(text: str, replacer: callable=None) -> Tuple[Set, str]:", "completion_path": "federation/utils/text.py"}
{"ce_id": "6306292352e177c0ba469f1e", "namespace": "6306292352e177c0ba469f1e", "namespace_real": "federation.utils.text.process_text_links", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "process_text_links", "contexts_above": "import re\nfrom typing import Set, Tuple\nfrom urllib.parse import urlparse\n\nimport bleach\nfrom bleach import callbacks\n\nILLEGAL_TAG_CHARS = \"!#$%^&*+.,@\u00a3/()=?`'\\\\{[]}~;:\\\"\u2019\u201d\u2014\\xa0\"\n\n\ndef decode_if_bytes(text):\n    try:\n        return text.decode(\"utf-8\")\n    except AttributeError:\n        return text\n\n\ndef encode_if_text(text):\n    try:\n        return bytes(text, encoding=\"utf-8\")\n    except TypeError:\n        return text\n\n\ndef find_tags(text: str, replacer: callable = None) -> Tuple[Set, str]:\n    \"\"\"Find tags in text.\n\n    Tries to ignore tags inside code blocks.\n\n    Optionally, if passed a \"replacer\", will also replace the tag word with the result\n    of the replacer function called with the tag word.\n\n    Returns a set of tags and the original or replaced text.\n    \"\"\"\n    found_tags = set()\n    # <br> and <p> tags cause issues in us finding words - add some spacing around them\n    new_text = text.replace(\"<br>\", \" <br> \").replace(\"<p>\", \" <p> \").replace(\"</p>\", \" </p> \")\n    lines = new_text.splitlines(keepends=True)\n    final_lines = []\n    code_block = False\n    final_text = None\n    # Check each line separately\n    for line in lines:\n        final_words = []\n        if line[0:3] == \"```\":\n            code_block = not code_block\n        if line.find(\"#\") == -1 or line[0:4] == \"    \" or code_block:\n            # Just add the whole line\n            final_lines.append(line)\n            continue\n        # Check each word separately\n        words = line.split(\" \")\n        for word in words:\n            if word.find('#') > -1:\n                candidate = word.strip().strip(\"([]),.!?:*_%/\")\n                if candidate.find('<') > -1 or candidate.find('>') > -1:\n                    # Strip html\n                    candidate = bleach.clean(word, strip=True)\n                # Now split with slashes\n                candidates = candidate.split(\"/\")\n                to_replace = []\n                for candidate in candidates:\n                    if candidate.startswith(\"#\"):\n                        candidate = candidate.strip(\"#\")\n                        if test_tag(candidate.lower()):\n                            found_tags.add(candidate.lower())\n                            to_replace.append(candidate)\n                if replacer:\n                    tag_word = word\n                    try:\n                        for counter, replacee in enumerate(to_replace, 1):\n                            tag_word = tag_word.replace(\"#%s\" % replacee, replacer(replacee))\n                    except Exception:\n                        pass\n                    final_words.append(tag_word)\n                else:\n                    final_words.append(word)\n            else:\n                final_words.append(word)\n        final_lines.append(\" \".join(final_words))\n    if replacer:\n        final_text = \"\".join(final_lines)\n    if final_text:\n        final_text = final_text.replace(\" <br> \", \"<br>\").replace(\" <p> \", \"<p>\").replace(\" </p> \", \"</p>\")\n    return found_tags, final_text or text\n\n\ndef get_path_from_url(url: str) -> str:\n    \"\"\"\n    Return only the path part of an URL.\n    \"\"\"\n    parsed = urlparse(url)\n    return parsed.path\n\n", "contexts_below": "\n def test_tag(tag: str) -> bool:\n     \"\"\"Test a word whether it could be accepted as a tag.\"\"\"\n     if not tag:\n         return False\n     for char in ILLEGAL_TAG_CHARS:\n         if char in tag:\n             return False\n     return True\n \n \n def validate_handle(handle):\n     \"\"\"\n     Very basic handle validation as per\n     https://diaspora.github.io/diaspora_federation/federation/types.html#diaspora-id\n     \"\"\"\n     return re.match(r\"[a-z0-9\\-_.]+@[^@/]+\\.[^@/]+\", handle, flags=re.IGNORECASE) is not None\n \n \n def with_slash(url):\n     if url.endswith('/'):\n         return url\n     return f\"{url}/\"\n ", "input_code": "def process_text_links(text):\n\"\"\"\nProcess links in text, adding some attributes and linkifying textual links.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def process_text_links(text):\n    \"\"\"Process links in text, adding some attributes and linkifying textual links.\"\"\"\n    link_callbacks = [callbacks.nofollow, callbacks.target_blank]\n\n    def link_attributes(attrs, new=False):\n        \"\"\"Run standard callbacks except for internal links.\"\"\"\n        href_key = (None, \"href\")\n        if attrs.get(href_key).startswith(\"/\"):\n            return attrs\n\n        # Run the standard callbacks\n        for callback in link_callbacks:\n            attrs = callback(attrs, new)\n        return attrs\n\n    return bleach.linkify(\n        text,\n        callbacks=[link_attributes],\n        parse_email=False,\n        skip_tags=[\"code\"],\n    )", "signature": "def process_text_links(text):", "completion_path": "federation/utils/text.py"}
{"ce_id": "6306292652e177c0ba469f34", "namespace": "6306292652e177c0ba469f34", "namespace_real": "federation.utils.network.fetch_content_type", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "fetch_content_type", "contexts_above": "import calendar\nimport datetime\nimport logging\nimport re\nimport socket\nfrom typing import Optional, Dict\nfrom urllib.parse import quote\nfrom uuid import uuid4\n\nimport requests\nfrom requests.exceptions import RequestException, HTTPError, SSLError\nfrom requests.exceptions import ConnectionError\nfrom requests.structures import CaseInsensitiveDict\n\nfrom federation import __version__\n\nlogger = logging.getLogger(\"federation\")\n\nUSER_AGENT = \"python/federation/%s\" % __version__\n\n", "contexts_below": "\n def fetch_document(url=None, host=None, path=\"/\", timeout=10, raise_ssl_errors=True, extra_headers=None, **kwargs):\n     \"\"\"Helper method to fetch remote document.\n \n     Must be given either the ``url`` or ``host``.\n     If ``url`` is given, only that will be tried without falling back to http from https.\n     If ``host`` given, `path` will be added to it. Will fall back to http on non-success status code.\n \n     :arg url: Full url to fetch, including protocol\n     :arg host: Domain part only without path or protocol\n     :arg path: Path without domain (defaults to \"/\")\n     :arg timeout: Seconds to wait for response (defaults to 10)\n     :arg raise_ssl_errors: Pass False if you want to try HTTP even for sites with SSL errors (default True)\n     :arg extra_headers: Optional extra headers dictionary to add to requests\n     :arg kwargs holds extra args passed to requests.get\n     :returns: Tuple of document (str or None), status code (int or None) and error (an exception class instance or None)\n     :raises ValueError: If neither url nor host are given as parameters\n     \"\"\"\n     if not url and not host:\n         raise ValueError(\"Need url or host.\")\n \n     logger.debug(\"fetch_document: url=%s, host=%s, path=%s, timeout=%s, raise_ssl_errors=%s\",\n                  url, host, path, timeout, raise_ssl_errors)\n     headers = {'user-agent': USER_AGENT}\n     if extra_headers:\n         headers.update(extra_headers)\n     if url:\n         # Use url since it was given\n         logger.debug(\"fetch_document: trying %s\", url)\n         try:\n             response = requests.get(url, timeout=timeout, headers=headers, **kwargs)\n             logger.debug(\"fetch_document: found document, code %s\", response.status_code)\n             response.raise_for_status()\n             return response.text, response.status_code, None\n         except RequestException as ex:\n             logger.debug(\"fetch_document: exception %s\", ex)\n             return None, None, ex\n     # Build url with some little sanitizing\n     host_string = host.replace(\"http://\", \"\").replace(\"https://\", \"\").strip(\"/\")\n     path_string = path if path.startswith(\"/\") else \"/%s\" % path\n     url = \"https://%s%s\" % (host_string, path_string)\n     logger.debug(\"fetch_document: trying %s\", url)\n     try:\n         response = requests.get(url, timeout=timeout, headers=headers)\n         logger.debug(\"fetch_document: found document, code %s\", response.status_code)\n         response.raise_for_status()\n         return response.text, response.status_code, None\n     except (HTTPError, SSLError, ConnectionError) as ex:\n         if isinstance(ex, SSLError) and raise_ssl_errors:\n             logger.debug(\"fetch_document: exception %s\", ex)\n             return None, None, ex\n         # Try http then\n         url = url.replace(\"https://\", \"http://\")\n         logger.debug(\"fetch_document: trying %s\", url)\n         try:\n             response = requests.get(url, timeout=timeout, headers=headers)\n             logger.debug(\"fetch_document: found document, code %s\", response.status_code)\n             response.raise_for_status()\n             return response.text, response.status_code, None\n         except RequestException as ex:\n             logger.debug(\"fetch_document: exception %s\", ex)\n             return None, None, ex\n     except RequestException as ex:\n         logger.debug(\"fetch_document: exception %s\", ex)\n         return None, None, ex\n \n \n def fetch_host_ip(host: str) -> str:\n     \"\"\"\n     Fetch ip by host\n     \"\"\"\n     try:\n         ip = socket.gethostbyname(host)\n     except socket.gaierror:\n         return ''\n \n     return ip\n \n \n def fetch_file(url: str, timeout: int = 30, extra_headers: Dict = None) -> str:\n     \"\"\"\n     Download a file with a temporary name and return the name.\n     \"\"\"\n     headers = {'user-agent': USER_AGENT}\n     if extra_headers:\n         headers.update(extra_headers)\n     response = requests.get(url, timeout=timeout, headers=headers, stream=True)\n     response.raise_for_status()\n     name = f\"/tmp/{str(uuid4())}\"\n     with open(name, \"wb\") as f:\n         for chunk in response.iter_content(chunk_size=8192):\n             f.write(chunk)\n     return name\n \n \n def parse_http_date(date):\n     \"\"\"\n     Parse a date format as specified by HTTP RFC7231 section 7.1.1.1.\n \n     The three formats allowed by the RFC are accepted, even if only the first\n     one is still in widespread use.\n \n     Return an integer expressed in seconds since the epoch, in UTC.\n \n     Implementation copied from Django.\n     https://github.com/django/django/blob/master/django/utils/http.py#L157\n     License: BSD 3-clause\n     \"\"\"\n     MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec'.split()\n     __D = r'(?P<day>\\d{2})'\n     __D2 = r'(?P<day>[ \\d]\\d)'\n     __M = r'(?P<mon>\\w{3})'\n     __Y = r'(?P<year>\\d{4})'\n     __Y2 = r'(?P<year>\\d{2})'\n     __T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'\n     RFC1123_DATE = re.compile(r'^\\w{3}, %s %s %s %s GMT$' % (__D, __M, __Y, __T))\n     RFC850_DATE = re.compile(r'^\\w{6,9}, %s-%s-%s %s GMT$' % (__D, __M, __Y2, __T))\n     ASCTIME_DATE = re.compile(r'^\\w{3} %s %s %s %s$' % (__M, __D2, __T, __Y))\n     # email.utils.parsedate() does the job for RFC1123 dates; unfortunately\n     # RFC7231 makes it mandatory to support RFC850 dates too. So we roll\n     # our own RFC-compliant parsing.\n     for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:\n         m = regex.match(date)\n         if m is not None:\n             break\n     else:\n         raise ValueError(\"%r is not in a valid HTTP date format\" % date)\n     try:\n         year = int(m.group('year'))\n         if year < 100:\n             if year < 70:\n                 year += 2000\n             else:\n                 year += 1900\n         month = MONTHS.index(m.group('mon').lower()) + 1\n         day = int(m.group('day'))\n         hour = int(m.group('hour'))\n         min = int(m.group('min'))\n         sec = int(m.group('sec'))\n         result = datetime.datetime(year, month, day, hour, min, sec)\n         return calendar.timegm(result.utctimetuple())\n     except Exception as exc:\n         raise ValueError(\"%r is not a valid date\" % date) from exc\n \n \n def send_document(url, data, timeout=10, method=\"post\", *args, **kwargs):\n     \"\"\"Helper method to send a document via POST.\n \n     Additional ``*args`` and ``**kwargs`` will be passed on to ``requests.post``.\n \n     :arg url: Full url to send to, including protocol\n     :arg data: Dictionary (will be form-encoded), bytes, or file-like object to send in the body\n     :arg timeout: Seconds to wait for response (defaults to 10)\n     :arg method: Method to use, defaults to post\n     :returns: Tuple of status code (int or None) and error (exception class instance or None)\n     \"\"\"\n     logger.debug(\"send_document: url=%s, data=%s, timeout=%s, method=%s\", url, data, timeout, method)\n     if not method:\n         method = \"post\"\n     headers = CaseInsensitiveDict({\n         'User-Agent': USER_AGENT,\n     })\n     if \"headers\" in kwargs:\n         # Update from kwargs\n         headers.update(kwargs.get(\"headers\"))\n     kwargs.update({\n         \"data\": data, \"timeout\": timeout, \"headers\": headers\n     })\n     request_func = getattr(requests, method)\n     try:\n         response = request_func(url, *args, **kwargs)\n         logger.debug(\"send_document: response status code %s\", response.status_code)\n         return response.status_code, None\n     # TODO support rate limit 429 code\n     except RequestException as ex:\n         logger.debug(\"send_document: exception %s\", ex)\n         return None, ex\n \n \n def try_retrieve_webfinger_document(handle: str) -> Optional[str]:\n     \"\"\"\n     Try to retrieve an RFC7033 webfinger document. Does not raise if it fails.\n     \"\"\"\n     try:\n         host = handle.split(\"@\")[1]\n     except AttributeError:\n         logger.warning(\"retrieve_webfinger_document: invalid handle given: %s\", handle)\n         return None\n     document, code, exception = fetch_document(\n         host=host, path=\"/.well-known/webfinger?resource=acct:%s\" % quote(handle),\n     )\n     if exception:\n         logger.debug(\"retrieve_webfinger_document: failed to fetch webfinger document: %s, %s\", code, exception)\n     return document\n ", "input_code": "def fetch_content_type(url: str) -> Optional[str]:\n\"\"\"\nFetch the HEAD of the remote url to determine the content type.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def fetch_content_type(url: str) -> Optional[str]:\n    \"\"\"\n    Fetch the HEAD of the remote url to determine the content type.\n    \"\"\"\n    try:\n        response = requests.head(url, headers={'user-agent': USER_AGENT}, timeout=10)\n    except RequestException as ex:\n        logger.warning(\"fetch_content_type - %s when fetching url %s\", ex, url)\n    else:\n        return response.headers.get('Content-Type')", "signature": "def fetch_content_type(url: str) -> Optional[str]:", "completion_path": "federation/utils/network.py"}
{"ce_id": "6306292a52e177c0ba469f41", "namespace": "6306292a52e177c0ba469f41", "namespace_real": "federation.utils.text.test_tag", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "test_tag", "contexts_above": "import re\nfrom typing import Set, Tuple\nfrom urllib.parse import urlparse\n\nimport bleach\nfrom bleach import callbacks\n\nILLEGAL_TAG_CHARS = \"!#$%^&*+.,@\u00a3/()=?`'\\\\{[]}~;:\\\"\u2019\u201d\u2014\\xa0\"\n\n\ndef decode_if_bytes(text):\n    try:\n        return text.decode(\"utf-8\")\n    except AttributeError:\n        return text\n\n\ndef encode_if_text(text):\n    try:\n        return bytes(text, encoding=\"utf-8\")\n    except TypeError:\n        return text\n\n\ndef find_tags(text: str, replacer: callable = None) -> Tuple[Set, str]:\n    \"\"\"Find tags in text.\n\n    Tries to ignore tags inside code blocks.\n\n    Optionally, if passed a \"replacer\", will also replace the tag word with the result\n    of the replacer function called with the tag word.\n\n    Returns a set of tags and the original or replaced text.\n    \"\"\"\n    found_tags = set()\n    # <br> and <p> tags cause issues in us finding words - add some spacing around them\n    new_text = text.replace(\"<br>\", \" <br> \").replace(\"<p>\", \" <p> \").replace(\"</p>\", \" </p> \")\n    lines = new_text.splitlines(keepends=True)\n    final_lines = []\n    code_block = False\n    final_text = None\n    # Check each line separately\n    for line in lines:\n        final_words = []\n        if line[0:3] == \"```\":\n            code_block = not code_block\n        if line.find(\"#\") == -1 or line[0:4] == \"    \" or code_block:\n            # Just add the whole line\n            final_lines.append(line)\n            continue\n        # Check each word separately\n        words = line.split(\" \")\n        for word in words:\n            if word.find('#') > -1:\n                candidate = word.strip().strip(\"([]),.!?:*_%/\")\n                if candidate.find('<') > -1 or candidate.find('>') > -1:\n                    # Strip html\n                    candidate = bleach.clean(word, strip=True)\n                # Now split with slashes\n                candidates = candidate.split(\"/\")\n                to_replace = []\n                for candidate in candidates:\n                    if candidate.startswith(\"#\"):\n                        candidate = candidate.strip(\"#\")\n                        if test_tag(candidate.lower()):\n                            found_tags.add(candidate.lower())\n                            to_replace.append(candidate)\n                if replacer:\n                    tag_word = word\n                    try:\n                        for counter, replacee in enumerate(to_replace, 1):\n                            tag_word = tag_word.replace(\"#%s\" % replacee, replacer(replacee))\n                    except Exception:\n                        pass\n                    final_words.append(tag_word)\n                else:\n                    final_words.append(word)\n            else:\n                final_words.append(word)\n        final_lines.append(\" \".join(final_words))\n    if replacer:\n        final_text = \"\".join(final_lines)\n    if final_text:\n        final_text = final_text.replace(\" <br> \", \"<br>\").replace(\" <p> \", \"<p>\").replace(\" </p> \", \"</p>\")\n    return found_tags, final_text or text\n\n\ndef get_path_from_url(url: str) -> str:\n    \"\"\"\n    Return only the path part of an URL.\n    \"\"\"\n    parsed = urlparse(url)\n    return parsed.path\n\n\ndef process_text_links(text):\n    \"\"\"Process links in text, adding some attributes and linkifying textual links.\"\"\"\n    link_callbacks = [callbacks.nofollow, callbacks.target_blank]\n\n    def link_attributes(attrs, new=False):\n        \"\"\"Run standard callbacks except for internal links.\"\"\"\n        href_key = (None, \"href\")\n        if attrs.get(href_key).startswith(\"/\"):\n            return attrs\n\n        # Run the standard callbacks\n        for callback in link_callbacks:\n            attrs = callback(attrs, new)\n        return attrs\n\n    return bleach.linkify(\n        text,\n        callbacks=[link_attributes],\n        parse_email=False,\n        skip_tags=[\"code\"],\n    )\n\n", "contexts_below": "\n def validate_handle(handle):\n     \"\"\"\n     Very basic handle validation as per\n     https://diaspora.github.io/diaspora_federation/federation/types.html#diaspora-id\n     \"\"\"\n     return re.match(r\"[a-z0-9\\-_.]+@[^@/]+\\.[^@/]+\", handle, flags=re.IGNORECASE) is not None\n \n \n def with_slash(url):\n     if url.endswith('/'):\n         return url\n     return f\"{url}/\"\n ", "input_code": "def test_tag(tag: str) -> bool:\n\"\"\"\nTest a word whether it could be accepted as a tag.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def test_tag(tag: str) -> bool:\n    \"\"\"Test a word whether it could be accepted as a tag.\"\"\"\n    if not tag:\n        return False\n    for char in ILLEGAL_TAG_CHARS:\n        if char in tag:\n            return False\n    return True", "signature": "def test_tag(tag: str) -> bool:", "completion_path": "federation/utils/text.py"}
{"ce_id": "6306298b52e177c0ba469fdc", "namespace": "6306298b52e177c0ba469fdc", "namespace_real": "federation.entities.diaspora.mappers.xml_children_as_dict", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "xml_children_as_dict", "contexts_above": "import logging\nfrom datetime import datetime\nfrom typing import Callable, List\n\n# noinspection PyPackageRequirements\nfrom Crypto.PublicKey.RSA import RsaKey\nfrom lxml import etree\n\nfrom federation.entities.base import Comment, Follow, Post, Profile, Reaction, Retraction, Share\nfrom federation.entities.diaspora.entities import (\n    DiasporaComment, DiasporaContact, DiasporaLike, DiasporaPost,\n    DiasporaProfile, DiasporaReshare, DiasporaRetraction,\n    DiasporaImage)\nfrom federation.entities.diaspora.mixins import DiasporaRelayableMixin\nfrom federation.entities.mixins import BaseEntity\nfrom federation.protocols.diaspora.signatures import get_element_child_info\nfrom federation.types import UserType, ReceiverVariant\nfrom federation.utils.diaspora import retrieve_and_parse_profile\n\nlogger = logging.getLogger(\"federation\")\n\nMAPPINGS = {\n    \"status_message\": DiasporaPost,\n    \"comment\": DiasporaComment,\n    \"photo\": DiasporaImage,\n    \"like\": DiasporaLike,\n    \"profile\": DiasporaProfile,\n    \"retraction\": DiasporaRetraction,\n    \"contact\": DiasporaContact,\n    \"reshare\": DiasporaReshare,\n}\n\nTAGS = [\n    # Order is important. Any top level tags should be before possibly child tags\n    \"reshare\", \"status_message\", \"comment\", \"like\", \"request\", \"profile\", \"retraction\", \"photo\", \"contact\",\n]\n\nBOOLEAN_KEYS = (\n    \"public\",\n    \"nsfw\",\n    \"following\",\n    \"sharing\",\n)\n\nDATETIME_KEYS = (\n    \"created_at\",\n)\n\nINTEGER_KEYS = (\n    \"height\",\n    \"width\",\n)\n\n", "contexts_below": "\n def check_sender_and_entity_handle_match(sender_handle, entity_handle):\n     \"\"\"Ensure that sender and entity handles match.\n \n     Basically we've already verified the sender is who they say when receiving the payload. However, the sender might\n     be trying to set another author in the payload itself, since Diaspora has the sender in both the payload headers\n     AND the object. We must ensure they're the same.\n     \"\"\"\n     if sender_handle != entity_handle:\n         logger.warning(\"sender_handle and entity_handle don't match, aborting! sender_handle: %s, entity_handle: %s\",\n                        sender_handle, entity_handle)\n         return False\n     return True\n \n \n def element_to_objects(\n         element: etree.ElementTree, sender: str, sender_key_fetcher: Callable[[str], str] = None, user: UserType = None,\n ) -> List:\n     \"\"\"Transform an Element to a list of entities recursively.\n \n     Possible child entities are added to each entity ``_children`` list.\n \n     Optional parameter ``sender_key_fetcher`` can be a function to fetch sender public key.\n     If not given, key will always be fetched over the network. The function should take sender as the only parameter.\n     \"\"\"\n     entities = []\n     cls = MAPPINGS.get(element.tag)\n     if not cls:\n         return []\n \n     attrs = xml_children_as_dict(element)\n     transformed = transform_attributes(attrs, cls)\n     if hasattr(cls, \"fill_extra_attributes\"):\n         transformed = cls.fill_extra_attributes(transformed)\n     entity = cls(**transformed)\n     # Add protocol name\n     entity._source_protocol = \"diaspora\"\n     # Save element object to entity for possible later use\n     entity._source_object = etree.tostring(element)\n \n     # Save receivers on the entity\n     if user:\n         # Single receiver\n         entity._receivers = [UserType(id=user.id, receiver_variant=ReceiverVariant.ACTOR)]\n     else:\n         # Followers\n         entity._receivers = [UserType(id=sender, receiver_variant=ReceiverVariant.FOLLOWERS)]\n \n     if issubclass(cls, DiasporaRelayableMixin):\n         # If relayable, fetch sender key for validation\n         entity._xml_tags = get_element_child_info(element, \"tag\")\n         if sender_key_fetcher:\n             entity._sender_key = sender_key_fetcher(entity.actor_id)\n         else:\n             profile = retrieve_and_parse_profile(entity.handle)\n             if profile:\n                 entity._sender_key = profile.public_key\n     else:\n         # If not relayable, ensure handles match\n         if not check_sender_and_entity_handle_match(sender, entity.handle):\n             return []\n     try:\n         entity.validate()\n     except ValueError as ex:\n         logger.error(\"Failed to validate entity %s: %s\", entity, ex, extra={\n             \"attrs\": attrs,\n             \"transformed\": transformed,\n         })\n         return []\n \n     # Extract mentions\n     if hasattr(entity, \"extract_mentions\"):\n         entity.extract_mentions()\n \n     # Do child elements\n     for child in element:\n         # noinspection PyProtectedMember\n         entity._children.extend(element_to_objects(child, sender, user=user))\n     # Add to entities list\n     entities.append(entity)\n     return entities\n \n \n def message_to_objects(\n         message: str, sender: str, sender_key_fetcher:Callable[[str], str]=None, user: UserType =None,\n ) -> List:\n     \"\"\"Takes in a message extracted by a protocol and maps it to entities.\n \n     :param message: XML payload\n     :type message: str\n     :param sender: Payload sender id\n     :type message: str\n     :param sender_key_fetcher: Function to fetch sender public key. If not given, key will always be fetched\n         over network. The function should take sender handle as the only parameter.\n     :param user: Optional receiving user object. If given, should have a `handle`.\n     :returns: list of entities\n     \"\"\"\n     doc = etree.fromstring(message)\n     if doc.tag in TAGS:\n         return element_to_objects(doc, sender, sender_key_fetcher, user)\n     return []\n \n \n def transform_attributes(attrs, cls):\n     \"\"\"Transform some attribute keys.\n \n     :param attrs: Properties from the XML\n     :type attrs: dict\n     :param cls: Class of the entity\n     :type cls: class\n     \"\"\"\n     transformed = {}\n     for key, value in attrs.items():\n         if value is None:\n             value = \"\"\n         if key == \"text\":\n             transformed[\"raw_content\"] = value\n         elif key == \"activitypub_id\":\n             transformed[\"id\"] = value\n         elif key == \"author\":\n             if cls == DiasporaProfile:\n                 # Diaspora Profile XML message contains no GUID. We need the guid. Fetch it.\n                 profile = retrieve_and_parse_profile(value)\n                 transformed['id'] = value\n                 transformed[\"guid\"] = profile.guid\n             else:\n                 transformed[\"actor_id\"] = value\n             transformed[\"handle\"] = value\n         elif key == 'guid':\n             if cls != DiasporaProfile:\n                 transformed[\"id\"] = value\n                 transformed[\"guid\"] = value\n         elif key in (\"root_author\", \"recipient\"):\n             transformed[\"target_id\"] = value\n             transformed[\"target_handle\"] = value\n         elif key in (\"target_guid\", \"root_guid\", \"parent_guid\"):\n             transformed[\"target_id\"] = value\n             transformed[\"target_guid\"] = value\n         elif key == \"thread_parent_guid\":\n             transformed[\"root_target_id\"] = value\n             transformed[\"root_target_guid\"] = value\n         elif key in (\"first_name\", \"last_name\"):\n             values = [attrs.get('first_name'), attrs.get('last_name')]\n             values = [v for v in values if v]\n             transformed[\"name\"] = \" \".join(values)\n         elif key == \"image_url\":\n             if \"image_urls\" not in transformed:\n                 transformed[\"image_urls\"] = {}\n             transformed[\"image_urls\"][\"large\"] = value\n         elif key == \"image_url_small\":\n             if \"image_urls\" not in transformed:\n                 transformed[\"image_urls\"] = {}\n             transformed[\"image_urls\"][\"small\"] = value\n         elif key == \"image_url_medium\":\n             if \"image_urls\" not in transformed:\n                 transformed[\"image_urls\"] = {}\n             transformed[\"image_urls\"][\"medium\"] = value\n         elif key == \"tag_string\":\n             if value:\n                 transformed[\"tag_list\"] = value.replace(\"#\", \"\").split(\" \")\n         elif key == \"bio\":\n             transformed[\"raw_content\"] = value\n         elif key == \"searchable\":\n             transformed[\"public\"] = True if value == \"true\" else False\n         elif key in [\"target_type\"] and cls == DiasporaRetraction:\n             transformed[\"entity_type\"] = DiasporaRetraction.entity_type_from_remote(value)\n         elif key == \"remote_photo_path\":\n             transformed[\"url\"] = f\"{value}{attrs.get('remote_photo_name')}\"\n         elif key == \"author_signature\":\n             transformed[\"signature\"] = value\n         elif key in BOOLEAN_KEYS:\n             transformed[key] = True if value == \"true\" else False\n         elif key in DATETIME_KEYS:\n             transformed[key] = datetime.strptime(value, \"%Y-%m-%dT%H:%M:%SZ\")\n         elif key in INTEGER_KEYS:\n             transformed[key] = int(value)\n         else:\n             transformed[key] = value\n     return transformed\n \n \n def get_outbound_entity(entity: BaseEntity, private_key: RsaKey):\n     \"\"\"Get the correct outbound entity for this protocol.\n \n     We might have to look at entity values to decide the correct outbound entity.\n     If we cannot find one, we should raise as conversion cannot be guaranteed to the given protocol.\n \n     Private key of author is needed to be passed for signing the outbound entity.\n \n     :arg entity: An entity instance which can be of a base or protocol entity class.\n     :arg private_key: Private key of sender as an RSA object\n     :returns: Protocol specific entity class instance.\n     :raises ValueError: If conversion cannot be done.\n     \"\"\"\n     if getattr(entity, \"outbound_doc\", None):\n         # If the entity already has an outbound doc, just return the entity as is\n         return entity\n     outbound = None\n     cls = entity.__class__\n     if cls in [DiasporaPost, DiasporaImage, DiasporaComment, DiasporaLike, DiasporaProfile, DiasporaRetraction,\n                DiasporaContact, DiasporaReshare]:\n         # Already fine\n         outbound = entity\n     elif cls == Post:\n         outbound = DiasporaPost.from_base(entity)\n     elif cls == Comment:\n         outbound = DiasporaComment.from_base(entity)\n     elif cls == Reaction:\n         if entity.reaction == \"like\":\n             outbound = DiasporaLike.from_base(entity)\n     elif cls == Follow:\n         outbound = DiasporaContact.from_base(entity)\n     elif cls == Profile:\n         outbound = DiasporaProfile.from_base(entity)\n     elif cls == Retraction:\n         outbound = DiasporaRetraction.from_base(entity)\n     elif cls == Share:\n         outbound = DiasporaReshare.from_base(entity)\n     if not outbound:\n         raise ValueError(\"Don't know how to convert this base entity to Diaspora protocol entities.\")\n     if isinstance(outbound, DiasporaRelayableMixin) and not outbound.signature:\n         # Sign by author if not signed yet. We don't want to overwrite any existing signature in the case\n         # that this is being sent by the parent author\n         outbound.sign(private_key)\n         # If missing, also add same signature to `parent_author_signature`. This is required at the moment\n         # in all situations but is apparently being removed.\n         # TODO: remove this once Diaspora removes the extra signature\n         outbound.parent_signature = outbound.signature\n     # Validate the entity\n     outbound.validate(direction=\"outbound\")\n     return outbound\n ", "input_code": "def xml_children_as_dict(node):\n\"\"\"\nTurn the children of node <xml> into a dict, keyed by tag name.\n\nThis is only a shallow conversation - child nodes are not recursively processed.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def xml_children_as_dict(node):\n    \"\"\"Turn the children of node <xml> into a dict, keyed by tag name.\n\n    This is only a shallow conversation - child nodes are not recursively processed.\n    \"\"\"\n    return dict((e.tag, e.text) for e in node)", "signature": "def xml_children_as_dict(node):", "completion_path": "federation/entities/diaspora/mappers.py"}
{"ce_id": "6306299052e177c0ba469fe8", "namespace": "6306299052e177c0ba469fe8", "namespace_real": "federation.entities.diaspora.mappers.check_sender_and_entity_handle_match", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "check_sender_and_entity_handle_match", "contexts_above": "import logging\nfrom datetime import datetime\nfrom typing import Callable, List\n\n# noinspection PyPackageRequirements\nfrom Crypto.PublicKey.RSA import RsaKey\nfrom lxml import etree\n\nfrom federation.entities.base import Comment, Follow, Post, Profile, Reaction, Retraction, Share\nfrom federation.entities.diaspora.entities import (\n    DiasporaComment, DiasporaContact, DiasporaLike, DiasporaPost,\n    DiasporaProfile, DiasporaReshare, DiasporaRetraction,\n    DiasporaImage)\nfrom federation.entities.diaspora.mixins import DiasporaRelayableMixin\nfrom federation.entities.mixins import BaseEntity\nfrom federation.protocols.diaspora.signatures import get_element_child_info\nfrom federation.types import UserType, ReceiverVariant\nfrom federation.utils.diaspora import retrieve_and_parse_profile\n\nlogger = logging.getLogger(\"federation\")\n\nMAPPINGS = {\n    \"status_message\": DiasporaPost,\n    \"comment\": DiasporaComment,\n    \"photo\": DiasporaImage,\n    \"like\": DiasporaLike,\n    \"profile\": DiasporaProfile,\n    \"retraction\": DiasporaRetraction,\n    \"contact\": DiasporaContact,\n    \"reshare\": DiasporaReshare,\n}\n\nTAGS = [\n    # Order is important. Any top level tags should be before possibly child tags\n    \"reshare\", \"status_message\", \"comment\", \"like\", \"request\", \"profile\", \"retraction\", \"photo\", \"contact\",\n]\n\nBOOLEAN_KEYS = (\n    \"public\",\n    \"nsfw\",\n    \"following\",\n    \"sharing\",\n)\n\nDATETIME_KEYS = (\n    \"created_at\",\n)\n\nINTEGER_KEYS = (\n    \"height\",\n    \"width\",\n)\n\n\ndef xml_children_as_dict(node):\n    \"\"\"Turn the children of node <xml> into a dict, keyed by tag name.\n\n    This is only a shallow conversation - child nodes are not recursively processed.\n    \"\"\"\n    return dict((e.tag, e.text) for e in node)\n\n", "contexts_below": "\n def element_to_objects(\n         element: etree.ElementTree, sender: str, sender_key_fetcher: Callable[[str], str] = None, user: UserType = None,\n ) -> List:\n     \"\"\"Transform an Element to a list of entities recursively.\n \n     Possible child entities are added to each entity ``_children`` list.\n \n     Optional parameter ``sender_key_fetcher`` can be a function to fetch sender public key.\n     If not given, key will always be fetched over the network. The function should take sender as the only parameter.\n     \"\"\"\n     entities = []\n     cls = MAPPINGS.get(element.tag)\n     if not cls:\n         return []\n \n     attrs = xml_children_as_dict(element)\n     transformed = transform_attributes(attrs, cls)\n     if hasattr(cls, \"fill_extra_attributes\"):\n         transformed = cls.fill_extra_attributes(transformed)\n     entity = cls(**transformed)\n     # Add protocol name\n     entity._source_protocol = \"diaspora\"\n     # Save element object to entity for possible later use\n     entity._source_object = etree.tostring(element)\n \n     # Save receivers on the entity\n     if user:\n         # Single receiver\n         entity._receivers = [UserType(id=user.id, receiver_variant=ReceiverVariant.ACTOR)]\n     else:\n         # Followers\n         entity._receivers = [UserType(id=sender, receiver_variant=ReceiverVariant.FOLLOWERS)]\n \n     if issubclass(cls, DiasporaRelayableMixin):\n         # If relayable, fetch sender key for validation\n         entity._xml_tags = get_element_child_info(element, \"tag\")\n         if sender_key_fetcher:\n             entity._sender_key = sender_key_fetcher(entity.actor_id)\n         else:\n             profile = retrieve_and_parse_profile(entity.handle)\n             if profile:\n                 entity._sender_key = profile.public_key\n     else:\n         # If not relayable, ensure handles match\n         if not check_sender_and_entity_handle_match(sender, entity.handle):\n             return []\n     try:\n         entity.validate()\n     except ValueError as ex:\n         logger.error(\"Failed to validate entity %s: %s\", entity, ex, extra={\n             \"attrs\": attrs,\n             \"transformed\": transformed,\n         })\n         return []\n \n     # Extract mentions\n     if hasattr(entity, \"extract_mentions\"):\n         entity.extract_mentions()\n \n     # Do child elements\n     for child in element:\n         # noinspection PyProtectedMember\n         entity._children.extend(element_to_objects(child, sender, user=user))\n     # Add to entities list\n     entities.append(entity)\n     return entities\n \n \n def message_to_objects(\n         message: str, sender: str, sender_key_fetcher:Callable[[str], str]=None, user: UserType =None,\n ) -> List:\n     \"\"\"Takes in a message extracted by a protocol and maps it to entities.\n \n     :param message: XML payload\n     :type message: str\n     :param sender: Payload sender id\n     :type message: str\n     :param sender_key_fetcher: Function to fetch sender public key. If not given, key will always be fetched\n         over network. The function should take sender handle as the only parameter.\n     :param user: Optional receiving user object. If given, should have a `handle`.\n     :returns: list of entities\n     \"\"\"\n     doc = etree.fromstring(message)\n     if doc.tag in TAGS:\n         return element_to_objects(doc, sender, sender_key_fetcher, user)\n     return []\n \n \n def transform_attributes(attrs, cls):\n     \"\"\"Transform some attribute keys.\n \n     :param attrs: Properties from the XML\n     :type attrs: dict\n     :param cls: Class of the entity\n     :type cls: class\n     \"\"\"\n     transformed = {}\n     for key, value in attrs.items():\n         if value is None:\n             value = \"\"\n         if key == \"text\":\n             transformed[\"raw_content\"] = value\n         elif key == \"activitypub_id\":\n             transformed[\"id\"] = value\n         elif key == \"author\":\n             if cls == DiasporaProfile:\n                 # Diaspora Profile XML message contains no GUID. We need the guid. Fetch it.\n                 profile = retrieve_and_parse_profile(value)\n                 transformed['id'] = value\n                 transformed[\"guid\"] = profile.guid\n             else:\n                 transformed[\"actor_id\"] = value\n             transformed[\"handle\"] = value\n         elif key == 'guid':\n             if cls != DiasporaProfile:\n                 transformed[\"id\"] = value\n                 transformed[\"guid\"] = value\n         elif key in (\"root_author\", \"recipient\"):\n             transformed[\"target_id\"] = value\n             transformed[\"target_handle\"] = value\n         elif key in (\"target_guid\", \"root_guid\", \"parent_guid\"):\n             transformed[\"target_id\"] = value\n             transformed[\"target_guid\"] = value\n         elif key == \"thread_parent_guid\":\n             transformed[\"root_target_id\"] = value\n             transformed[\"root_target_guid\"] = value\n         elif key in (\"first_name\", \"last_name\"):\n             values = [attrs.get('first_name'), attrs.get('last_name')]\n             values = [v for v in values if v]\n             transformed[\"name\"] = \" \".join(values)\n         elif key == \"image_url\":\n             if \"image_urls\" not in transformed:\n                 transformed[\"image_urls\"] = {}\n             transformed[\"image_urls\"][\"large\"] = value\n         elif key == \"image_url_small\":\n             if \"image_urls\" not in transformed:\n                 transformed[\"image_urls\"] = {}\n             transformed[\"image_urls\"][\"small\"] = value\n         elif key == \"image_url_medium\":\n             if \"image_urls\" not in transformed:\n                 transformed[\"image_urls\"] = {}\n             transformed[\"image_urls\"][\"medium\"] = value\n         elif key == \"tag_string\":\n             if value:\n                 transformed[\"tag_list\"] = value.replace(\"#\", \"\").split(\" \")\n         elif key == \"bio\":\n             transformed[\"raw_content\"] = value\n         elif key == \"searchable\":\n             transformed[\"public\"] = True if value == \"true\" else False\n         elif key in [\"target_type\"] and cls == DiasporaRetraction:\n             transformed[\"entity_type\"] = DiasporaRetraction.entity_type_from_remote(value)\n         elif key == \"remote_photo_path\":\n             transformed[\"url\"] = f\"{value}{attrs.get('remote_photo_name')}\"\n         elif key == \"author_signature\":\n             transformed[\"signature\"] = value\n         elif key in BOOLEAN_KEYS:\n             transformed[key] = True if value == \"true\" else False\n         elif key in DATETIME_KEYS:\n             transformed[key] = datetime.strptime(value, \"%Y-%m-%dT%H:%M:%SZ\")\n         elif key in INTEGER_KEYS:\n             transformed[key] = int(value)\n         else:\n             transformed[key] = value\n     return transformed\n \n \n def get_outbound_entity(entity: BaseEntity, private_key: RsaKey):\n     \"\"\"Get the correct outbound entity for this protocol.\n \n     We might have to look at entity values to decide the correct outbound entity.\n     If we cannot find one, we should raise as conversion cannot be guaranteed to the given protocol.\n \n     Private key of author is needed to be passed for signing the outbound entity.\n \n     :arg entity: An entity instance which can be of a base or protocol entity class.\n     :arg private_key: Private key of sender as an RSA object\n     :returns: Protocol specific entity class instance.\n     :raises ValueError: If conversion cannot be done.\n     \"\"\"\n     if getattr(entity, \"outbound_doc\", None):\n         # If the entity already has an outbound doc, just return the entity as is\n         return entity\n     outbound = None\n     cls = entity.__class__\n     if cls in [DiasporaPost, DiasporaImage, DiasporaComment, DiasporaLike, DiasporaProfile, DiasporaRetraction,\n                DiasporaContact, DiasporaReshare]:\n         # Already fine\n         outbound = entity\n     elif cls == Post:\n         outbound = DiasporaPost.from_base(entity)\n     elif cls == Comment:\n         outbound = DiasporaComment.from_base(entity)\n     elif cls == Reaction:\n         if entity.reaction == \"like\":\n             outbound = DiasporaLike.from_base(entity)\n     elif cls == Follow:\n         outbound = DiasporaContact.from_base(entity)\n     elif cls == Profile:\n         outbound = DiasporaProfile.from_base(entity)\n     elif cls == Retraction:\n         outbound = DiasporaRetraction.from_base(entity)\n     elif cls == Share:\n         outbound = DiasporaReshare.from_base(entity)\n     if not outbound:\n         raise ValueError(\"Don't know how to convert this base entity to Diaspora protocol entities.\")\n     if isinstance(outbound, DiasporaRelayableMixin) and not outbound.signature:\n         # Sign by author if not signed yet. We don't want to overwrite any existing signature in the case\n         # that this is being sent by the parent author\n         outbound.sign(private_key)\n         # If missing, also add same signature to `parent_author_signature`. This is required at the moment\n         # in all situations but is apparently being removed.\n         # TODO: remove this once Diaspora removes the extra signature\n         outbound.parent_signature = outbound.signature\n     # Validate the entity\n     outbound.validate(direction=\"outbound\")\n     return outbound\n ", "input_code": "def check_sender_and_entity_handle_match(sender_handle, entity_handle):\n\"\"\"\nEnsure that sender and entity handles match.\n\nBasically we've already verified the sender is who they say when receiving the payload. However, the sender might\nbe trying to set another author in the payload itself, since Diaspora has the sender in both the payload headers\nAND the object. We must ensure they're the same.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def check_sender_and_entity_handle_match(sender_handle, entity_handle):\n    \"\"\"Ensure that sender and entity handles match.\n\n    Basically we've already verified the sender is who they say when receiving the payload. However, the sender might\n    be trying to set another author in the payload itself, since Diaspora has the sender in both the payload headers\n    AND the object. We must ensure they're the same.\n    \"\"\"\n    if sender_handle != entity_handle:\n        logger.warning(\"sender_handle and entity_handle don't match, aborting! sender_handle: %s, entity_handle: %s\",\n                       sender_handle, entity_handle)\n        return False\n    return True", "signature": "def check_sender_and_entity_handle_match(sender_handle, entity_handle):", "completion_path": "federation/entities/diaspora/mappers.py"}
{"ce_id": "630629b952e177c0ba46a043", "namespace": "630629b952e177c0ba46a043", "namespace_real": "federation.hostmeta.generators.get_nodeinfo_well_known_document", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "get_nodeinfo_well_known_document", "contexts_above": "import json\nimport os\nimport warnings\nfrom base64 import b64encode\nfrom string import Template\nfrom typing import Dict\n\nfrom jsonschema import validate\nfrom jsonschema.exceptions import ValidationError\nfrom xrd import XRD, Link, Element\n\n\ndef generate_host_meta(template=None, *args, **kwargs):\n    \"\"\"Generate a host-meta XRD document.\n\n    Template specific key-value pairs need to be passed as ``kwargs``, see classes.\n\n    :arg template: Ready template to fill with args, for example \"diaspora\" (optional)\n    :returns: Rendered XRD document (str)\n    \"\"\"\n    if template == \"diaspora\":\n        hostmeta = DiasporaHostMeta(*args, **kwargs)\n    else:\n        hostmeta = BaseHostMeta(*args, **kwargs)\n    return hostmeta.render()\n\n\ndef generate_legacy_webfinger(template=None, *args, **kwargs):\n    \"\"\"Generate a legacy webfinger XRD document.\n\n    Template specific key-value pairs need to be passed as ``kwargs``, see classes.\n\n    :arg template: Ready template to fill with args, for example \"diaspora\" (optional)\n    :returns: Rendered XRD document (str)\n    \"\"\"\n    if template == \"diaspora\":\n        webfinger = DiasporaWebFinger(*args, **kwargs)\n    else:\n        webfinger = BaseLegacyWebFinger(*args, **kwargs)\n    return webfinger.render()\n\n\ndef generate_nodeinfo2_document(**kwargs):\n    \"\"\"\n    Generate a NodeInfo2 document.\n\n    Pass in a dictionary as per NodeInfo2 1.0 schema:\n    https://github.com/jaywink/nodeinfo2/blob/master/schemas/1.0/schema.json\n\n    Minimum required schema:\n        {server:\n          baseUrl\n          name\n          software\n          version\n        }\n        openRegistrations\n\n    Protocols default will match what this library supports, ie \"diaspora\" currently.\n\n    :return: dict\n    :raises: KeyError on missing required items\n    \"\"\"\n    return {\n        \"version\": \"1.0\",\n        \"server\": {\n            \"baseUrl\": kwargs['server']['baseUrl'],\n            \"name\": kwargs['server']['name'],\n            \"software\": kwargs['server']['software'],\n            \"version\": kwargs['server']['version'],\n        },\n        \"organization\": {\n            \"name\": kwargs.get('organization', {}).get('name', None),\n            \"contact\": kwargs.get('organization', {}).get('contact', None),\n            \"account\": kwargs.get('organization', {}).get('account', None),\n        },\n        \"protocols\": kwargs.get('protocols', [\"diaspora\"]),\n        \"relay\": kwargs.get('relay', ''),\n        \"services\": {\n            \"inbound\": kwargs.get('service', {}).get('inbound', []),\n            \"outbound\": kwargs.get('service', {}).get('outbound', []),\n        },\n        \"openRegistrations\": kwargs['openRegistrations'],\n        \"usage\": {\n            \"users\": {\n                \"total\": kwargs.get('usage', {}).get('users', {}).get('total'),\n                \"activeHalfyear\": kwargs.get('usage', {}).get('users', {}).get('activeHalfyear'),\n                \"activeMonth\": kwargs.get('usage', {}).get('users', {}).get('activeMonth'),\n                \"activeWeek\": kwargs.get('usage', {}).get('users', {}).get('activeWeek'),\n            },\n            \"localPosts\": kwargs.get('usage', {}).get('localPosts'),\n            \"localComments\": kwargs.get('usage', {}).get('localComments'),\n        }\n    }\n\n\ndef generate_hcard(template=None, **kwargs):\n    \"\"\"Generate a hCard document.\n\n    Template specific key-value pairs need to be passed as ``kwargs``, see classes.\n\n    :arg template: Ready template to fill with args, for example \"diaspora\" (optional)\n    :returns: HTML document (str)\n    \"\"\"\n    if template == \"diaspora\":\n        hcard = DiasporaHCard(**kwargs)\n    else:\n        raise NotImplementedError()\n    return hcard.render()\n\n\nclass BaseHostMeta:\n    def __init__(self, *args, **kwargs):\n        self.xrd = XRD()\n\n    def render(self):\n        return self.xrd.to_xml().toprettyxml(indent=\"  \", encoding=\"UTF-8\")\n\n\nclass DiasporaHostMeta(BaseHostMeta):\n    \"\"\"Diaspora host-meta.\n\n    Required keyword args:\n\n    * webfinger_host (str)\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        link = Link(\n            rel='lrdd',\n            type_='application/xrd+xml',\n            template='%s/webfinger?q={uri}' % kwargs[\"webfinger_host\"]\n        )\n        self.xrd.links.append(link)\n\n\nclass BaseLegacyWebFinger(BaseHostMeta):\n    \"\"\"Legacy XRD WebFinger.\n\n    See: https://code.google.com/p/webfinger/wiki/WebFingerProtocol\n    \"\"\"\n    def __init__(self, address, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        subject = Element(\"Subject\", \"acct:%s\" % address)\n        self.xrd.elements.append(subject)\n\n\nclass DiasporaWebFinger(BaseLegacyWebFinger):\n    \"\"\"Diaspora version of legacy WebFinger.\n\n    Required keyword args:\n\n    * handle (str)        - eg user@domain.tld\n    * host (str)          - eg https://domain.tld\n    * guid (str)          - guid of user\n    * public_key (str)    - public key\n    \"\"\"\n    def __init__(self, handle, host, guid, public_key, *args, **kwargs):\n        super().__init__(handle, *args, **kwargs)\n        self.xrd.elements.append(Element(\"Alias\", \"%s/people/%s\" % (\n            host, guid\n        )))\n        username = handle.split(\"@\")[0]\n        self.xrd.links.append(Link(\n            rel=\"http://microformats.org/profile/hcard\",\n            type_=\"text/html\",\n            href=\"%s/hcard/users/%s\" %(\n                host, guid\n            )\n        ))\n        self.xrd.links.append(Link(\n            rel=\"http://joindiaspora.com/seed_location\",\n            type_=\"text/html\",\n            href=host\n        ))\n        self.xrd.links.append(Link(\n            rel=\"http://joindiaspora.com/guid\",\n            type_=\"text/html\",\n            href=guid\n        ))\n        self.xrd.links.append(Link(\n            rel=\"http://webfinger.net/rel/profile-page\",\n            type_=\"text/html\",\n            href=\"%s/u/%s\" % (\n                host, username\n            )\n        ))\n        self.xrd.links.append(Link(\n            rel=\"http://schemas.google.com/g/2010#updates-from\",\n            type_=\"application/atom+xml\",\n            href=\"%s/public/%s.atom\" % (\n                host, username\n            )\n        ))\n        # Base64 the key\n        # See https://wiki.diasporafoundation.org/Federation_Protocol_Overview#Diaspora_Public_Key\n        try:\n            base64_key = b64encode(bytes(public_key, encoding=\"UTF-8\")).decode(\"ascii\")\n        except TypeError:\n            # Python 2\n            base64_key = b64encode(public_key).decode(\"ascii\")\n        self.xrd.links.append(Link(\n            rel=\"diaspora-public-key\",\n            type_=\"RSA\",\n            href=base64_key\n        ))\n\n\nclass DiasporaHCard:\n    \"\"\"Diaspora hCard document.\n\n    Must receive the `required` attributes as keyword arguments to init.\n    \"\"\"\n\n    required = [\n        \"hostname\", \"fullname\", \"firstname\", \"lastname\", \"photo300\", \"photo100\", \"photo50\", \"searchable\", \"guid\", \"public_key\", \"username\",\n    ]\n\n    def __init__(self, **kwargs):\n        self.kwargs = kwargs\n        template_path = os.path.join(os.path.dirname(__file__), \"templates\", \"hcard_diaspora.html\")\n        with open(template_path) as f:\n            self.template = Template(f.read())\n\n    def render(self):\n        required = self.required[:]\n        for key, value in self.kwargs.items():\n            required.remove(key)\n            assert value is not None\n            assert isinstance(value, str)\n        assert len(required) == 0\n        return self.template.substitute(self.kwargs)\n\n\nclass SocialRelayWellKnown:\n    \"\"\"A `.well-known/social-relay` document in JSON.\n\n    For apps wanting to announce their preferences towards relay applications.\n\n    See WIP spec: https://wiki.diasporafoundation.org/Relay_servers_for_public_posts\n\n    Schema see `schemas/social-relay-well-known.json`\n\n    :arg subscribe: bool\n    :arg tags: tuple, optional\n    :arg scope: Should be either \"all\" or \"tags\", default is \"all\" if not given\n    \"\"\"\n    def __init__(self, subscribe, tags=(), scope=\"all\", *args, **kwargs):\n        self.doc = {\n            \"subscribe\": subscribe,\n            \"scope\": scope,\n            \"tags\": list(tags),\n        }\n\n    def render(self):\n        self.validate_doc()\n        return json.dumps(self.doc)\n\n    def validate_doc(self):\n        schema_path = os.path.join(os.path.dirname(__file__), \"schemas\", \"social-relay-well-known.json\")\n        with open(schema_path) as f:\n            schema = json.load(f)\n        validate(self.doc, schema)\n\n\nclass NodeInfo:\n    \"\"\"Generate a NodeInfo document.\n\n    See spec: http://nodeinfo.diaspora.software\n\n    NodeInfo is unnecessarely restrictive in field values. We wont be supporting such strictness, though\n    we will raise a warning unless validation is skipped with `skip_validate=True`.\n\n    For strictness, `raise_on_validate=True` will cause a `ValidationError` to be raised.\n\n    See schema document `federation/hostmeta/schemas/nodeinfo-1.0.json` for how to instantiate this class.\n    \"\"\"\n\n    def __init__(self, software, protocols, services, open_registrations, usage, metadata, skip_validate=False,\n                 raise_on_validate=False):\n        self.doc = {\n            \"version\": \"1.0\",\n            \"software\": software,\n            \"protocols\": protocols,\n            \"services\": services,\n            \"openRegistrations\": open_registrations,\n            \"usage\": usage,\n            \"metadata\": metadata,\n        }\n        self.skip_validate = skip_validate\n        self.raise_on_validate = raise_on_validate\n\n    def render(self):\n        if not self.skip_validate:\n            self.validate_doc()\n        return json.dumps(self.doc)\n\n    def validate_doc(self):\n        schema_path = os.path.join(os.path.dirname(__file__), \"schemas\", \"nodeinfo-1.0.json\")\n        with open(schema_path) as f:\n            schema = json.load(f)\n        try:\n            validate(self.doc, schema)\n        except ValidationError:\n            if self.raise_on_validate:\n                raise\n            warnings.warn(\"NodeInfo document generated does not validate against NodeInfo 1.0 specification.\")\n\n\n# The default NodeInfo document path\nNODEINFO_DOCUMENT_PATH = \"/nodeinfo/1.0\"\n\n", "contexts_below": "\n class MatrixClientWellKnown:\n     \"\"\"\n     Matrix Client well-known as per https://matrix.org/docs/spec/client_server/r0.6.1#server-discovery\n     \"\"\"\n     def __init__(self, homeserver_base_url: str, identity_server_base_url: str = None, other_keys: Dict = None):\n         self.homeserver_base_url = homeserver_base_url\n         self.identity_server_base_url = identity_server_base_url\n         self.other_keys = other_keys\n \n     def render(self):\n         doc = {\n             \"m.homeserver\": {\n                 \"base_url\": self.homeserver_base_url,\n             }\n         }\n         if self.identity_server_base_url:\n             doc[\"m.identity_server\"] = {\n                 \"base_url\": self.identity_server_base_url,\n             }\n         if self.other_keys:\n             doc.update(self.other_keys)\n         return doc\n \n \n class MatrixServerWellKnown:\n     \"\"\"\n     Matrix Server well-known as per https://matrix.org/docs/spec/server_server/r0.1.4#server-discovery\n     \"\"\"\n     def __init__(self, homeserver_domain_with_port: str):\n         self.homeserver_domain_with_port = homeserver_domain_with_port\n \n     def render(self):\n         return {\n             \"m.server\": self.homeserver_domain_with_port,\n         }\n \n \n class RFC7033Webfinger:\n     \"\"\"\n     RFC 7033 webfinger - see https://tools.ietf.org/html/rfc7033\n \n     A Django view is also available, see the child ``django`` module for view and url configuration.\n \n     :param id: Profile ActivityPub ID in URL format\n     :param handle: Profile Diaspora handle\n     :param guid: Profile Diaspora guid\n     :param base_url: The base URL of the server (protocol://domain.tld)\n     :param profile_path: Profile path for the user (for example `/profile/johndoe/`)\n     :param hcard_path: (Optional) hCard path, defaults to ``/hcard/users/``.\n     :param atom_path: (Optional) atom feed path\n     :returns: dict\n     \"\"\"\n     def __init__(\n             self, id: str, handle: str, guid: str, base_url: str, profile_path: str, hcard_path: str=\"/hcard/users/\",\n             atom_path: str=None, search_path: str=None,\n     ):\n         self.id = id\n         self.handle = handle\n         self.guid = guid\n         self.base_url = base_url\n         self.hcard_path = hcard_path\n         self.profile_path = profile_path\n         self.atom_path = atom_path\n         self.search_path = search_path\n \n     def render(self):\n         webfinger = {\n             \"subject\": \"acct:%s\" % self.handle,\n             \"aliases\": [\n                 f\"{self.base_url}{self.profile_path}\",\n                 self.id,\n             ],\n             \"links\": [\n                 {\n                     \"rel\": \"http://microformats.org/profile/hcard\",\n                     \"type\": \"text/html\",\n                     \"href\": \"%s%s%s\" % (self.base_url, self.hcard_path, self.guid),\n                 },\n                 {\n                     \"rel\": \"http://joindiaspora.com/seed_location\",\n                     \"type\": \"text/html\",\n                     \"href\": self.base_url,\n                 },\n                 {\n                     \"rel\": \"http://webfinger.net/rel/profile-page\",\n                     \"type\": \"text/html\",\n                     \"href\": \"%s%s\" % (self.base_url, self.profile_path),\n                 },\n                 {\n                     \"rel\": \"salmon\",\n                     \"href\": \"%s/receive/users/%s\" % (self.base_url, self.guid),\n                 },\n             ],\n         }\n \n         webfinger[\"links\"].append({\n             \"rel\": \"self\",\n             \"href\": self.id,\n             \"type\": \"application/activity+json\",\n         })\n \n         if self.atom_path:\n             webfinger['links'].append(\n                 {\n                     \"rel\": \"http://schemas.google.com/g/2010#updates-from\",\n                     \"type\": \"application/atom+xml\",\n                     \"href\": \"%s%s\" % (self.base_url, self.atom_path),\n                 }\n             )\n         if self.search_path:\n             webfinger['links'].append(\n                 {\n                     \"rel\": \"http://ostatus.org/schema/1.0/subscribe\",\n                     \"template\": \"%s%s{uri}\" % (self.base_url, self.search_path),\n                 },\n             )\n         return webfinger\n ", "input_code": "def get_nodeinfo_well_known_document(url, document_path=None):\n\"\"\"\nGenerate a NodeInfo .well-known document.\n\nSee spec: http://nodeinfo.diaspora.software\n\n:arg url: The full base url with protocol, ie https://example.com\n:arg document_path: Custom NodeInfo document path if supplied (optional)\n:returns: dict\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def get_nodeinfo_well_known_document(url, document_path=None):\n    \"\"\"Generate a NodeInfo .well-known document.\n\n    See spec: http://nodeinfo.diaspora.software\n\n    :arg url: The full base url with protocol, ie https://example.com\n    :arg document_path: Custom NodeInfo document path if supplied (optional)\n    :returns: dict\n    \"\"\"\n    return {\n        \"links\": [\n            {\n                \"rel\": \"http://nodeinfo.diaspora.software/ns/schema/1.0\",\n                \"href\": \"{url}{path}\".format(\n                    url=url, path=document_path or NODEINFO_DOCUMENT_PATH\n                )\n            }\n        ]\n    }", "signature": "def get_nodeinfo_well_known_document(url, document_path=None):", "completion_path": "federation/hostmeta/generators.py"}
{"ce_id": "630629d052e177c0ba46a0a1", "namespace": "630629d052e177c0ba46a0a1", "namespace_real": "federation.protocols.diaspora.signatures.verify_relayable_signature", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "verify_relayable_signature", "contexts_above": "from base64 import b64decode, b64encode\n\nfrom Crypto.Hash import SHA256\nfrom Crypto.PublicKey import RSA\nfrom Crypto.PublicKey.RSA import RsaKey\nfrom Crypto.Signature import PKCS1_v1_5\n\n\ndef get_element_child_info(doc, attr):\n    \"\"\"Get information from child elements of this elementas a list since order is important.\n\n    Don't include signature tags.\n\n    :param doc: XML element\n    :param attr: Attribute to get from the elements, for example \"tag\" or \"text\".\n    \"\"\"\n    props = []\n    for child in doc:\n        if child.tag not in [\"author_signature\", \"parent_author_signature\"]:\n            props.append(getattr(child, attr))\n    return props\n\n\ndef _create_signature_hash(doc):\n    props = get_element_child_info(doc, \"text\")\n    content = \";\".join(props)\n    return SHA256.new(content.encode(\"utf-8\"))\n\n", "contexts_below": "\n def create_relayable_signature(private_key: RsaKey, doc):\n     sig_hash = _create_signature_hash(doc)\n     cipher = PKCS1_v1_5.new(private_key)\n     return b64encode(cipher.sign(sig_hash)).decode(\"ascii\")\n ", "input_code": "def verify_relayable_signature(public_key, doc, signature):\n\"\"\"\nVerify the signed XML elements to have confidence that the claimed\nauthor did actually generate this message.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def verify_relayable_signature(public_key, doc, signature):\n    \"\"\"\n    Verify the signed XML elements to have confidence that the claimed\n    author did actually generate this message.\n    \"\"\"\n    sig_hash = _create_signature_hash(doc)\n    cipher = PKCS1_v1_5.new(RSA.importKey(public_key))\n    return cipher.verify(sig_hash, b64decode(signature))", "signature": "def verify_relayable_signature(public_key, doc, signature):", "completion_path": "federation/protocols/diaspora/signatures.py"}
{"ce_id": "630629e052e177c0ba46a0c4", "namespace": "630629e052e177c0ba46a0c4", "namespace_real": "federation.utils.diaspora.parse_diaspora_webfinger", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "parse_diaspora_webfinger", "contexts_above": "import json\nimport logging\nimport xml\nfrom typing import Callable, Dict\nfrom urllib.parse import quote\n\nfrom lxml import html\nfrom xrd import XRD\n\nfrom federation.inbound import handle_receive\nfrom federation.types import RequestType\nfrom federation.utils.network import fetch_document, try_retrieve_webfinger_document\nfrom federation.utils.text import validate_handle\n\nlogger = logging.getLogger(\"federation\")\n\n\ndef fetch_public_key(handle):\n    \"\"\"Fetch public key over the network.\n\n    :param handle: Remote handle to retrieve public key for.\n    :return: Public key in str format from parsed profile.\n    \"\"\"\n    profile = retrieve_and_parse_profile(handle)\n    return profile.public_key\n\n", "contexts_below": "\n def retrieve_diaspora_hcard(handle):\n     \"\"\"\n     Retrieve a remote Diaspora hCard document.\n \n     :arg handle: Remote handle to retrieve\n     :return: str (HTML document)\n     \"\"\"\n     webfinger = retrieve_and_parse_diaspora_webfinger(handle)\n     document, code, exception = fetch_document(webfinger.get(\"hcard_url\"))\n     if exception:\n         return None\n     return document\n \n \n def retrieve_and_parse_diaspora_webfinger(handle):\n     \"\"\"\n     Retrieve a and parse a remote Diaspora webfinger document.\n \n     :arg handle: Remote handle to retrieve\n     :returns: dict\n     \"\"\"\n     document = try_retrieve_webfinger_document(handle)\n     if document:\n         return parse_diaspora_webfinger(document)\n     host = handle.split(\"@\")[1]\n     hostmeta = retrieve_diaspora_host_meta(host)\n     if not hostmeta:\n         return None\n     url = hostmeta.find_link(rels=\"lrdd\").template.replace(\"{uri}\", quote(handle))\n     document, code, exception = fetch_document(url)\n     if exception:\n         return None\n     return parse_diaspora_webfinger(document)\n \n \n def retrieve_diaspora_host_meta(host):\n     \"\"\"\n     Retrieve a remote Diaspora host-meta document.\n \n     :arg host: Host to retrieve from\n     :returns: ``XRD`` instance\n     \"\"\"\n     document, code, exception = fetch_document(host=host, path=\"/.well-known/host-meta\")\n     if exception:\n         return None\n     xrd = XRD.parse_xrd(document)\n     return xrd\n \n \n def _get_element_text_or_none(document, selector):\n     \"\"\"\n     Using a CSS selector, get the element and return the text, or None if no element.\n \n     :arg document: ``HTMLElement`` document\n     :arg selector: CSS selector\n     :returns: str or None\n     \"\"\"\n     element = document.cssselect(selector)\n     if element:\n         return element[0].text\n     return None\n \n \n def _get_element_attr_or_none(document, selector, attribute):\n     \"\"\"\n     Using a CSS selector, get the element and return the given attribute value, or None if no element.\n \n     Args:\n         document (HTMLElement) - HTMLElement document\n         selector (str) - CSS selector\n         attribute (str) - The attribute to get from the element\n     \"\"\"\n     element = document.cssselect(selector)\n     if element:\n         return element[0].get(attribute)\n     return None\n \n \n def parse_profile_from_hcard(hcard: str, handle: str):\n     \"\"\"\n     Parse all the fields we can from a hCard document to get a Profile.\n \n     :arg hcard: HTML hcard document (str)\n     :arg handle: User handle in username@domain.tld format\n     :returns: ``federation.entities.diaspora.entities.DiasporaProfile`` instance\n     \"\"\"\n     from federation.entities.diaspora.entities import DiasporaProfile  # Circulars\n     doc = html.fromstring(hcard)\n     profile = DiasporaProfile(\n         name=_get_element_text_or_none(doc, \".fn\"),\n         image_urls={\n             \"small\": _get_element_attr_or_none(doc, \".entity_photo_small .photo\", \"src\"),\n             \"medium\": _get_element_attr_or_none(doc, \".entity_photo_medium .photo\", \"src\"),\n             \"large\": _get_element_attr_or_none(doc, \".entity_photo .photo\", \"src\"),\n         },\n         public=True,\n         id=handle,\n         handle=handle,\n         guid=_get_element_text_or_none(doc, \".uid\"),\n         public_key=_get_element_text_or_none(doc, \".key\"),\n         username=handle.split('@')[0],\n         _source_protocol=\"diaspora\",\n     )\n     return profile\n \n \n def retrieve_and_parse_content(\n         id: str, guid: str, handle: str, entity_type: str, sender_key_fetcher: Callable[[str], str]=None):\n     \"\"\"Retrieve remote content and return an Entity class instance.\n \n     This is basically the inverse of receiving an entity. Instead, we fetch it, then call \"handle_receive\".\n \n     :param sender_key_fetcher: Function to use to fetch sender public key. If not given, network will be used\n         to fetch the profile and the key. Function must take handle as only parameter and return a public key.\n     :returns: Entity object instance or ``None``\n     \"\"\"\n     if not validate_handle(handle):\n         return\n     _username, domain = handle.split(\"@\")\n     url = get_fetch_content_endpoint(domain, entity_type.lower(), guid)\n     document, status_code, error = fetch_document(url)\n     if status_code == 200:\n         request = RequestType(body=document)\n         _sender, _protocol, entities = handle_receive(request, sender_key_fetcher=sender_key_fetcher)\n         if len(entities) > 1:\n             logger.warning(\"retrieve_and_parse_content - more than one entity parsed from remote even though we\"\n                            \"expected only one! ID %s\", guid)\n         if entities:\n             return entities[0]\n         return\n     elif status_code == 404:\n         logger.warning(\"retrieve_and_parse_content - remote content %s not found\", guid)\n         return\n     if error:\n         raise error\n     raise Exception(\"retrieve_and_parse_content - unknown problem when fetching document: %s, %s, %s\" % (\n         document, status_code, error,\n     ))\n \n \n def retrieve_and_parse_profile(handle):\n     \"\"\"\n     Retrieve the remote user and return a Profile object.\n \n     :arg handle: User handle in username@domain.tld format\n     :returns: ``federation.entities.Profile`` instance or None\n     \"\"\"\n     hcard = retrieve_diaspora_hcard(handle)\n     if not hcard:\n         return None\n     profile = parse_profile_from_hcard(hcard, handle)\n     try:\n         profile.validate()\n     except ValueError as ex:\n         logger.warning(\"retrieve_and_parse_profile - found profile %s but it didn't validate: %s\",\n                        profile, ex)\n         return None\n     return profile\n \n \n def get_fetch_content_endpoint(domain, entity_type, guid):\n     \"\"\"Get remote fetch content endpoint.\n \n     See: https://diaspora.github.io/diaspora_federation/federation/fetching.html\n     \"\"\"\n     return \"https://%s/fetch/%s/%s\" % (domain, entity_type, guid)\n \n \n def get_public_endpoint(id: str) -> str:\n     \"\"\"Get remote endpoint for delivering public payloads.\"\"\"\n     _username, domain = id.split(\"@\")\n     return \"https://%s/receive/public\" % domain\n \n \n def get_private_endpoint(id: str, guid: str) -> str:\n     \"\"\"Get remote endpoint for delivering private payloads.\"\"\"\n     _username, domain = id.split(\"@\")\n     return \"https://%s/receive/users/%s\" % (domain, guid)\n ", "input_code": "def parse_diaspora_webfinger(document: str) -> Dict:\n\"\"\"\nParse Diaspora webfinger which is either in JSON format (new) or XRD (old).\n\nhttps://diaspora.github.io/diaspora_federation/discovery/webfinger.html\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def parse_diaspora_webfinger(document: str) -> Dict:\n    \"\"\"\n    Parse Diaspora webfinger which is either in JSON format (new) or XRD (old).\n\n    https://diaspora.github.io/diaspora_federation/discovery/webfinger.html\n    \"\"\"\n    webfinger = {\n        \"hcard_url\": None,\n    }\n    # noinspection PyBroadException\n    try:\n        doc = json.loads(document)\n        for link in doc[\"links\"]:\n            if link[\"rel\"] == \"http://microformats.org/profile/hcard\":\n                webfinger[\"hcard_url\"] = link[\"href\"]\n                break\n        else:\n            logger.warning(\"parse_diaspora_webfinger: found JSON webfinger but it has no hcard href\")\n            raise ValueError\n    except Exception:\n        try:\n            xrd = XRD.parse_xrd(document)\n            webfinger[\"hcard_url\"] = xrd.find_link(rels=\"http://microformats.org/profile/hcard\").href\n        except (xml.parsers.expat.ExpatError, TypeError):\n            logger.warning(\"parse_diaspora_webfinger: found XML webfinger but it fails to parse\")\n            pass\n    return webfinger", "signature": "def parse_diaspora_webfinger(document: str) -> Dict:", "completion_path": "federation/utils/diaspora.py"}
{"ce_id": "630629e152e177c0ba46a0d1", "namespace": "630629e152e177c0ba46a0d1", "namespace_real": "federation.utils.network.try_retrieve_webfinger_document", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "try_retrieve_webfinger_document", "contexts_above": "import calendar\nimport datetime\nimport logging\nimport re\nimport socket\nfrom typing import Optional, Dict\nfrom urllib.parse import quote\nfrom uuid import uuid4\n\nimport requests\nfrom requests.exceptions import RequestException, HTTPError, SSLError\nfrom requests.exceptions import ConnectionError\nfrom requests.structures import CaseInsensitiveDict\n\nfrom federation import __version__\n\nlogger = logging.getLogger(\"federation\")\n\nUSER_AGENT = \"python/federation/%s\" % __version__\n\n\ndef fetch_content_type(url: str) -> Optional[str]:\n    \"\"\"\n    Fetch the HEAD of the remote url to determine the content type.\n    \"\"\"\n    try:\n        response = requests.head(url, headers={'user-agent': USER_AGENT}, timeout=10)\n    except RequestException as ex:\n        logger.warning(\"fetch_content_type - %s when fetching url %s\", ex, url)\n    else:\n        return response.headers.get('Content-Type')\n\n\ndef fetch_document(url=None, host=None, path=\"/\", timeout=10, raise_ssl_errors=True, extra_headers=None, **kwargs):\n    \"\"\"Helper method to fetch remote document.\n\n    Must be given either the ``url`` or ``host``.\n    If ``url`` is given, only that will be tried without falling back to http from https.\n    If ``host`` given, `path` will be added to it. Will fall back to http on non-success status code.\n\n    :arg url: Full url to fetch, including protocol\n    :arg host: Domain part only without path or protocol\n    :arg path: Path without domain (defaults to \"/\")\n    :arg timeout: Seconds to wait for response (defaults to 10)\n    :arg raise_ssl_errors: Pass False if you want to try HTTP even for sites with SSL errors (default True)\n    :arg extra_headers: Optional extra headers dictionary to add to requests\n    :arg kwargs holds extra args passed to requests.get\n    :returns: Tuple of document (str or None), status code (int or None) and error (an exception class instance or None)\n    :raises ValueError: If neither url nor host are given as parameters\n    \"\"\"\n    if not url and not host:\n        raise ValueError(\"Need url or host.\")\n\n    logger.debug(\"fetch_document: url=%s, host=%s, path=%s, timeout=%s, raise_ssl_errors=%s\",\n                 url, host, path, timeout, raise_ssl_errors)\n    headers = {'user-agent': USER_AGENT}\n    if extra_headers:\n        headers.update(extra_headers)\n    if url:\n        # Use url since it was given\n        logger.debug(\"fetch_document: trying %s\", url)\n        try:\n            response = requests.get(url, timeout=timeout, headers=headers, **kwargs)\n            logger.debug(\"fetch_document: found document, code %s\", response.status_code)\n            response.raise_for_status()\n            return response.text, response.status_code, None\n        except RequestException as ex:\n            logger.debug(\"fetch_document: exception %s\", ex)\n            return None, None, ex\n    # Build url with some little sanitizing\n    host_string = host.replace(\"http://\", \"\").replace(\"https://\", \"\").strip(\"/\")\n    path_string = path if path.startswith(\"/\") else \"/%s\" % path\n    url = \"https://%s%s\" % (host_string, path_string)\n    logger.debug(\"fetch_document: trying %s\", url)\n    try:\n        response = requests.get(url, timeout=timeout, headers=headers)\n        logger.debug(\"fetch_document: found document, code %s\", response.status_code)\n        response.raise_for_status()\n        return response.text, response.status_code, None\n    except (HTTPError, SSLError, ConnectionError) as ex:\n        if isinstance(ex, SSLError) and raise_ssl_errors:\n            logger.debug(\"fetch_document: exception %s\", ex)\n            return None, None, ex\n        # Try http then\n        url = url.replace(\"https://\", \"http://\")\n        logger.debug(\"fetch_document: trying %s\", url)\n        try:\n            response = requests.get(url, timeout=timeout, headers=headers)\n            logger.debug(\"fetch_document: found document, code %s\", response.status_code)\n            response.raise_for_status()\n            return response.text, response.status_code, None\n        except RequestException as ex:\n            logger.debug(\"fetch_document: exception %s\", ex)\n            return None, None, ex\n    except RequestException as ex:\n        logger.debug(\"fetch_document: exception %s\", ex)\n        return None, None, ex\n\n\ndef fetch_host_ip(host: str) -> str:\n    \"\"\"\n    Fetch ip by host\n    \"\"\"\n    try:\n        ip = socket.gethostbyname(host)\n    except socket.gaierror:\n        return ''\n\n    return ip\n\n\ndef fetch_file(url: str, timeout: int = 30, extra_headers: Dict = None) -> str:\n    \"\"\"\n    Download a file with a temporary name and return the name.\n    \"\"\"\n    headers = {'user-agent': USER_AGENT}\n    if extra_headers:\n        headers.update(extra_headers)\n    response = requests.get(url, timeout=timeout, headers=headers, stream=True)\n    response.raise_for_status()\n    name = f\"/tmp/{str(uuid4())}\"\n    with open(name, \"wb\") as f:\n        for chunk in response.iter_content(chunk_size=8192):\n            f.write(chunk)\n    return name\n\n\ndef parse_http_date(date):\n    \"\"\"\n    Parse a date format as specified by HTTP RFC7231 section 7.1.1.1.\n\n    The three formats allowed by the RFC are accepted, even if only the first\n    one is still in widespread use.\n\n    Return an integer expressed in seconds since the epoch, in UTC.\n\n    Implementation copied from Django.\n    https://github.com/django/django/blob/master/django/utils/http.py#L157\n    License: BSD 3-clause\n    \"\"\"\n    MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec'.split()\n    __D = r'(?P<day>\\d{2})'\n    __D2 = r'(?P<day>[ \\d]\\d)'\n    __M = r'(?P<mon>\\w{3})'\n    __Y = r'(?P<year>\\d{4})'\n    __Y2 = r'(?P<year>\\d{2})'\n    __T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'\n    RFC1123_DATE = re.compile(r'^\\w{3}, %s %s %s %s GMT$' % (__D, __M, __Y, __T))\n    RFC850_DATE = re.compile(r'^\\w{6,9}, %s-%s-%s %s GMT$' % (__D, __M, __Y2, __T))\n    ASCTIME_DATE = re.compile(r'^\\w{3} %s %s %s %s$' % (__M, __D2, __T, __Y))\n    # email.utils.parsedate() does the job for RFC1123 dates; unfortunately\n    # RFC7231 makes it mandatory to support RFC850 dates too. So we roll\n    # our own RFC-compliant parsing.\n    for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:\n        m = regex.match(date)\n        if m is not None:\n            break\n    else:\n        raise ValueError(\"%r is not in a valid HTTP date format\" % date)\n    try:\n        year = int(m.group('year'))\n        if year < 100:\n            if year < 70:\n                year += 2000\n            else:\n                year += 1900\n        month = MONTHS.index(m.group('mon').lower()) + 1\n        day = int(m.group('day'))\n        hour = int(m.group('hour'))\n        min = int(m.group('min'))\n        sec = int(m.group('sec'))\n        result = datetime.datetime(year, month, day, hour, min, sec)\n        return calendar.timegm(result.utctimetuple())\n    except Exception as exc:\n        raise ValueError(\"%r is not a valid date\" % date) from exc\n\n\ndef send_document(url, data, timeout=10, method=\"post\", *args, **kwargs):\n    \"\"\"Helper method to send a document via POST.\n\n    Additional ``*args`` and ``**kwargs`` will be passed on to ``requests.post``.\n\n    :arg url: Full url to send to, including protocol\n    :arg data: Dictionary (will be form-encoded), bytes, or file-like object to send in the body\n    :arg timeout: Seconds to wait for response (defaults to 10)\n    :arg method: Method to use, defaults to post\n    :returns: Tuple of status code (int or None) and error (exception class instance or None)\n    \"\"\"\n    logger.debug(\"send_document: url=%s, data=%s, timeout=%s, method=%s\", url, data, timeout, method)\n    if not method:\n        method = \"post\"\n    headers = CaseInsensitiveDict({\n        'User-Agent': USER_AGENT,\n    })\n    if \"headers\" in kwargs:\n        # Update from kwargs\n        headers.update(kwargs.get(\"headers\"))\n    kwargs.update({\n        \"data\": data, \"timeout\": timeout, \"headers\": headers\n    })\n    request_func = getattr(requests, method)\n    try:\n        response = request_func(url, *args, **kwargs)\n        logger.debug(\"send_document: response status code %s\", response.status_code)\n        return response.status_code, None\n    # TODO support rate limit 429 code\n    except RequestException as ex:\n        logger.debug(\"send_document: exception %s\", ex)\n        return None, ex\n\n", "contexts_below": "", "input_code": "def try_retrieve_webfinger_document(handle: str) -> Optional[str]:\n\"\"\"\nTry to retrieve an RFC7033 webfinger document. Does not raise if it fails.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def try_retrieve_webfinger_document(handle: str) -> Optional[str]:\n    \"\"\"\n    Try to retrieve an RFC7033 webfinger document. Does not raise if it fails.\n    \"\"\"\n    try:\n        host = handle.split(\"@\")[1]\n    except AttributeError:\n        logger.warning(\"retrieve_webfinger_document: invalid handle given: %s\", handle)\n        return None\n    document, code, exception = fetch_document(\n        host=host, path=\"/.well-known/webfinger?resource=acct:%s\" % quote(handle),\n    )\n    if exception:\n        logger.debug(\"retrieve_webfinger_document: failed to fetch webfinger document: %s, %s\", code, exception)\n    return document", "signature": "def try_retrieve_webfinger_document(handle: str) -> Optional[str]:", "completion_path": "federation/utils/network.py"}
{"ce_id": "630629e152e177c0ba46a0d2", "namespace": "630629e152e177c0ba46a0d2", "namespace_real": "federation.utils.diaspora.retrieve_and_parse_diaspora_webfinger", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "retrieve_and_parse_diaspora_webfinger", "contexts_above": "import json\nimport logging\nimport xml\nfrom typing import Callable, Dict\nfrom urllib.parse import quote\n\nfrom lxml import html\nfrom xrd import XRD\n\nfrom federation.inbound import handle_receive\nfrom federation.types import RequestType\nfrom federation.utils.network import fetch_document, try_retrieve_webfinger_document\nfrom federation.utils.text import validate_handle\n\nlogger = logging.getLogger(\"federation\")\n\n\ndef fetch_public_key(handle):\n    \"\"\"Fetch public key over the network.\n\n    :param handle: Remote handle to retrieve public key for.\n    :return: Public key in str format from parsed profile.\n    \"\"\"\n    profile = retrieve_and_parse_profile(handle)\n    return profile.public_key\n\n\ndef parse_diaspora_webfinger(document: str) -> Dict:\n    \"\"\"\n    Parse Diaspora webfinger which is either in JSON format (new) or XRD (old).\n\n    https://diaspora.github.io/diaspora_federation/discovery/webfinger.html\n    \"\"\"\n    webfinger = {\n        \"hcard_url\": None,\n    }\n    # noinspection PyBroadException\n    try:\n        doc = json.loads(document)\n        for link in doc[\"links\"]:\n            if link[\"rel\"] == \"http://microformats.org/profile/hcard\":\n                webfinger[\"hcard_url\"] = link[\"href\"]\n                break\n        else:\n            logger.warning(\"parse_diaspora_webfinger: found JSON webfinger but it has no hcard href\")\n            raise ValueError\n    except Exception:\n        try:\n            xrd = XRD.parse_xrd(document)\n            webfinger[\"hcard_url\"] = xrd.find_link(rels=\"http://microformats.org/profile/hcard\").href\n        except (xml.parsers.expat.ExpatError, TypeError):\n            logger.warning(\"parse_diaspora_webfinger: found XML webfinger but it fails to parse\")\n            pass\n    return webfinger\n\n\ndef retrieve_diaspora_hcard(handle):\n    \"\"\"\n    Retrieve a remote Diaspora hCard document.\n\n    :arg handle: Remote handle to retrieve\n    :return: str (HTML document)\n    \"\"\"\n    webfinger = retrieve_and_parse_diaspora_webfinger(handle)\n    document, code, exception = fetch_document(webfinger.get(\"hcard_url\"))\n    if exception:\n        return None\n    return document\n\n", "contexts_below": "\n def retrieve_diaspora_host_meta(host):\n     \"\"\"\n     Retrieve a remote Diaspora host-meta document.\n \n     :arg host: Host to retrieve from\n     :returns: ``XRD`` instance\n     \"\"\"\n     document, code, exception = fetch_document(host=host, path=\"/.well-known/host-meta\")\n     if exception:\n         return None\n     xrd = XRD.parse_xrd(document)\n     return xrd\n \n \n def _get_element_text_or_none(document, selector):\n     \"\"\"\n     Using a CSS selector, get the element and return the text, or None if no element.\n \n     :arg document: ``HTMLElement`` document\n     :arg selector: CSS selector\n     :returns: str or None\n     \"\"\"\n     element = document.cssselect(selector)\n     if element:\n         return element[0].text\n     return None\n \n \n def _get_element_attr_or_none(document, selector, attribute):\n     \"\"\"\n     Using a CSS selector, get the element and return the given attribute value, or None if no element.\n \n     Args:\n         document (HTMLElement) - HTMLElement document\n         selector (str) - CSS selector\n         attribute (str) - The attribute to get from the element\n     \"\"\"\n     element = document.cssselect(selector)\n     if element:\n         return element[0].get(attribute)\n     return None\n \n \n def parse_profile_from_hcard(hcard: str, handle: str):\n     \"\"\"\n     Parse all the fields we can from a hCard document to get a Profile.\n \n     :arg hcard: HTML hcard document (str)\n     :arg handle: User handle in username@domain.tld format\n     :returns: ``federation.entities.diaspora.entities.DiasporaProfile`` instance\n     \"\"\"\n     from federation.entities.diaspora.entities import DiasporaProfile  # Circulars\n     doc = html.fromstring(hcard)\n     profile = DiasporaProfile(\n         name=_get_element_text_or_none(doc, \".fn\"),\n         image_urls={\n             \"small\": _get_element_attr_or_none(doc, \".entity_photo_small .photo\", \"src\"),\n             \"medium\": _get_element_attr_or_none(doc, \".entity_photo_medium .photo\", \"src\"),\n             \"large\": _get_element_attr_or_none(doc, \".entity_photo .photo\", \"src\"),\n         },\n         public=True,\n         id=handle,\n         handle=handle,\n         guid=_get_element_text_or_none(doc, \".uid\"),\n         public_key=_get_element_text_or_none(doc, \".key\"),\n         username=handle.split('@')[0],\n         _source_protocol=\"diaspora\",\n     )\n     return profile\n \n \n def retrieve_and_parse_content(\n         id: str, guid: str, handle: str, entity_type: str, sender_key_fetcher: Callable[[str], str]=None):\n     \"\"\"Retrieve remote content and return an Entity class instance.\n \n     This is basically the inverse of receiving an entity. Instead, we fetch it, then call \"handle_receive\".\n \n     :param sender_key_fetcher: Function to use to fetch sender public key. If not given, network will be used\n         to fetch the profile and the key. Function must take handle as only parameter and return a public key.\n     :returns: Entity object instance or ``None``\n     \"\"\"\n     if not validate_handle(handle):\n         return\n     _username, domain = handle.split(\"@\")\n     url = get_fetch_content_endpoint(domain, entity_type.lower(), guid)\n     document, status_code, error = fetch_document(url)\n     if status_code == 200:\n         request = RequestType(body=document)\n         _sender, _protocol, entities = handle_receive(request, sender_key_fetcher=sender_key_fetcher)\n         if len(entities) > 1:\n             logger.warning(\"retrieve_and_parse_content - more than one entity parsed from remote even though we\"\n                            \"expected only one! ID %s\", guid)\n         if entities:\n             return entities[0]\n         return\n     elif status_code == 404:\n         logger.warning(\"retrieve_and_parse_content - remote content %s not found\", guid)\n         return\n     if error:\n         raise error\n     raise Exception(\"retrieve_and_parse_content - unknown problem when fetching document: %s, %s, %s\" % (\n         document, status_code, error,\n     ))\n \n \n def retrieve_and_parse_profile(handle):\n     \"\"\"\n     Retrieve the remote user and return a Profile object.\n \n     :arg handle: User handle in username@domain.tld format\n     :returns: ``federation.entities.Profile`` instance or None\n     \"\"\"\n     hcard = retrieve_diaspora_hcard(handle)\n     if not hcard:\n         return None\n     profile = parse_profile_from_hcard(hcard, handle)\n     try:\n         profile.validate()\n     except ValueError as ex:\n         logger.warning(\"retrieve_and_parse_profile - found profile %s but it didn't validate: %s\",\n                        profile, ex)\n         return None\n     return profile\n \n \n def get_fetch_content_endpoint(domain, entity_type, guid):\n     \"\"\"Get remote fetch content endpoint.\n \n     See: https://diaspora.github.io/diaspora_federation/federation/fetching.html\n     \"\"\"\n     return \"https://%s/fetch/%s/%s\" % (domain, entity_type, guid)\n \n \n def get_public_endpoint(id: str) -> str:\n     \"\"\"Get remote endpoint for delivering public payloads.\"\"\"\n     _username, domain = id.split(\"@\")\n     return \"https://%s/receive/public\" % domain\n \n \n def get_private_endpoint(id: str, guid: str) -> str:\n     \"\"\"Get remote endpoint for delivering private payloads.\"\"\"\n     _username, domain = id.split(\"@\")\n     return \"https://%s/receive/users/%s\" % (domain, guid)\n ", "input_code": "def retrieve_and_parse_diaspora_webfinger(handle):\n\"\"\"\nRetrieve a and parse a remote Diaspora webfinger document.\n\n:arg handle: Remote handle to retrieve\n:returns: dict\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def retrieve_and_parse_diaspora_webfinger(handle):\n    \"\"\"\n    Retrieve a and parse a remote Diaspora webfinger document.\n\n    :arg handle: Remote handle to retrieve\n    :returns: dict\n    \"\"\"\n    document = try_retrieve_webfinger_document(handle)\n    if document:\n        return parse_diaspora_webfinger(document)\n    host = handle.split(\"@\")[1]\n    hostmeta = retrieve_diaspora_host_meta(host)\n    if not hostmeta:\n        return None\n    url = hostmeta.find_link(rels=\"lrdd\").template.replace(\"{uri}\", quote(handle))\n    document, code, exception = fetch_document(url)\n    if exception:\n        return None\n    return parse_diaspora_webfinger(document)", "signature": "def retrieve_and_parse_diaspora_webfinger(handle):", "completion_path": "federation/utils/diaspora.py"}
{"ce_id": "630629e252e177c0ba46a0d6", "namespace": "630629e252e177c0ba46a0d6", "namespace_real": "federation.utils.diaspora.retrieve_diaspora_host_meta", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "retrieve_diaspora_host_meta", "contexts_above": "import json\nimport logging\nimport xml\nfrom typing import Callable, Dict\nfrom urllib.parse import quote\n\nfrom lxml import html\nfrom xrd import XRD\n\nfrom federation.inbound import handle_receive\nfrom federation.types import RequestType\nfrom federation.utils.network import fetch_document, try_retrieve_webfinger_document\nfrom federation.utils.text import validate_handle\n\nlogger = logging.getLogger(\"federation\")\n\n\ndef fetch_public_key(handle):\n    \"\"\"Fetch public key over the network.\n\n    :param handle: Remote handle to retrieve public key for.\n    :return: Public key in str format from parsed profile.\n    \"\"\"\n    profile = retrieve_and_parse_profile(handle)\n    return profile.public_key\n\n\ndef parse_diaspora_webfinger(document: str) -> Dict:\n    \"\"\"\n    Parse Diaspora webfinger which is either in JSON format (new) or XRD (old).\n\n    https://diaspora.github.io/diaspora_federation/discovery/webfinger.html\n    \"\"\"\n    webfinger = {\n        \"hcard_url\": None,\n    }\n    # noinspection PyBroadException\n    try:\n        doc = json.loads(document)\n        for link in doc[\"links\"]:\n            if link[\"rel\"] == \"http://microformats.org/profile/hcard\":\n                webfinger[\"hcard_url\"] = link[\"href\"]\n                break\n        else:\n            logger.warning(\"parse_diaspora_webfinger: found JSON webfinger but it has no hcard href\")\n            raise ValueError\n    except Exception:\n        try:\n            xrd = XRD.parse_xrd(document)\n            webfinger[\"hcard_url\"] = xrd.find_link(rels=\"http://microformats.org/profile/hcard\").href\n        except (xml.parsers.expat.ExpatError, TypeError):\n            logger.warning(\"parse_diaspora_webfinger: found XML webfinger but it fails to parse\")\n            pass\n    return webfinger\n\n\ndef retrieve_diaspora_hcard(handle):\n    \"\"\"\n    Retrieve a remote Diaspora hCard document.\n\n    :arg handle: Remote handle to retrieve\n    :return: str (HTML document)\n    \"\"\"\n    webfinger = retrieve_and_parse_diaspora_webfinger(handle)\n    document, code, exception = fetch_document(webfinger.get(\"hcard_url\"))\n    if exception:\n        return None\n    return document\n\n\ndef retrieve_and_parse_diaspora_webfinger(handle):\n    \"\"\"\n    Retrieve a and parse a remote Diaspora webfinger document.\n\n    :arg handle: Remote handle to retrieve\n    :returns: dict\n    \"\"\"\n    document = try_retrieve_webfinger_document(handle)\n    if document:\n        return parse_diaspora_webfinger(document)\n    host = handle.split(\"@\")[1]\n    hostmeta = retrieve_diaspora_host_meta(host)\n    if not hostmeta:\n        return None\n    url = hostmeta.find_link(rels=\"lrdd\").template.replace(\"{uri}\", quote(handle))\n    document, code, exception = fetch_document(url)\n    if exception:\n        return None\n    return parse_diaspora_webfinger(document)\n\n", "contexts_below": "\n def _get_element_text_or_none(document, selector):\n     \"\"\"\n     Using a CSS selector, get the element and return the text, or None if no element.\n \n     :arg document: ``HTMLElement`` document\n     :arg selector: CSS selector\n     :returns: str or None\n     \"\"\"\n     element = document.cssselect(selector)\n     if element:\n         return element[0].text\n     return None\n \n \n def _get_element_attr_or_none(document, selector, attribute):\n     \"\"\"\n     Using a CSS selector, get the element and return the given attribute value, or None if no element.\n \n     Args:\n         document (HTMLElement) - HTMLElement document\n         selector (str) - CSS selector\n         attribute (str) - The attribute to get from the element\n     \"\"\"\n     element = document.cssselect(selector)\n     if element:\n         return element[0].get(attribute)\n     return None\n \n \n def parse_profile_from_hcard(hcard: str, handle: str):\n     \"\"\"\n     Parse all the fields we can from a hCard document to get a Profile.\n \n     :arg hcard: HTML hcard document (str)\n     :arg handle: User handle in username@domain.tld format\n     :returns: ``federation.entities.diaspora.entities.DiasporaProfile`` instance\n     \"\"\"\n     from federation.entities.diaspora.entities import DiasporaProfile  # Circulars\n     doc = html.fromstring(hcard)\n     profile = DiasporaProfile(\n         name=_get_element_text_or_none(doc, \".fn\"),\n         image_urls={\n             \"small\": _get_element_attr_or_none(doc, \".entity_photo_small .photo\", \"src\"),\n             \"medium\": _get_element_attr_or_none(doc, \".entity_photo_medium .photo\", \"src\"),\n             \"large\": _get_element_attr_or_none(doc, \".entity_photo .photo\", \"src\"),\n         },\n         public=True,\n         id=handle,\n         handle=handle,\n         guid=_get_element_text_or_none(doc, \".uid\"),\n         public_key=_get_element_text_or_none(doc, \".key\"),\n         username=handle.split('@')[0],\n         _source_protocol=\"diaspora\",\n     )\n     return profile\n \n \n def retrieve_and_parse_content(\n         id: str, guid: str, handle: str, entity_type: str, sender_key_fetcher: Callable[[str], str]=None):\n     \"\"\"Retrieve remote content and return an Entity class instance.\n \n     This is basically the inverse of receiving an entity. Instead, we fetch it, then call \"handle_receive\".\n \n     :param sender_key_fetcher: Function to use to fetch sender public key. If not given, network will be used\n         to fetch the profile and the key. Function must take handle as only parameter and return a public key.\n     :returns: Entity object instance or ``None``\n     \"\"\"\n     if not validate_handle(handle):\n         return\n     _username, domain = handle.split(\"@\")\n     url = get_fetch_content_endpoint(domain, entity_type.lower(), guid)\n     document, status_code, error = fetch_document(url)\n     if status_code == 200:\n         request = RequestType(body=document)\n         _sender, _protocol, entities = handle_receive(request, sender_key_fetcher=sender_key_fetcher)\n         if len(entities) > 1:\n             logger.warning(\"retrieve_and_parse_content - more than one entity parsed from remote even though we\"\n                            \"expected only one! ID %s\", guid)\n         if entities:\n             return entities[0]\n         return\n     elif status_code == 404:\n         logger.warning(\"retrieve_and_parse_content - remote content %s not found\", guid)\n         return\n     if error:\n         raise error\n     raise Exception(\"retrieve_and_parse_content - unknown problem when fetching document: %s, %s, %s\" % (\n         document, status_code, error,\n     ))\n \n \n def retrieve_and_parse_profile(handle):\n     \"\"\"\n     Retrieve the remote user and return a Profile object.\n \n     :arg handle: User handle in username@domain.tld format\n     :returns: ``federation.entities.Profile`` instance or None\n     \"\"\"\n     hcard = retrieve_diaspora_hcard(handle)\n     if not hcard:\n         return None\n     profile = parse_profile_from_hcard(hcard, handle)\n     try:\n         profile.validate()\n     except ValueError as ex:\n         logger.warning(\"retrieve_and_parse_profile - found profile %s but it didn't validate: %s\",\n                        profile, ex)\n         return None\n     return profile\n \n \n def get_fetch_content_endpoint(domain, entity_type, guid):\n     \"\"\"Get remote fetch content endpoint.\n \n     See: https://diaspora.github.io/diaspora_federation/federation/fetching.html\n     \"\"\"\n     return \"https://%s/fetch/%s/%s\" % (domain, entity_type, guid)\n \n \n def get_public_endpoint(id: str) -> str:\n     \"\"\"Get remote endpoint for delivering public payloads.\"\"\"\n     _username, domain = id.split(\"@\")\n     return \"https://%s/receive/public\" % domain\n \n \n def get_private_endpoint(id: str, guid: str) -> str:\n     \"\"\"Get remote endpoint for delivering private payloads.\"\"\"\n     _username, domain = id.split(\"@\")\n     return \"https://%s/receive/users/%s\" % (domain, guid)\n ", "input_code": "def retrieve_diaspora_host_meta(host):\n\"\"\"\nRetrieve a remote Diaspora host-meta document.\n\n:arg host: Host to retrieve from\n:returns: ``XRD`` instance\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def retrieve_diaspora_host_meta(host):\n    \"\"\"\n    Retrieve a remote Diaspora host-meta document.\n\n    :arg host: Host to retrieve from\n    :returns: ``XRD`` instance\n    \"\"\"\n    document, code, exception = fetch_document(host=host, path=\"/.well-known/host-meta\")\n    if exception:\n        return None\n    xrd = XRD.parse_xrd(document)\n    return xrd", "signature": "def retrieve_diaspora_host_meta(host):", "completion_path": "federation/utils/diaspora.py"}
{"ce_id": "630629e752e177c0ba46a0fb", "namespace": "630629e752e177c0ba46a0fb", "namespace_real": "federation.utils.network.send_document", "real_proj_path": "jaywink---federation/", "type": "function", "class_name": null, "function_name": "send_document", "contexts_above": "import calendar\nimport datetime\nimport logging\nimport re\nimport socket\nfrom typing import Optional, Dict\nfrom urllib.parse import quote\nfrom uuid import uuid4\n\nimport requests\nfrom requests.exceptions import RequestException, HTTPError, SSLError\nfrom requests.exceptions import ConnectionError\nfrom requests.structures import CaseInsensitiveDict\n\nfrom federation import __version__\n\nlogger = logging.getLogger(\"federation\")\n\nUSER_AGENT = \"python/federation/%s\" % __version__\n\n\ndef fetch_content_type(url: str) -> Optional[str]:\n    \"\"\"\n    Fetch the HEAD of the remote url to determine the content type.\n    \"\"\"\n    try:\n        response = requests.head(url, headers={'user-agent': USER_AGENT}, timeout=10)\n    except RequestException as ex:\n        logger.warning(\"fetch_content_type - %s when fetching url %s\", ex, url)\n    else:\n        return response.headers.get('Content-Type')\n\n\ndef fetch_document(url=None, host=None, path=\"/\", timeout=10, raise_ssl_errors=True, extra_headers=None, **kwargs):\n    \"\"\"Helper method to fetch remote document.\n\n    Must be given either the ``url`` or ``host``.\n    If ``url`` is given, only that will be tried without falling back to http from https.\n    If ``host`` given, `path` will be added to it. Will fall back to http on non-success status code.\n\n    :arg url: Full url to fetch, including protocol\n    :arg host: Domain part only without path or protocol\n    :arg path: Path without domain (defaults to \"/\")\n    :arg timeout: Seconds to wait for response (defaults to 10)\n    :arg raise_ssl_errors: Pass False if you want to try HTTP even for sites with SSL errors (default True)\n    :arg extra_headers: Optional extra headers dictionary to add to requests\n    :arg kwargs holds extra args passed to requests.get\n    :returns: Tuple of document (str or None), status code (int or None) and error (an exception class instance or None)\n    :raises ValueError: If neither url nor host are given as parameters\n    \"\"\"\n    if not url and not host:\n        raise ValueError(\"Need url or host.\")\n\n    logger.debug(\"fetch_document: url=%s, host=%s, path=%s, timeout=%s, raise_ssl_errors=%s\",\n                 url, host, path, timeout, raise_ssl_errors)\n    headers = {'user-agent': USER_AGENT}\n    if extra_headers:\n        headers.update(extra_headers)\n    if url:\n        # Use url since it was given\n        logger.debug(\"fetch_document: trying %s\", url)\n        try:\n            response = requests.get(url, timeout=timeout, headers=headers, **kwargs)\n            logger.debug(\"fetch_document: found document, code %s\", response.status_code)\n            response.raise_for_status()\n            return response.text, response.status_code, None\n        except RequestException as ex:\n            logger.debug(\"fetch_document: exception %s\", ex)\n            return None, None, ex\n    # Build url with some little sanitizing\n    host_string = host.replace(\"http://\", \"\").replace(\"https://\", \"\").strip(\"/\")\n    path_string = path if path.startswith(\"/\") else \"/%s\" % path\n    url = \"https://%s%s\" % (host_string, path_string)\n    logger.debug(\"fetch_document: trying %s\", url)\n    try:\n        response = requests.get(url, timeout=timeout, headers=headers)\n        logger.debug(\"fetch_document: found document, code %s\", response.status_code)\n        response.raise_for_status()\n        return response.text, response.status_code, None\n    except (HTTPError, SSLError, ConnectionError) as ex:\n        if isinstance(ex, SSLError) and raise_ssl_errors:\n            logger.debug(\"fetch_document: exception %s\", ex)\n            return None, None, ex\n        # Try http then\n        url = url.replace(\"https://\", \"http://\")\n        logger.debug(\"fetch_document: trying %s\", url)\n        try:\n            response = requests.get(url, timeout=timeout, headers=headers)\n            logger.debug(\"fetch_document: found document, code %s\", response.status_code)\n            response.raise_for_status()\n            return response.text, response.status_code, None\n        except RequestException as ex:\n            logger.debug(\"fetch_document: exception %s\", ex)\n            return None, None, ex\n    except RequestException as ex:\n        logger.debug(\"fetch_document: exception %s\", ex)\n        return None, None, ex\n\n\ndef fetch_host_ip(host: str) -> str:\n    \"\"\"\n    Fetch ip by host\n    \"\"\"\n    try:\n        ip = socket.gethostbyname(host)\n    except socket.gaierror:\n        return ''\n\n    return ip\n\n\ndef fetch_file(url: str, timeout: int = 30, extra_headers: Dict = None) -> str:\n    \"\"\"\n    Download a file with a temporary name and return the name.\n    \"\"\"\n    headers = {'user-agent': USER_AGENT}\n    if extra_headers:\n        headers.update(extra_headers)\n    response = requests.get(url, timeout=timeout, headers=headers, stream=True)\n    response.raise_for_status()\n    name = f\"/tmp/{str(uuid4())}\"\n    with open(name, \"wb\") as f:\n        for chunk in response.iter_content(chunk_size=8192):\n            f.write(chunk)\n    return name\n\n\ndef parse_http_date(date):\n    \"\"\"\n    Parse a date format as specified by HTTP RFC7231 section 7.1.1.1.\n\n    The three formats allowed by the RFC are accepted, even if only the first\n    one is still in widespread use.\n\n    Return an integer expressed in seconds since the epoch, in UTC.\n\n    Implementation copied from Django.\n    https://github.com/django/django/blob/master/django/utils/http.py#L157\n    License: BSD 3-clause\n    \"\"\"\n    MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec'.split()\n    __D = r'(?P<day>\\d{2})'\n    __D2 = r'(?P<day>[ \\d]\\d)'\n    __M = r'(?P<mon>\\w{3})'\n    __Y = r'(?P<year>\\d{4})'\n    __Y2 = r'(?P<year>\\d{2})'\n    __T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'\n    RFC1123_DATE = re.compile(r'^\\w{3}, %s %s %s %s GMT$' % (__D, __M, __Y, __T))\n    RFC850_DATE = re.compile(r'^\\w{6,9}, %s-%s-%s %s GMT$' % (__D, __M, __Y2, __T))\n    ASCTIME_DATE = re.compile(r'^\\w{3} %s %s %s %s$' % (__M, __D2, __T, __Y))\n    # email.utils.parsedate() does the job for RFC1123 dates; unfortunately\n    # RFC7231 makes it mandatory to support RFC850 dates too. So we roll\n    # our own RFC-compliant parsing.\n    for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:\n        m = regex.match(date)\n        if m is not None:\n            break\n    else:\n        raise ValueError(\"%r is not in a valid HTTP date format\" % date)\n    try:\n        year = int(m.group('year'))\n        if year < 100:\n            if year < 70:\n                year += 2000\n            else:\n                year += 1900\n        month = MONTHS.index(m.group('mon').lower()) + 1\n        day = int(m.group('day'))\n        hour = int(m.group('hour'))\n        min = int(m.group('min'))\n        sec = int(m.group('sec'))\n        result = datetime.datetime(year, month, day, hour, min, sec)\n        return calendar.timegm(result.utctimetuple())\n    except Exception as exc:\n        raise ValueError(\"%r is not a valid date\" % date) from exc\n\n", "contexts_below": "\n def try_retrieve_webfinger_document(handle: str) -> Optional[str]:\n     \"\"\"\n     Try to retrieve an RFC7033 webfinger document. Does not raise if it fails.\n     \"\"\"\n     try:\n         host = handle.split(\"@\")[1]\n     except AttributeError:\n         logger.warning(\"retrieve_webfinger_document: invalid handle given: %s\", handle)\n         return None\n     document, code, exception = fetch_document(\n         host=host, path=\"/.well-known/webfinger?resource=acct:%s\" % quote(handle),\n     )\n     if exception:\n         logger.debug(\"retrieve_webfinger_document: failed to fetch webfinger document: %s, %s\", code, exception)\n     return document\n ", "input_code": "def send_document(url, data, timeout=10, method='post', *args, **kwargs):\n\"\"\"\nHelper method to send a document via POST.\n\nAdditional ``*args`` and ``**kwargs`` will be passed on to ``requests.post``.\n\n:arg url: Full url to send to, including protocol\n:arg data: Dictionary (will be form-encoded), bytes, or file-like object to send in the body\n:arg timeout: Seconds to wait for response (defaults to 10)\n:arg method: Method to use, defaults to post\n:returns: Tuple of status code (int or None) and error (exception class instance or None)\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def send_document(url, data, timeout=10, method=\"post\", *args, **kwargs):\n    \"\"\"Helper method to send a document via POST.\n\n    Additional ``*args`` and ``**kwargs`` will be passed on to ``requests.post``.\n\n    :arg url: Full url to send to, including protocol\n    :arg data: Dictionary (will be form-encoded), bytes, or file-like object to send in the body\n    :arg timeout: Seconds to wait for response (defaults to 10)\n    :arg method: Method to use, defaults to post\n    :returns: Tuple of status code (int or None) and error (exception class instance or None)\n    \"\"\"\n    logger.debug(\"send_document: url=%s, data=%s, timeout=%s, method=%s\", url, data, timeout, method)\n    if not method:\n        method = \"post\"\n    headers = CaseInsensitiveDict({\n        'User-Agent': USER_AGENT,\n    })\n    if \"headers\" in kwargs:\n        # Update from kwargs\n        headers.update(kwargs.get(\"headers\"))\n    kwargs.update({\n        \"data\": data, \"timeout\": timeout, \"headers\": headers\n    })\n    request_func = getattr(requests, method)\n    try:\n        response = request_func(url, *args, **kwargs)\n        logger.debug(\"send_document: response status code %s\", response.status_code)\n        return response.status_code, None\n    # TODO support rate limit 429 code\n    except RequestException as ex:\n        logger.debug(\"send_document: exception %s\", ex)\n        return None, ex", "signature": "def send_document(url, data, timeout=10, method='post', *args, **kwargs):", "completion_path": "federation/utils/network.py"}
{"ce_id": "6306091073426c38ae68acac", "namespace": "6306091073426c38ae68acac", "namespace_real": "infrared.core.utils.dict_utils.dict_insert", "real_proj_path": "redhat-openstack---infrared/", "type": "function", "class_name": null, "function_name": "dict_insert", "contexts_above": "\"\"\"This module provides helper methods for dict merging and dict insertion. \"\"\"\n\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n", "contexts_below": "\n class ConflictResolver(object):\n     \"\"\"Resolves conflicts while merging dicts. \"\"\"\n \n     @staticmethod\n     def none_resolver(first, second, key):\n         \"\"\"Replaces value in first dict only if it is None.\n \n         Appends second value into the first in type is list.\n         \"\"\"\n \n         # tyr to merge lists first\n         if isinstance(first[key], list):\n             if isinstance(second[key], list):\n                 first[key].extend(second[key])\n             elif second[key] is not None:\n                 first[key].append(second[key])\n \n         if key not in first or first[key] is None:\n             first[key] = second[key]\n \n     @staticmethod\n     def greedy_resolver(first, second, key):\n         \"\"\"Replace always first with the value from second \"\"\"\n         first[key] = second[key]\n \n     @staticmethod\n     def unique_append_list_resolver(first, second, key):\n         \"\"\"Merges first and second lists \"\"\"\n         if isinstance(first[key], list) and isinstance(second[key], list):\n             for item in second[key]:\n                 if item not in first[key]:\n                     first[key].append(item)\n         else:\n             return ConflictResolver.greedy_resolver(first, second, key)\n \n \n def dict_merge(first, second,\n                conflict_resolver=ConflictResolver.greedy_resolver):\n     \"\"\"Merge `second` dict into `first`.\n \n     :param first: Modified dict\n     :param second: Modifier dict\n     :param conflict_resolver: Function that resolves a merge between 2 values\n         when one of them isn't a dict\n     \"\"\"\n     for key in second:\n         if key in first:\n             if isinstance(first[key], dict) and isinstance(second[key], dict):\n                 dict_merge(first[key], second[key],\n                            conflict_resolver=conflict_resolver)\n             else:\n                 # replace first value with the value from second\n                 conflict_resolver(first, second, key)\n         else:\n             try:\n                 first[key] = second[key]\n             except TypeError as e:\n                 LOG.error(\"dict_merge(%s, %s) failed on: %s\" % (first, second, key))\n                 raise e\n ", "input_code": "def dict_insert(dic, val, key, *keys):\n\"\"\"\ninsert a value of a nested key into a dictionary\n\nto insert value for a nested key, all ancestor keys should be given as\nmethod's arguments\n\nexample:\n  dict_insert({}, 'val', 'key1.key2'.split('.'))\n\n:param dic: a dictionary object to insert the nested key value into\n:param val: a value to insert to the given dictionary\n:param key: first key in a chain of key that will store the value\n:param keys: sub keys in the keys chain\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def dict_insert(dic, val, key, *keys):\n    \"\"\"insert a value of a nested key into a dictionary\n\n    to insert value for a nested key, all ancestor keys should be given as\n    method's arguments\n\n    example:\n      dict_insert({}, 'val', 'key1.key2'.split('.'))\n\n    :param dic: a dictionary object to insert the nested key value into\n    :param val: a value to insert to the given dictionary\n    :param key: first key in a chain of key that will store the value\n    :param keys: sub keys in the keys chain\n    \"\"\"\n    if dic is None:\n        return\n\n    if not keys:\n        if isinstance(dic.get(key, None), dict) and isinstance(val, dict):\n            dict_merge(dic[key], val)\n        else:\n            dic[key] = val\n        return\n\n    dict_insert(dic.setdefault(key, {}), val, *keys)", "signature": "def dict_insert(dic, val, key, *keys):", "completion_path": "infrared/core/utils/dict_utils.py"}
{"ce_id": "6306091a73426c38ae68acc8", "namespace": "6306091a73426c38ae68acc8", "namespace_real": "tests.test_complex_types.list_of_file_names", "real_proj_path": "redhat-openstack---infrared/", "type": "function", "class_name": null, "function_name": "list_of_file_names", "contexts_above": "import os\n\nimport pytest\n\nfrom infrared.core.cli import cli\nfrom infrared.core.utils import exceptions\n\n\n@pytest.fixture\ndef list_value_type():\n    \"\"\"\n    Create a new list value complex type\n    \"\"\"\n    return cli.ListValue(\"test\", [os.getcwd(), ], 'cmd', None)\n\n\n@pytest.fixture\ndef dict_type():\n    \"\"\"Create a new IniType complex type\n    \"\"\"\n    return cli.Dict(\"TestDict\", None, None, None)\n\n\n@pytest.fixture\ndef nested_dict():\n    \"\"\"Create a new NestedDict complex type\n    \"\"\"\n    return cli.NestedDict(\"TestNestedDict\", None, None, None)\n\n\n@pytest.fixture\ndef nested_list():\n    \"\"\"Create a new NestedList complex type\n    \"\"\"\n    return cli.NestedList(\"TestNestedList\", None, None, None)\n\n\n@pytest.fixture\ndef flag_type():\n    \"\"\"Create a new Flag complex type\n    \"\"\"\n    return cli.Flag(\"test\", None, None, None)\n\n\n@pytest.mark.parametrize(\n    \"test_value,expected\", [\n        (\"item1,item2\", [\"item1\", \"item2\"]),\n        (\"item1\", [\"item1\", ]),\n        (\"item1,item2,item3,\", [\"item1\", \"item2\", \"item3\", ''])])\ndef test_list_value_resolve(list_value_type, test_value, expected):\n    \"\"\"\n    Verifies the string value can be resolved to the list.\n    \"\"\"\n    assert expected == list_value_type.resolve(test_value)\n\n\n@pytest.mark.parametrize(\"input_value, expected_return\", [\n    (['k1=v1'], {'k1': 'v1'}),\n    (['l1.s1.k1=v1'], {'l1': {'s1': {'k1': 'v1'}}}),\n    ([' s1.k1=v1 '], {'s1': {'k1': 'v1'}}),\n    (['s1.k1=v1', 's1.k2=v2', 's2.k3=v3'],\n     {'s1': {'k1': 'v1', 'k2': 'v2'}, 's2': {'k3': 'v3'}}),\n    ('k1=v1', {'k1': 'v1'}),\n    ('s1.k1=v1', {'s1': {'k1': 'v1'}}),\n    (' s1.k1=v1 ', {'s1': {'k1': 'v1'}}),\n    ('s1.k1=v1,s1.k2=v2,s2.k3=v3',\n     {'s1': {'k1': 'v1', 'k2': 'v2'}, 's2': {'k3': 'v3'}}),\n    ('s1.k1=v1, s1.l2.k2=v2, s2.k3=v3',\n     {'s1': {'k1': 'v1', 'l2': {'k2': 'v2'}}, 's2': {'k3': 'v3'}}),\n])\ndef test_nested_dict_resolve(input_value, expected_return, nested_dict):\n    \"\"\"Verifies the return value of 'resolve' method in 'NestedDict' Complex type\n    \"\"\"\n    assert nested_dict.resolve(input_value) == expected_return\n\n\n@pytest.mark.parametrize(\"input_value, expected_return\", [\n    ([\"k1=v1\",\"k2=v2\"], [{\"k1\":\"v1\"},{\"k2\":\"v2\"}])\n])\ndef test_nested_list_resolve(input_value, expected_return, nested_list):\n    \"\"\"Verifies the return value of 'resolve' method in 'NestedList'\n    Complex type\"\"\"\n    assert nested_list.resolve(input_value) == expected_return\n\n\n@pytest.mark.parametrize(\"input_value, expected_return\", [\n    (['k1=v1'], {'k1': 'v1'}),\n    (['l1.s1.k1=v1'], {'l1.s1.k1': 'v1'}),\n    ([' s1.k1=v1 '], {'s1.k1': 'v1'}),\n    (['s1.k1=v1', 's1.k2=v2', 's2.k3=v3'],\n     {'s1.k1': 'v1', 's1.k2': 'v2', 's2.k3': 'v3'}),\n    ('k1=v1', {'k1': 'v1'}),\n])\ndef test_dict_type_resolve(input_value, expected_return, dict_type):\n    \"\"\"Verifies the return value of 'resolve' method in 'IniType' Complex type\n    \"\"\"\n    assert dict_type.resolve(input_value) == expected_return\n\n\n@pytest.mark.parametrize(\"input_value, expected_return\", [\n    ('test', True),\n])\ndef test_flag_type_resolve(input_value, expected_return, flag_type):\n    \"\"\"Verifies the return value of 'resolve' method in 'Flag' Complex type\n    \"\"\"\n    assert flag_type.resolve(input_value) == expected_return\n\n\n@pytest.fixture(scope=\"module\")\ndef file_root_dir(tmpdir_factory):\n    \"\"\"Prepares the testing dirs for file tests\"\"\"\n    root_dir = tmpdir_factory.mktemp('complex_file_dir')\n\n    for file_path in ['file1.yml',\n                      'arg/name/file2',\n                      'defaults/arg/name/file.yml',\n                      'defaults/arg/name/file2',\n                      'vars/arg/name/file1.yml',\n                      'vars/arg/name/file3.yml',\n                      'vars/arg/name/nested/file4.yml']:\n        root_dir.join(file_path).ensure()\n\n    return root_dir\n\n\n@pytest.fixture(scope=\"module\")\ndef dir_root_dir(tmpdir_factory):\n    \"\"\"Prepares the testing dirs for dir tests\"\"\"\n    root_dir = tmpdir_factory.mktemp('complex_dir')\n\n    for dir_path in ['dir0/1.file',\n                     'arg/name/dir1/1.file',\n                     'vars/arg/name/dir2/1.file',\n                     'defaults/arg/name/dir3/1.file']:\n        # creating a file will create a dir\n        root_dir.join(dir_path).ensure()\n\n    return root_dir\n\n\ndef create_file_type(root_dir, type_class):\n    return type_class(\"arg-name\",\n                      (root_dir.join('vars').strpath,\n                       root_dir.join('defaults').strpath),\n                      None,\n                      None)\n\n\n@pytest.fixture\ndef file_type(file_root_dir, request):\n    return create_file_type(file_root_dir, request.param)\n\n\n@pytest.fixture\ndef dir_type(dir_root_dir, request):\n    return create_file_type(dir_root_dir, request.param)\n\n\n@pytest.mark.parametrize('file_type', [cli.FileType], indirect=True)\ndef test_file_type_resolve(file_root_dir, file_type, monkeypatch):\n    \"\"\"Verifies the file complex type\"\"\"\n    # change cwd to the temp dir\n    monkeypatch.setattr(\"os.getcwd\", lambda: file_root_dir.strpath)\n\n    assert file_type.resolve('file1') == file_root_dir.join(\n        'file1.yml').strpath\n    assert file_type.resolve('file2') == file_root_dir.join(\n        'arg/name/file2').strpath\n    with pytest.raises(exceptions.IRFileNotFoundException):\n        file_type.resolve('file.yml')\n\n\n@pytest.mark.parametrize('file_type', [cli.VarFileType], indirect=True)\ndef test_var_file_type_resolve(file_root_dir, file_type, monkeypatch):\n    \"\"\"Verifies the file complex type\"\"\"\n    # change cwd to the temp dir\n    monkeypatch.setattr(\"os.getcwd\", lambda: file_root_dir.strpath)\n\n    assert file_type.resolve('file1') == file_root_dir.join(\n        'file1.yml').strpath\n    assert file_type.resolve(\n        os.path.abspath('file1')) == file_root_dir.join('file1.yml').strpath\n    assert file_type.resolve('file2') == file_root_dir.join(\n        'arg/name/file2').strpath\n    assert file_type.resolve('file.yml') == file_root_dir.join(\n        'defaults/arg/name/file.yml').strpath\n    assert file_type.resolve('file3') == file_root_dir.join(\n        'vars/arg/name/file3.yml').strpath\n    assert file_type.resolve('nested/file4.yml') == file_root_dir.join(\n        'vars/arg/name/nested/file4.yml').strpath\n\n    with pytest.raises(exceptions.IRFileNotFoundException):\n        file_type.resolve('file5')\n\n\n@pytest.mark.parametrize('file_type', [cli.ListFileType], indirect=True)\ndef test_list_of_var_files(file_root_dir, file_type, monkeypatch):\n    \"\"\"Verifies the list of files\"\"\"\n    monkeypatch.setattr(\"os.getcwd\", lambda: file_root_dir.strpath)\n\n    assert file_type.resolve('file1') == [\n        file_root_dir.join('file1.yml').strpath]\n    assert file_type.resolve('file1,file2') == [\n        file_root_dir.join('file1.yml').strpath,\n        file_root_dir.join('arg/name/file2').strpath]\n    assert file_type.resolve('file3.yml,vars/arg/name/file3') == [\n        file_root_dir.join('vars/arg/name/file3.yml').strpath,\n        file_root_dir.join('vars/arg/name/file3.yml').strpath]\n\n\n@pytest.mark.parametrize('dir_type', [cli.VarDirType], indirect=True)\ndef test_dir_type_resolve(dir_root_dir, dir_type, monkeypatch):\n    \"\"\"Verifies the file complex type\"\"\"\n    # change cwd to the temp dir\n    monkeypatch.setattr(\"os.getcwd\", lambda: dir_root_dir.strpath)\n\n    assert dir_type.resolve('dir0') == dir_root_dir.join(\n        'dir0/').strpath\n    assert dir_type.resolve('dir1') == dir_root_dir.join(\n        'arg/name/dir1/').strpath\n    assert dir_type.resolve('dir2') == dir_root_dir.join(\n        'vars/arg/name/dir2/').strpath\n    assert dir_type.resolve('dir3') == dir_root_dir.join(\n        'defaults/arg/name/dir3/').strpath\n    with pytest.raises(exceptions.IRFileNotFoundException):\n        dir_type.resolve('dir4')\n\n", "contexts_below": "\n def test_list_of_file_names_values_auto_propagation():\n     expected = [\"task1\", \"task2\", \"task3\"]\n     settings_dirs = [\"\", \"\", 'tests/example']\n     spec_option = {'lookup_dir': 'post_tasks'}\n \n     complex_action = list_of_file_names(settings_dirs, spec_option)\n     allowed_values = complex_action.get_allowed_values()\n \n     assert expected.sort() == allowed_values.sort()\n \n \n def test_list_of_file_names_resolve():\n     expected = [\"task2\", \"task3\"]\n     settings_dirs = [\"\", \"\", 'tests/example/']\n     spec_option = {'lookup_dir': 'post_tasks'}\n     value = \"task2,task3\"\n \n     complex_action = list_of_file_names(settings_dirs, spec_option)\n     values = complex_action.resolve(value)\n     print(values)\n \n     assert expected.sort() == values.sort()\n ", "input_code": "def list_of_file_names(settings_dirs, spec_option):\n\"\"\"\nCreate a new IniType complex type\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def list_of_file_names(settings_dirs, spec_option):\n    \"\"\"Create a new IniType complex type\n    \"\"\"\n    return cli.ListOfFileNames(\"ListOfFileNames\", settings_dirs, None,\n                               spec_option)", "signature": "def list_of_file_names(settings_dirs, spec_option):", "completion_path": "tests/test_complex_types.py"}
{"ce_id": "6306091b73426c38ae68acd7", "namespace": "6306091b73426c38ae68acd7", "namespace_real": "infrared.core.services.__init__.ansible_config_manager", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "__init__", "function_name": "ansible_config_manager", "contexts_above": "\"\"\"Service locator for the IR services\n\nStores and resolves all the dependencies for the services.\n\"\"\"\nimport os\nimport sys\n\nfrom infrared.core.services import ansible_config\nfrom infrared.core.services import execution_logger\nfrom infrared.core.services import plugins\nfrom infrared.core.services import workspaces\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n\nclass ServiceName(object):\n    \"\"\"Holds the supported services names. \"\"\"\n    WORKSPACE_MANAGER = \"workspace_manager\"\n    PLUGINS_MANAGER = \"plugins_manager\"\n    ANSIBLE_CONFIG_MANAGER = \"ansible_config_manager\"\n    EXECUTION_LOGGER_MANAGER = \"execution_logger_manager\"\n\n\nclass CoreSettings(object):\n    \"\"\"Holds the main settings for the infrared. \"\"\"\n\n    def __init__(self, workspaces_base_folder=None,\n                 plugins_conf_file=None,\n                 install_plugin_at_start=True,\n                 plugins_base_folder=None):\n        \"\"\"Constructor.\n\n        :param workspaces_base_folder: folder where the\n               workspace will be stored\n        :param plugins_conf_file: location of the plugins.ini file with the\n               list of all plugins and types.\n        :param install_plugin_at_start: specifies whether all the plugins\n               should be installed on ir start. Skip installation may be\n               required for unit tests, for example.\n        \"\"\"\n\n        self.infrared_home = os.path.abspath(os.environ.get(\n            \"IR_HOME\", os.path.join(os.path.expanduser(\"~\"), '.infrared')))\n\n        # todo(obaranov) replace .workspaces to workspaces and .plugins.ini to\n        # todo(obaranov) plugins.ini once IR is packaged as pip\n        self.plugins_conf_file = plugins_conf_file or os.path.join(\n            self.infrared_home, '.plugins.ini')\n        self.workspaces_base_folder = workspaces_base_folder or os.path.join(\n            self.infrared_home, '.workspaces')\n        self.install_plugin_at_start = install_plugin_at_start\n        self.plugins_base_folder = plugins_base_folder or os.path.join(\n            self.infrared_home, 'plugins')\n\n\nclass CoreServices(object):\n    \"\"\"Holds and configures all the required for core services. \"\"\"\n\n    _SERVICES = {}\n\n    @classmethod\n    def setup(cls, core_settings=None):\n        \"\"\"Creates configuration from file or from defaults.\n\n        :param core_settings: the instance of the CoreSettings class with the\n        desired settings. If None is provided then the default settings\n        will be used.\n        \"\"\"\n\n        if core_settings is None:\n            core_settings = CoreSettings()\n\n        # create workspace manager\n        if ServiceName.WORKSPACE_MANAGER not in cls._SERVICES:\n            cls.register_service(ServiceName.WORKSPACE_MANAGER,\n                                 workspaces.WorkspaceManager(\n                                     core_settings.workspaces_base_folder))\n\n        # create plugins manager\n        if ServiceName.PLUGINS_MANAGER not in cls._SERVICES:\n            # A temporary WH to skip all plugins installation on first InfraRed\n            # command if the command is 'infrared plugin add'.\n            # Should be removed together with auto plugins installation\n            # mechanism.\n            skip_plugins_install = {'plugin', 'add'}.issubset(sys.argv)\n            cls.register_service(\n                ServiceName.PLUGINS_MANAGER, plugins.InfraredPluginManager(\n                    plugins_conf=core_settings.plugins_conf_file,\n                    install_plugins=(core_settings.install_plugin_at_start and\n                                     not skip_plugins_install),\n                    plugins_dir=core_settings.plugins_base_folder))\n\n        # create ansible config manager\n        if ServiceName.ANSIBLE_CONFIG_MANAGER not in cls._SERVICES:\n            cls.register_service(ServiceName.ANSIBLE_CONFIG_MANAGER,\n                                 ansible_config.AnsibleConfigManager(\n                                     core_settings.infrared_home))\n\n        # create execution logger manager\n        if ServiceName.EXECUTION_LOGGER_MANAGER not in cls._SERVICES:\n            # get ansible manager\n            ansible_manager = CoreServices.ansible_config_manager()\n            # build log file path\n            log_file = \\\n                os.path.join(core_settings.infrared_home, 'ir-commands.log')\n            cls.register_service(ServiceName.EXECUTION_LOGGER_MANAGER,\n                                 execution_logger.ExecutionLoggerManager(\n                                     ansible_manager.ansible_config_path,\n                                     log_file=log_file))\n\n    @classmethod\n    def register_service(cls, service_name, service):\n        \"\"\"Protect the _SERVICES dict\"\"\"\n        CoreServices._SERVICES[service_name] = service\n\n    @classmethod\n    def _get_service(cls, name):\n        if name not in cls._SERVICES:\n            cls.setup()\n        return cls._SERVICES[name]\n\n    @classmethod\n    def workspace_manager(cls):\n        \"\"\"Gets the workspace manager. \"\"\"\n        return cls._get_service(ServiceName.WORKSPACE_MANAGER)\n\n    @classmethod\n    def plugins_manager(cls):\n        \"\"\"Gets the plugin manager. \"\"\"\n        return cls._get_service(ServiceName.PLUGINS_MANAGER)\n\n    @classmethod", "contexts_below": "    @classmethod\n     def execution_logger_manager(cls):\n         \"\"\"Gets the execution logger manager. \"\"\"\n         return cls._get_service(ServiceName.EXECUTION_LOGGER_MANAGER)\n ", "input_code": "@classmethod\ndef ansible_config_manager(cls):\n\"\"\"\nGets the ansible config manager.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @classmethod\n    def ansible_config_manager(cls):\n        \"\"\"Gets the ansible config manager. \"\"\"\n        return cls._get_service(ServiceName.ANSIBLE_CONFIG_MANAGER)", "signature": "@classmethod\ndef ansible_config_manager(cls):", "completion_path": "infrared/core/services/__init__.py"}
{"ce_id": "6306091b73426c38ae68acd9", "namespace": "6306091b73426c38ae68acd9", "namespace_real": "infrared.core.services.__init__.workspace_manager", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "__init__", "function_name": "workspace_manager", "contexts_above": "\"\"\"Service locator for the IR services\n\nStores and resolves all the dependencies for the services.\n\"\"\"\nimport os\nimport sys\n\nfrom infrared.core.services import ansible_config\nfrom infrared.core.services import execution_logger\nfrom infrared.core.services import plugins\nfrom infrared.core.services import workspaces\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n\nclass ServiceName(object):\n    \"\"\"Holds the supported services names. \"\"\"\n    WORKSPACE_MANAGER = \"workspace_manager\"\n    PLUGINS_MANAGER = \"plugins_manager\"\n    ANSIBLE_CONFIG_MANAGER = \"ansible_config_manager\"\n    EXECUTION_LOGGER_MANAGER = \"execution_logger_manager\"\n\n\nclass CoreSettings(object):\n    \"\"\"Holds the main settings for the infrared. \"\"\"\n\n    def __init__(self, workspaces_base_folder=None,\n                 plugins_conf_file=None,\n                 install_plugin_at_start=True,\n                 plugins_base_folder=None):\n        \"\"\"Constructor.\n\n        :param workspaces_base_folder: folder where the\n               workspace will be stored\n        :param plugins_conf_file: location of the plugins.ini file with the\n               list of all plugins and types.\n        :param install_plugin_at_start: specifies whether all the plugins\n               should be installed on ir start. Skip installation may be\n               required for unit tests, for example.\n        \"\"\"\n\n        self.infrared_home = os.path.abspath(os.environ.get(\n            \"IR_HOME\", os.path.join(os.path.expanduser(\"~\"), '.infrared')))\n\n        # todo(obaranov) replace .workspaces to workspaces and .plugins.ini to\n        # todo(obaranov) plugins.ini once IR is packaged as pip\n        self.plugins_conf_file = plugins_conf_file or os.path.join(\n            self.infrared_home, '.plugins.ini')\n        self.workspaces_base_folder = workspaces_base_folder or os.path.join(\n            self.infrared_home, '.workspaces')\n        self.install_plugin_at_start = install_plugin_at_start\n        self.plugins_base_folder = plugins_base_folder or os.path.join(\n            self.infrared_home, 'plugins')\n\n\nclass CoreServices(object):\n    \"\"\"Holds and configures all the required for core services. \"\"\"\n\n    _SERVICES = {}\n\n    @classmethod\n    def setup(cls, core_settings=None):\n        \"\"\"Creates configuration from file or from defaults.\n\n        :param core_settings: the instance of the CoreSettings class with the\n        desired settings. If None is provided then the default settings\n        will be used.\n        \"\"\"\n\n        if core_settings is None:\n            core_settings = CoreSettings()\n\n        # create workspace manager\n        if ServiceName.WORKSPACE_MANAGER not in cls._SERVICES:\n            cls.register_service(ServiceName.WORKSPACE_MANAGER,\n                                 workspaces.WorkspaceManager(\n                                     core_settings.workspaces_base_folder))\n\n        # create plugins manager\n        if ServiceName.PLUGINS_MANAGER not in cls._SERVICES:\n            # A temporary WH to skip all plugins installation on first InfraRed\n            # command if the command is 'infrared plugin add'.\n            # Should be removed together with auto plugins installation\n            # mechanism.\n            skip_plugins_install = {'plugin', 'add'}.issubset(sys.argv)\n            cls.register_service(\n                ServiceName.PLUGINS_MANAGER, plugins.InfraredPluginManager(\n                    plugins_conf=core_settings.plugins_conf_file,\n                    install_plugins=(core_settings.install_plugin_at_start and\n                                     not skip_plugins_install),\n                    plugins_dir=core_settings.plugins_base_folder))\n\n        # create ansible config manager\n        if ServiceName.ANSIBLE_CONFIG_MANAGER not in cls._SERVICES:\n            cls.register_service(ServiceName.ANSIBLE_CONFIG_MANAGER,\n                                 ansible_config.AnsibleConfigManager(\n                                     core_settings.infrared_home))\n\n        # create execution logger manager\n        if ServiceName.EXECUTION_LOGGER_MANAGER not in cls._SERVICES:\n            # get ansible manager\n            ansible_manager = CoreServices.ansible_config_manager()\n            # build log file path\n            log_file = \\\n                os.path.join(core_settings.infrared_home, 'ir-commands.log')\n            cls.register_service(ServiceName.EXECUTION_LOGGER_MANAGER,\n                                 execution_logger.ExecutionLoggerManager(\n                                     ansible_manager.ansible_config_path,\n                                     log_file=log_file))\n\n    @classmethod\n    def register_service(cls, service_name, service):\n        \"\"\"Protect the _SERVICES dict\"\"\"\n        CoreServices._SERVICES[service_name] = service\n\n    @classmethod\n    def _get_service(cls, name):\n        if name not in cls._SERVICES:\n            cls.setup()\n        return cls._SERVICES[name]\n\n    @classmethod", "contexts_below": "    @classmethod\n     def plugins_manager(cls):\n         \"\"\"Gets the plugin manager. \"\"\"\n         return cls._get_service(ServiceName.PLUGINS_MANAGER)\n \n     @classmethod\n     def ansible_config_manager(cls):\n         \"\"\"Gets the ansible config manager. \"\"\"\n         return cls._get_service(ServiceName.ANSIBLE_CONFIG_MANAGER)\n \n     @classmethod\n     def execution_logger_manager(cls):\n         \"\"\"Gets the execution logger manager. \"\"\"\n         return cls._get_service(ServiceName.EXECUTION_LOGGER_MANAGER)\n ", "input_code": "@classmethod\ndef workspace_manager(cls):\n\"\"\"\nGets the workspace manager.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @classmethod\n    def workspace_manager(cls):\n        \"\"\"Gets the workspace manager. \"\"\"\n        return cls._get_service(ServiceName.WORKSPACE_MANAGER)", "signature": "@classmethod\ndef workspace_manager(cls):", "completion_path": "infrared/core/services/__init__.py"}
{"ce_id": "6306091b73426c38ae68acda", "namespace": "6306091b73426c38ae68acda", "namespace_real": "infrared.core.services.__init__.plugins_manager", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "__init__", "function_name": "plugins_manager", "contexts_above": "\"\"\"Service locator for the IR services\n\nStores and resolves all the dependencies for the services.\n\"\"\"\nimport os\nimport sys\n\nfrom infrared.core.services import ansible_config\nfrom infrared.core.services import execution_logger\nfrom infrared.core.services import plugins\nfrom infrared.core.services import workspaces\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n\nclass ServiceName(object):\n    \"\"\"Holds the supported services names. \"\"\"\n    WORKSPACE_MANAGER = \"workspace_manager\"\n    PLUGINS_MANAGER = \"plugins_manager\"\n    ANSIBLE_CONFIG_MANAGER = \"ansible_config_manager\"\n    EXECUTION_LOGGER_MANAGER = \"execution_logger_manager\"\n\n\nclass CoreSettings(object):\n    \"\"\"Holds the main settings for the infrared. \"\"\"\n\n    def __init__(self, workspaces_base_folder=None,\n                 plugins_conf_file=None,\n                 install_plugin_at_start=True,\n                 plugins_base_folder=None):\n        \"\"\"Constructor.\n\n        :param workspaces_base_folder: folder where the\n               workspace will be stored\n        :param plugins_conf_file: location of the plugins.ini file with the\n               list of all plugins and types.\n        :param install_plugin_at_start: specifies whether all the plugins\n               should be installed on ir start. Skip installation may be\n               required for unit tests, for example.\n        \"\"\"\n\n        self.infrared_home = os.path.abspath(os.environ.get(\n            \"IR_HOME\", os.path.join(os.path.expanduser(\"~\"), '.infrared')))\n\n        # todo(obaranov) replace .workspaces to workspaces and .plugins.ini to\n        # todo(obaranov) plugins.ini once IR is packaged as pip\n        self.plugins_conf_file = plugins_conf_file or os.path.join(\n            self.infrared_home, '.plugins.ini')\n        self.workspaces_base_folder = workspaces_base_folder or os.path.join(\n            self.infrared_home, '.workspaces')\n        self.install_plugin_at_start = install_plugin_at_start\n        self.plugins_base_folder = plugins_base_folder or os.path.join(\n            self.infrared_home, 'plugins')\n\n\nclass CoreServices(object):\n    \"\"\"Holds and configures all the required for core services. \"\"\"\n\n    _SERVICES = {}\n\n    @classmethod\n    def setup(cls, core_settings=None):\n        \"\"\"Creates configuration from file or from defaults.\n\n        :param core_settings: the instance of the CoreSettings class with the\n        desired settings. If None is provided then the default settings\n        will be used.\n        \"\"\"\n\n        if core_settings is None:\n            core_settings = CoreSettings()\n\n        # create workspace manager\n        if ServiceName.WORKSPACE_MANAGER not in cls._SERVICES:\n            cls.register_service(ServiceName.WORKSPACE_MANAGER,\n                                 workspaces.WorkspaceManager(\n                                     core_settings.workspaces_base_folder))\n\n        # create plugins manager\n        if ServiceName.PLUGINS_MANAGER not in cls._SERVICES:\n            # A temporary WH to skip all plugins installation on first InfraRed\n            # command if the command is 'infrared plugin add'.\n            # Should be removed together with auto plugins installation\n            # mechanism.\n            skip_plugins_install = {'plugin', 'add'}.issubset(sys.argv)\n            cls.register_service(\n                ServiceName.PLUGINS_MANAGER, plugins.InfraredPluginManager(\n                    plugins_conf=core_settings.plugins_conf_file,\n                    install_plugins=(core_settings.install_plugin_at_start and\n                                     not skip_plugins_install),\n                    plugins_dir=core_settings.plugins_base_folder))\n\n        # create ansible config manager\n        if ServiceName.ANSIBLE_CONFIG_MANAGER not in cls._SERVICES:\n            cls.register_service(ServiceName.ANSIBLE_CONFIG_MANAGER,\n                                 ansible_config.AnsibleConfigManager(\n                                     core_settings.infrared_home))\n\n        # create execution logger manager\n        if ServiceName.EXECUTION_LOGGER_MANAGER not in cls._SERVICES:\n            # get ansible manager\n            ansible_manager = CoreServices.ansible_config_manager()\n            # build log file path\n            log_file = \\\n                os.path.join(core_settings.infrared_home, 'ir-commands.log')\n            cls.register_service(ServiceName.EXECUTION_LOGGER_MANAGER,\n                                 execution_logger.ExecutionLoggerManager(\n                                     ansible_manager.ansible_config_path,\n                                     log_file=log_file))\n\n    @classmethod\n    def register_service(cls, service_name, service):\n        \"\"\"Protect the _SERVICES dict\"\"\"\n        CoreServices._SERVICES[service_name] = service\n\n    @classmethod\n    def _get_service(cls, name):\n        if name not in cls._SERVICES:\n            cls.setup()\n        return cls._SERVICES[name]\n\n    @classmethod\n    def workspace_manager(cls):\n        \"\"\"Gets the workspace manager. \"\"\"\n        return cls._get_service(ServiceName.WORKSPACE_MANAGER)\n\n    @classmethod", "contexts_below": "    @classmethod\n     def ansible_config_manager(cls):\n         \"\"\"Gets the ansible config manager. \"\"\"\n         return cls._get_service(ServiceName.ANSIBLE_CONFIG_MANAGER)\n \n     @classmethod\n     def execution_logger_manager(cls):\n         \"\"\"Gets the execution logger manager. \"\"\"\n         return cls._get_service(ServiceName.EXECUTION_LOGGER_MANAGER)\n ", "input_code": "@classmethod\ndef plugins_manager(cls):\n\"\"\"\nGets the plugin manager.\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @classmethod\n    def plugins_manager(cls):\n        \"\"\"Gets the plugin manager. \"\"\"\n        return cls._get_service(ServiceName.PLUGINS_MANAGER)", "signature": "@classmethod\ndef plugins_manager(cls):", "completion_path": "infrared/core/services/__init__.py"}
{"ce_id": "6306091c73426c38ae68acdc", "namespace": "6306091c73426c38ae68acdc", "namespace_real": "infrared.core.utils.validators.validate_from_content", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "validators", "function_name": "validate_from_content", "contexts_above": "import jsonschema\nimport os\nfrom six.moves import configparser\nimport yaml\n\nfrom infrared.core.utils.exceptions import IRValidatorException\nfrom infrared.core.utils.logger import LOG as logger\n\n\nclass Validator(object):\n\n    @classmethod\n    def validate_from_file(cls, yaml_file=None):\n        \"\"\"Loads & validates that a YAML file has all required fields\n\n        :param yaml_file: Path to YAML file\n        :raise IRValidatorException: when mandatory data is missing in file\n        :return: Dictionary with data loaded from a YAML file\n        \"\"\"\n        if yaml_file is None:\n            raise IRValidatorException(\n                \"YAML file is missing\")\n\n        if not os.path.isfile(yaml_file):\n            raise IRValidatorException(\n                \"The YAML file doesn't exist: {}\".format(yaml_file))\n\n        with open(yaml_file) as fp:\n            spec_dict = cls.validate_from_content(fp.read())\n\n        return spec_dict\n\n    @classmethod\n    def validate_from_content(cls, file_content=None):\n        \"\"\"validates that YAML content has all required fields\n\n        :param file_content: content of the YAML file\n        :raise IRValidatorException: when mandatory data is missing in file\n        :return: Dictionary with data loaded from a YAML file\n        \"\"\"\n        raise NotImplementedError\n\n\nclass SpecValidator(Validator):\n    \"\"\"Class for validating a plugin spec.\n\n    It checks that a plugin spec (YAML) has all required fields.\n    \"\"\"\n    CONFIG_PART_SCHEMA = {\n        \"type\": \"object\",\n        \"properties\": {\n            \"plugin_type\": {\"type\": \"string\", \"minLength\": 1},\n            \"entry_point\": {\"type\": \"string\", \"minLength\": 1},\n            \"roles_path\": {\"type\": \"string\", \"minLength\": 1},\n        },\n        \"additionalProperties\": False,\n        \"required\": [\"plugin_type\"]\n    }\n\n    SUBPARSER_PART_SCHEMA = {\n        \"type\": \"object\",\n        \"minProperties\": 1,\n        \"maxProperties\": 1,\n        \"patternProperties\": {\n            \"^(?!(?:all)$).+$\": {\n                \"type\": \"object\",\n            }\n        },\n        \"additionalProperties\": False\n    }\n\n    SCHEMA_WITH_CONFIG = {\n        \"type\": \"object\",\n        \"properties\": {\n            \"description\": {\"type\": \"string\", \"minLength\": 1},\n            \"config\": CONFIG_PART_SCHEMA,\n            \"subparsers\": SUBPARSER_PART_SCHEMA\n        },\n        \"additionalProperties\": False,\n        \"required\": [\"config\", \"subparsers\"]\n    }\n\n    SCHEMA_WITHOUT_CONFIG = {\n        \"type\": \"object\",\n        \"properties\": {\n            \"plugin_type\": {\"type\": \"string\", \"minLength\": 1},\n            \"entry_point\": {\"type\": \"string\", \"minLength\": 1},\n            \"roles_path\": {\"type\": \"string\", \"minLength\": 1},\n            \"description\": {\"type\": \"string\", \"minLength\": 1},\n            \"subparsers\": SUBPARSER_PART_SCHEMA\n        },\n        \"additionalProperties\": False,\n        \"required\": [\"plugin_type\", \"subparsers\"]\n    }\n\n    @classmethod", "contexts_below": "\n class RegistryValidator(Validator):\n     SCHEMA_REGISTRY = {\n         \"type\": \"object\",\n         \"patternProperties\": {\n             \"^.+$\": {\n                 \"type\": \"object\",\n                 \"properties\": {\n                     \"src\": {\"type\": \"string\", \"minLength\": 1},\n                     \"src_path\": {\"type\": \"string\", \"minLength\": 1},\n                     \"rev\": {\"type\": \"string\", \"minLength\": 1},\n                     \"desc\": {\"type\": \"string\", \"minLength\": 1},\n                     \"type\": {\"type\": \"string\", \"minLength\": 1},\n                 },\n                 \"additionalProperties\": False,\n                 \"required\": [\"src\", \"desc\", \"type\"]\n             }\n         },\n         \"additionalProperties\": False,\n     }\n \n     @classmethod\n     def validate_from_content(cls, file_content=None):\n         \"\"\"validates that Registry YAML content has all required fields\n \n         :param file_content: content of the Registry YAML file\n         :raise IRValidatorException: when mandatory data is missing in Registry\n         :return: Dictionary with data loaded from a Registry YAML file\n         \"\"\"\n         if file_content is None:\n             raise IRValidatorException(\n                 \"Registry YAML content is missing\")\n \n         registry_dict = yaml.safe_load(file_content)\n \n         if not isinstance(registry_dict, dict):\n             raise IRValidatorException(\n                 \"Registry file is empty or corrupted: {}\".format(file_content))\n \n         try:\n             # validate schema\n             jsonschema.validate(registry_dict,\n                                 cls.SCHEMA_REGISTRY)\n \n         except jsonschema.exceptions.ValidationError as error:\n             raise IRValidatorException(\n                 \"{} in file:\\n{}\".format(error.message, file_content))\n \n         return registry_dict\n \n \n class AnsibleConfigValidator(Validator):\n     ANSIBLE_CONFIG_OPTIONS = {\n         'defaults': {\n             'host_key_checking': {\n                 'type': 'bool',\n                 'comparison': 'eq',\n                 'expected_value': False,\n                 'critical': True\n             },\n             'forks': {\n                 'type': 'int',\n                 'comparison': 'gt',\n                 'expected_value': 500,\n                 'critical': False\n             },\n             'timeout': {\n                 'type': 'int',\n                 'comparison': 'gt',\n                 'expected_value': 30,\n                 'critical': False\n             }\n         }\n     }\n \n     @classmethod\n     def validate_from_file(cls, yaml_file=None):\n         config = configparser.RawConfigParser()\n         config.read(yaml_file)\n         config_dict = cls._convert_config_to_dict(config)\n \n         for section, option_details in cls.ANSIBLE_CONFIG_OPTIONS.items():\n             for opt_name, opt_params in option_details.items():\n                 try:\n                     config_value = config_dict[section][opt_name]\n                     cls._validate_config_option(yaml_file,\n                                                 opt_name,\n                                                 opt_params['type'],\n                                                 opt_params['comparison'],\n                                                 opt_params['expected_value'],\n                                                 config_value,\n                                                 opt_params['critical'])\n                 except KeyError:\n                     cls._handle_missing_value(yaml_file, section, opt_name,\n                                               opt_params['expected_value'],\n                                               opt_params['critical'])\n \n     @classmethod\n     def validate_from_content(cls, file_content=None):\n         pass\n \n     @classmethod\n     def _validate_config_option(cls, yaml_file, opt_name, opt_type,\n                                 comparison, exp_value, cur_value, critical):\n         if opt_type == 'int':\n             cur_value = int(cur_value)\n         if opt_type == 'bool':\n             if cur_value == 'True':\n                 cur_value = True\n             else:\n                 cur_value = False\n \n         if comparison == 'eq':\n             if cur_value != exp_value:\n                 cls._handle_wrong_value(yaml_file, opt_name, exp_value,\n                                         cur_value, critical)\n \n         if comparison == 'gt':\n             if cur_value < exp_value:\n                 cls._handle_wrong_value(yaml_file, opt_name, exp_value,\n                                         cur_value, critical)\n \n     @classmethod\n     def _handle_wrong_value(cls, yaml_file, option_name, exp_value,\n                             cur_value, critical):\n         msg = \"There is an issue with Ansible configuration in \" \\\n               \"{}. Expected value for the option '{}' is '{}', \" \\\n               \"current value is '{}'\".format(yaml_file, option_name,\n                                              exp_value, cur_value)\n         if critical:\n             raise IRValidatorException(msg)\n         else:\n             logger.warn(msg)\n \n     @classmethod\n     def _handle_missing_value(cls, yaml_file, section, option_name,\n                               exp_value, critical):\n         msg = \"There is an issue with Ansible configuration in\" \\\n               \" {}. Option '{}' with value of '{}' not found in\" \\\n               \" section '{}'\".format(yaml_file, option_name,\n                                      exp_value, section)\n         if critical:\n             raise IRValidatorException(msg)\n         else:\n             logger.warn(msg)\n \n     @staticmethod\n     def _convert_config_to_dict(config):\n         config_dict = {}\n         for section in config.sections():\n             if section not in config_dict:\n                 config_dict[section] = {}\n \n             for option in config.options(section):\n                 option_value = config.get(section, option)\n                 try:\n                     option_value = int(option_value)\n                 except ValueError:\n                     pass\n \n                 config_dict[section][option] = option_value\n \n         return config_dict\n ", "input_code": "@classmethod\ndef validate_from_content(cls, spec_content=None):\n\"\"\"\nvalidates that spec (YAML) content has all required fields\n\n:param spec_content: content of spec file\n:raise IRValidatorException: when mandatory data\nis missing in spec file\n:return: Dictionary with data loaded from a spec (YAML) file\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @classmethod\n    def validate_from_content(cls, spec_content=None):\n        \"\"\"validates that spec (YAML) content has all required fields\n\n        :param spec_content: content of spec file\n        :raise IRValidatorException: when mandatory data\n        is missing in spec file\n        :return: Dictionary with data loaded from a spec (YAML) file\n        \"\"\"\n        if spec_content is None:\n            raise IRValidatorException(\n                \"Plugin spec content is missing\")\n\n        spec_dict = yaml.safe_load(spec_content)\n\n        if not isinstance(spec_dict, dict):\n            raise IRValidatorException(\n                \"Spec file is empty or corrupted: {}\".format(spec_content))\n\n        # check if new spec file structure\n        try:\n            if \"config\" in spec_dict:\n                jsonschema.validate(spec_dict,\n                                    cls.SCHEMA_WITH_CONFIG)\n            else:\n                jsonschema.validate(spec_dict,\n                                    cls.SCHEMA_WITHOUT_CONFIG)\n\n        except jsonschema.exceptions.ValidationError as error:\n            raise IRValidatorException(\n                \"{} in file:\\n{}\".format(error.message, spec_content))\n\n        subparsers_key = \"subparsers\"\n        if (\"description\" not in spec_dict and \"description\"\n                not in list(spec_dict[subparsers_key].values())[0]):\n            raise IRValidatorException(\n                \"Required key 'description' is missing for supbarser '{}' in \"\n                \"spec file: {}\".format(\n                    list(spec_dict[subparsers_key].keys())[0], spec_content))\n\n        return spec_dict", "signature": "@classmethod\ndef validate_from_content(cls, spec_content=None):", "completion_path": "infrared/core/utils/validators.py"}
{"ce_id": "6306091c73426c38ae68acdd", "namespace": "6306091c73426c38ae68acdd", "namespace_real": "infrared.core.utils.validators.validate_from_file", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "validators", "function_name": "validate_from_file", "contexts_above": "import jsonschema\nimport os\nfrom six.moves import configparser\nimport yaml\n\nfrom infrared.core.utils.exceptions import IRValidatorException\nfrom infrared.core.utils.logger import LOG as logger\n\n\nclass Validator(object):\n\n    @classmethod", "contexts_below": "    @classmethod\n     def validate_from_content(cls, file_content=None):\n         \"\"\"validates that YAML content has all required fields\n \n         :param file_content: content of the YAML file\n         :raise IRValidatorException: when mandatory data is missing in file\n         :return: Dictionary with data loaded from a YAML file\n         \"\"\"\n         raise NotImplementedError\n \n \n class SpecValidator(Validator):\n     \"\"\"Class for validating a plugin spec.\n \n     It checks that a plugin spec (YAML) has all required fields.\n     \"\"\"\n     CONFIG_PART_SCHEMA = {\n         \"type\": \"object\",\n         \"properties\": {\n             \"plugin_type\": {\"type\": \"string\", \"minLength\": 1},\n             \"entry_point\": {\"type\": \"string\", \"minLength\": 1},\n             \"roles_path\": {\"type\": \"string\", \"minLength\": 1},\n         },\n         \"additionalProperties\": False,\n         \"required\": [\"plugin_type\"]\n     }\n \n     SUBPARSER_PART_SCHEMA = {\n         \"type\": \"object\",\n         \"minProperties\": 1,\n         \"maxProperties\": 1,\n         \"patternProperties\": {\n             \"^(?!(?:all)$).+$\": {\n                 \"type\": \"object\",\n             }\n         },\n         \"additionalProperties\": False\n     }\n \n     SCHEMA_WITH_CONFIG = {\n         \"type\": \"object\",\n         \"properties\": {\n             \"description\": {\"type\": \"string\", \"minLength\": 1},\n             \"config\": CONFIG_PART_SCHEMA,\n             \"subparsers\": SUBPARSER_PART_SCHEMA\n         },\n         \"additionalProperties\": False,\n         \"required\": [\"config\", \"subparsers\"]\n     }\n \n     SCHEMA_WITHOUT_CONFIG = {\n         \"type\": \"object\",\n         \"properties\": {\n             \"plugin_type\": {\"type\": \"string\", \"minLength\": 1},\n             \"entry_point\": {\"type\": \"string\", \"minLength\": 1},\n             \"roles_path\": {\"type\": \"string\", \"minLength\": 1},\n             \"description\": {\"type\": \"string\", \"minLength\": 1},\n             \"subparsers\": SUBPARSER_PART_SCHEMA\n         },\n         \"additionalProperties\": False,\n         \"required\": [\"plugin_type\", \"subparsers\"]\n     }\n \n     @classmethod\n     def validate_from_content(cls, spec_content=None):\n         \"\"\"validates that spec (YAML) content has all required fields\n \n         :param spec_content: content of spec file\n         :raise IRValidatorException: when mandatory data\n         is missing in spec file\n         :return: Dictionary with data loaded from a spec (YAML) file\n         \"\"\"\n         if spec_content is None:\n             raise IRValidatorException(\n                 \"Plugin spec content is missing\")\n \n         spec_dict = yaml.safe_load(spec_content)\n \n         if not isinstance(spec_dict, dict):\n             raise IRValidatorException(\n                 \"Spec file is empty or corrupted: {}\".format(spec_content))\n \n         # check if new spec file structure\n         try:\n             if \"config\" in spec_dict:\n                 jsonschema.validate(spec_dict,\n                                     cls.SCHEMA_WITH_CONFIG)\n             else:\n                 jsonschema.validate(spec_dict,\n                                     cls.SCHEMA_WITHOUT_CONFIG)\n \n         except jsonschema.exceptions.ValidationError as error:\n             raise IRValidatorException(\n                 \"{} in file:\\n{}\".format(error.message, spec_content))\n \n         subparsers_key = \"subparsers\"\n         if (\"description\" not in spec_dict and \"description\"\n                 not in list(spec_dict[subparsers_key].values())[0]):\n             raise IRValidatorException(\n                 \"Required key 'description' is missing for supbarser '{}' in \"\n                 \"spec file: {}\".format(\n                     list(spec_dict[subparsers_key].keys())[0], spec_content))\n \n         return spec_dict\n \n \n class RegistryValidator(Validator):\n     SCHEMA_REGISTRY = {\n         \"type\": \"object\",\n         \"patternProperties\": {\n             \"^.+$\": {\n                 \"type\": \"object\",\n                 \"properties\": {\n                     \"src\": {\"type\": \"string\", \"minLength\": 1},\n                     \"src_path\": {\"type\": \"string\", \"minLength\": 1},\n                     \"rev\": {\"type\": \"string\", \"minLength\": 1},\n                     \"desc\": {\"type\": \"string\", \"minLength\": 1},\n                     \"type\": {\"type\": \"string\", \"minLength\": 1},\n                 },\n                 \"additionalProperties\": False,\n                 \"required\": [\"src\", \"desc\", \"type\"]\n             }\n         },\n         \"additionalProperties\": False,\n     }\n \n     @classmethod\n     def validate_from_content(cls, file_content=None):\n         \"\"\"validates that Registry YAML content has all required fields\n \n         :param file_content: content of the Registry YAML file\n         :raise IRValidatorException: when mandatory data is missing in Registry\n         :return: Dictionary with data loaded from a Registry YAML file\n         \"\"\"\n         if file_content is None:\n             raise IRValidatorException(\n                 \"Registry YAML content is missing\")\n \n         registry_dict = yaml.safe_load(file_content)\n \n         if not isinstance(registry_dict, dict):\n             raise IRValidatorException(\n                 \"Registry file is empty or corrupted: {}\".format(file_content))\n \n         try:\n             # validate schema\n             jsonschema.validate(registry_dict,\n                                 cls.SCHEMA_REGISTRY)\n \n         except jsonschema.exceptions.ValidationError as error:\n             raise IRValidatorException(\n                 \"{} in file:\\n{}\".format(error.message, file_content))\n \n         return registry_dict\n \n \n class AnsibleConfigValidator(Validator):\n     ANSIBLE_CONFIG_OPTIONS = {\n         'defaults': {\n             'host_key_checking': {\n                 'type': 'bool',\n                 'comparison': 'eq',\n                 'expected_value': False,\n                 'critical': True\n             },\n             'forks': {\n                 'type': 'int',\n                 'comparison': 'gt',\n                 'expected_value': 500,\n                 'critical': False\n             },\n             'timeout': {\n                 'type': 'int',\n                 'comparison': 'gt',\n                 'expected_value': 30,\n                 'critical': False\n             }\n         }\n     }\n \n     @classmethod\n     def validate_from_file(cls, yaml_file=None):\n         config = configparser.RawConfigParser()\n         config.read(yaml_file)\n         config_dict = cls._convert_config_to_dict(config)\n \n         for section, option_details in cls.ANSIBLE_CONFIG_OPTIONS.items():\n             for opt_name, opt_params in option_details.items():\n                 try:\n                     config_value = config_dict[section][opt_name]\n                     cls._validate_config_option(yaml_file,\n                                                 opt_name,\n                                                 opt_params['type'],\n                                                 opt_params['comparison'],\n                                                 opt_params['expected_value'],\n                                                 config_value,\n                                                 opt_params['critical'])\n                 except KeyError:\n                     cls._handle_missing_value(yaml_file, section, opt_name,\n                                               opt_params['expected_value'],\n                                               opt_params['critical'])\n \n     @classmethod\n     def validate_from_content(cls, file_content=None):\n         pass\n \n     @classmethod\n     def _validate_config_option(cls, yaml_file, opt_name, opt_type,\n                                 comparison, exp_value, cur_value, critical):\n         if opt_type == 'int':\n             cur_value = int(cur_value)\n         if opt_type == 'bool':\n             if cur_value == 'True':\n                 cur_value = True\n             else:\n                 cur_value = False\n \n         if comparison == 'eq':\n             if cur_value != exp_value:\n                 cls._handle_wrong_value(yaml_file, opt_name, exp_value,\n                                         cur_value, critical)\n \n         if comparison == 'gt':\n             if cur_value < exp_value:\n                 cls._handle_wrong_value(yaml_file, opt_name, exp_value,\n                                         cur_value, critical)\n \n     @classmethod\n     def _handle_wrong_value(cls, yaml_file, option_name, exp_value,\n                             cur_value, critical):\n         msg = \"There is an issue with Ansible configuration in \" \\\n               \"{}. Expected value for the option '{}' is '{}', \" \\\n               \"current value is '{}'\".format(yaml_file, option_name,\n                                              exp_value, cur_value)\n         if critical:\n             raise IRValidatorException(msg)\n         else:\n             logger.warn(msg)\n \n     @classmethod\n     def _handle_missing_value(cls, yaml_file, section, option_name,\n                               exp_value, critical):\n         msg = \"There is an issue with Ansible configuration in\" \\\n               \" {}. Option '{}' with value of '{}' not found in\" \\\n               \" section '{}'\".format(yaml_file, option_name,\n                                      exp_value, section)\n         if critical:\n             raise IRValidatorException(msg)\n         else:\n             logger.warn(msg)\n \n     @staticmethod\n     def _convert_config_to_dict(config):\n         config_dict = {}\n         for section in config.sections():\n             if section not in config_dict:\n                 config_dict[section] = {}\n \n             for option in config.options(section):\n                 option_value = config.get(section, option)\n                 try:\n                     option_value = int(option_value)\n                 except ValueError:\n                     pass\n \n                 config_dict[section][option] = option_value\n \n         return config_dict\n ", "input_code": "@classmethod\ndef validate_from_file(cls, yaml_file=None):\n\"\"\"\nLoads & validates that a YAML file has all required fields\n\n:param yaml_file: Path to YAML file\n:raise IRValidatorException: when mandatory data is missing in file\n:return: Dictionary with data loaded from a YAML file\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @classmethod\n    def validate_from_file(cls, yaml_file=None):\n        \"\"\"Loads & validates that a YAML file has all required fields\n\n        :param yaml_file: Path to YAML file\n        :raise IRValidatorException: when mandatory data is missing in file\n        :return: Dictionary with data loaded from a YAML file\n        \"\"\"\n        if yaml_file is None:\n            raise IRValidatorException(\n                \"YAML file is missing\")\n\n        if not os.path.isfile(yaml_file):\n            raise IRValidatorException(\n                \"The YAML file doesn't exist: {}\".format(yaml_file))\n\n        with open(yaml_file) as fp:\n            spec_dict = cls.validate_from_content(fp.read())\n\n        return spec_dict", "signature": "@classmethod\ndef validate_from_file(cls, yaml_file=None):", "completion_path": "infrared/core/utils/validators.py"}
{"ce_id": "6306091d73426c38ae68ace5", "namespace": "6306091d73426c38ae68ace5", "namespace_real": "infrared.core.inspector.helper._include_groups", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "helper", "function_name": "_include_groups", "contexts_above": "from copy import deepcopy\nfrom infrared.core.utils.exceptions import SpecParserException\n\nOptionState = dict(\n    UNRECOGNIZED='unrecognized',\n    IS_SET='is set',\n    NOT_SET='is no set'\n)\n\n\nclass SpecDictHelper(object):\n    \"\"\"Controls the spec dicts and provides useful methods to get spec info.\"\"\"\n\n    def __init__(self, spec_dict):\n        self.spec_dict = spec_dict\n        # make structure of the dict flat\n        # 1. handle include_groups directive in main parser\n        parser_dict = self.spec_dict\n        self._include_groups(parser_dict)\n        # 2. Include groups for all subparsers\n        for subparser_name, subparser_dict in parser_dict.get(\n                'subparsers', {}).items():\n            self._include_groups(subparser_dict)\n\n    def iterate_parsers(self):\n        \"\"\"Iterates over the main parsers and subparsers. \"\"\"\n\n        for subparser_name, subparser_dict in self.spec_dict.get(\n                'subparsers', {}).items():\n            yield dict(name=subparser_name, **subparser_dict)\n\n    def iterate_option_specs(self):\n        \"\"\"Iterates over all the option specs.\n\n        Returns pair of parser and option on every iteration.\n        \"\"\"\n        for parser in self.iterate_parsers():\n            for spec_option in self._get_all_options_spec(parser):\n                yield parser, spec_option\n\n    @staticmethod\n    def _get_all_options_spec(parser_dict):\n        \"\"\"Gets all the options specification as the list of dicts. \"\"\"\n        result = []\n        for group in parser_dict.get('groups', []):\n            for option_name, option_dict in group.get('options', {}).items():\n                result.append(dict(name=option_name, **option_dict))\n\n        for option_name, option_dict in parser_dict.get('options', {}).items():\n            result.append(dict(name=option_name, **option_dict))\n\n        return result\n\n    def get_parser_option_specs(self, command_name):\n        \"\"\"Gets all the options for the specified command\n\n        :param command_name: the command name (main, virsh, ospd, etc...)\n        :return: the list of all command options\n        \"\"\"\n        options = []\n        for parser in self.iterate_parsers():\n            if parser['name'] == command_name:\n                options = self._get_all_options_spec(parser)\n                break\n        return options\n\n    def get_option_spec(self, command_name, argument_name):\n        \"\"\"Gets the specification for the specified option name. \"\"\"\n\n        options = self.get_parser_option_specs(command_name)\n        return next((opt for opt in options\n                     if opt['name'] == argument_name), {})\n\n    def get_option_state(self, command_name, option_name, args):\n        \"\"\"Gets the option state.\n\n        :param command_name: The command name\n        :param option_name: The option name to analyze\n        :param args: The received arguments.\n        \"\"\"\n        option_spec = self.get_option_spec(command_name, option_name)\n\n        if not option_spec:\n            res = OptionState['UNRECOGNIZED']\n\n        elif option_name not in args.get(command_name, {}):\n            res = OptionState['NOT_SET']\n        else:\n            option_value = args[command_name][option_name]\n            if option_spec.get('action', '') in ['store_true'] \\\n                    and option_value is False:\n                res = OptionState['NOT_SET']\n            else:\n                res = OptionState['IS_SET']\n\n        return res\n", "contexts_below": "", "input_code": "def _include_groups(self, parser_dict):\n\"\"\"\nResolves the include dict directive in the spec files.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def _include_groups(self, parser_dict):\n        \"\"\"Resolves the include dict directive in the spec files. \"\"\"\n        for group in parser_dict.get('include_groups', []):\n            # ensure we have that group\n            grp_dict = next(\n                (grp for grp in self.spec_dict.get('shared_groups', [])\n                 if grp['title'] == group),\n                None)\n            if grp_dict is None:\n                raise SpecParserException(\n                    \"Unable to include group '{}' in '{}' parser. \"\n                    \"Group was not found!\".format(\n                        group,\n                        parser_dict['name']))\n\n            for option in grp_dict.get('options', {}).values():\n                option['is_shared_group_option'] = True\n\n            parser_groups_list = parser_dict.get('groups', [])\n            parser_groups_list.append(deepcopy(grp_dict))\n            parser_dict['groups'] = parser_groups_list", "signature": "def _include_groups(self, parser_dict):", "completion_path": "infrared/core/inspector/helper.py"}
{"ce_id": "6306092373426c38ae68acfa", "namespace": "6306092373426c38ae68acfa", "namespace_real": "infrared.core.inspector.inspector.get_spec_defaults", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "inspector", "function_name": "get_spec_defaults", "contexts_above": "import collections\nimport os\nfrom six.moves import configparser\nfrom string import Template\nimport yaml\n\nfrom infrared.core.cli.cli import CliParser\nfrom infrared.core.cli.cli import COMPLEX_TYPES\nfrom infrared.core.inspector import helper\nfrom infrared.core.utils import dict_utils\nfrom infrared.core.utils import exceptions\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n\nclass SpecParser(object):\n    \"\"\"Parses input arguments from different sources (cli, answers file). \"\"\"\n\n    @classmethod\n    def from_plugin(cls, subparser, plugin, base_groups):\n        \"\"\"Reads spec & vars from plugin and constructs the parser instance\n\n        :param subparser: argparse.subparser to extend\n        :param plugin: InfraredPlugin object\n        :param base_groups: dict, included groups\n        :return: SpecParser object based on given plugin spec & vars\n        \"\"\"\n\n        spec_dict = base_groups or {}\n        with open(plugin.spec) as stream:\n            spec = yaml.safe_load(stream) or {}\n            dict_utils.dict_merge(\n                base_groups,\n                spec,\n                dict_utils.ConflictResolver.unique_append_list_resolver)\n\n        # The \"try-excpet\" block here is for adding spec file path if it\n        # includes an unsupported option type\n        try:\n            return SpecParser(subparser, spec_dict, plugin.vars_dir,\n                              plugin.defaults_dir, plugin.path)\n        except exceptions.IRUnsupportedSpecOptionType as ex:\n            ex.message += ' in file: {}'.format(plugin.spec)\n            raise ex\n\n    def __init__(self, subparser, spec_dict, vars_dir, defaults_dir,\n                 plugin_path):\n        \"\"\"Constructor.\n\n        :param subparser: argparse.subparser to extend\n        :param spec_dict: dict with CLI description\n        :param vars_dir: Path to plugin's vars dir\n        :param defaults_dir: Path to plugin's defaults dir\n        \"\"\"\n        self.vars = vars_dir\n        self.defaults = defaults_dir\n        self.plugin_path = plugin_path\n        self.spec_helper = helper.SpecDictHelper(spec_dict)\n\n        # create parser\n        self.parser = CliParser.create_parser(self, subparser)\n\n    def add_shared_groups(self, list_of_groups):\n        \"\"\"Adds the user defined shared groups\n\n        :param list_of_groups: list, of group dicts\n        \"\"\"\n        shared_groups = self.spec_helper.spec_dict.get('shared_groups', [])\n        shared_groups.expand(list_of_groups)\n        self.spec_helper.spec_dict['shared_groups'] = shared_groups\n\n    def _get_defaults(self, default_getter_func):\n        \"\"\"Resolve arguments' values from cli or answers file.\n\n        :param default_getter_func: callable. will be called for all the\n            available options in spec file.\n        \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            default_value = default_getter_func(option)\n            if default_value is not None:\n                sub = parser['name']\n                result[sub][option['name']] = default_value\n\n        return result\n", "contexts_below": "    @staticmethod\n     def get_env_option(name):\n         \"\"\"Try get \"\"\"\n         return os.environ.get('IR_' + name.upper().replace('-', '_'))\n \n     def get_deprecated_args(self):\n         \"\"\"Returning dict with options which deprecate others. \"\"\"\n \n         result = collections.defaultdict(dict)\n         for parser, option in self.spec_helper.iterate_option_specs():\n             if option.get('deprecates') is not None:\n                 result[option.get('deprecates')] = option.get('name')\n \n         return result\n \n     @staticmethod\n     def parse_env_variable_from_file(value):\n         if isinstance(value, str):\n             t = Template(value)\n             try:\n                 value = t.substitute(os.environ)\n             except KeyError as undefined_var:\n                 raise exceptions.IRAnswersFileEnvVarNotDefined(undefined_var)\n         return value\n \n     def get_answers_file_args(self, cli_args):\n         \"\"\"Resolve arguments' values from answers INI file. \"\"\"\n \n         file_result = {}\n         args_to_remove = []\n         for (parser_name, parser_dict, arg_name, arg_value,\n              option_spec) in self._iterate_received_arguments(cli_args):\n             file_result[parser_name] = file_result.get(parser_name, {})\n             if option_spec and option_spec.get(\n                     'action', '') == 'read-answers':\n                 # Iterate over arguments supplied by file\n                 for parsed_arg in parser_dict[arg_name]:\n                     # Supplied arguments' value can be a list\n                     if isinstance(parser_dict[arg_name][parsed_arg], list):\n                         i = 0\n                         # Iterrate over argument values list\n                         for parsed_value in parser_dict[arg_name][parsed_arg]:\n                             parser_dict[arg_name][parsed_arg][i] = \\\n                                 SpecParser.parse_env_variable_from_file(parsed_value)\n                             i += 1\n                     else:\n                         parser_dict[arg_name][parsed_arg] = \\\n                             SpecParser.parse_env_variable_from_file(parser_dict[arg_name][parsed_arg])\n                 # we have config option. saving it.\n                 self._convert_non_cli_args(\n                     parser_name, parser_dict[arg_name])\n                 dict_utils.dict_merge(\n                     file_result[parser_name],\n                     parser_dict[arg_name])\n                 # remove from cli args\n                 args_to_remove.append((parser_name, arg_name))\n \n         # remove parser dict outside loop to avoid iteration dict modification\n         for parser_name, arg_name in args_to_remove:\n             for spec_parser in self.spec_helper.iterate_parsers():\n                 if spec_parser['name'] in cli_args and spec_parser['name'] == parser_name:\n                     parser_dict = cli_args[spec_parser['name']]\n                     parser_dict.pop(arg_name)\n                     break\n \n         return file_result\n \n     def generate_answers_file(self, cli_args, spec_defaults):\n         \"\"\"Generates answers INI file\n \n         :param cli_args: list, cli arguments.\n         :param spec_defaults: the default values.\n         \"\"\"\n \n         def put_option(config, parser_name, option_name, value):\n             for opt_help in option.get('help', '').split('\\n'):\n                 help_opt = '# ' + opt_help\n \n                 # add help comment\n                 if config.has_option(parser_name, help_opt):\n                     config.remove_option(parser_name, help_opt)\n                 config.set(\n                     parser_name, help_opt)\n \n             if config.has_option(parser_name, option_name):\n                 value = config.get(parser_name, option_name)\n                 config.remove_option(parser_name, option_name)\n \n             config.set(\n                 parser_name,\n                 option_name,\n                 str(value))\n \n         file_generated = False\n \n         # load generate answers file for all the parsers\n         for (parser_name, parser_dict, arg_name, arg_value,\n              option_spec) in self._iterate_received_arguments(cli_args):\n             if option_spec and option_spec.get(\n                     'action', '') == 'generate-answers':\n                 options_to_save = \\\n                     self.spec_helper.get_parser_option_specs(parser_name)\n                 out_answers = configparser.ConfigParser(allow_no_value=True)\n \n                 if not out_answers.has_section(parser_name):\n                     out_answers.add_section(parser_name)\n \n                 for option in options_to_save:\n                     opt_name = option['name']\n                     if opt_name in parser_dict:\n                         put_option(\n                             out_answers,\n                             parser_name,\n                             opt_name,\n                             parser_dict[opt_name])\n                     elif opt_name in spec_defaults[parser_name]:\n                         put_option(\n                             out_answers,\n                             parser_name,\n                             opt_name,\n                             spec_defaults[parser_name][opt_name])\n                     elif option.get('required', False):\n                         put_option(\n                             out_answers,\n                             parser_name,\n                             '# ' + opt_name,\n                             \"Required argument. \"\n                             \"Edit with one of the allowed values OR \"\n                             \"override with \"\n                             \"CLI: --{}=<option>\".format(opt_name))\n \n                 # write to file\n                 with open(arg_value, 'w') as answers_file:\n                     out_answers.write(answers_file)\n                 file_generated = True\n \n         return file_generated\n \n     def resolve_custom_types(self, args):\n         \"\"\"Transforms the arguments with custom types\n \n         :param args: the list of received arguments.\n         \"\"\"\n         for parser_name, parser_dict in args.items():\n             spec_complex_options = [opt for opt in\n                                     self.spec_helper.get_parser_option_specs(\n                                         parser_name) if\n                                     opt.get('type', None) in COMPLEX_TYPES]\n             for spec_option in spec_complex_options:\n                 option_name = spec_option['name']\n                 if option_name in parser_dict:\n                     # we have custom type to resolve\n                     type_name = spec_option['type']\n                     option_value = parser_dict[option_name]\n                     action = self.create_complex_argumet_type(\n                         parser_name,\n                         type_name,\n                         option_name,\n                         spec_option)\n \n                     # resolving value\n                     parser_dict[option_name] = action.resolve(option_value)\n \n     def create_complex_argumet_type(self, subcommand, type_name, option_name,\n                                     spec_option):\n         \"\"\"Build the complex argument type\n \n         :param subcommand: the command name\n         :param type_name: the complex type name\n         :param option_name: the option name\n         :param spec_option: option's specifications\n         :return: the complex type instance\n         \"\"\"\n         complex_action = COMPLEX_TYPES.get(\n             type_name, None)\n         if complex_action is None:\n             raise exceptions.SpecParserException(\n                 \"Unknown complex type: {}\".format(type_name))\n         return complex_action(\n             option_name,\n             (self.vars, self.defaults, self.plugin_path),\n             subcommand,\n             spec_option)\n \n     def parse_args(self, arg_parser, args=None):\n         \"\"\"Parses all the arguments (cli, answers file)\n \n         :return: None, if ``--generate-answers-file`` in arg_arg_parser\n         :return: (dict, dict):\n             * command arguments dict (arguments to control the IR logic)\n             * nested arguments dict (arguments to pass to the playbooks)\n         \"\"\"\n \n         spec_defaults = self.get_spec_defaults()\n         cli_args = CliParser.parse_cli_input(arg_parser, args)\n \n         file_args = self.get_answers_file_args(cli_args)\n \n         # generate answers file and exit\n         if self.generate_answers_file(cli_args, spec_defaults):\n             LOG.warning(\"Answers file generated. Exiting.\")\n \n         # print warnings when something was overridden from non-cli source.\n         self.validate_arg_sources(cli_args, file_args,\n                                   spec_defaults)\n \n         # print warnings for deprecated\n         self.validate_arg_deprecation(cli_args, file_args)\n \n         # now filter defaults to have only parser defined in cli\n         defaults = dict((key, spec_defaults[key])\n                         for key in cli_args.keys() if\n                         key in spec_defaults)\n \n         # copy cli args with the same name to all parser groups\n         self._merge_duplicated_cli_args(cli_args)\n         self._merge_duplicated_cli_args(file_args)\n \n         dict_utils.dict_merge(defaults, file_args)\n         dict_utils.dict_merge(defaults, cli_args)\n         self.validate_requires_args(defaults)\n         self.validate_length_args(defaults)\n         self.validate_choices_args(defaults)\n         self.validate_min_max_args(defaults)\n \n         # now resolve complex types.\n         self.resolve_custom_types(defaults)\n         nested, control, custom = \\\n             self.get_nested_custom_and_control_args(defaults)\n         return nested, control, custom\n \n     def validate_arg_deprecation(self, cli_args, answer_file_args):\n         \"\"\"Validates and prints the deprecated arguments.\n \n         :param cli_args: the dict of arguments from cli\n         :param answer_file_args:  the dict of arguments from files\n         \"\"\"\n \n         for deprecated, deprecates in self.get_deprecated_args().items():\n             for input_args in (answer_file_args.items(), cli_args.items()):\n                 for command, command_dict in input_args:\n                     if deprecated in command_dict:\n                         if deprecates in command_dict:\n                             raise exceptions.IRDeprecationException(\n                                 \"[{}] Argument '{}' deprecates '{}',\"\n                                 \" please use only the new one.\".format(\n                                     command, deprecated, deprecates))\n \n                         if deprecated in answer_file_args[command]:\n                             answer_file_args[command][deprecates] = \\\n                                 answer_file_args[command][deprecated]\n \n                         if deprecated in cli_args[command]:\n                             cli_args[command][deprecates] = \\\n                                 cli_args[command][deprecated]\n \n                         LOG.warning(\n                             \"[{}] Argument '{}' was deprecated,\"\n                             \" please use '{}'.\".format(\n                                 command, deprecated, deprecates))\n \n     @staticmethod\n     def validate_arg_sources(cli_args, answer_file_args, spec_defaults):\n         \"\"\"Validates and prints the arguments' source.\n \n         :param cli_args: the dict of arguments from cli\n         :param answer_file_args:  the dict of arguments from files\n         :param spec_defaults:  the default values from spec files\n         \"\"\"\n \n         def show_diff(diff, command_name, cmd_dict, source_name):\n             if diff:\n                 for arg_name in diff:\n                     value = cmd_dict[arg_name]\n                     LOG.info(\n                         \"[{}] Argument '{}' was set to\"\n                         \" '{}' from the {} source.\".format(\n                             command_name, arg_name, value, source_name))\n \n         for command, command_dict in cli_args.items():\n             file_dict = answer_file_args.get(command, {})\n             file_diff = set(file_dict.keys()) - set(command_dict.keys())\n             show_diff(file_diff, command, file_dict, 'answers file')\n \n             def_dict = spec_defaults.get(command, {})\n             default_diff = set(def_dict.keys()) - set(\n                 command_dict.keys()) - file_diff\n             show_diff(default_diff, command, def_dict, 'spec defaults')\n \n     def _get_conditionally_required_args(self, command_name, options_spec,\n                                          args):\n         \"\"\"List arguments with ``required_when`` condition matched.\n \n         :param command_name: the command name.\n         :param options_spec:  the list of command spec options.\n         :param args: the received input arguments\n         :return: list, list of argument names with matched ``required_when``\n             condition\n         \"\"\"\n         opts_names = [option_spec['name'] for option_spec in options_spec]\n         missing_args = []\n         for option_spec in options_spec:\n             option_results = []\n             if option_spec and 'required_when' in option_spec:\n                 req_when_args = [option_spec['required_when']] \\\n                     if not type(option_spec['required_when']) is list \\\n                     else option_spec['required_when']\n \n                 # validate conditions\n                 for req_when_arg in req_when_args:\n                     splited_args_list = req_when_arg.split()\n                     for idx, req_arg in enumerate(splited_args_list):\n                         if req_arg in opts_names:\n                             splited_args_list[idx] = \\\n                                 args.get(command_name, {}).get(req_arg.strip())\n                         if splited_args_list[idx] is None:\n                             option_results.append(False)\n                             break\n                         splited_args_list[idx] = str(splited_args_list[idx])\n                         if (splited_args_list[idx] not in ['and', 'or'] and\n                             not any(\n                                 (c in '<>=') for c in splited_args_list[idx])):\n                             splited_args_list[idx] = \"'{0}'\".format(\n                                 yaml.safe_load(splited_args_list[idx]))\n                     else:\n                         option_results.append(\n                             eval(' '.join(splited_args_list)))\n                 if all(option_results) and \\\n                         self.spec_helper.get_option_state(\n                             command_name,\n                             option_spec['name'],\n                             args) == helper.OptionState['NOT_SET']:\n                     missing_args.append(option_spec['name'])\n         return missing_args\n \n     def validate_requires_args(self, args):\n         \"\"\"Check if all the required arguments have been provided. \"\"\"\n \n         silent_args = self.get_silent_args(args)\n \n         def validate_parser(parser_name, expected_options, parser_args):\n             \"\"\"Helper method to resolve dict_merge. \"\"\"\n \n             result = collections.defaultdict(list)\n             condition_req_args = self._get_conditionally_required_args(\n                 parser_name, expected_options, args)\n \n             for option in expected_options:\n                 name = option['name']\n \n                 # check required options.\n                 if (option.get('required', False) and\n                     name not in parser_args or\n                     option['name'] in condition_req_args) and \\\n                         name not in silent_args:\n                     result[parser_name].append(name)\n \n             return result\n \n         res = {}\n         for command_data in self.spec_helper.iterate_parsers():\n             cmd_name = command_data['name']\n             if cmd_name in args:\n                 dict_utils.dict_merge(\n                     res,\n                     validate_parser(\n                         cmd_name,\n                         self.spec_helper.get_parser_option_specs(cmd_name),\n                         args[cmd_name]))\n \n         missing_args = dict((cmd_name, args)\n                             for cmd_name, args in res.items() if len(args) > 0)\n         if missing_args:\n             raise exceptions.IRRequiredArgsMissingException(missing_args)\n \n     def validate_length_args(self, args):\n         \"\"\"Check if value of arguments is not longer than length specified.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if 'length' not in spec_option:\n                     # skip options that does not contain length\n                     continue\n                 option_name = spec_option['name']\n                 if option_name in parser_dict:\n                     # resolve length\n                     length = spec_option['length']\n                     option_value = parser_dict[option_name]\n                     if len(option_value) > int(length):\n                         # found invalid option, append to list of invalid opts\n                         invalid_options.append((\n                             option_name,\n                             option_value,\n                             length\n                         ))\n         if invalid_options:\n             # raise exception with all arguments that exceed length\n             raise exceptions.IRInvalidLengthException(invalid_options)\n \n     def validate_choices_args(self, args):\n         \"\"\"Check if value of choice arguments is one of the available choices.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if 'choices' not in spec_option:\n                     # skip options that does not contain choices\n                     continue\n                 option_name = spec_option['name']\n                 if option_name in parser_dict:\n                     # resolve choices\n                     choices = spec_option['choices']\n                     option_value = parser_dict[option_name]\n                     if option_value not in choices:\n                         # found invalid option, append to list of invalid opts\n                         invalid_options.append((\n                             option_name,\n                             option_value,\n                             choices\n                         ))\n         if invalid_options:\n             # raise exception with all arguments that contains invalid choices\n             raise exceptions.IRInvalidChoiceException(invalid_options)\n \n     def validate_min_max_args(self, args):\n         \"\"\"Check if value of arguments is between minimum and maximum values.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if all([key not in spec_option\n                         for key in ('maximum', 'minimum')]):\n                     # skip options that does not contain minimum or maximum\n                     continue\n                 option_name = spec_option['name']\n \n                 if option_name in parser_dict:\n                     option_value = parser_dict[option_name]\n                     min_value = spec_option.get('minimum')\n                     max_value = spec_option.get('maximum')\n                     # handle empty values in spec files which load as None\n                     min_value = '' if 'minimum' in spec_option \\\n                                       and min_value is None else min_value\n                     max_value = '' if 'maximum' in spec_option \\\n                                       and max_value is None else max_value\n \n                     values = {\n                         \"value\": option_value,\n                         \"maximum\": max_value,\n                         \"minimum\": min_value\n                     }\n \n                     # make sure that values are numbers\n                     is_all_values_numbers = True\n                     for name, num in values.items():\n                         if num is not None \\\n                                 and (isinstance(num, bool) or\n                                      not isinstance(num, (int, float))):\n                             invalid_options.append((\n                                 option_name,\n                                 name,\n                                 \"number\",\n                                 type(num).__name__\n                             ))\n                             is_all_values_numbers = False\n \n                     if not is_all_values_numbers:\n                         # don't continue to min max checks since some of the\n                         # values are not numbers\n                         continue\n \n                     # check bigger than minimum\n                     if min_value is not None and option_value < min_value:\n                         invalid_options.append((\n                             option_name,\n                             \"minimum\",\n                             min_value,\n                             option_value\n                         ))\n                     # check smaller than maximum\n                     if max_value is not None and option_value > max_value:\n                         invalid_options.append((\n                             option_name,\n                             \"maximum\",\n                             max_value,\n                             option_value\n                         ))\n \n         if invalid_options:\n             # raise exception with all arguments that contains invalid choices\n             raise exceptions.IRInvalidMinMaxRangeException(invalid_options)\n \n     def get_silent_args(self, args):\n         \"\"\"list of silenced argument\n \n         :param args: The received arguments.\n         :return: list, slienced argument names\n         \"\"\"\n         silent_args_names = []\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if arg_spec and 'silent' in arg_spec and \\\n                     self.spec_helper.get_option_state(\n                         parser_name,\n                         arg_name,\n                         args) == helper.OptionState['IS_SET']:\n                 silent_args_names.extend(arg_spec['silent'])\n \n         return list(set(silent_args_names))\n \n     def get_nested_custom_and_control_args(self, args):\n         \"\"\"Split input arguments to control nested and custom.\n \n         Controls arguments: control the IR behavior. These arguments\n             will not be put into the spec yml file\n         Nested arguments: are used by the Ansible playbooks and will be put\n             into the spec yml file.\n         Custom arguments: Custom ansible variables to be used instead of the\n             normal nested usage.\n \n         :param args: the collected list of args.\n         :return: (dict, dict): flat dicts (control_args, nested_args)\n         \"\"\"\n         # returns flat dicts\n         nested = {}\n         control_args = {}\n         custom_args = {}\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if all([arg_spec, arg_spec.get('type', None),\n                     arg_spec.get('type', None) in\n                     [ctype_name for ctype_name, klass in\n                      COMPLEX_TYPES.items() if klass.is_nested]\n                     ]) or ('is_shared_group_option' not in arg_spec):\n                 if arg_name in nested:\n                     LOG.warning(\n                         \"Duplicated nested argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, nested[arg_name]))\n                 elif arg_name in custom_args:\n                     LOG.warning(\n                         \"Duplicated custom argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, custom_args[arg_name]))\n                 else:\n                     if \"ansible_variable\" in arg_spec:\n                         custom_args[arg_spec[\"ansible_variable\"]] = arg_value\n                     else:\n                         nested[arg_name] = arg_value\n             else:\n                 if arg_name in control_args:\n                     LOG.warning(\n                         \"Duplicated control argument found: '{}'. Using \"\n                         \"old value: '{}'\".format(\n                             arg_name, control_args[arg_name]))\n                 else:\n                     control_args[arg_name] = arg_value\n \n         return nested, control_args, custom_args\n \n     def _iterate_received_arguments(self, args):\n         \"\"\"Iterator helper method over all the received arguments\n \n         :return: yields tuple:\n             (spec name, spec dict,\n              argument name, argument value, argument spec)\n         \"\"\"\n         for spec_parser in self.spec_helper.iterate_parsers():\n             if spec_parser['name'] in args:\n                 parser_dict = args[spec_parser['name']]\n                 for arg_name, arg_val in parser_dict.items():\n                     arg_spec = self.spec_helper.get_option_spec(\n                         spec_parser['name'], arg_name)\n                     yield (spec_parser['name'], parser_dict,\n                            arg_name, arg_val, arg_spec)\n \n     def _convert_non_cli_args(self, parser_name, values_dict):\n         \"\"\"Casts arguments to correct types by modifying values_dict param.\n \n         By default all the values are strings.\n \n         :param parser_name: The command name, e.g. main, virsh, ospd, etc\n         :param values_dict: The dict of with arguments\n        \"\"\"\n         for opt_name, opt_value in values_dict.items():\n             file_option_spec = self.spec_helper.get_option_spec(\n                 parser_name, opt_name)\n             if file_option_spec.get('type', None) in ['int', ] or \\\n                     file_option_spec.get('action', None) in ['count', ]:\n                 values_dict[opt_name] = int(opt_value)\n \n     def _merge_duplicated_cli_args(self, cli_args):\n         \"\"\"Merge duplicated arguments to all the parsers\n \n         This is need to handle control args, shared among several parsers.\n         for example, verbose, inventory\n         \"\"\"\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(cli_args):\n             for parser_name2, parser_dict2 in cli_args.items():\n                 if all([parser_name2, parser_name != parser_name2,\n                         arg_name not in parser_dict2]):\n                     if self.spec_helper.get_option_spec(parser_name2,\n                                                         arg_name):\n                         parser_dict2[arg_name] = arg_value\n ", "input_code": "def get_spec_defaults(self):\n\"\"\"\nResolve arguments' values from spec and other sources.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def get_spec_defaults(self):\n        \"\"\"Resolve arguments' values from spec and other sources. \"\"\"\n\n        def spec_default_getter(option):\n            \"\"\"Getter function to retrieve the default value from spec.\n\n            :param option: argument name\n            \"\"\"\n\n            # first try to get environment variable with IR_ prefix\n            default_value = SpecParser.get_env_option(option['name'])\n            if default_value is not None:\n                LOG.info(\n                    \"[environ] Loading '{0}' default value\"\n                    \" '{1}' from the environment variable\".format(\n                        option['name'], default_value))\n            elif option.get('default', None) is not None:\n                default_value = option['default']\n            elif option.get('action', None) in ['store_true']:\n                default_value = False\n            return default_value\n\n        return self._get_defaults(spec_default_getter)", "signature": "def get_spec_defaults(self):", "completion_path": "infrared/core/inspector/inspector.py"}
{"ce_id": "6306092973426c38ae68ad01", "namespace": "6306092973426c38ae68ad01", "namespace_real": "infrared.core.inspector.inspector.get_deprecated_args", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "inspector", "function_name": "get_deprecated_args", "contexts_above": "import collections\nimport os\nfrom six.moves import configparser\nfrom string import Template\nimport yaml\n\nfrom infrared.core.cli.cli import CliParser\nfrom infrared.core.cli.cli import COMPLEX_TYPES\nfrom infrared.core.inspector import helper\nfrom infrared.core.utils import dict_utils\nfrom infrared.core.utils import exceptions\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n\nclass SpecParser(object):\n    \"\"\"Parses input arguments from different sources (cli, answers file). \"\"\"\n\n    @classmethod\n    def from_plugin(cls, subparser, plugin, base_groups):\n        \"\"\"Reads spec & vars from plugin and constructs the parser instance\n\n        :param subparser: argparse.subparser to extend\n        :param plugin: InfraredPlugin object\n        :param base_groups: dict, included groups\n        :return: SpecParser object based on given plugin spec & vars\n        \"\"\"\n\n        spec_dict = base_groups or {}\n        with open(plugin.spec) as stream:\n            spec = yaml.safe_load(stream) or {}\n            dict_utils.dict_merge(\n                base_groups,\n                spec,\n                dict_utils.ConflictResolver.unique_append_list_resolver)\n\n        # The \"try-excpet\" block here is for adding spec file path if it\n        # includes an unsupported option type\n        try:\n            return SpecParser(subparser, spec_dict, plugin.vars_dir,\n                              plugin.defaults_dir, plugin.path)\n        except exceptions.IRUnsupportedSpecOptionType as ex:\n            ex.message += ' in file: {}'.format(plugin.spec)\n            raise ex\n\n    def __init__(self, subparser, spec_dict, vars_dir, defaults_dir,\n                 plugin_path):\n        \"\"\"Constructor.\n\n        :param subparser: argparse.subparser to extend\n        :param spec_dict: dict with CLI description\n        :param vars_dir: Path to plugin's vars dir\n        :param defaults_dir: Path to plugin's defaults dir\n        \"\"\"\n        self.vars = vars_dir\n        self.defaults = defaults_dir\n        self.plugin_path = plugin_path\n        self.spec_helper = helper.SpecDictHelper(spec_dict)\n\n        # create parser\n        self.parser = CliParser.create_parser(self, subparser)\n\n    def add_shared_groups(self, list_of_groups):\n        \"\"\"Adds the user defined shared groups\n\n        :param list_of_groups: list, of group dicts\n        \"\"\"\n        shared_groups = self.spec_helper.spec_dict.get('shared_groups', [])\n        shared_groups.expand(list_of_groups)\n        self.spec_helper.spec_dict['shared_groups'] = shared_groups\n\n    def _get_defaults(self, default_getter_func):\n        \"\"\"Resolve arguments' values from cli or answers file.\n\n        :param default_getter_func: callable. will be called for all the\n            available options in spec file.\n        \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            default_value = default_getter_func(option)\n            if default_value is not None:\n                sub = parser['name']\n                result[sub][option['name']] = default_value\n\n        return result\n\n    def get_spec_defaults(self):\n        \"\"\"Resolve arguments' values from spec and other sources. \"\"\"\n\n        def spec_default_getter(option):\n            \"\"\"Getter function to retrieve the default value from spec.\n\n            :param option: argument name\n            \"\"\"\n\n            # first try to get environment variable with IR_ prefix\n            default_value = SpecParser.get_env_option(option['name'])\n            if default_value is not None:\n                LOG.info(\n                    \"[environ] Loading '{0}' default value\"\n                    \" '{1}' from the environment variable\".format(\n                        option['name'], default_value))\n            elif option.get('default', None) is not None:\n                default_value = option['default']\n            elif option.get('action', None) in ['store_true']:\n                default_value = False\n            return default_value\n\n        return self._get_defaults(spec_default_getter)\n\n    @staticmethod\n    def get_env_option(name):\n        \"\"\"Try get \"\"\"\n        return os.environ.get('IR_' + name.upper().replace('-', '_'))\n", "contexts_below": "    @staticmethod\n     def parse_env_variable_from_file(value):\n         if isinstance(value, str):\n             t = Template(value)\n             try:\n                 value = t.substitute(os.environ)\n             except KeyError as undefined_var:\n                 raise exceptions.IRAnswersFileEnvVarNotDefined(undefined_var)\n         return value\n \n     def get_answers_file_args(self, cli_args):\n         \"\"\"Resolve arguments' values from answers INI file. \"\"\"\n \n         file_result = {}\n         args_to_remove = []\n         for (parser_name, parser_dict, arg_name, arg_value,\n              option_spec) in self._iterate_received_arguments(cli_args):\n             file_result[parser_name] = file_result.get(parser_name, {})\n             if option_spec and option_spec.get(\n                     'action', '') == 'read-answers':\n                 # Iterate over arguments supplied by file\n                 for parsed_arg in parser_dict[arg_name]:\n                     # Supplied arguments' value can be a list\n                     if isinstance(parser_dict[arg_name][parsed_arg], list):\n                         i = 0\n                         # Iterrate over argument values list\n                         for parsed_value in parser_dict[arg_name][parsed_arg]:\n                             parser_dict[arg_name][parsed_arg][i] = \\\n                                 SpecParser.parse_env_variable_from_file(parsed_value)\n                             i += 1\n                     else:\n                         parser_dict[arg_name][parsed_arg] = \\\n                             SpecParser.parse_env_variable_from_file(parser_dict[arg_name][parsed_arg])\n                 # we have config option. saving it.\n                 self._convert_non_cli_args(\n                     parser_name, parser_dict[arg_name])\n                 dict_utils.dict_merge(\n                     file_result[parser_name],\n                     parser_dict[arg_name])\n                 # remove from cli args\n                 args_to_remove.append((parser_name, arg_name))\n \n         # remove parser dict outside loop to avoid iteration dict modification\n         for parser_name, arg_name in args_to_remove:\n             for spec_parser in self.spec_helper.iterate_parsers():\n                 if spec_parser['name'] in cli_args and spec_parser['name'] == parser_name:\n                     parser_dict = cli_args[spec_parser['name']]\n                     parser_dict.pop(arg_name)\n                     break\n \n         return file_result\n \n     def generate_answers_file(self, cli_args, spec_defaults):\n         \"\"\"Generates answers INI file\n \n         :param cli_args: list, cli arguments.\n         :param spec_defaults: the default values.\n         \"\"\"\n \n         def put_option(config, parser_name, option_name, value):\n             for opt_help in option.get('help', '').split('\\n'):\n                 help_opt = '# ' + opt_help\n \n                 # add help comment\n                 if config.has_option(parser_name, help_opt):\n                     config.remove_option(parser_name, help_opt)\n                 config.set(\n                     parser_name, help_opt)\n \n             if config.has_option(parser_name, option_name):\n                 value = config.get(parser_name, option_name)\n                 config.remove_option(parser_name, option_name)\n \n             config.set(\n                 parser_name,\n                 option_name,\n                 str(value))\n \n         file_generated = False\n \n         # load generate answers file for all the parsers\n         for (parser_name, parser_dict, arg_name, arg_value,\n              option_spec) in self._iterate_received_arguments(cli_args):\n             if option_spec and option_spec.get(\n                     'action', '') == 'generate-answers':\n                 options_to_save = \\\n                     self.spec_helper.get_parser_option_specs(parser_name)\n                 out_answers = configparser.ConfigParser(allow_no_value=True)\n \n                 if not out_answers.has_section(parser_name):\n                     out_answers.add_section(parser_name)\n \n                 for option in options_to_save:\n                     opt_name = option['name']\n                     if opt_name in parser_dict:\n                         put_option(\n                             out_answers,\n                             parser_name,\n                             opt_name,\n                             parser_dict[opt_name])\n                     elif opt_name in spec_defaults[parser_name]:\n                         put_option(\n                             out_answers,\n                             parser_name,\n                             opt_name,\n                             spec_defaults[parser_name][opt_name])\n                     elif option.get('required', False):\n                         put_option(\n                             out_answers,\n                             parser_name,\n                             '# ' + opt_name,\n                             \"Required argument. \"\n                             \"Edit with one of the allowed values OR \"\n                             \"override with \"\n                             \"CLI: --{}=<option>\".format(opt_name))\n \n                 # write to file\n                 with open(arg_value, 'w') as answers_file:\n                     out_answers.write(answers_file)\n                 file_generated = True\n \n         return file_generated\n \n     def resolve_custom_types(self, args):\n         \"\"\"Transforms the arguments with custom types\n \n         :param args: the list of received arguments.\n         \"\"\"\n         for parser_name, parser_dict in args.items():\n             spec_complex_options = [opt for opt in\n                                     self.spec_helper.get_parser_option_specs(\n                                         parser_name) if\n                                     opt.get('type', None) in COMPLEX_TYPES]\n             for spec_option in spec_complex_options:\n                 option_name = spec_option['name']\n                 if option_name in parser_dict:\n                     # we have custom type to resolve\n                     type_name = spec_option['type']\n                     option_value = parser_dict[option_name]\n                     action = self.create_complex_argumet_type(\n                         parser_name,\n                         type_name,\n                         option_name,\n                         spec_option)\n \n                     # resolving value\n                     parser_dict[option_name] = action.resolve(option_value)\n \n     def create_complex_argumet_type(self, subcommand, type_name, option_name,\n                                     spec_option):\n         \"\"\"Build the complex argument type\n \n         :param subcommand: the command name\n         :param type_name: the complex type name\n         :param option_name: the option name\n         :param spec_option: option's specifications\n         :return: the complex type instance\n         \"\"\"\n         complex_action = COMPLEX_TYPES.get(\n             type_name, None)\n         if complex_action is None:\n             raise exceptions.SpecParserException(\n                 \"Unknown complex type: {}\".format(type_name))\n         return complex_action(\n             option_name,\n             (self.vars, self.defaults, self.plugin_path),\n             subcommand,\n             spec_option)\n \n     def parse_args(self, arg_parser, args=None):\n         \"\"\"Parses all the arguments (cli, answers file)\n \n         :return: None, if ``--generate-answers-file`` in arg_arg_parser\n         :return: (dict, dict):\n             * command arguments dict (arguments to control the IR logic)\n             * nested arguments dict (arguments to pass to the playbooks)\n         \"\"\"\n \n         spec_defaults = self.get_spec_defaults()\n         cli_args = CliParser.parse_cli_input(arg_parser, args)\n \n         file_args = self.get_answers_file_args(cli_args)\n \n         # generate answers file and exit\n         if self.generate_answers_file(cli_args, spec_defaults):\n             LOG.warning(\"Answers file generated. Exiting.\")\n \n         # print warnings when something was overridden from non-cli source.\n         self.validate_arg_sources(cli_args, file_args,\n                                   spec_defaults)\n \n         # print warnings for deprecated\n         self.validate_arg_deprecation(cli_args, file_args)\n \n         # now filter defaults to have only parser defined in cli\n         defaults = dict((key, spec_defaults[key])\n                         for key in cli_args.keys() if\n                         key in spec_defaults)\n \n         # copy cli args with the same name to all parser groups\n         self._merge_duplicated_cli_args(cli_args)\n         self._merge_duplicated_cli_args(file_args)\n \n         dict_utils.dict_merge(defaults, file_args)\n         dict_utils.dict_merge(defaults, cli_args)\n         self.validate_requires_args(defaults)\n         self.validate_length_args(defaults)\n         self.validate_choices_args(defaults)\n         self.validate_min_max_args(defaults)\n \n         # now resolve complex types.\n         self.resolve_custom_types(defaults)\n         nested, control, custom = \\\n             self.get_nested_custom_and_control_args(defaults)\n         return nested, control, custom\n \n     def validate_arg_deprecation(self, cli_args, answer_file_args):\n         \"\"\"Validates and prints the deprecated arguments.\n \n         :param cli_args: the dict of arguments from cli\n         :param answer_file_args:  the dict of arguments from files\n         \"\"\"\n \n         for deprecated, deprecates in self.get_deprecated_args().items():\n             for input_args in (answer_file_args.items(), cli_args.items()):\n                 for command, command_dict in input_args:\n                     if deprecated in command_dict:\n                         if deprecates in command_dict:\n                             raise exceptions.IRDeprecationException(\n                                 \"[{}] Argument '{}' deprecates '{}',\"\n                                 \" please use only the new one.\".format(\n                                     command, deprecated, deprecates))\n \n                         if deprecated in answer_file_args[command]:\n                             answer_file_args[command][deprecates] = \\\n                                 answer_file_args[command][deprecated]\n \n                         if deprecated in cli_args[command]:\n                             cli_args[command][deprecates] = \\\n                                 cli_args[command][deprecated]\n \n                         LOG.warning(\n                             \"[{}] Argument '{}' was deprecated,\"\n                             \" please use '{}'.\".format(\n                                 command, deprecated, deprecates))\n \n     @staticmethod\n     def validate_arg_sources(cli_args, answer_file_args, spec_defaults):\n         \"\"\"Validates and prints the arguments' source.\n \n         :param cli_args: the dict of arguments from cli\n         :param answer_file_args:  the dict of arguments from files\n         :param spec_defaults:  the default values from spec files\n         \"\"\"\n \n         def show_diff(diff, command_name, cmd_dict, source_name):\n             if diff:\n                 for arg_name in diff:\n                     value = cmd_dict[arg_name]\n                     LOG.info(\n                         \"[{}] Argument '{}' was set to\"\n                         \" '{}' from the {} source.\".format(\n                             command_name, arg_name, value, source_name))\n \n         for command, command_dict in cli_args.items():\n             file_dict = answer_file_args.get(command, {})\n             file_diff = set(file_dict.keys()) - set(command_dict.keys())\n             show_diff(file_diff, command, file_dict, 'answers file')\n \n             def_dict = spec_defaults.get(command, {})\n             default_diff = set(def_dict.keys()) - set(\n                 command_dict.keys()) - file_diff\n             show_diff(default_diff, command, def_dict, 'spec defaults')\n \n     def _get_conditionally_required_args(self, command_name, options_spec,\n                                          args):\n         \"\"\"List arguments with ``required_when`` condition matched.\n \n         :param command_name: the command name.\n         :param options_spec:  the list of command spec options.\n         :param args: the received input arguments\n         :return: list, list of argument names with matched ``required_when``\n             condition\n         \"\"\"\n         opts_names = [option_spec['name'] for option_spec in options_spec]\n         missing_args = []\n         for option_spec in options_spec:\n             option_results = []\n             if option_spec and 'required_when' in option_spec:\n                 req_when_args = [option_spec['required_when']] \\\n                     if not type(option_spec['required_when']) is list \\\n                     else option_spec['required_when']\n \n                 # validate conditions\n                 for req_when_arg in req_when_args:\n                     splited_args_list = req_when_arg.split()\n                     for idx, req_arg in enumerate(splited_args_list):\n                         if req_arg in opts_names:\n                             splited_args_list[idx] = \\\n                                 args.get(command_name, {}).get(req_arg.strip())\n                         if splited_args_list[idx] is None:\n                             option_results.append(False)\n                             break\n                         splited_args_list[idx] = str(splited_args_list[idx])\n                         if (splited_args_list[idx] not in ['and', 'or'] and\n                             not any(\n                                 (c in '<>=') for c in splited_args_list[idx])):\n                             splited_args_list[idx] = \"'{0}'\".format(\n                                 yaml.safe_load(splited_args_list[idx]))\n                     else:\n                         option_results.append(\n                             eval(' '.join(splited_args_list)))\n                 if all(option_results) and \\\n                         self.spec_helper.get_option_state(\n                             command_name,\n                             option_spec['name'],\n                             args) == helper.OptionState['NOT_SET']:\n                     missing_args.append(option_spec['name'])\n         return missing_args\n \n     def validate_requires_args(self, args):\n         \"\"\"Check if all the required arguments have been provided. \"\"\"\n \n         silent_args = self.get_silent_args(args)\n \n         def validate_parser(parser_name, expected_options, parser_args):\n             \"\"\"Helper method to resolve dict_merge. \"\"\"\n \n             result = collections.defaultdict(list)\n             condition_req_args = self._get_conditionally_required_args(\n                 parser_name, expected_options, args)\n \n             for option in expected_options:\n                 name = option['name']\n \n                 # check required options.\n                 if (option.get('required', False) and\n                     name not in parser_args or\n                     option['name'] in condition_req_args) and \\\n                         name not in silent_args:\n                     result[parser_name].append(name)\n \n             return result\n \n         res = {}\n         for command_data in self.spec_helper.iterate_parsers():\n             cmd_name = command_data['name']\n             if cmd_name in args:\n                 dict_utils.dict_merge(\n                     res,\n                     validate_parser(\n                         cmd_name,\n                         self.spec_helper.get_parser_option_specs(cmd_name),\n                         args[cmd_name]))\n \n         missing_args = dict((cmd_name, args)\n                             for cmd_name, args in res.items() if len(args) > 0)\n         if missing_args:\n             raise exceptions.IRRequiredArgsMissingException(missing_args)\n \n     def validate_length_args(self, args):\n         \"\"\"Check if value of arguments is not longer than length specified.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if 'length' not in spec_option:\n                     # skip options that does not contain length\n                     continue\n                 option_name = spec_option['name']\n                 if option_name in parser_dict:\n                     # resolve length\n                     length = spec_option['length']\n                     option_value = parser_dict[option_name]\n                     if len(option_value) > int(length):\n                         # found invalid option, append to list of invalid opts\n                         invalid_options.append((\n                             option_name,\n                             option_value,\n                             length\n                         ))\n         if invalid_options:\n             # raise exception with all arguments that exceed length\n             raise exceptions.IRInvalidLengthException(invalid_options)\n \n     def validate_choices_args(self, args):\n         \"\"\"Check if value of choice arguments is one of the available choices.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if 'choices' not in spec_option:\n                     # skip options that does not contain choices\n                     continue\n                 option_name = spec_option['name']\n                 if option_name in parser_dict:\n                     # resolve choices\n                     choices = spec_option['choices']\n                     option_value = parser_dict[option_name]\n                     if option_value not in choices:\n                         # found invalid option, append to list of invalid opts\n                         invalid_options.append((\n                             option_name,\n                             option_value,\n                             choices\n                         ))\n         if invalid_options:\n             # raise exception with all arguments that contains invalid choices\n             raise exceptions.IRInvalidChoiceException(invalid_options)\n \n     def validate_min_max_args(self, args):\n         \"\"\"Check if value of arguments is between minimum and maximum values.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if all([key not in spec_option\n                         for key in ('maximum', 'minimum')]):\n                     # skip options that does not contain minimum or maximum\n                     continue\n                 option_name = spec_option['name']\n \n                 if option_name in parser_dict:\n                     option_value = parser_dict[option_name]\n                     min_value = spec_option.get('minimum')\n                     max_value = spec_option.get('maximum')\n                     # handle empty values in spec files which load as None\n                     min_value = '' if 'minimum' in spec_option \\\n                                       and min_value is None else min_value\n                     max_value = '' if 'maximum' in spec_option \\\n                                       and max_value is None else max_value\n \n                     values = {\n                         \"value\": option_value,\n                         \"maximum\": max_value,\n                         \"minimum\": min_value\n                     }\n \n                     # make sure that values are numbers\n                     is_all_values_numbers = True\n                     for name, num in values.items():\n                         if num is not None \\\n                                 and (isinstance(num, bool) or\n                                      not isinstance(num, (int, float))):\n                             invalid_options.append((\n                                 option_name,\n                                 name,\n                                 \"number\",\n                                 type(num).__name__\n                             ))\n                             is_all_values_numbers = False\n \n                     if not is_all_values_numbers:\n                         # don't continue to min max checks since some of the\n                         # values are not numbers\n                         continue\n \n                     # check bigger than minimum\n                     if min_value is not None and option_value < min_value:\n                         invalid_options.append((\n                             option_name,\n                             \"minimum\",\n                             min_value,\n                             option_value\n                         ))\n                     # check smaller than maximum\n                     if max_value is not None and option_value > max_value:\n                         invalid_options.append((\n                             option_name,\n                             \"maximum\",\n                             max_value,\n                             option_value\n                         ))\n \n         if invalid_options:\n             # raise exception with all arguments that contains invalid choices\n             raise exceptions.IRInvalidMinMaxRangeException(invalid_options)\n \n     def get_silent_args(self, args):\n         \"\"\"list of silenced argument\n \n         :param args: The received arguments.\n         :return: list, slienced argument names\n         \"\"\"\n         silent_args_names = []\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if arg_spec and 'silent' in arg_spec and \\\n                     self.spec_helper.get_option_state(\n                         parser_name,\n                         arg_name,\n                         args) == helper.OptionState['IS_SET']:\n                 silent_args_names.extend(arg_spec['silent'])\n \n         return list(set(silent_args_names))\n \n     def get_nested_custom_and_control_args(self, args):\n         \"\"\"Split input arguments to control nested and custom.\n \n         Controls arguments: control the IR behavior. These arguments\n             will not be put into the spec yml file\n         Nested arguments: are used by the Ansible playbooks and will be put\n             into the spec yml file.\n         Custom arguments: Custom ansible variables to be used instead of the\n             normal nested usage.\n \n         :param args: the collected list of args.\n         :return: (dict, dict): flat dicts (control_args, nested_args)\n         \"\"\"\n         # returns flat dicts\n         nested = {}\n         control_args = {}\n         custom_args = {}\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if all([arg_spec, arg_spec.get('type', None),\n                     arg_spec.get('type', None) in\n                     [ctype_name for ctype_name, klass in\n                      COMPLEX_TYPES.items() if klass.is_nested]\n                     ]) or ('is_shared_group_option' not in arg_spec):\n                 if arg_name in nested:\n                     LOG.warning(\n                         \"Duplicated nested argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, nested[arg_name]))\n                 elif arg_name in custom_args:\n                     LOG.warning(\n                         \"Duplicated custom argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, custom_args[arg_name]))\n                 else:\n                     if \"ansible_variable\" in arg_spec:\n                         custom_args[arg_spec[\"ansible_variable\"]] = arg_value\n                     else:\n                         nested[arg_name] = arg_value\n             else:\n                 if arg_name in control_args:\n                     LOG.warning(\n                         \"Duplicated control argument found: '{}'. Using \"\n                         \"old value: '{}'\".format(\n                             arg_name, control_args[arg_name]))\n                 else:\n                     control_args[arg_name] = arg_value\n \n         return nested, control_args, custom_args\n \n     def _iterate_received_arguments(self, args):\n         \"\"\"Iterator helper method over all the received arguments\n \n         :return: yields tuple:\n             (spec name, spec dict,\n              argument name, argument value, argument spec)\n         \"\"\"\n         for spec_parser in self.spec_helper.iterate_parsers():\n             if spec_parser['name'] in args:\n                 parser_dict = args[spec_parser['name']]\n                 for arg_name, arg_val in parser_dict.items():\n                     arg_spec = self.spec_helper.get_option_spec(\n                         spec_parser['name'], arg_name)\n                     yield (spec_parser['name'], parser_dict,\n                            arg_name, arg_val, arg_spec)\n \n     def _convert_non_cli_args(self, parser_name, values_dict):\n         \"\"\"Casts arguments to correct types by modifying values_dict param.\n \n         By default all the values are strings.\n \n         :param parser_name: The command name, e.g. main, virsh, ospd, etc\n         :param values_dict: The dict of with arguments\n        \"\"\"\n         for opt_name, opt_value in values_dict.items():\n             file_option_spec = self.spec_helper.get_option_spec(\n                 parser_name, opt_name)\n             if file_option_spec.get('type', None) in ['int', ] or \\\n                     file_option_spec.get('action', None) in ['count', ]:\n                 values_dict[opt_name] = int(opt_value)\n \n     def _merge_duplicated_cli_args(self, cli_args):\n         \"\"\"Merge duplicated arguments to all the parsers\n \n         This is need to handle control args, shared among several parsers.\n         for example, verbose, inventory\n         \"\"\"\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(cli_args):\n             for parser_name2, parser_dict2 in cli_args.items():\n                 if all([parser_name2, parser_name != parser_name2,\n                         arg_name not in parser_dict2]):\n                     if self.spec_helper.get_option_spec(parser_name2,\n                                                         arg_name):\n                         parser_dict2[arg_name] = arg_value\n ", "input_code": "def get_deprecated_args(self):\n\"\"\"\nReturning dict with options which deprecate others.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def get_deprecated_args(self):\n        \"\"\"Returning dict with options which deprecate others. \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            if option.get('deprecates') is not None:\n                result[option.get('deprecates')] = option.get('name')\n\n        return result", "signature": "def get_deprecated_args(self):", "completion_path": "infrared/core/inspector/inspector.py"}
{"ce_id": "6306092c73426c38ae68ad02", "namespace": "6306092c73426c38ae68ad02", "namespace_real": "infrared.core.inspector.inspector.validate_arg_deprecation", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "inspector", "function_name": "validate_arg_deprecation", "contexts_above": "import collections\nimport os\nfrom six.moves import configparser\nfrom string import Template\nimport yaml\n\nfrom infrared.core.cli.cli import CliParser\nfrom infrared.core.cli.cli import COMPLEX_TYPES\nfrom infrared.core.inspector import helper\nfrom infrared.core.utils import dict_utils\nfrom infrared.core.utils import exceptions\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n\nclass SpecParser(object):\n    \"\"\"Parses input arguments from different sources (cli, answers file). \"\"\"\n\n    @classmethod\n    def from_plugin(cls, subparser, plugin, base_groups):\n        \"\"\"Reads spec & vars from plugin and constructs the parser instance\n\n        :param subparser: argparse.subparser to extend\n        :param plugin: InfraredPlugin object\n        :param base_groups: dict, included groups\n        :return: SpecParser object based on given plugin spec & vars\n        \"\"\"\n\n        spec_dict = base_groups or {}\n        with open(plugin.spec) as stream:\n            spec = yaml.safe_load(stream) or {}\n            dict_utils.dict_merge(\n                base_groups,\n                spec,\n                dict_utils.ConflictResolver.unique_append_list_resolver)\n\n        # The \"try-excpet\" block here is for adding spec file path if it\n        # includes an unsupported option type\n        try:\n            return SpecParser(subparser, spec_dict, plugin.vars_dir,\n                              plugin.defaults_dir, plugin.path)\n        except exceptions.IRUnsupportedSpecOptionType as ex:\n            ex.message += ' in file: {}'.format(plugin.spec)\n            raise ex\n\n    def __init__(self, subparser, spec_dict, vars_dir, defaults_dir,\n                 plugin_path):\n        \"\"\"Constructor.\n\n        :param subparser: argparse.subparser to extend\n        :param spec_dict: dict with CLI description\n        :param vars_dir: Path to plugin's vars dir\n        :param defaults_dir: Path to plugin's defaults dir\n        \"\"\"\n        self.vars = vars_dir\n        self.defaults = defaults_dir\n        self.plugin_path = plugin_path\n        self.spec_helper = helper.SpecDictHelper(spec_dict)\n\n        # create parser\n        self.parser = CliParser.create_parser(self, subparser)\n\n    def add_shared_groups(self, list_of_groups):\n        \"\"\"Adds the user defined shared groups\n\n        :param list_of_groups: list, of group dicts\n        \"\"\"\n        shared_groups = self.spec_helper.spec_dict.get('shared_groups', [])\n        shared_groups.expand(list_of_groups)\n        self.spec_helper.spec_dict['shared_groups'] = shared_groups\n\n    def _get_defaults(self, default_getter_func):\n        \"\"\"Resolve arguments' values from cli or answers file.\n\n        :param default_getter_func: callable. will be called for all the\n            available options in spec file.\n        \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            default_value = default_getter_func(option)\n            if default_value is not None:\n                sub = parser['name']\n                result[sub][option['name']] = default_value\n\n        return result\n\n    def get_spec_defaults(self):\n        \"\"\"Resolve arguments' values from spec and other sources. \"\"\"\n\n        def spec_default_getter(option):\n            \"\"\"Getter function to retrieve the default value from spec.\n\n            :param option: argument name\n            \"\"\"\n\n            # first try to get environment variable with IR_ prefix\n            default_value = SpecParser.get_env_option(option['name'])\n            if default_value is not None:\n                LOG.info(\n                    \"[environ] Loading '{0}' default value\"\n                    \" '{1}' from the environment variable\".format(\n                        option['name'], default_value))\n            elif option.get('default', None) is not None:\n                default_value = option['default']\n            elif option.get('action', None) in ['store_true']:\n                default_value = False\n            return default_value\n\n        return self._get_defaults(spec_default_getter)\n\n    @staticmethod\n    def get_env_option(name):\n        \"\"\"Try get \"\"\"\n        return os.environ.get('IR_' + name.upper().replace('-', '_'))\n\n    def get_deprecated_args(self):\n        \"\"\"Returning dict with options which deprecate others. \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            if option.get('deprecates') is not None:\n                result[option.get('deprecates')] = option.get('name')\n\n        return result\n\n    @staticmethod\n    def parse_env_variable_from_file(value):\n        if isinstance(value, str):\n            t = Template(value)\n            try:\n                value = t.substitute(os.environ)\n            except KeyError as undefined_var:\n                raise exceptions.IRAnswersFileEnvVarNotDefined(undefined_var)\n        return value\n\n    def get_answers_file_args(self, cli_args):\n        \"\"\"Resolve arguments' values from answers INI file. \"\"\"\n\n        file_result = {}\n        args_to_remove = []\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            file_result[parser_name] = file_result.get(parser_name, {})\n            if option_spec and option_spec.get(\n                    'action', '') == 'read-answers':\n                # Iterate over arguments supplied by file\n                for parsed_arg in parser_dict[arg_name]:\n                    # Supplied arguments' value can be a list\n                    if isinstance(parser_dict[arg_name][parsed_arg], list):\n                        i = 0\n                        # Iterrate over argument values list\n                        for parsed_value in parser_dict[arg_name][parsed_arg]:\n                            parser_dict[arg_name][parsed_arg][i] = \\\n                                SpecParser.parse_env_variable_from_file(parsed_value)\n                            i += 1\n                    else:\n                        parser_dict[arg_name][parsed_arg] = \\\n                            SpecParser.parse_env_variable_from_file(parser_dict[arg_name][parsed_arg])\n                # we have config option. saving it.\n                self._convert_non_cli_args(\n                    parser_name, parser_dict[arg_name])\n                dict_utils.dict_merge(\n                    file_result[parser_name],\n                    parser_dict[arg_name])\n                # remove from cli args\n                args_to_remove.append((parser_name, arg_name))\n\n        # remove parser dict outside loop to avoid iteration dict modification\n        for parser_name, arg_name in args_to_remove:\n            for spec_parser in self.spec_helper.iterate_parsers():\n                if spec_parser['name'] in cli_args and spec_parser['name'] == parser_name:\n                    parser_dict = cli_args[spec_parser['name']]\n                    parser_dict.pop(arg_name)\n                    break\n\n        return file_result\n\n    def generate_answers_file(self, cli_args, spec_defaults):\n        \"\"\"Generates answers INI file\n\n        :param cli_args: list, cli arguments.\n        :param spec_defaults: the default values.\n        \"\"\"\n\n        def put_option(config, parser_name, option_name, value):\n            for opt_help in option.get('help', '').split('\\n'):\n                help_opt = '# ' + opt_help\n\n                # add help comment\n                if config.has_option(parser_name, help_opt):\n                    config.remove_option(parser_name, help_opt)\n                config.set(\n                    parser_name, help_opt)\n\n            if config.has_option(parser_name, option_name):\n                value = config.get(parser_name, option_name)\n                config.remove_option(parser_name, option_name)\n\n            config.set(\n                parser_name,\n                option_name,\n                str(value))\n\n        file_generated = False\n\n        # load generate answers file for all the parsers\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            if option_spec and option_spec.get(\n                    'action', '') == 'generate-answers':\n                options_to_save = \\\n                    self.spec_helper.get_parser_option_specs(parser_name)\n                out_answers = configparser.ConfigParser(allow_no_value=True)\n\n                if not out_answers.has_section(parser_name):\n                    out_answers.add_section(parser_name)\n\n                for option in options_to_save:\n                    opt_name = option['name']\n                    if opt_name in parser_dict:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            parser_dict[opt_name])\n                    elif opt_name in spec_defaults[parser_name]:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            spec_defaults[parser_name][opt_name])\n                    elif option.get('required', False):\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            '# ' + opt_name,\n                            \"Required argument. \"\n                            \"Edit with one of the allowed values OR \"\n                            \"override with \"\n                            \"CLI: --{}=<option>\".format(opt_name))\n\n                # write to file\n                with open(arg_value, 'w') as answers_file:\n                    out_answers.write(answers_file)\n                file_generated = True\n\n        return file_generated\n\n    def resolve_custom_types(self, args):\n        \"\"\"Transforms the arguments with custom types\n\n        :param args: the list of received arguments.\n        \"\"\"\n        for parser_name, parser_dict in args.items():\n            spec_complex_options = [opt for opt in\n                                    self.spec_helper.get_parser_option_specs(\n                                        parser_name) if\n                                    opt.get('type', None) in COMPLEX_TYPES]\n            for spec_option in spec_complex_options:\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # we have custom type to resolve\n                    type_name = spec_option['type']\n                    option_value = parser_dict[option_name]\n                    action = self.create_complex_argumet_type(\n                        parser_name,\n                        type_name,\n                        option_name,\n                        spec_option)\n\n                    # resolving value\n                    parser_dict[option_name] = action.resolve(option_value)\n\n    def create_complex_argumet_type(self, subcommand, type_name, option_name,\n                                    spec_option):\n        \"\"\"Build the complex argument type\n\n        :param subcommand: the command name\n        :param type_name: the complex type name\n        :param option_name: the option name\n        :param spec_option: option's specifications\n        :return: the complex type instance\n        \"\"\"\n        complex_action = COMPLEX_TYPES.get(\n            type_name, None)\n        if complex_action is None:\n            raise exceptions.SpecParserException(\n                \"Unknown complex type: {}\".format(type_name))\n        return complex_action(\n            option_name,\n            (self.vars, self.defaults, self.plugin_path),\n            subcommand,\n            spec_option)\n\n    def parse_args(self, arg_parser, args=None):\n        \"\"\"Parses all the arguments (cli, answers file)\n\n        :return: None, if ``--generate-answers-file`` in arg_arg_parser\n        :return: (dict, dict):\n            * command arguments dict (arguments to control the IR logic)\n            * nested arguments dict (arguments to pass to the playbooks)\n        \"\"\"\n\n        spec_defaults = self.get_spec_defaults()\n        cli_args = CliParser.parse_cli_input(arg_parser, args)\n\n        file_args = self.get_answers_file_args(cli_args)\n\n        # generate answers file and exit\n        if self.generate_answers_file(cli_args, spec_defaults):\n            LOG.warning(\"Answers file generated. Exiting.\")\n\n        # print warnings when something was overridden from non-cli source.\n        self.validate_arg_sources(cli_args, file_args,\n                                  spec_defaults)\n\n        # print warnings for deprecated\n        self.validate_arg_deprecation(cli_args, file_args)\n\n        # now filter defaults to have only parser defined in cli\n        defaults = dict((key, spec_defaults[key])\n                        for key in cli_args.keys() if\n                        key in spec_defaults)\n\n        # copy cli args with the same name to all parser groups\n        self._merge_duplicated_cli_args(cli_args)\n        self._merge_duplicated_cli_args(file_args)\n\n        dict_utils.dict_merge(defaults, file_args)\n        dict_utils.dict_merge(defaults, cli_args)\n        self.validate_requires_args(defaults)\n        self.validate_length_args(defaults)\n        self.validate_choices_args(defaults)\n        self.validate_min_max_args(defaults)\n\n        # now resolve complex types.\n        self.resolve_custom_types(defaults)\n        nested, control, custom = \\\n            self.get_nested_custom_and_control_args(defaults)\n        return nested, control, custom\n", "contexts_below": "    @staticmethod\n     def validate_arg_sources(cli_args, answer_file_args, spec_defaults):\n         \"\"\"Validates and prints the arguments' source.\n \n         :param cli_args: the dict of arguments from cli\n         :param answer_file_args:  the dict of arguments from files\n         :param spec_defaults:  the default values from spec files\n         \"\"\"\n \n         def show_diff(diff, command_name, cmd_dict, source_name):\n             if diff:\n                 for arg_name in diff:\n                     value = cmd_dict[arg_name]\n                     LOG.info(\n                         \"[{}] Argument '{}' was set to\"\n                         \" '{}' from the {} source.\".format(\n                             command_name, arg_name, value, source_name))\n \n         for command, command_dict in cli_args.items():\n             file_dict = answer_file_args.get(command, {})\n             file_diff = set(file_dict.keys()) - set(command_dict.keys())\n             show_diff(file_diff, command, file_dict, 'answers file')\n \n             def_dict = spec_defaults.get(command, {})\n             default_diff = set(def_dict.keys()) - set(\n                 command_dict.keys()) - file_diff\n             show_diff(default_diff, command, def_dict, 'spec defaults')\n \n     def _get_conditionally_required_args(self, command_name, options_spec,\n                                          args):\n         \"\"\"List arguments with ``required_when`` condition matched.\n \n         :param command_name: the command name.\n         :param options_spec:  the list of command spec options.\n         :param args: the received input arguments\n         :return: list, list of argument names with matched ``required_when``\n             condition\n         \"\"\"\n         opts_names = [option_spec['name'] for option_spec in options_spec]\n         missing_args = []\n         for option_spec in options_spec:\n             option_results = []\n             if option_spec and 'required_when' in option_spec:\n                 req_when_args = [option_spec['required_when']] \\\n                     if not type(option_spec['required_when']) is list \\\n                     else option_spec['required_when']\n \n                 # validate conditions\n                 for req_when_arg in req_when_args:\n                     splited_args_list = req_when_arg.split()\n                     for idx, req_arg in enumerate(splited_args_list):\n                         if req_arg in opts_names:\n                             splited_args_list[idx] = \\\n                                 args.get(command_name, {}).get(req_arg.strip())\n                         if splited_args_list[idx] is None:\n                             option_results.append(False)\n                             break\n                         splited_args_list[idx] = str(splited_args_list[idx])\n                         if (splited_args_list[idx] not in ['and', 'or'] and\n                             not any(\n                                 (c in '<>=') for c in splited_args_list[idx])):\n                             splited_args_list[idx] = \"'{0}'\".format(\n                                 yaml.safe_load(splited_args_list[idx]))\n                     else:\n                         option_results.append(\n                             eval(' '.join(splited_args_list)))\n                 if all(option_results) and \\\n                         self.spec_helper.get_option_state(\n                             command_name,\n                             option_spec['name'],\n                             args) == helper.OptionState['NOT_SET']:\n                     missing_args.append(option_spec['name'])\n         return missing_args\n \n     def validate_requires_args(self, args):\n         \"\"\"Check if all the required arguments have been provided. \"\"\"\n \n         silent_args = self.get_silent_args(args)\n \n         def validate_parser(parser_name, expected_options, parser_args):\n             \"\"\"Helper method to resolve dict_merge. \"\"\"\n \n             result = collections.defaultdict(list)\n             condition_req_args = self._get_conditionally_required_args(\n                 parser_name, expected_options, args)\n \n             for option in expected_options:\n                 name = option['name']\n \n                 # check required options.\n                 if (option.get('required', False) and\n                     name not in parser_args or\n                     option['name'] in condition_req_args) and \\\n                         name not in silent_args:\n                     result[parser_name].append(name)\n \n             return result\n \n         res = {}\n         for command_data in self.spec_helper.iterate_parsers():\n             cmd_name = command_data['name']\n             if cmd_name in args:\n                 dict_utils.dict_merge(\n                     res,\n                     validate_parser(\n                         cmd_name,\n                         self.spec_helper.get_parser_option_specs(cmd_name),\n                         args[cmd_name]))\n \n         missing_args = dict((cmd_name, args)\n                             for cmd_name, args in res.items() if len(args) > 0)\n         if missing_args:\n             raise exceptions.IRRequiredArgsMissingException(missing_args)\n \n     def validate_length_args(self, args):\n         \"\"\"Check if value of arguments is not longer than length specified.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if 'length' not in spec_option:\n                     # skip options that does not contain length\n                     continue\n                 option_name = spec_option['name']\n                 if option_name in parser_dict:\n                     # resolve length\n                     length = spec_option['length']\n                     option_value = parser_dict[option_name]\n                     if len(option_value) > int(length):\n                         # found invalid option, append to list of invalid opts\n                         invalid_options.append((\n                             option_name,\n                             option_value,\n                             length\n                         ))\n         if invalid_options:\n             # raise exception with all arguments that exceed length\n             raise exceptions.IRInvalidLengthException(invalid_options)\n \n     def validate_choices_args(self, args):\n         \"\"\"Check if value of choice arguments is one of the available choices.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if 'choices' not in spec_option:\n                     # skip options that does not contain choices\n                     continue\n                 option_name = spec_option['name']\n                 if option_name in parser_dict:\n                     # resolve choices\n                     choices = spec_option['choices']\n                     option_value = parser_dict[option_name]\n                     if option_value not in choices:\n                         # found invalid option, append to list of invalid opts\n                         invalid_options.append((\n                             option_name,\n                             option_value,\n                             choices\n                         ))\n         if invalid_options:\n             # raise exception with all arguments that contains invalid choices\n             raise exceptions.IRInvalidChoiceException(invalid_options)\n \n     def validate_min_max_args(self, args):\n         \"\"\"Check if value of arguments is between minimum and maximum values.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if all([key not in spec_option\n                         for key in ('maximum', 'minimum')]):\n                     # skip options that does not contain minimum or maximum\n                     continue\n                 option_name = spec_option['name']\n \n                 if option_name in parser_dict:\n                     option_value = parser_dict[option_name]\n                     min_value = spec_option.get('minimum')\n                     max_value = spec_option.get('maximum')\n                     # handle empty values in spec files which load as None\n                     min_value = '' if 'minimum' in spec_option \\\n                                       and min_value is None else min_value\n                     max_value = '' if 'maximum' in spec_option \\\n                                       and max_value is None else max_value\n \n                     values = {\n                         \"value\": option_value,\n                         \"maximum\": max_value,\n                         \"minimum\": min_value\n                     }\n \n                     # make sure that values are numbers\n                     is_all_values_numbers = True\n                     for name, num in values.items():\n                         if num is not None \\\n                                 and (isinstance(num, bool) or\n                                      not isinstance(num, (int, float))):\n                             invalid_options.append((\n                                 option_name,\n                                 name,\n                                 \"number\",\n                                 type(num).__name__\n                             ))\n                             is_all_values_numbers = False\n \n                     if not is_all_values_numbers:\n                         # don't continue to min max checks since some of the\n                         # values are not numbers\n                         continue\n \n                     # check bigger than minimum\n                     if min_value is not None and option_value < min_value:\n                         invalid_options.append((\n                             option_name,\n                             \"minimum\",\n                             min_value,\n                             option_value\n                         ))\n                     # check smaller than maximum\n                     if max_value is not None and option_value > max_value:\n                         invalid_options.append((\n                             option_name,\n                             \"maximum\",\n                             max_value,\n                             option_value\n                         ))\n \n         if invalid_options:\n             # raise exception with all arguments that contains invalid choices\n             raise exceptions.IRInvalidMinMaxRangeException(invalid_options)\n \n     def get_silent_args(self, args):\n         \"\"\"list of silenced argument\n \n         :param args: The received arguments.\n         :return: list, slienced argument names\n         \"\"\"\n         silent_args_names = []\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if arg_spec and 'silent' in arg_spec and \\\n                     self.spec_helper.get_option_state(\n                         parser_name,\n                         arg_name,\n                         args) == helper.OptionState['IS_SET']:\n                 silent_args_names.extend(arg_spec['silent'])\n \n         return list(set(silent_args_names))\n \n     def get_nested_custom_and_control_args(self, args):\n         \"\"\"Split input arguments to control nested and custom.\n \n         Controls arguments: control the IR behavior. These arguments\n             will not be put into the spec yml file\n         Nested arguments: are used by the Ansible playbooks and will be put\n             into the spec yml file.\n         Custom arguments: Custom ansible variables to be used instead of the\n             normal nested usage.\n \n         :param args: the collected list of args.\n         :return: (dict, dict): flat dicts (control_args, nested_args)\n         \"\"\"\n         # returns flat dicts\n         nested = {}\n         control_args = {}\n         custom_args = {}\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if all([arg_spec, arg_spec.get('type', None),\n                     arg_spec.get('type', None) in\n                     [ctype_name for ctype_name, klass in\n                      COMPLEX_TYPES.items() if klass.is_nested]\n                     ]) or ('is_shared_group_option' not in arg_spec):\n                 if arg_name in nested:\n                     LOG.warning(\n                         \"Duplicated nested argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, nested[arg_name]))\n                 elif arg_name in custom_args:\n                     LOG.warning(\n                         \"Duplicated custom argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, custom_args[arg_name]))\n                 else:\n                     if \"ansible_variable\" in arg_spec:\n                         custom_args[arg_spec[\"ansible_variable\"]] = arg_value\n                     else:\n                         nested[arg_name] = arg_value\n             else:\n                 if arg_name in control_args:\n                     LOG.warning(\n                         \"Duplicated control argument found: '{}'. Using \"\n                         \"old value: '{}'\".format(\n                             arg_name, control_args[arg_name]))\n                 else:\n                     control_args[arg_name] = arg_value\n \n         return nested, control_args, custom_args\n \n     def _iterate_received_arguments(self, args):\n         \"\"\"Iterator helper method over all the received arguments\n \n         :return: yields tuple:\n             (spec name, spec dict,\n              argument name, argument value, argument spec)\n         \"\"\"\n         for spec_parser in self.spec_helper.iterate_parsers():\n             if spec_parser['name'] in args:\n                 parser_dict = args[spec_parser['name']]\n                 for arg_name, arg_val in parser_dict.items():\n                     arg_spec = self.spec_helper.get_option_spec(\n                         spec_parser['name'], arg_name)\n                     yield (spec_parser['name'], parser_dict,\n                            arg_name, arg_val, arg_spec)\n \n     def _convert_non_cli_args(self, parser_name, values_dict):\n         \"\"\"Casts arguments to correct types by modifying values_dict param.\n \n         By default all the values are strings.\n \n         :param parser_name: The command name, e.g. main, virsh, ospd, etc\n         :param values_dict: The dict of with arguments\n        \"\"\"\n         for opt_name, opt_value in values_dict.items():\n             file_option_spec = self.spec_helper.get_option_spec(\n                 parser_name, opt_name)\n             if file_option_spec.get('type', None) in ['int', ] or \\\n                     file_option_spec.get('action', None) in ['count', ]:\n                 values_dict[opt_name] = int(opt_value)\n \n     def _merge_duplicated_cli_args(self, cli_args):\n         \"\"\"Merge duplicated arguments to all the parsers\n \n         This is need to handle control args, shared among several parsers.\n         for example, verbose, inventory\n         \"\"\"\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(cli_args):\n             for parser_name2, parser_dict2 in cli_args.items():\n                 if all([parser_name2, parser_name != parser_name2,\n                         arg_name not in parser_dict2]):\n                     if self.spec_helper.get_option_spec(parser_name2,\n                                                         arg_name):\n                         parser_dict2[arg_name] = arg_value\n ", "input_code": "def validate_arg_deprecation(self, cli_args, answer_file_args):\n\"\"\"\nValidates and prints the deprecated arguments.\n\n:param cli_args: the dict of arguments from cli\n:param answer_file_args:  the dict of arguments from files\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def validate_arg_deprecation(self, cli_args, answer_file_args):\n        \"\"\"Validates and prints the deprecated arguments.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        \"\"\"\n\n        for deprecated, deprecates in self.get_deprecated_args().items():\n            for input_args in (answer_file_args.items(), cli_args.items()):\n                for command, command_dict in input_args:\n                    if deprecated in command_dict:\n                        if deprecates in command_dict:\n                            raise exceptions.IRDeprecationException(\n                                \"[{}] Argument '{}' deprecates '{}',\"\n                                \" please use only the new one.\".format(\n                                    command, deprecated, deprecates))\n\n                        if deprecated in answer_file_args[command]:\n                            answer_file_args[command][deprecates] = \\\n                                answer_file_args[command][deprecated]\n\n                        if deprecated in cli_args[command]:\n                            cli_args[command][deprecates] = \\\n                                cli_args[command][deprecated]\n\n                        LOG.warning(\n                            \"[{}] Argument '{}' was deprecated,\"\n                            \" please use '{}'.\".format(\n                                command, deprecated, deprecates))", "signature": "def validate_arg_deprecation(self, cli_args, answer_file_args):", "completion_path": "infrared/core/inspector/inspector.py"}
{"ce_id": "6306092d73426c38ae68ad04", "namespace": "6306092d73426c38ae68ad04", "namespace_real": "infrared.core.inspector.helper.get_parser_option_specs", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "helper", "function_name": "get_parser_option_specs", "contexts_above": "from copy import deepcopy\nfrom infrared.core.utils.exceptions import SpecParserException\n\nOptionState = dict(\n    UNRECOGNIZED='unrecognized',\n    IS_SET='is set',\n    NOT_SET='is no set'\n)\n\n\nclass SpecDictHelper(object):\n    \"\"\"Controls the spec dicts and provides useful methods to get spec info.\"\"\"\n\n    def __init__(self, spec_dict):\n        self.spec_dict = spec_dict\n        # make structure of the dict flat\n        # 1. handle include_groups directive in main parser\n        parser_dict = self.spec_dict\n        self._include_groups(parser_dict)\n        # 2. Include groups for all subparsers\n        for subparser_name, subparser_dict in parser_dict.get(\n                'subparsers', {}).items():\n            self._include_groups(subparser_dict)\n\n    def iterate_parsers(self):\n        \"\"\"Iterates over the main parsers and subparsers. \"\"\"\n\n        for subparser_name, subparser_dict in self.spec_dict.get(\n                'subparsers', {}).items():\n            yield dict(name=subparser_name, **subparser_dict)\n\n    def iterate_option_specs(self):\n        \"\"\"Iterates over all the option specs.\n\n        Returns pair of parser and option on every iteration.\n        \"\"\"\n        for parser in self.iterate_parsers():\n            for spec_option in self._get_all_options_spec(parser):\n                yield parser, spec_option\n\n    @staticmethod\n    def _get_all_options_spec(parser_dict):\n        \"\"\"Gets all the options specification as the list of dicts. \"\"\"\n        result = []\n        for group in parser_dict.get('groups', []):\n            for option_name, option_dict in group.get('options', {}).items():\n                result.append(dict(name=option_name, **option_dict))\n\n        for option_name, option_dict in parser_dict.get('options', {}).items():\n            result.append(dict(name=option_name, **option_dict))\n\n        return result\n", "contexts_below": "    def get_option_spec(self, command_name, argument_name):\n         \"\"\"Gets the specification for the specified option name. \"\"\"\n \n         options = self.get_parser_option_specs(command_name)\n         return next((opt for opt in options\n                      if opt['name'] == argument_name), {})\n \n     def get_option_state(self, command_name, option_name, args):\n         \"\"\"Gets the option state.\n \n         :param command_name: The command name\n         :param option_name: The option name to analyze\n         :param args: The received arguments.\n         \"\"\"\n         option_spec = self.get_option_spec(command_name, option_name)\n \n         if not option_spec:\n             res = OptionState['UNRECOGNIZED']\n \n         elif option_name not in args.get(command_name, {}):\n             res = OptionState['NOT_SET']\n         else:\n             option_value = args[command_name][option_name]\n             if option_spec.get('action', '') in ['store_true'] \\\n                     and option_value is False:\n                 res = OptionState['NOT_SET']\n             else:\n                 res = OptionState['IS_SET']\n \n         return res\n \n     def _include_groups(self, parser_dict):\n         \"\"\"Resolves the include dict directive in the spec files. \"\"\"\n         for group in parser_dict.get('include_groups', []):\n             # ensure we have that group\n             grp_dict = next(\n                 (grp for grp in self.spec_dict.get('shared_groups', [])\n                  if grp['title'] == group),\n                 None)\n             if grp_dict is None:\n                 raise SpecParserException(\n                     \"Unable to include group '{}' in '{}' parser. \"\n                     \"Group was not found!\".format(\n                         group,\n                         parser_dict['name']))\n \n             for option in grp_dict.get('options', {}).values():\n                 option['is_shared_group_option'] = True\n \n             parser_groups_list = parser_dict.get('groups', [])\n             parser_groups_list.append(deepcopy(grp_dict))\n             parser_dict['groups'] = parser_groups_list\n ", "input_code": "def get_parser_option_specs(self, command_name):\n\"\"\"\nGets all the options for the specified command\n\n:param command_name: the command name (main, virsh, ospd, etc...)\n:return: the list of all command options\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def get_parser_option_specs(self, command_name):\n        \"\"\"Gets all the options for the specified command\n\n        :param command_name: the command name (main, virsh, ospd, etc...)\n        :return: the list of all command options\n        \"\"\"\n        options = []\n        for parser in self.iterate_parsers():\n            if parser['name'] == command_name:\n                options = self._get_all_options_spec(parser)\n                break\n        return options", "signature": "def get_parser_option_specs(self, command_name):", "completion_path": "infrared/core/inspector/helper.py"}
{"ce_id": "6306092d73426c38ae68ad05", "namespace": "6306092d73426c38ae68ad05", "namespace_real": "infrared.core.inspector.helper.get_option_spec", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "helper", "function_name": "get_option_spec", "contexts_above": "from copy import deepcopy\nfrom infrared.core.utils.exceptions import SpecParserException\n\nOptionState = dict(\n    UNRECOGNIZED='unrecognized',\n    IS_SET='is set',\n    NOT_SET='is no set'\n)\n\n\nclass SpecDictHelper(object):\n    \"\"\"Controls the spec dicts and provides useful methods to get spec info.\"\"\"\n\n    def __init__(self, spec_dict):\n        self.spec_dict = spec_dict\n        # make structure of the dict flat\n        # 1. handle include_groups directive in main parser\n        parser_dict = self.spec_dict\n        self._include_groups(parser_dict)\n        # 2. Include groups for all subparsers\n        for subparser_name, subparser_dict in parser_dict.get(\n                'subparsers', {}).items():\n            self._include_groups(subparser_dict)\n\n    def iterate_parsers(self):\n        \"\"\"Iterates over the main parsers and subparsers. \"\"\"\n\n        for subparser_name, subparser_dict in self.spec_dict.get(\n                'subparsers', {}).items():\n            yield dict(name=subparser_name, **subparser_dict)\n\n    def iterate_option_specs(self):\n        \"\"\"Iterates over all the option specs.\n\n        Returns pair of parser and option on every iteration.\n        \"\"\"\n        for parser in self.iterate_parsers():\n            for spec_option in self._get_all_options_spec(parser):\n                yield parser, spec_option\n\n    @staticmethod\n    def _get_all_options_spec(parser_dict):\n        \"\"\"Gets all the options specification as the list of dicts. \"\"\"\n        result = []\n        for group in parser_dict.get('groups', []):\n            for option_name, option_dict in group.get('options', {}).items():\n                result.append(dict(name=option_name, **option_dict))\n\n        for option_name, option_dict in parser_dict.get('options', {}).items():\n            result.append(dict(name=option_name, **option_dict))\n\n        return result\n\n    def get_parser_option_specs(self, command_name):\n        \"\"\"Gets all the options for the specified command\n\n        :param command_name: the command name (main, virsh, ospd, etc...)\n        :return: the list of all command options\n        \"\"\"\n        options = []\n        for parser in self.iterate_parsers():\n            if parser['name'] == command_name:\n                options = self._get_all_options_spec(parser)\n                break\n        return options\n", "contexts_below": "    def get_option_state(self, command_name, option_name, args):\n         \"\"\"Gets the option state.\n \n         :param command_name: The command name\n         :param option_name: The option name to analyze\n         :param args: The received arguments.\n         \"\"\"\n         option_spec = self.get_option_spec(command_name, option_name)\n \n         if not option_spec:\n             res = OptionState['UNRECOGNIZED']\n \n         elif option_name not in args.get(command_name, {}):\n             res = OptionState['NOT_SET']\n         else:\n             option_value = args[command_name][option_name]\n             if option_spec.get('action', '') in ['store_true'] \\\n                     and option_value is False:\n                 res = OptionState['NOT_SET']\n             else:\n                 res = OptionState['IS_SET']\n \n         return res\n \n     def _include_groups(self, parser_dict):\n         \"\"\"Resolves the include dict directive in the spec files. \"\"\"\n         for group in parser_dict.get('include_groups', []):\n             # ensure we have that group\n             grp_dict = next(\n                 (grp for grp in self.spec_dict.get('shared_groups', [])\n                  if grp['title'] == group),\n                 None)\n             if grp_dict is None:\n                 raise SpecParserException(\n                     \"Unable to include group '{}' in '{}' parser. \"\n                     \"Group was not found!\".format(\n                         group,\n                         parser_dict['name']))\n \n             for option in grp_dict.get('options', {}).values():\n                 option['is_shared_group_option'] = True\n \n             parser_groups_list = parser_dict.get('groups', [])\n             parser_groups_list.append(deepcopy(grp_dict))\n             parser_dict['groups'] = parser_groups_list\n ", "input_code": "def get_option_spec(self, command_name, argument_name):\n\"\"\"\nGets the specification for the specified option name.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def get_option_spec(self, command_name, argument_name):\n        \"\"\"Gets the specification for the specified option name. \"\"\"\n\n        options = self.get_parser_option_specs(command_name)\n        return next((opt for opt in options\n                     if opt['name'] == argument_name), {})", "signature": "def get_option_spec(self, command_name, argument_name):", "completion_path": "infrared/core/inspector/helper.py"}
{"ce_id": "6306092d73426c38ae68ad06", "namespace": "6306092d73426c38ae68ad06", "namespace_real": "infrared.core.inspector.inspector.get_silent_args", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "inspector", "function_name": "get_silent_args", "contexts_above": "import collections\nimport os\nfrom six.moves import configparser\nfrom string import Template\nimport yaml\n\nfrom infrared.core.cli.cli import CliParser\nfrom infrared.core.cli.cli import COMPLEX_TYPES\nfrom infrared.core.inspector import helper\nfrom infrared.core.utils import dict_utils\nfrom infrared.core.utils import exceptions\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n\nclass SpecParser(object):\n    \"\"\"Parses input arguments from different sources (cli, answers file). \"\"\"\n\n    @classmethod\n    def from_plugin(cls, subparser, plugin, base_groups):\n        \"\"\"Reads spec & vars from plugin and constructs the parser instance\n\n        :param subparser: argparse.subparser to extend\n        :param plugin: InfraredPlugin object\n        :param base_groups: dict, included groups\n        :return: SpecParser object based on given plugin spec & vars\n        \"\"\"\n\n        spec_dict = base_groups or {}\n        with open(plugin.spec) as stream:\n            spec = yaml.safe_load(stream) or {}\n            dict_utils.dict_merge(\n                base_groups,\n                spec,\n                dict_utils.ConflictResolver.unique_append_list_resolver)\n\n        # The \"try-excpet\" block here is for adding spec file path if it\n        # includes an unsupported option type\n        try:\n            return SpecParser(subparser, spec_dict, plugin.vars_dir,\n                              plugin.defaults_dir, plugin.path)\n        except exceptions.IRUnsupportedSpecOptionType as ex:\n            ex.message += ' in file: {}'.format(plugin.spec)\n            raise ex\n\n    def __init__(self, subparser, spec_dict, vars_dir, defaults_dir,\n                 plugin_path):\n        \"\"\"Constructor.\n\n        :param subparser: argparse.subparser to extend\n        :param spec_dict: dict with CLI description\n        :param vars_dir: Path to plugin's vars dir\n        :param defaults_dir: Path to plugin's defaults dir\n        \"\"\"\n        self.vars = vars_dir\n        self.defaults = defaults_dir\n        self.plugin_path = plugin_path\n        self.spec_helper = helper.SpecDictHelper(spec_dict)\n\n        # create parser\n        self.parser = CliParser.create_parser(self, subparser)\n\n    def add_shared_groups(self, list_of_groups):\n        \"\"\"Adds the user defined shared groups\n\n        :param list_of_groups: list, of group dicts\n        \"\"\"\n        shared_groups = self.spec_helper.spec_dict.get('shared_groups', [])\n        shared_groups.expand(list_of_groups)\n        self.spec_helper.spec_dict['shared_groups'] = shared_groups\n\n    def _get_defaults(self, default_getter_func):\n        \"\"\"Resolve arguments' values from cli or answers file.\n\n        :param default_getter_func: callable. will be called for all the\n            available options in spec file.\n        \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            default_value = default_getter_func(option)\n            if default_value is not None:\n                sub = parser['name']\n                result[sub][option['name']] = default_value\n\n        return result\n\n    def get_spec_defaults(self):\n        \"\"\"Resolve arguments' values from spec and other sources. \"\"\"\n\n        def spec_default_getter(option):\n            \"\"\"Getter function to retrieve the default value from spec.\n\n            :param option: argument name\n            \"\"\"\n\n            # first try to get environment variable with IR_ prefix\n            default_value = SpecParser.get_env_option(option['name'])\n            if default_value is not None:\n                LOG.info(\n                    \"[environ] Loading '{0}' default value\"\n                    \" '{1}' from the environment variable\".format(\n                        option['name'], default_value))\n            elif option.get('default', None) is not None:\n                default_value = option['default']\n            elif option.get('action', None) in ['store_true']:\n                default_value = False\n            return default_value\n\n        return self._get_defaults(spec_default_getter)\n\n    @staticmethod\n    def get_env_option(name):\n        \"\"\"Try get \"\"\"\n        return os.environ.get('IR_' + name.upper().replace('-', '_'))\n\n    def get_deprecated_args(self):\n        \"\"\"Returning dict with options which deprecate others. \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            if option.get('deprecates') is not None:\n                result[option.get('deprecates')] = option.get('name')\n\n        return result\n\n    @staticmethod\n    def parse_env_variable_from_file(value):\n        if isinstance(value, str):\n            t = Template(value)\n            try:\n                value = t.substitute(os.environ)\n            except KeyError as undefined_var:\n                raise exceptions.IRAnswersFileEnvVarNotDefined(undefined_var)\n        return value\n\n    def get_answers_file_args(self, cli_args):\n        \"\"\"Resolve arguments' values from answers INI file. \"\"\"\n\n        file_result = {}\n        args_to_remove = []\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            file_result[parser_name] = file_result.get(parser_name, {})\n            if option_spec and option_spec.get(\n                    'action', '') == 'read-answers':\n                # Iterate over arguments supplied by file\n                for parsed_arg in parser_dict[arg_name]:\n                    # Supplied arguments' value can be a list\n                    if isinstance(parser_dict[arg_name][parsed_arg], list):\n                        i = 0\n                        # Iterrate over argument values list\n                        for parsed_value in parser_dict[arg_name][parsed_arg]:\n                            parser_dict[arg_name][parsed_arg][i] = \\\n                                SpecParser.parse_env_variable_from_file(parsed_value)\n                            i += 1\n                    else:\n                        parser_dict[arg_name][parsed_arg] = \\\n                            SpecParser.parse_env_variable_from_file(parser_dict[arg_name][parsed_arg])\n                # we have config option. saving it.\n                self._convert_non_cli_args(\n                    parser_name, parser_dict[arg_name])\n                dict_utils.dict_merge(\n                    file_result[parser_name],\n                    parser_dict[arg_name])\n                # remove from cli args\n                args_to_remove.append((parser_name, arg_name))\n\n        # remove parser dict outside loop to avoid iteration dict modification\n        for parser_name, arg_name in args_to_remove:\n            for spec_parser in self.spec_helper.iterate_parsers():\n                if spec_parser['name'] in cli_args and spec_parser['name'] == parser_name:\n                    parser_dict = cli_args[spec_parser['name']]\n                    parser_dict.pop(arg_name)\n                    break\n\n        return file_result\n\n    def generate_answers_file(self, cli_args, spec_defaults):\n        \"\"\"Generates answers INI file\n\n        :param cli_args: list, cli arguments.\n        :param spec_defaults: the default values.\n        \"\"\"\n\n        def put_option(config, parser_name, option_name, value):\n            for opt_help in option.get('help', '').split('\\n'):\n                help_opt = '# ' + opt_help\n\n                # add help comment\n                if config.has_option(parser_name, help_opt):\n                    config.remove_option(parser_name, help_opt)\n                config.set(\n                    parser_name, help_opt)\n\n            if config.has_option(parser_name, option_name):\n                value = config.get(parser_name, option_name)\n                config.remove_option(parser_name, option_name)\n\n            config.set(\n                parser_name,\n                option_name,\n                str(value))\n\n        file_generated = False\n\n        # load generate answers file for all the parsers\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            if option_spec and option_spec.get(\n                    'action', '') == 'generate-answers':\n                options_to_save = \\\n                    self.spec_helper.get_parser_option_specs(parser_name)\n                out_answers = configparser.ConfigParser(allow_no_value=True)\n\n                if not out_answers.has_section(parser_name):\n                    out_answers.add_section(parser_name)\n\n                for option in options_to_save:\n                    opt_name = option['name']\n                    if opt_name in parser_dict:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            parser_dict[opt_name])\n                    elif opt_name in spec_defaults[parser_name]:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            spec_defaults[parser_name][opt_name])\n                    elif option.get('required', False):\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            '# ' + opt_name,\n                            \"Required argument. \"\n                            \"Edit with one of the allowed values OR \"\n                            \"override with \"\n                            \"CLI: --{}=<option>\".format(opt_name))\n\n                # write to file\n                with open(arg_value, 'w') as answers_file:\n                    out_answers.write(answers_file)\n                file_generated = True\n\n        return file_generated\n\n    def resolve_custom_types(self, args):\n        \"\"\"Transforms the arguments with custom types\n\n        :param args: the list of received arguments.\n        \"\"\"\n        for parser_name, parser_dict in args.items():\n            spec_complex_options = [opt for opt in\n                                    self.spec_helper.get_parser_option_specs(\n                                        parser_name) if\n                                    opt.get('type', None) in COMPLEX_TYPES]\n            for spec_option in spec_complex_options:\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # we have custom type to resolve\n                    type_name = spec_option['type']\n                    option_value = parser_dict[option_name]\n                    action = self.create_complex_argumet_type(\n                        parser_name,\n                        type_name,\n                        option_name,\n                        spec_option)\n\n                    # resolving value\n                    parser_dict[option_name] = action.resolve(option_value)\n\n    def create_complex_argumet_type(self, subcommand, type_name, option_name,\n                                    spec_option):\n        \"\"\"Build the complex argument type\n\n        :param subcommand: the command name\n        :param type_name: the complex type name\n        :param option_name: the option name\n        :param spec_option: option's specifications\n        :return: the complex type instance\n        \"\"\"\n        complex_action = COMPLEX_TYPES.get(\n            type_name, None)\n        if complex_action is None:\n            raise exceptions.SpecParserException(\n                \"Unknown complex type: {}\".format(type_name))\n        return complex_action(\n            option_name,\n            (self.vars, self.defaults, self.plugin_path),\n            subcommand,\n            spec_option)\n\n    def parse_args(self, arg_parser, args=None):\n        \"\"\"Parses all the arguments (cli, answers file)\n\n        :return: None, if ``--generate-answers-file`` in arg_arg_parser\n        :return: (dict, dict):\n            * command arguments dict (arguments to control the IR logic)\n            * nested arguments dict (arguments to pass to the playbooks)\n        \"\"\"\n\n        spec_defaults = self.get_spec_defaults()\n        cli_args = CliParser.parse_cli_input(arg_parser, args)\n\n        file_args = self.get_answers_file_args(cli_args)\n\n        # generate answers file and exit\n        if self.generate_answers_file(cli_args, spec_defaults):\n            LOG.warning(\"Answers file generated. Exiting.\")\n\n        # print warnings when something was overridden from non-cli source.\n        self.validate_arg_sources(cli_args, file_args,\n                                  spec_defaults)\n\n        # print warnings for deprecated\n        self.validate_arg_deprecation(cli_args, file_args)\n\n        # now filter defaults to have only parser defined in cli\n        defaults = dict((key, spec_defaults[key])\n                        for key in cli_args.keys() if\n                        key in spec_defaults)\n\n        # copy cli args with the same name to all parser groups\n        self._merge_duplicated_cli_args(cli_args)\n        self._merge_duplicated_cli_args(file_args)\n\n        dict_utils.dict_merge(defaults, file_args)\n        dict_utils.dict_merge(defaults, cli_args)\n        self.validate_requires_args(defaults)\n        self.validate_length_args(defaults)\n        self.validate_choices_args(defaults)\n        self.validate_min_max_args(defaults)\n\n        # now resolve complex types.\n        self.resolve_custom_types(defaults)\n        nested, control, custom = \\\n            self.get_nested_custom_and_control_args(defaults)\n        return nested, control, custom\n\n    def validate_arg_deprecation(self, cli_args, answer_file_args):\n        \"\"\"Validates and prints the deprecated arguments.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        \"\"\"\n\n        for deprecated, deprecates in self.get_deprecated_args().items():\n            for input_args in (answer_file_args.items(), cli_args.items()):\n                for command, command_dict in input_args:\n                    if deprecated in command_dict:\n                        if deprecates in command_dict:\n                            raise exceptions.IRDeprecationException(\n                                \"[{}] Argument '{}' deprecates '{}',\"\n                                \" please use only the new one.\".format(\n                                    command, deprecated, deprecates))\n\n                        if deprecated in answer_file_args[command]:\n                            answer_file_args[command][deprecates] = \\\n                                answer_file_args[command][deprecated]\n\n                        if deprecated in cli_args[command]:\n                            cli_args[command][deprecates] = \\\n                                cli_args[command][deprecated]\n\n                        LOG.warning(\n                            \"[{}] Argument '{}' was deprecated,\"\n                            \" please use '{}'.\".format(\n                                command, deprecated, deprecates))\n\n    @staticmethod\n    def validate_arg_sources(cli_args, answer_file_args, spec_defaults):\n        \"\"\"Validates and prints the arguments' source.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        :param spec_defaults:  the default values from spec files\n        \"\"\"\n\n        def show_diff(diff, command_name, cmd_dict, source_name):\n            if diff:\n                for arg_name in diff:\n                    value = cmd_dict[arg_name]\n                    LOG.info(\n                        \"[{}] Argument '{}' was set to\"\n                        \" '{}' from the {} source.\".format(\n                            command_name, arg_name, value, source_name))\n\n        for command, command_dict in cli_args.items():\n            file_dict = answer_file_args.get(command, {})\n            file_diff = set(file_dict.keys()) - set(command_dict.keys())\n            show_diff(file_diff, command, file_dict, 'answers file')\n\n            def_dict = spec_defaults.get(command, {})\n            default_diff = set(def_dict.keys()) - set(\n                command_dict.keys()) - file_diff\n            show_diff(default_diff, command, def_dict, 'spec defaults')\n\n    def _get_conditionally_required_args(self, command_name, options_spec,\n                                         args):\n        \"\"\"List arguments with ``required_when`` condition matched.\n\n        :param command_name: the command name.\n        :param options_spec:  the list of command spec options.\n        :param args: the received input arguments\n        :return: list, list of argument names with matched ``required_when``\n            condition\n        \"\"\"\n        opts_names = [option_spec['name'] for option_spec in options_spec]\n        missing_args = []\n        for option_spec in options_spec:\n            option_results = []\n            if option_spec and 'required_when' in option_spec:\n                req_when_args = [option_spec['required_when']] \\\n                    if not type(option_spec['required_when']) is list \\\n                    else option_spec['required_when']\n\n                # validate conditions\n                for req_when_arg in req_when_args:\n                    splited_args_list = req_when_arg.split()\n                    for idx, req_arg in enumerate(splited_args_list):\n                        if req_arg in opts_names:\n                            splited_args_list[idx] = \\\n                                args.get(command_name, {}).get(req_arg.strip())\n                        if splited_args_list[idx] is None:\n                            option_results.append(False)\n                            break\n                        splited_args_list[idx] = str(splited_args_list[idx])\n                        if (splited_args_list[idx] not in ['and', 'or'] and\n                            not any(\n                                (c in '<>=') for c in splited_args_list[idx])):\n                            splited_args_list[idx] = \"'{0}'\".format(\n                                yaml.safe_load(splited_args_list[idx]))\n                    else:\n                        option_results.append(\n                            eval(' '.join(splited_args_list)))\n                if all(option_results) and \\\n                        self.spec_helper.get_option_state(\n                            command_name,\n                            option_spec['name'],\n                            args) == helper.OptionState['NOT_SET']:\n                    missing_args.append(option_spec['name'])\n        return missing_args\n\n    def validate_requires_args(self, args):\n        \"\"\"Check if all the required arguments have been provided. \"\"\"\n\n        silent_args = self.get_silent_args(args)\n\n        def validate_parser(parser_name, expected_options, parser_args):\n            \"\"\"Helper method to resolve dict_merge. \"\"\"\n\n            result = collections.defaultdict(list)\n            condition_req_args = self._get_conditionally_required_args(\n                parser_name, expected_options, args)\n\n            for option in expected_options:\n                name = option['name']\n\n                # check required options.\n                if (option.get('required', False) and\n                    name not in parser_args or\n                    option['name'] in condition_req_args) and \\\n                        name not in silent_args:\n                    result[parser_name].append(name)\n\n            return result\n\n        res = {}\n        for command_data in self.spec_helper.iterate_parsers():\n            cmd_name = command_data['name']\n            if cmd_name in args:\n                dict_utils.dict_merge(\n                    res,\n                    validate_parser(\n                        cmd_name,\n                        self.spec_helper.get_parser_option_specs(cmd_name),\n                        args[cmd_name]))\n\n        missing_args = dict((cmd_name, args)\n                            for cmd_name, args in res.items() if len(args) > 0)\n        if missing_args:\n            raise exceptions.IRRequiredArgsMissingException(missing_args)\n\n    def validate_length_args(self, args):\n        \"\"\"Check if value of arguments is not longer than length specified.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if 'length' not in spec_option:\n                    # skip options that does not contain length\n                    continue\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # resolve length\n                    length = spec_option['length']\n                    option_value = parser_dict[option_name]\n                    if len(option_value) > int(length):\n                        # found invalid option, append to list of invalid opts\n                        invalid_options.append((\n                            option_name,\n                            option_value,\n                            length\n                        ))\n        if invalid_options:\n            # raise exception with all arguments that exceed length\n            raise exceptions.IRInvalidLengthException(invalid_options)\n\n    def validate_choices_args(self, args):\n        \"\"\"Check if value of choice arguments is one of the available choices.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if 'choices' not in spec_option:\n                    # skip options that does not contain choices\n                    continue\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # resolve choices\n                    choices = spec_option['choices']\n                    option_value = parser_dict[option_name]\n                    if option_value not in choices:\n                        # found invalid option, append to list of invalid opts\n                        invalid_options.append((\n                            option_name,\n                            option_value,\n                            choices\n                        ))\n        if invalid_options:\n            # raise exception with all arguments that contains invalid choices\n            raise exceptions.IRInvalidChoiceException(invalid_options)\n\n    def validate_min_max_args(self, args):\n        \"\"\"Check if value of arguments is between minimum and maximum values.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if all([key not in spec_option\n                        for key in ('maximum', 'minimum')]):\n                    # skip options that does not contain minimum or maximum\n                    continue\n                option_name = spec_option['name']\n\n                if option_name in parser_dict:\n                    option_value = parser_dict[option_name]\n                    min_value = spec_option.get('minimum')\n                    max_value = spec_option.get('maximum')\n                    # handle empty values in spec files which load as None\n                    min_value = '' if 'minimum' in spec_option \\\n                                      and min_value is None else min_value\n                    max_value = '' if 'maximum' in spec_option \\\n                                      and max_value is None else max_value\n\n                    values = {\n                        \"value\": option_value,\n                        \"maximum\": max_value,\n                        \"minimum\": min_value\n                    }\n\n                    # make sure that values are numbers\n                    is_all_values_numbers = True\n                    for name, num in values.items():\n                        if num is not None \\\n                                and (isinstance(num, bool) or\n                                     not isinstance(num, (int, float))):\n                            invalid_options.append((\n                                option_name,\n                                name,\n                                \"number\",\n                                type(num).__name__\n                            ))\n                            is_all_values_numbers = False\n\n                    if not is_all_values_numbers:\n                        # don't continue to min max checks since some of the\n                        # values are not numbers\n                        continue\n\n                    # check bigger than minimum\n                    if min_value is not None and option_value < min_value:\n                        invalid_options.append((\n                            option_name,\n                            \"minimum\",\n                            min_value,\n                            option_value\n                        ))\n                    # check smaller than maximum\n                    if max_value is not None and option_value > max_value:\n                        invalid_options.append((\n                            option_name,\n                            \"maximum\",\n                            max_value,\n                            option_value\n                        ))\n\n        if invalid_options:\n            # raise exception with all arguments that contains invalid choices\n            raise exceptions.IRInvalidMinMaxRangeException(invalid_options)\n", "contexts_below": "    def get_nested_custom_and_control_args(self, args):\n         \"\"\"Split input arguments to control nested and custom.\n \n         Controls arguments: control the IR behavior. These arguments\n             will not be put into the spec yml file\n         Nested arguments: are used by the Ansible playbooks and will be put\n             into the spec yml file.\n         Custom arguments: Custom ansible variables to be used instead of the\n             normal nested usage.\n \n         :param args: the collected list of args.\n         :return: (dict, dict): flat dicts (control_args, nested_args)\n         \"\"\"\n         # returns flat dicts\n         nested = {}\n         control_args = {}\n         custom_args = {}\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if all([arg_spec, arg_spec.get('type', None),\n                     arg_spec.get('type', None) in\n                     [ctype_name for ctype_name, klass in\n                      COMPLEX_TYPES.items() if klass.is_nested]\n                     ]) or ('is_shared_group_option' not in arg_spec):\n                 if arg_name in nested:\n                     LOG.warning(\n                         \"Duplicated nested argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, nested[arg_name]))\n                 elif arg_name in custom_args:\n                     LOG.warning(\n                         \"Duplicated custom argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, custom_args[arg_name]))\n                 else:\n                     if \"ansible_variable\" in arg_spec:\n                         custom_args[arg_spec[\"ansible_variable\"]] = arg_value\n                     else:\n                         nested[arg_name] = arg_value\n             else:\n                 if arg_name in control_args:\n                     LOG.warning(\n                         \"Duplicated control argument found: '{}'. Using \"\n                         \"old value: '{}'\".format(\n                             arg_name, control_args[arg_name]))\n                 else:\n                     control_args[arg_name] = arg_value\n \n         return nested, control_args, custom_args\n \n     def _iterate_received_arguments(self, args):\n         \"\"\"Iterator helper method over all the received arguments\n \n         :return: yields tuple:\n             (spec name, spec dict,\n              argument name, argument value, argument spec)\n         \"\"\"\n         for spec_parser in self.spec_helper.iterate_parsers():\n             if spec_parser['name'] in args:\n                 parser_dict = args[spec_parser['name']]\n                 for arg_name, arg_val in parser_dict.items():\n                     arg_spec = self.spec_helper.get_option_spec(\n                         spec_parser['name'], arg_name)\n                     yield (spec_parser['name'], parser_dict,\n                            arg_name, arg_val, arg_spec)\n \n     def _convert_non_cli_args(self, parser_name, values_dict):\n         \"\"\"Casts arguments to correct types by modifying values_dict param.\n \n         By default all the values are strings.\n \n         :param parser_name: The command name, e.g. main, virsh, ospd, etc\n         :param values_dict: The dict of with arguments\n        \"\"\"\n         for opt_name, opt_value in values_dict.items():\n             file_option_spec = self.spec_helper.get_option_spec(\n                 parser_name, opt_name)\n             if file_option_spec.get('type', None) in ['int', ] or \\\n                     file_option_spec.get('action', None) in ['count', ]:\n                 values_dict[opt_name] = int(opt_value)\n \n     def _merge_duplicated_cli_args(self, cli_args):\n         \"\"\"Merge duplicated arguments to all the parsers\n \n         This is need to handle control args, shared among several parsers.\n         for example, verbose, inventory\n         \"\"\"\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(cli_args):\n             for parser_name2, parser_dict2 in cli_args.items():\n                 if all([parser_name2, parser_name != parser_name2,\n                         arg_name not in parser_dict2]):\n                     if self.spec_helper.get_option_spec(parser_name2,\n                                                         arg_name):\n                         parser_dict2[arg_name] = arg_value\n ", "input_code": "def get_silent_args(self, args):\n\"\"\"\nlist of silenced argument\n\n:param args: The received arguments.\n:return: list, slienced argument names\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def get_silent_args(self, args):\n        \"\"\"list of silenced argument\n\n        :param args: The received arguments.\n        :return: list, slienced argument names\n        \"\"\"\n        silent_args_names = []\n        for (parser_name, parser_dict, arg_name, arg_value,\n             arg_spec) in self._iterate_received_arguments(args):\n            if arg_spec and 'silent' in arg_spec and \\\n                    self.spec_helper.get_option_state(\n                        parser_name,\n                        arg_name,\n                        args) == helper.OptionState['IS_SET']:\n                silent_args_names.extend(arg_spec['silent'])\n\n        return list(set(silent_args_names))", "signature": "def get_silent_args(self, args):", "completion_path": "infrared/core/inspector/inspector.py"}
{"ce_id": "6306092d73426c38ae68ad07", "namespace": "6306092d73426c38ae68ad07", "namespace_real": "infrared.core.inspector.inspector.validate_requires_args", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "inspector", "function_name": "validate_requires_args", "contexts_above": "import collections\nimport os\nfrom six.moves import configparser\nfrom string import Template\nimport yaml\n\nfrom infrared.core.cli.cli import CliParser\nfrom infrared.core.cli.cli import COMPLEX_TYPES\nfrom infrared.core.inspector import helper\nfrom infrared.core.utils import dict_utils\nfrom infrared.core.utils import exceptions\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n\nclass SpecParser(object):\n    \"\"\"Parses input arguments from different sources (cli, answers file). \"\"\"\n\n    @classmethod\n    def from_plugin(cls, subparser, plugin, base_groups):\n        \"\"\"Reads spec & vars from plugin and constructs the parser instance\n\n        :param subparser: argparse.subparser to extend\n        :param plugin: InfraredPlugin object\n        :param base_groups: dict, included groups\n        :return: SpecParser object based on given plugin spec & vars\n        \"\"\"\n\n        spec_dict = base_groups or {}\n        with open(plugin.spec) as stream:\n            spec = yaml.safe_load(stream) or {}\n            dict_utils.dict_merge(\n                base_groups,\n                spec,\n                dict_utils.ConflictResolver.unique_append_list_resolver)\n\n        # The \"try-excpet\" block here is for adding spec file path if it\n        # includes an unsupported option type\n        try:\n            return SpecParser(subparser, spec_dict, plugin.vars_dir,\n                              plugin.defaults_dir, plugin.path)\n        except exceptions.IRUnsupportedSpecOptionType as ex:\n            ex.message += ' in file: {}'.format(plugin.spec)\n            raise ex\n\n    def __init__(self, subparser, spec_dict, vars_dir, defaults_dir,\n                 plugin_path):\n        \"\"\"Constructor.\n\n        :param subparser: argparse.subparser to extend\n        :param spec_dict: dict with CLI description\n        :param vars_dir: Path to plugin's vars dir\n        :param defaults_dir: Path to plugin's defaults dir\n        \"\"\"\n        self.vars = vars_dir\n        self.defaults = defaults_dir\n        self.plugin_path = plugin_path\n        self.spec_helper = helper.SpecDictHelper(spec_dict)\n\n        # create parser\n        self.parser = CliParser.create_parser(self, subparser)\n\n    def add_shared_groups(self, list_of_groups):\n        \"\"\"Adds the user defined shared groups\n\n        :param list_of_groups: list, of group dicts\n        \"\"\"\n        shared_groups = self.spec_helper.spec_dict.get('shared_groups', [])\n        shared_groups.expand(list_of_groups)\n        self.spec_helper.spec_dict['shared_groups'] = shared_groups\n\n    def _get_defaults(self, default_getter_func):\n        \"\"\"Resolve arguments' values from cli or answers file.\n\n        :param default_getter_func: callable. will be called for all the\n            available options in spec file.\n        \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            default_value = default_getter_func(option)\n            if default_value is not None:\n                sub = parser['name']\n                result[sub][option['name']] = default_value\n\n        return result\n\n    def get_spec_defaults(self):\n        \"\"\"Resolve arguments' values from spec and other sources. \"\"\"\n\n        def spec_default_getter(option):\n            \"\"\"Getter function to retrieve the default value from spec.\n\n            :param option: argument name\n            \"\"\"\n\n            # first try to get environment variable with IR_ prefix\n            default_value = SpecParser.get_env_option(option['name'])\n            if default_value is not None:\n                LOG.info(\n                    \"[environ] Loading '{0}' default value\"\n                    \" '{1}' from the environment variable\".format(\n                        option['name'], default_value))\n            elif option.get('default', None) is not None:\n                default_value = option['default']\n            elif option.get('action', None) in ['store_true']:\n                default_value = False\n            return default_value\n\n        return self._get_defaults(spec_default_getter)\n\n    @staticmethod\n    def get_env_option(name):\n        \"\"\"Try get \"\"\"\n        return os.environ.get('IR_' + name.upper().replace('-', '_'))\n\n    def get_deprecated_args(self):\n        \"\"\"Returning dict with options which deprecate others. \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            if option.get('deprecates') is not None:\n                result[option.get('deprecates')] = option.get('name')\n\n        return result\n\n    @staticmethod\n    def parse_env_variable_from_file(value):\n        if isinstance(value, str):\n            t = Template(value)\n            try:\n                value = t.substitute(os.environ)\n            except KeyError as undefined_var:\n                raise exceptions.IRAnswersFileEnvVarNotDefined(undefined_var)\n        return value\n\n    def get_answers_file_args(self, cli_args):\n        \"\"\"Resolve arguments' values from answers INI file. \"\"\"\n\n        file_result = {}\n        args_to_remove = []\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            file_result[parser_name] = file_result.get(parser_name, {})\n            if option_spec and option_spec.get(\n                    'action', '') == 'read-answers':\n                # Iterate over arguments supplied by file\n                for parsed_arg in parser_dict[arg_name]:\n                    # Supplied arguments' value can be a list\n                    if isinstance(parser_dict[arg_name][parsed_arg], list):\n                        i = 0\n                        # Iterrate over argument values list\n                        for parsed_value in parser_dict[arg_name][parsed_arg]:\n                            parser_dict[arg_name][parsed_arg][i] = \\\n                                SpecParser.parse_env_variable_from_file(parsed_value)\n                            i += 1\n                    else:\n                        parser_dict[arg_name][parsed_arg] = \\\n                            SpecParser.parse_env_variable_from_file(parser_dict[arg_name][parsed_arg])\n                # we have config option. saving it.\n                self._convert_non_cli_args(\n                    parser_name, parser_dict[arg_name])\n                dict_utils.dict_merge(\n                    file_result[parser_name],\n                    parser_dict[arg_name])\n                # remove from cli args\n                args_to_remove.append((parser_name, arg_name))\n\n        # remove parser dict outside loop to avoid iteration dict modification\n        for parser_name, arg_name in args_to_remove:\n            for spec_parser in self.spec_helper.iterate_parsers():\n                if spec_parser['name'] in cli_args and spec_parser['name'] == parser_name:\n                    parser_dict = cli_args[spec_parser['name']]\n                    parser_dict.pop(arg_name)\n                    break\n\n        return file_result\n\n    def generate_answers_file(self, cli_args, spec_defaults):\n        \"\"\"Generates answers INI file\n\n        :param cli_args: list, cli arguments.\n        :param spec_defaults: the default values.\n        \"\"\"\n\n        def put_option(config, parser_name, option_name, value):\n            for opt_help in option.get('help', '').split('\\n'):\n                help_opt = '# ' + opt_help\n\n                # add help comment\n                if config.has_option(parser_name, help_opt):\n                    config.remove_option(parser_name, help_opt)\n                config.set(\n                    parser_name, help_opt)\n\n            if config.has_option(parser_name, option_name):\n                value = config.get(parser_name, option_name)\n                config.remove_option(parser_name, option_name)\n\n            config.set(\n                parser_name,\n                option_name,\n                str(value))\n\n        file_generated = False\n\n        # load generate answers file for all the parsers\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            if option_spec and option_spec.get(\n                    'action', '') == 'generate-answers':\n                options_to_save = \\\n                    self.spec_helper.get_parser_option_specs(parser_name)\n                out_answers = configparser.ConfigParser(allow_no_value=True)\n\n                if not out_answers.has_section(parser_name):\n                    out_answers.add_section(parser_name)\n\n                for option in options_to_save:\n                    opt_name = option['name']\n                    if opt_name in parser_dict:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            parser_dict[opt_name])\n                    elif opt_name in spec_defaults[parser_name]:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            spec_defaults[parser_name][opt_name])\n                    elif option.get('required', False):\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            '# ' + opt_name,\n                            \"Required argument. \"\n                            \"Edit with one of the allowed values OR \"\n                            \"override with \"\n                            \"CLI: --{}=<option>\".format(opt_name))\n\n                # write to file\n                with open(arg_value, 'w') as answers_file:\n                    out_answers.write(answers_file)\n                file_generated = True\n\n        return file_generated\n\n    def resolve_custom_types(self, args):\n        \"\"\"Transforms the arguments with custom types\n\n        :param args: the list of received arguments.\n        \"\"\"\n        for parser_name, parser_dict in args.items():\n            spec_complex_options = [opt for opt in\n                                    self.spec_helper.get_parser_option_specs(\n                                        parser_name) if\n                                    opt.get('type', None) in COMPLEX_TYPES]\n            for spec_option in spec_complex_options:\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # we have custom type to resolve\n                    type_name = spec_option['type']\n                    option_value = parser_dict[option_name]\n                    action = self.create_complex_argumet_type(\n                        parser_name,\n                        type_name,\n                        option_name,\n                        spec_option)\n\n                    # resolving value\n                    parser_dict[option_name] = action.resolve(option_value)\n\n    def create_complex_argumet_type(self, subcommand, type_name, option_name,\n                                    spec_option):\n        \"\"\"Build the complex argument type\n\n        :param subcommand: the command name\n        :param type_name: the complex type name\n        :param option_name: the option name\n        :param spec_option: option's specifications\n        :return: the complex type instance\n        \"\"\"\n        complex_action = COMPLEX_TYPES.get(\n            type_name, None)\n        if complex_action is None:\n            raise exceptions.SpecParserException(\n                \"Unknown complex type: {}\".format(type_name))\n        return complex_action(\n            option_name,\n            (self.vars, self.defaults, self.plugin_path),\n            subcommand,\n            spec_option)\n\n    def parse_args(self, arg_parser, args=None):\n        \"\"\"Parses all the arguments (cli, answers file)\n\n        :return: None, if ``--generate-answers-file`` in arg_arg_parser\n        :return: (dict, dict):\n            * command arguments dict (arguments to control the IR logic)\n            * nested arguments dict (arguments to pass to the playbooks)\n        \"\"\"\n\n        spec_defaults = self.get_spec_defaults()\n        cli_args = CliParser.parse_cli_input(arg_parser, args)\n\n        file_args = self.get_answers_file_args(cli_args)\n\n        # generate answers file and exit\n        if self.generate_answers_file(cli_args, spec_defaults):\n            LOG.warning(\"Answers file generated. Exiting.\")\n\n        # print warnings when something was overridden from non-cli source.\n        self.validate_arg_sources(cli_args, file_args,\n                                  spec_defaults)\n\n        # print warnings for deprecated\n        self.validate_arg_deprecation(cli_args, file_args)\n\n        # now filter defaults to have only parser defined in cli\n        defaults = dict((key, spec_defaults[key])\n                        for key in cli_args.keys() if\n                        key in spec_defaults)\n\n        # copy cli args with the same name to all parser groups\n        self._merge_duplicated_cli_args(cli_args)\n        self._merge_duplicated_cli_args(file_args)\n\n        dict_utils.dict_merge(defaults, file_args)\n        dict_utils.dict_merge(defaults, cli_args)\n        self.validate_requires_args(defaults)\n        self.validate_length_args(defaults)\n        self.validate_choices_args(defaults)\n        self.validate_min_max_args(defaults)\n\n        # now resolve complex types.\n        self.resolve_custom_types(defaults)\n        nested, control, custom = \\\n            self.get_nested_custom_and_control_args(defaults)\n        return nested, control, custom\n\n    def validate_arg_deprecation(self, cli_args, answer_file_args):\n        \"\"\"Validates and prints the deprecated arguments.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        \"\"\"\n\n        for deprecated, deprecates in self.get_deprecated_args().items():\n            for input_args in (answer_file_args.items(), cli_args.items()):\n                for command, command_dict in input_args:\n                    if deprecated in command_dict:\n                        if deprecates in command_dict:\n                            raise exceptions.IRDeprecationException(\n                                \"[{}] Argument '{}' deprecates '{}',\"\n                                \" please use only the new one.\".format(\n                                    command, deprecated, deprecates))\n\n                        if deprecated in answer_file_args[command]:\n                            answer_file_args[command][deprecates] = \\\n                                answer_file_args[command][deprecated]\n\n                        if deprecated in cli_args[command]:\n                            cli_args[command][deprecates] = \\\n                                cli_args[command][deprecated]\n\n                        LOG.warning(\n                            \"[{}] Argument '{}' was deprecated,\"\n                            \" please use '{}'.\".format(\n                                command, deprecated, deprecates))\n\n    @staticmethod\n    def validate_arg_sources(cli_args, answer_file_args, spec_defaults):\n        \"\"\"Validates and prints the arguments' source.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        :param spec_defaults:  the default values from spec files\n        \"\"\"\n\n        def show_diff(diff, command_name, cmd_dict, source_name):\n            if diff:\n                for arg_name in diff:\n                    value = cmd_dict[arg_name]\n                    LOG.info(\n                        \"[{}] Argument '{}' was set to\"\n                        \" '{}' from the {} source.\".format(\n                            command_name, arg_name, value, source_name))\n\n        for command, command_dict in cli_args.items():\n            file_dict = answer_file_args.get(command, {})\n            file_diff = set(file_dict.keys()) - set(command_dict.keys())\n            show_diff(file_diff, command, file_dict, 'answers file')\n\n            def_dict = spec_defaults.get(command, {})\n            default_diff = set(def_dict.keys()) - set(\n                command_dict.keys()) - file_diff\n            show_diff(default_diff, command, def_dict, 'spec defaults')\n\n    def _get_conditionally_required_args(self, command_name, options_spec,\n                                         args):\n        \"\"\"List arguments with ``required_when`` condition matched.\n\n        :param command_name: the command name.\n        :param options_spec:  the list of command spec options.\n        :param args: the received input arguments\n        :return: list, list of argument names with matched ``required_when``\n            condition\n        \"\"\"\n        opts_names = [option_spec['name'] for option_spec in options_spec]\n        missing_args = []\n        for option_spec in options_spec:\n            option_results = []\n            if option_spec and 'required_when' in option_spec:\n                req_when_args = [option_spec['required_when']] \\\n                    if not type(option_spec['required_when']) is list \\\n                    else option_spec['required_when']\n\n                # validate conditions\n                for req_when_arg in req_when_args:\n                    splited_args_list = req_when_arg.split()\n                    for idx, req_arg in enumerate(splited_args_list):\n                        if req_arg in opts_names:\n                            splited_args_list[idx] = \\\n                                args.get(command_name, {}).get(req_arg.strip())\n                        if splited_args_list[idx] is None:\n                            option_results.append(False)\n                            break\n                        splited_args_list[idx] = str(splited_args_list[idx])\n                        if (splited_args_list[idx] not in ['and', 'or'] and\n                            not any(\n                                (c in '<>=') for c in splited_args_list[idx])):\n                            splited_args_list[idx] = \"'{0}'\".format(\n                                yaml.safe_load(splited_args_list[idx]))\n                    else:\n                        option_results.append(\n                            eval(' '.join(splited_args_list)))\n                if all(option_results) and \\\n                        self.spec_helper.get_option_state(\n                            command_name,\n                            option_spec['name'],\n                            args) == helper.OptionState['NOT_SET']:\n                    missing_args.append(option_spec['name'])\n        return missing_args\n", "contexts_below": "    def validate_length_args(self, args):\n         \"\"\"Check if value of arguments is not longer than length specified.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if 'length' not in spec_option:\n                     # skip options that does not contain length\n                     continue\n                 option_name = spec_option['name']\n                 if option_name in parser_dict:\n                     # resolve length\n                     length = spec_option['length']\n                     option_value = parser_dict[option_name]\n                     if len(option_value) > int(length):\n                         # found invalid option, append to list of invalid opts\n                         invalid_options.append((\n                             option_name,\n                             option_value,\n                             length\n                         ))\n         if invalid_options:\n             # raise exception with all arguments that exceed length\n             raise exceptions.IRInvalidLengthException(invalid_options)\n \n     def validate_choices_args(self, args):\n         \"\"\"Check if value of choice arguments is one of the available choices.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if 'choices' not in spec_option:\n                     # skip options that does not contain choices\n                     continue\n                 option_name = spec_option['name']\n                 if option_name in parser_dict:\n                     # resolve choices\n                     choices = spec_option['choices']\n                     option_value = parser_dict[option_name]\n                     if option_value not in choices:\n                         # found invalid option, append to list of invalid opts\n                         invalid_options.append((\n                             option_name,\n                             option_value,\n                             choices\n                         ))\n         if invalid_options:\n             # raise exception with all arguments that contains invalid choices\n             raise exceptions.IRInvalidChoiceException(invalid_options)\n \n     def validate_min_max_args(self, args):\n         \"\"\"Check if value of arguments is between minimum and maximum values.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if all([key not in spec_option\n                         for key in ('maximum', 'minimum')]):\n                     # skip options that does not contain minimum or maximum\n                     continue\n                 option_name = spec_option['name']\n \n                 if option_name in parser_dict:\n                     option_value = parser_dict[option_name]\n                     min_value = spec_option.get('minimum')\n                     max_value = spec_option.get('maximum')\n                     # handle empty values in spec files which load as None\n                     min_value = '' if 'minimum' in spec_option \\\n                                       and min_value is None else min_value\n                     max_value = '' if 'maximum' in spec_option \\\n                                       and max_value is None else max_value\n \n                     values = {\n                         \"value\": option_value,\n                         \"maximum\": max_value,\n                         \"minimum\": min_value\n                     }\n \n                     # make sure that values are numbers\n                     is_all_values_numbers = True\n                     for name, num in values.items():\n                         if num is not None \\\n                                 and (isinstance(num, bool) or\n                                      not isinstance(num, (int, float))):\n                             invalid_options.append((\n                                 option_name,\n                                 name,\n                                 \"number\",\n                                 type(num).__name__\n                             ))\n                             is_all_values_numbers = False\n \n                     if not is_all_values_numbers:\n                         # don't continue to min max checks since some of the\n                         # values are not numbers\n                         continue\n \n                     # check bigger than minimum\n                     if min_value is not None and option_value < min_value:\n                         invalid_options.append((\n                             option_name,\n                             \"minimum\",\n                             min_value,\n                             option_value\n                         ))\n                     # check smaller than maximum\n                     if max_value is not None and option_value > max_value:\n                         invalid_options.append((\n                             option_name,\n                             \"maximum\",\n                             max_value,\n                             option_value\n                         ))\n \n         if invalid_options:\n             # raise exception with all arguments that contains invalid choices\n             raise exceptions.IRInvalidMinMaxRangeException(invalid_options)\n \n     def get_silent_args(self, args):\n         \"\"\"list of silenced argument\n \n         :param args: The received arguments.\n         :return: list, slienced argument names\n         \"\"\"\n         silent_args_names = []\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if arg_spec and 'silent' in arg_spec and \\\n                     self.spec_helper.get_option_state(\n                         parser_name,\n                         arg_name,\n                         args) == helper.OptionState['IS_SET']:\n                 silent_args_names.extend(arg_spec['silent'])\n \n         return list(set(silent_args_names))\n \n     def get_nested_custom_and_control_args(self, args):\n         \"\"\"Split input arguments to control nested and custom.\n \n         Controls arguments: control the IR behavior. These arguments\n             will not be put into the spec yml file\n         Nested arguments: are used by the Ansible playbooks and will be put\n             into the spec yml file.\n         Custom arguments: Custom ansible variables to be used instead of the\n             normal nested usage.\n \n         :param args: the collected list of args.\n         :return: (dict, dict): flat dicts (control_args, nested_args)\n         \"\"\"\n         # returns flat dicts\n         nested = {}\n         control_args = {}\n         custom_args = {}\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if all([arg_spec, arg_spec.get('type', None),\n                     arg_spec.get('type', None) in\n                     [ctype_name for ctype_name, klass in\n                      COMPLEX_TYPES.items() if klass.is_nested]\n                     ]) or ('is_shared_group_option' not in arg_spec):\n                 if arg_name in nested:\n                     LOG.warning(\n                         \"Duplicated nested argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, nested[arg_name]))\n                 elif arg_name in custom_args:\n                     LOG.warning(\n                         \"Duplicated custom argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, custom_args[arg_name]))\n                 else:\n                     if \"ansible_variable\" in arg_spec:\n                         custom_args[arg_spec[\"ansible_variable\"]] = arg_value\n                     else:\n                         nested[arg_name] = arg_value\n             else:\n                 if arg_name in control_args:\n                     LOG.warning(\n                         \"Duplicated control argument found: '{}'. Using \"\n                         \"old value: '{}'\".format(\n                             arg_name, control_args[arg_name]))\n                 else:\n                     control_args[arg_name] = arg_value\n \n         return nested, control_args, custom_args\n \n     def _iterate_received_arguments(self, args):\n         \"\"\"Iterator helper method over all the received arguments\n \n         :return: yields tuple:\n             (spec name, spec dict,\n              argument name, argument value, argument spec)\n         \"\"\"\n         for spec_parser in self.spec_helper.iterate_parsers():\n             if spec_parser['name'] in args:\n                 parser_dict = args[spec_parser['name']]\n                 for arg_name, arg_val in parser_dict.items():\n                     arg_spec = self.spec_helper.get_option_spec(\n                         spec_parser['name'], arg_name)\n                     yield (spec_parser['name'], parser_dict,\n                            arg_name, arg_val, arg_spec)\n \n     def _convert_non_cli_args(self, parser_name, values_dict):\n         \"\"\"Casts arguments to correct types by modifying values_dict param.\n \n         By default all the values are strings.\n \n         :param parser_name: The command name, e.g. main, virsh, ospd, etc\n         :param values_dict: The dict of with arguments\n        \"\"\"\n         for opt_name, opt_value in values_dict.items():\n             file_option_spec = self.spec_helper.get_option_spec(\n                 parser_name, opt_name)\n             if file_option_spec.get('type', None) in ['int', ] or \\\n                     file_option_spec.get('action', None) in ['count', ]:\n                 values_dict[opt_name] = int(opt_value)\n \n     def _merge_duplicated_cli_args(self, cli_args):\n         \"\"\"Merge duplicated arguments to all the parsers\n \n         This is need to handle control args, shared among several parsers.\n         for example, verbose, inventory\n         \"\"\"\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(cli_args):\n             for parser_name2, parser_dict2 in cli_args.items():\n                 if all([parser_name2, parser_name != parser_name2,\n                         arg_name not in parser_dict2]):\n                     if self.spec_helper.get_option_spec(parser_name2,\n                                                         arg_name):\n                         parser_dict2[arg_name] = arg_value\n ", "input_code": "def validate_requires_args(self, args):\n\"\"\"\nCheck if all the required arguments have been provided.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def validate_requires_args(self, args):\n        \"\"\"Check if all the required arguments have been provided. \"\"\"\n\n        silent_args = self.get_silent_args(args)\n\n        def validate_parser(parser_name, expected_options, parser_args):\n            \"\"\"Helper method to resolve dict_merge. \"\"\"\n\n            result = collections.defaultdict(list)\n            condition_req_args = self._get_conditionally_required_args(\n                parser_name, expected_options, args)\n\n            for option in expected_options:\n                name = option['name']\n\n                # check required options.\n                if (option.get('required', False) and\n                    name not in parser_args or\n                    option['name'] in condition_req_args) and \\\n                        name not in silent_args:\n                    result[parser_name].append(name)\n\n            return result\n\n        res = {}\n        for command_data in self.spec_helper.iterate_parsers():\n            cmd_name = command_data['name']\n            if cmd_name in args:\n                dict_utils.dict_merge(\n                    res,\n                    validate_parser(\n                        cmd_name,\n                        self.spec_helper.get_parser_option_specs(cmd_name),\n                        args[cmd_name]))\n\n        missing_args = dict((cmd_name, args)\n                            for cmd_name, args in res.items() if len(args) > 0)\n        if missing_args:\n            raise exceptions.IRRequiredArgsMissingException(missing_args)", "signature": "def validate_requires_args(self, args):", "completion_path": "infrared/core/inspector/inspector.py"}
{"ce_id": "6306092d73426c38ae68ad08", "namespace": "6306092d73426c38ae68ad08", "namespace_real": "infrared.core.inspector.inspector._get_conditionally_required_args", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "inspector", "function_name": "_get_conditionally_required_args", "contexts_above": "import collections\nimport os\nfrom six.moves import configparser\nfrom string import Template\nimport yaml\n\nfrom infrared.core.cli.cli import CliParser\nfrom infrared.core.cli.cli import COMPLEX_TYPES\nfrom infrared.core.inspector import helper\nfrom infrared.core.utils import dict_utils\nfrom infrared.core.utils import exceptions\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n\nclass SpecParser(object):\n    \"\"\"Parses input arguments from different sources (cli, answers file). \"\"\"\n\n    @classmethod\n    def from_plugin(cls, subparser, plugin, base_groups):\n        \"\"\"Reads spec & vars from plugin and constructs the parser instance\n\n        :param subparser: argparse.subparser to extend\n        :param plugin: InfraredPlugin object\n        :param base_groups: dict, included groups\n        :return: SpecParser object based on given plugin spec & vars\n        \"\"\"\n\n        spec_dict = base_groups or {}\n        with open(plugin.spec) as stream:\n            spec = yaml.safe_load(stream) or {}\n            dict_utils.dict_merge(\n                base_groups,\n                spec,\n                dict_utils.ConflictResolver.unique_append_list_resolver)\n\n        # The \"try-excpet\" block here is for adding spec file path if it\n        # includes an unsupported option type\n        try:\n            return SpecParser(subparser, spec_dict, plugin.vars_dir,\n                              plugin.defaults_dir, plugin.path)\n        except exceptions.IRUnsupportedSpecOptionType as ex:\n            ex.message += ' in file: {}'.format(plugin.spec)\n            raise ex\n\n    def __init__(self, subparser, spec_dict, vars_dir, defaults_dir,\n                 plugin_path):\n        \"\"\"Constructor.\n\n        :param subparser: argparse.subparser to extend\n        :param spec_dict: dict with CLI description\n        :param vars_dir: Path to plugin's vars dir\n        :param defaults_dir: Path to plugin's defaults dir\n        \"\"\"\n        self.vars = vars_dir\n        self.defaults = defaults_dir\n        self.plugin_path = plugin_path\n        self.spec_helper = helper.SpecDictHelper(spec_dict)\n\n        # create parser\n        self.parser = CliParser.create_parser(self, subparser)\n\n    def add_shared_groups(self, list_of_groups):\n        \"\"\"Adds the user defined shared groups\n\n        :param list_of_groups: list, of group dicts\n        \"\"\"\n        shared_groups = self.spec_helper.spec_dict.get('shared_groups', [])\n        shared_groups.expand(list_of_groups)\n        self.spec_helper.spec_dict['shared_groups'] = shared_groups\n\n    def _get_defaults(self, default_getter_func):\n        \"\"\"Resolve arguments' values from cli or answers file.\n\n        :param default_getter_func: callable. will be called for all the\n            available options in spec file.\n        \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            default_value = default_getter_func(option)\n            if default_value is not None:\n                sub = parser['name']\n                result[sub][option['name']] = default_value\n\n        return result\n\n    def get_spec_defaults(self):\n        \"\"\"Resolve arguments' values from spec and other sources. \"\"\"\n\n        def spec_default_getter(option):\n            \"\"\"Getter function to retrieve the default value from spec.\n\n            :param option: argument name\n            \"\"\"\n\n            # first try to get environment variable with IR_ prefix\n            default_value = SpecParser.get_env_option(option['name'])\n            if default_value is not None:\n                LOG.info(\n                    \"[environ] Loading '{0}' default value\"\n                    \" '{1}' from the environment variable\".format(\n                        option['name'], default_value))\n            elif option.get('default', None) is not None:\n                default_value = option['default']\n            elif option.get('action', None) in ['store_true']:\n                default_value = False\n            return default_value\n\n        return self._get_defaults(spec_default_getter)\n\n    @staticmethod\n    def get_env_option(name):\n        \"\"\"Try get \"\"\"\n        return os.environ.get('IR_' + name.upper().replace('-', '_'))\n\n    def get_deprecated_args(self):\n        \"\"\"Returning dict with options which deprecate others. \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            if option.get('deprecates') is not None:\n                result[option.get('deprecates')] = option.get('name')\n\n        return result\n\n    @staticmethod\n    def parse_env_variable_from_file(value):\n        if isinstance(value, str):\n            t = Template(value)\n            try:\n                value = t.substitute(os.environ)\n            except KeyError as undefined_var:\n                raise exceptions.IRAnswersFileEnvVarNotDefined(undefined_var)\n        return value\n\n    def get_answers_file_args(self, cli_args):\n        \"\"\"Resolve arguments' values from answers INI file. \"\"\"\n\n        file_result = {}\n        args_to_remove = []\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            file_result[parser_name] = file_result.get(parser_name, {})\n            if option_spec and option_spec.get(\n                    'action', '') == 'read-answers':\n                # Iterate over arguments supplied by file\n                for parsed_arg in parser_dict[arg_name]:\n                    # Supplied arguments' value can be a list\n                    if isinstance(parser_dict[arg_name][parsed_arg], list):\n                        i = 0\n                        # Iterrate over argument values list\n                        for parsed_value in parser_dict[arg_name][parsed_arg]:\n                            parser_dict[arg_name][parsed_arg][i] = \\\n                                SpecParser.parse_env_variable_from_file(parsed_value)\n                            i += 1\n                    else:\n                        parser_dict[arg_name][parsed_arg] = \\\n                            SpecParser.parse_env_variable_from_file(parser_dict[arg_name][parsed_arg])\n                # we have config option. saving it.\n                self._convert_non_cli_args(\n                    parser_name, parser_dict[arg_name])\n                dict_utils.dict_merge(\n                    file_result[parser_name],\n                    parser_dict[arg_name])\n                # remove from cli args\n                args_to_remove.append((parser_name, arg_name))\n\n        # remove parser dict outside loop to avoid iteration dict modification\n        for parser_name, arg_name in args_to_remove:\n            for spec_parser in self.spec_helper.iterate_parsers():\n                if spec_parser['name'] in cli_args and spec_parser['name'] == parser_name:\n                    parser_dict = cli_args[spec_parser['name']]\n                    parser_dict.pop(arg_name)\n                    break\n\n        return file_result\n\n    def generate_answers_file(self, cli_args, spec_defaults):\n        \"\"\"Generates answers INI file\n\n        :param cli_args: list, cli arguments.\n        :param spec_defaults: the default values.\n        \"\"\"\n\n        def put_option(config, parser_name, option_name, value):\n            for opt_help in option.get('help', '').split('\\n'):\n                help_opt = '# ' + opt_help\n\n                # add help comment\n                if config.has_option(parser_name, help_opt):\n                    config.remove_option(parser_name, help_opt)\n                config.set(\n                    parser_name, help_opt)\n\n            if config.has_option(parser_name, option_name):\n                value = config.get(parser_name, option_name)\n                config.remove_option(parser_name, option_name)\n\n            config.set(\n                parser_name,\n                option_name,\n                str(value))\n\n        file_generated = False\n\n        # load generate answers file for all the parsers\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            if option_spec and option_spec.get(\n                    'action', '') == 'generate-answers':\n                options_to_save = \\\n                    self.spec_helper.get_parser_option_specs(parser_name)\n                out_answers = configparser.ConfigParser(allow_no_value=True)\n\n                if not out_answers.has_section(parser_name):\n                    out_answers.add_section(parser_name)\n\n                for option in options_to_save:\n                    opt_name = option['name']\n                    if opt_name in parser_dict:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            parser_dict[opt_name])\n                    elif opt_name in spec_defaults[parser_name]:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            spec_defaults[parser_name][opt_name])\n                    elif option.get('required', False):\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            '# ' + opt_name,\n                            \"Required argument. \"\n                            \"Edit with one of the allowed values OR \"\n                            \"override with \"\n                            \"CLI: --{}=<option>\".format(opt_name))\n\n                # write to file\n                with open(arg_value, 'w') as answers_file:\n                    out_answers.write(answers_file)\n                file_generated = True\n\n        return file_generated\n\n    def resolve_custom_types(self, args):\n        \"\"\"Transforms the arguments with custom types\n\n        :param args: the list of received arguments.\n        \"\"\"\n        for parser_name, parser_dict in args.items():\n            spec_complex_options = [opt for opt in\n                                    self.spec_helper.get_parser_option_specs(\n                                        parser_name) if\n                                    opt.get('type', None) in COMPLEX_TYPES]\n            for spec_option in spec_complex_options:\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # we have custom type to resolve\n                    type_name = spec_option['type']\n                    option_value = parser_dict[option_name]\n                    action = self.create_complex_argumet_type(\n                        parser_name,\n                        type_name,\n                        option_name,\n                        spec_option)\n\n                    # resolving value\n                    parser_dict[option_name] = action.resolve(option_value)\n\n    def create_complex_argumet_type(self, subcommand, type_name, option_name,\n                                    spec_option):\n        \"\"\"Build the complex argument type\n\n        :param subcommand: the command name\n        :param type_name: the complex type name\n        :param option_name: the option name\n        :param spec_option: option's specifications\n        :return: the complex type instance\n        \"\"\"\n        complex_action = COMPLEX_TYPES.get(\n            type_name, None)\n        if complex_action is None:\n            raise exceptions.SpecParserException(\n                \"Unknown complex type: {}\".format(type_name))\n        return complex_action(\n            option_name,\n            (self.vars, self.defaults, self.plugin_path),\n            subcommand,\n            spec_option)\n\n    def parse_args(self, arg_parser, args=None):\n        \"\"\"Parses all the arguments (cli, answers file)\n\n        :return: None, if ``--generate-answers-file`` in arg_arg_parser\n        :return: (dict, dict):\n            * command arguments dict (arguments to control the IR logic)\n            * nested arguments dict (arguments to pass to the playbooks)\n        \"\"\"\n\n        spec_defaults = self.get_spec_defaults()\n        cli_args = CliParser.parse_cli_input(arg_parser, args)\n\n        file_args = self.get_answers_file_args(cli_args)\n\n        # generate answers file and exit\n        if self.generate_answers_file(cli_args, spec_defaults):\n            LOG.warning(\"Answers file generated. Exiting.\")\n\n        # print warnings when something was overridden from non-cli source.\n        self.validate_arg_sources(cli_args, file_args,\n                                  spec_defaults)\n\n        # print warnings for deprecated\n        self.validate_arg_deprecation(cli_args, file_args)\n\n        # now filter defaults to have only parser defined in cli\n        defaults = dict((key, spec_defaults[key])\n                        for key in cli_args.keys() if\n                        key in spec_defaults)\n\n        # copy cli args with the same name to all parser groups\n        self._merge_duplicated_cli_args(cli_args)\n        self._merge_duplicated_cli_args(file_args)\n\n        dict_utils.dict_merge(defaults, file_args)\n        dict_utils.dict_merge(defaults, cli_args)\n        self.validate_requires_args(defaults)\n        self.validate_length_args(defaults)\n        self.validate_choices_args(defaults)\n        self.validate_min_max_args(defaults)\n\n        # now resolve complex types.\n        self.resolve_custom_types(defaults)\n        nested, control, custom = \\\n            self.get_nested_custom_and_control_args(defaults)\n        return nested, control, custom\n\n    def validate_arg_deprecation(self, cli_args, answer_file_args):\n        \"\"\"Validates and prints the deprecated arguments.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        \"\"\"\n\n        for deprecated, deprecates in self.get_deprecated_args().items():\n            for input_args in (answer_file_args.items(), cli_args.items()):\n                for command, command_dict in input_args:\n                    if deprecated in command_dict:\n                        if deprecates in command_dict:\n                            raise exceptions.IRDeprecationException(\n                                \"[{}] Argument '{}' deprecates '{}',\"\n                                \" please use only the new one.\".format(\n                                    command, deprecated, deprecates))\n\n                        if deprecated in answer_file_args[command]:\n                            answer_file_args[command][deprecates] = \\\n                                answer_file_args[command][deprecated]\n\n                        if deprecated in cli_args[command]:\n                            cli_args[command][deprecates] = \\\n                                cli_args[command][deprecated]\n\n                        LOG.warning(\n                            \"[{}] Argument '{}' was deprecated,\"\n                            \" please use '{}'.\".format(\n                                command, deprecated, deprecates))\n\n    @staticmethod\n    def validate_arg_sources(cli_args, answer_file_args, spec_defaults):\n        \"\"\"Validates and prints the arguments' source.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        :param spec_defaults:  the default values from spec files\n        \"\"\"\n\n        def show_diff(diff, command_name, cmd_dict, source_name):\n            if diff:\n                for arg_name in diff:\n                    value = cmd_dict[arg_name]\n                    LOG.info(\n                        \"[{}] Argument '{}' was set to\"\n                        \" '{}' from the {} source.\".format(\n                            command_name, arg_name, value, source_name))\n\n        for command, command_dict in cli_args.items():\n            file_dict = answer_file_args.get(command, {})\n            file_diff = set(file_dict.keys()) - set(command_dict.keys())\n            show_diff(file_diff, command, file_dict, 'answers file')\n\n            def_dict = spec_defaults.get(command, {})\n            default_diff = set(def_dict.keys()) - set(\n                command_dict.keys()) - file_diff\n            show_diff(default_diff, command, def_dict, 'spec defaults')\n", "contexts_below": "    def validate_requires_args(self, args):\n         \"\"\"Check if all the required arguments have been provided. \"\"\"\n \n         silent_args = self.get_silent_args(args)\n \n         def validate_parser(parser_name, expected_options, parser_args):\n             \"\"\"Helper method to resolve dict_merge. \"\"\"\n \n             result = collections.defaultdict(list)\n             condition_req_args = self._get_conditionally_required_args(\n                 parser_name, expected_options, args)\n \n             for option in expected_options:\n                 name = option['name']\n \n                 # check required options.\n                 if (option.get('required', False) and\n                     name not in parser_args or\n                     option['name'] in condition_req_args) and \\\n                         name not in silent_args:\n                     result[parser_name].append(name)\n \n             return result\n \n         res = {}\n         for command_data in self.spec_helper.iterate_parsers():\n             cmd_name = command_data['name']\n             if cmd_name in args:\n                 dict_utils.dict_merge(\n                     res,\n                     validate_parser(\n                         cmd_name,\n                         self.spec_helper.get_parser_option_specs(cmd_name),\n                         args[cmd_name]))\n \n         missing_args = dict((cmd_name, args)\n                             for cmd_name, args in res.items() if len(args) > 0)\n         if missing_args:\n             raise exceptions.IRRequiredArgsMissingException(missing_args)\n \n     def validate_length_args(self, args):\n         \"\"\"Check if value of arguments is not longer than length specified.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if 'length' not in spec_option:\n                     # skip options that does not contain length\n                     continue\n                 option_name = spec_option['name']\n                 if option_name in parser_dict:\n                     # resolve length\n                     length = spec_option['length']\n                     option_value = parser_dict[option_name]\n                     if len(option_value) > int(length):\n                         # found invalid option, append to list of invalid opts\n                         invalid_options.append((\n                             option_name,\n                             option_value,\n                             length\n                         ))\n         if invalid_options:\n             # raise exception with all arguments that exceed length\n             raise exceptions.IRInvalidLengthException(invalid_options)\n \n     def validate_choices_args(self, args):\n         \"\"\"Check if value of choice arguments is one of the available choices.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if 'choices' not in spec_option:\n                     # skip options that does not contain choices\n                     continue\n                 option_name = spec_option['name']\n                 if option_name in parser_dict:\n                     # resolve choices\n                     choices = spec_option['choices']\n                     option_value = parser_dict[option_name]\n                     if option_value not in choices:\n                         # found invalid option, append to list of invalid opts\n                         invalid_options.append((\n                             option_name,\n                             option_value,\n                             choices\n                         ))\n         if invalid_options:\n             # raise exception with all arguments that contains invalid choices\n             raise exceptions.IRInvalidChoiceException(invalid_options)\n \n     def validate_min_max_args(self, args):\n         \"\"\"Check if value of arguments is between minimum and maximum values.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if all([key not in spec_option\n                         for key in ('maximum', 'minimum')]):\n                     # skip options that does not contain minimum or maximum\n                     continue\n                 option_name = spec_option['name']\n \n                 if option_name in parser_dict:\n                     option_value = parser_dict[option_name]\n                     min_value = spec_option.get('minimum')\n                     max_value = spec_option.get('maximum')\n                     # handle empty values in spec files which load as None\n                     min_value = '' if 'minimum' in spec_option \\\n                                       and min_value is None else min_value\n                     max_value = '' if 'maximum' in spec_option \\\n                                       and max_value is None else max_value\n \n                     values = {\n                         \"value\": option_value,\n                         \"maximum\": max_value,\n                         \"minimum\": min_value\n                     }\n \n                     # make sure that values are numbers\n                     is_all_values_numbers = True\n                     for name, num in values.items():\n                         if num is not None \\\n                                 and (isinstance(num, bool) or\n                                      not isinstance(num, (int, float))):\n                             invalid_options.append((\n                                 option_name,\n                                 name,\n                                 \"number\",\n                                 type(num).__name__\n                             ))\n                             is_all_values_numbers = False\n \n                     if not is_all_values_numbers:\n                         # don't continue to min max checks since some of the\n                         # values are not numbers\n                         continue\n \n                     # check bigger than minimum\n                     if min_value is not None and option_value < min_value:\n                         invalid_options.append((\n                             option_name,\n                             \"minimum\",\n                             min_value,\n                             option_value\n                         ))\n                     # check smaller than maximum\n                     if max_value is not None and option_value > max_value:\n                         invalid_options.append((\n                             option_name,\n                             \"maximum\",\n                             max_value,\n                             option_value\n                         ))\n \n         if invalid_options:\n             # raise exception with all arguments that contains invalid choices\n             raise exceptions.IRInvalidMinMaxRangeException(invalid_options)\n \n     def get_silent_args(self, args):\n         \"\"\"list of silenced argument\n \n         :param args: The received arguments.\n         :return: list, slienced argument names\n         \"\"\"\n         silent_args_names = []\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if arg_spec and 'silent' in arg_spec and \\\n                     self.spec_helper.get_option_state(\n                         parser_name,\n                         arg_name,\n                         args) == helper.OptionState['IS_SET']:\n                 silent_args_names.extend(arg_spec['silent'])\n \n         return list(set(silent_args_names))\n \n     def get_nested_custom_and_control_args(self, args):\n         \"\"\"Split input arguments to control nested and custom.\n \n         Controls arguments: control the IR behavior. These arguments\n             will not be put into the spec yml file\n         Nested arguments: are used by the Ansible playbooks and will be put\n             into the spec yml file.\n         Custom arguments: Custom ansible variables to be used instead of the\n             normal nested usage.\n \n         :param args: the collected list of args.\n         :return: (dict, dict): flat dicts (control_args, nested_args)\n         \"\"\"\n         # returns flat dicts\n         nested = {}\n         control_args = {}\n         custom_args = {}\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if all([arg_spec, arg_spec.get('type', None),\n                     arg_spec.get('type', None) in\n                     [ctype_name for ctype_name, klass in\n                      COMPLEX_TYPES.items() if klass.is_nested]\n                     ]) or ('is_shared_group_option' not in arg_spec):\n                 if arg_name in nested:\n                     LOG.warning(\n                         \"Duplicated nested argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, nested[arg_name]))\n                 elif arg_name in custom_args:\n                     LOG.warning(\n                         \"Duplicated custom argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, custom_args[arg_name]))\n                 else:\n                     if \"ansible_variable\" in arg_spec:\n                         custom_args[arg_spec[\"ansible_variable\"]] = arg_value\n                     else:\n                         nested[arg_name] = arg_value\n             else:\n                 if arg_name in control_args:\n                     LOG.warning(\n                         \"Duplicated control argument found: '{}'. Using \"\n                         \"old value: '{}'\".format(\n                             arg_name, control_args[arg_name]))\n                 else:\n                     control_args[arg_name] = arg_value\n \n         return nested, control_args, custom_args\n \n     def _iterate_received_arguments(self, args):\n         \"\"\"Iterator helper method over all the received arguments\n \n         :return: yields tuple:\n             (spec name, spec dict,\n              argument name, argument value, argument spec)\n         \"\"\"\n         for spec_parser in self.spec_helper.iterate_parsers():\n             if spec_parser['name'] in args:\n                 parser_dict = args[spec_parser['name']]\n                 for arg_name, arg_val in parser_dict.items():\n                     arg_spec = self.spec_helper.get_option_spec(\n                         spec_parser['name'], arg_name)\n                     yield (spec_parser['name'], parser_dict,\n                            arg_name, arg_val, arg_spec)\n \n     def _convert_non_cli_args(self, parser_name, values_dict):\n         \"\"\"Casts arguments to correct types by modifying values_dict param.\n \n         By default all the values are strings.\n \n         :param parser_name: The command name, e.g. main, virsh, ospd, etc\n         :param values_dict: The dict of with arguments\n        \"\"\"\n         for opt_name, opt_value in values_dict.items():\n             file_option_spec = self.spec_helper.get_option_spec(\n                 parser_name, opt_name)\n             if file_option_spec.get('type', None) in ['int', ] or \\\n                     file_option_spec.get('action', None) in ['count', ]:\n                 values_dict[opt_name] = int(opt_value)\n \n     def _merge_duplicated_cli_args(self, cli_args):\n         \"\"\"Merge duplicated arguments to all the parsers\n \n         This is need to handle control args, shared among several parsers.\n         for example, verbose, inventory\n         \"\"\"\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(cli_args):\n             for parser_name2, parser_dict2 in cli_args.items():\n                 if all([parser_name2, parser_name != parser_name2,\n                         arg_name not in parser_dict2]):\n                     if self.spec_helper.get_option_spec(parser_name2,\n                                                         arg_name):\n                         parser_dict2[arg_name] = arg_value\n ", "input_code": "def _get_conditionally_required_args(self, command_name, options_spec, args):\n\"\"\"\nList arguments with ``required_when`` condition matched.\n\n:param command_name: the command name.\n:param options_spec:  the list of command spec options.\n:param args: the received input arguments\n:return: list, list of argument names with matched ``required_when``\n    condition\n\"\"\"\n", "indent_space": "                                         ", "ground_truth": "    def _get_conditionally_required_args(self, command_name, options_spec,\n                                         args):\n        \"\"\"List arguments with ``required_when`` condition matched.\n\n        :param command_name: the command name.\n        :param options_spec:  the list of command spec options.\n        :param args: the received input arguments\n        :return: list, list of argument names with matched ``required_when``\n            condition\n        \"\"\"\n        opts_names = [option_spec['name'] for option_spec in options_spec]\n        missing_args = []\n        for option_spec in options_spec:\n            option_results = []\n            if option_spec and 'required_when' in option_spec:\n                req_when_args = [option_spec['required_when']] \\\n                    if not type(option_spec['required_when']) is list \\\n                    else option_spec['required_when']\n\n                # validate conditions\n                for req_when_arg in req_when_args:\n                    splited_args_list = req_when_arg.split()\n                    for idx, req_arg in enumerate(splited_args_list):\n                        if req_arg in opts_names:\n                            splited_args_list[idx] = \\\n                                args.get(command_name, {}).get(req_arg.strip())\n                        if splited_args_list[idx] is None:\n                            option_results.append(False)\n                            break\n                        splited_args_list[idx] = str(splited_args_list[idx])\n                        if (splited_args_list[idx] not in ['and', 'or'] and\n                            not any(\n                                (c in '<>=') for c in splited_args_list[idx])):\n                            splited_args_list[idx] = \"'{0}'\".format(\n                                yaml.safe_load(splited_args_list[idx]))\n                    else:\n                        option_results.append(\n                            eval(' '.join(splited_args_list)))\n                if all(option_results) and \\\n                        self.spec_helper.get_option_state(\n                            command_name,\n                            option_spec['name'],\n                            args) == helper.OptionState['NOT_SET']:\n                    missing_args.append(option_spec['name'])\n        return missing_args", "signature": "def _get_conditionally_required_args(self, command_name, options_spec, args):", "completion_path": "infrared/core/inspector/inspector.py"}
{"ce_id": "6306092e73426c38ae68ad09", "namespace": "6306092e73426c38ae68ad09", "namespace_real": "infrared.core.inspector.inspector.validate_length_args", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "inspector", "function_name": "validate_length_args", "contexts_above": "import collections\nimport os\nfrom six.moves import configparser\nfrom string import Template\nimport yaml\n\nfrom infrared.core.cli.cli import CliParser\nfrom infrared.core.cli.cli import COMPLEX_TYPES\nfrom infrared.core.inspector import helper\nfrom infrared.core.utils import dict_utils\nfrom infrared.core.utils import exceptions\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n\nclass SpecParser(object):\n    \"\"\"Parses input arguments from different sources (cli, answers file). \"\"\"\n\n    @classmethod\n    def from_plugin(cls, subparser, plugin, base_groups):\n        \"\"\"Reads spec & vars from plugin and constructs the parser instance\n\n        :param subparser: argparse.subparser to extend\n        :param plugin: InfraredPlugin object\n        :param base_groups: dict, included groups\n        :return: SpecParser object based on given plugin spec & vars\n        \"\"\"\n\n        spec_dict = base_groups or {}\n        with open(plugin.spec) as stream:\n            spec = yaml.safe_load(stream) or {}\n            dict_utils.dict_merge(\n                base_groups,\n                spec,\n                dict_utils.ConflictResolver.unique_append_list_resolver)\n\n        # The \"try-excpet\" block here is for adding spec file path if it\n        # includes an unsupported option type\n        try:\n            return SpecParser(subparser, spec_dict, plugin.vars_dir,\n                              plugin.defaults_dir, plugin.path)\n        except exceptions.IRUnsupportedSpecOptionType as ex:\n            ex.message += ' in file: {}'.format(plugin.spec)\n            raise ex\n\n    def __init__(self, subparser, spec_dict, vars_dir, defaults_dir,\n                 plugin_path):\n        \"\"\"Constructor.\n\n        :param subparser: argparse.subparser to extend\n        :param spec_dict: dict with CLI description\n        :param vars_dir: Path to plugin's vars dir\n        :param defaults_dir: Path to plugin's defaults dir\n        \"\"\"\n        self.vars = vars_dir\n        self.defaults = defaults_dir\n        self.plugin_path = plugin_path\n        self.spec_helper = helper.SpecDictHelper(spec_dict)\n\n        # create parser\n        self.parser = CliParser.create_parser(self, subparser)\n\n    def add_shared_groups(self, list_of_groups):\n        \"\"\"Adds the user defined shared groups\n\n        :param list_of_groups: list, of group dicts\n        \"\"\"\n        shared_groups = self.spec_helper.spec_dict.get('shared_groups', [])\n        shared_groups.expand(list_of_groups)\n        self.spec_helper.spec_dict['shared_groups'] = shared_groups\n\n    def _get_defaults(self, default_getter_func):\n        \"\"\"Resolve arguments' values from cli or answers file.\n\n        :param default_getter_func: callable. will be called for all the\n            available options in spec file.\n        \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            default_value = default_getter_func(option)\n            if default_value is not None:\n                sub = parser['name']\n                result[sub][option['name']] = default_value\n\n        return result\n\n    def get_spec_defaults(self):\n        \"\"\"Resolve arguments' values from spec and other sources. \"\"\"\n\n        def spec_default_getter(option):\n            \"\"\"Getter function to retrieve the default value from spec.\n\n            :param option: argument name\n            \"\"\"\n\n            # first try to get environment variable with IR_ prefix\n            default_value = SpecParser.get_env_option(option['name'])\n            if default_value is not None:\n                LOG.info(\n                    \"[environ] Loading '{0}' default value\"\n                    \" '{1}' from the environment variable\".format(\n                        option['name'], default_value))\n            elif option.get('default', None) is not None:\n                default_value = option['default']\n            elif option.get('action', None) in ['store_true']:\n                default_value = False\n            return default_value\n\n        return self._get_defaults(spec_default_getter)\n\n    @staticmethod\n    def get_env_option(name):\n        \"\"\"Try get \"\"\"\n        return os.environ.get('IR_' + name.upper().replace('-', '_'))\n\n    def get_deprecated_args(self):\n        \"\"\"Returning dict with options which deprecate others. \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            if option.get('deprecates') is not None:\n                result[option.get('deprecates')] = option.get('name')\n\n        return result\n\n    @staticmethod\n    def parse_env_variable_from_file(value):\n        if isinstance(value, str):\n            t = Template(value)\n            try:\n                value = t.substitute(os.environ)\n            except KeyError as undefined_var:\n                raise exceptions.IRAnswersFileEnvVarNotDefined(undefined_var)\n        return value\n\n    def get_answers_file_args(self, cli_args):\n        \"\"\"Resolve arguments' values from answers INI file. \"\"\"\n\n        file_result = {}\n        args_to_remove = []\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            file_result[parser_name] = file_result.get(parser_name, {})\n            if option_spec and option_spec.get(\n                    'action', '') == 'read-answers':\n                # Iterate over arguments supplied by file\n                for parsed_arg in parser_dict[arg_name]:\n                    # Supplied arguments' value can be a list\n                    if isinstance(parser_dict[arg_name][parsed_arg], list):\n                        i = 0\n                        # Iterrate over argument values list\n                        for parsed_value in parser_dict[arg_name][parsed_arg]:\n                            parser_dict[arg_name][parsed_arg][i] = \\\n                                SpecParser.parse_env_variable_from_file(parsed_value)\n                            i += 1\n                    else:\n                        parser_dict[arg_name][parsed_arg] = \\\n                            SpecParser.parse_env_variable_from_file(parser_dict[arg_name][parsed_arg])\n                # we have config option. saving it.\n                self._convert_non_cli_args(\n                    parser_name, parser_dict[arg_name])\n                dict_utils.dict_merge(\n                    file_result[parser_name],\n                    parser_dict[arg_name])\n                # remove from cli args\n                args_to_remove.append((parser_name, arg_name))\n\n        # remove parser dict outside loop to avoid iteration dict modification\n        for parser_name, arg_name in args_to_remove:\n            for spec_parser in self.spec_helper.iterate_parsers():\n                if spec_parser['name'] in cli_args and spec_parser['name'] == parser_name:\n                    parser_dict = cli_args[spec_parser['name']]\n                    parser_dict.pop(arg_name)\n                    break\n\n        return file_result\n\n    def generate_answers_file(self, cli_args, spec_defaults):\n        \"\"\"Generates answers INI file\n\n        :param cli_args: list, cli arguments.\n        :param spec_defaults: the default values.\n        \"\"\"\n\n        def put_option(config, parser_name, option_name, value):\n            for opt_help in option.get('help', '').split('\\n'):\n                help_opt = '# ' + opt_help\n\n                # add help comment\n                if config.has_option(parser_name, help_opt):\n                    config.remove_option(parser_name, help_opt)\n                config.set(\n                    parser_name, help_opt)\n\n            if config.has_option(parser_name, option_name):\n                value = config.get(parser_name, option_name)\n                config.remove_option(parser_name, option_name)\n\n            config.set(\n                parser_name,\n                option_name,\n                str(value))\n\n        file_generated = False\n\n        # load generate answers file for all the parsers\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            if option_spec and option_spec.get(\n                    'action', '') == 'generate-answers':\n                options_to_save = \\\n                    self.spec_helper.get_parser_option_specs(parser_name)\n                out_answers = configparser.ConfigParser(allow_no_value=True)\n\n                if not out_answers.has_section(parser_name):\n                    out_answers.add_section(parser_name)\n\n                for option in options_to_save:\n                    opt_name = option['name']\n                    if opt_name in parser_dict:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            parser_dict[opt_name])\n                    elif opt_name in spec_defaults[parser_name]:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            spec_defaults[parser_name][opt_name])\n                    elif option.get('required', False):\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            '# ' + opt_name,\n                            \"Required argument. \"\n                            \"Edit with one of the allowed values OR \"\n                            \"override with \"\n                            \"CLI: --{}=<option>\".format(opt_name))\n\n                # write to file\n                with open(arg_value, 'w') as answers_file:\n                    out_answers.write(answers_file)\n                file_generated = True\n\n        return file_generated\n\n    def resolve_custom_types(self, args):\n        \"\"\"Transforms the arguments with custom types\n\n        :param args: the list of received arguments.\n        \"\"\"\n        for parser_name, parser_dict in args.items():\n            spec_complex_options = [opt for opt in\n                                    self.spec_helper.get_parser_option_specs(\n                                        parser_name) if\n                                    opt.get('type', None) in COMPLEX_TYPES]\n            for spec_option in spec_complex_options:\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # we have custom type to resolve\n                    type_name = spec_option['type']\n                    option_value = parser_dict[option_name]\n                    action = self.create_complex_argumet_type(\n                        parser_name,\n                        type_name,\n                        option_name,\n                        spec_option)\n\n                    # resolving value\n                    parser_dict[option_name] = action.resolve(option_value)\n\n    def create_complex_argumet_type(self, subcommand, type_name, option_name,\n                                    spec_option):\n        \"\"\"Build the complex argument type\n\n        :param subcommand: the command name\n        :param type_name: the complex type name\n        :param option_name: the option name\n        :param spec_option: option's specifications\n        :return: the complex type instance\n        \"\"\"\n        complex_action = COMPLEX_TYPES.get(\n            type_name, None)\n        if complex_action is None:\n            raise exceptions.SpecParserException(\n                \"Unknown complex type: {}\".format(type_name))\n        return complex_action(\n            option_name,\n            (self.vars, self.defaults, self.plugin_path),\n            subcommand,\n            spec_option)\n\n    def parse_args(self, arg_parser, args=None):\n        \"\"\"Parses all the arguments (cli, answers file)\n\n        :return: None, if ``--generate-answers-file`` in arg_arg_parser\n        :return: (dict, dict):\n            * command arguments dict (arguments to control the IR logic)\n            * nested arguments dict (arguments to pass to the playbooks)\n        \"\"\"\n\n        spec_defaults = self.get_spec_defaults()\n        cli_args = CliParser.parse_cli_input(arg_parser, args)\n\n        file_args = self.get_answers_file_args(cli_args)\n\n        # generate answers file and exit\n        if self.generate_answers_file(cli_args, spec_defaults):\n            LOG.warning(\"Answers file generated. Exiting.\")\n\n        # print warnings when something was overridden from non-cli source.\n        self.validate_arg_sources(cli_args, file_args,\n                                  spec_defaults)\n\n        # print warnings for deprecated\n        self.validate_arg_deprecation(cli_args, file_args)\n\n        # now filter defaults to have only parser defined in cli\n        defaults = dict((key, spec_defaults[key])\n                        for key in cli_args.keys() if\n                        key in spec_defaults)\n\n        # copy cli args with the same name to all parser groups\n        self._merge_duplicated_cli_args(cli_args)\n        self._merge_duplicated_cli_args(file_args)\n\n        dict_utils.dict_merge(defaults, file_args)\n        dict_utils.dict_merge(defaults, cli_args)\n        self.validate_requires_args(defaults)\n        self.validate_length_args(defaults)\n        self.validate_choices_args(defaults)\n        self.validate_min_max_args(defaults)\n\n        # now resolve complex types.\n        self.resolve_custom_types(defaults)\n        nested, control, custom = \\\n            self.get_nested_custom_and_control_args(defaults)\n        return nested, control, custom\n\n    def validate_arg_deprecation(self, cli_args, answer_file_args):\n        \"\"\"Validates and prints the deprecated arguments.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        \"\"\"\n\n        for deprecated, deprecates in self.get_deprecated_args().items():\n            for input_args in (answer_file_args.items(), cli_args.items()):\n                for command, command_dict in input_args:\n                    if deprecated in command_dict:\n                        if deprecates in command_dict:\n                            raise exceptions.IRDeprecationException(\n                                \"[{}] Argument '{}' deprecates '{}',\"\n                                \" please use only the new one.\".format(\n                                    command, deprecated, deprecates))\n\n                        if deprecated in answer_file_args[command]:\n                            answer_file_args[command][deprecates] = \\\n                                answer_file_args[command][deprecated]\n\n                        if deprecated in cli_args[command]:\n                            cli_args[command][deprecates] = \\\n                                cli_args[command][deprecated]\n\n                        LOG.warning(\n                            \"[{}] Argument '{}' was deprecated,\"\n                            \" please use '{}'.\".format(\n                                command, deprecated, deprecates))\n\n    @staticmethod\n    def validate_arg_sources(cli_args, answer_file_args, spec_defaults):\n        \"\"\"Validates and prints the arguments' source.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        :param spec_defaults:  the default values from spec files\n        \"\"\"\n\n        def show_diff(diff, command_name, cmd_dict, source_name):\n            if diff:\n                for arg_name in diff:\n                    value = cmd_dict[arg_name]\n                    LOG.info(\n                        \"[{}] Argument '{}' was set to\"\n                        \" '{}' from the {} source.\".format(\n                            command_name, arg_name, value, source_name))\n\n        for command, command_dict in cli_args.items():\n            file_dict = answer_file_args.get(command, {})\n            file_diff = set(file_dict.keys()) - set(command_dict.keys())\n            show_diff(file_diff, command, file_dict, 'answers file')\n\n            def_dict = spec_defaults.get(command, {})\n            default_diff = set(def_dict.keys()) - set(\n                command_dict.keys()) - file_diff\n            show_diff(default_diff, command, def_dict, 'spec defaults')\n\n    def _get_conditionally_required_args(self, command_name, options_spec,\n                                         args):\n        \"\"\"List arguments with ``required_when`` condition matched.\n\n        :param command_name: the command name.\n        :param options_spec:  the list of command spec options.\n        :param args: the received input arguments\n        :return: list, list of argument names with matched ``required_when``\n            condition\n        \"\"\"\n        opts_names = [option_spec['name'] for option_spec in options_spec]\n        missing_args = []\n        for option_spec in options_spec:\n            option_results = []\n            if option_spec and 'required_when' in option_spec:\n                req_when_args = [option_spec['required_when']] \\\n                    if not type(option_spec['required_when']) is list \\\n                    else option_spec['required_when']\n\n                # validate conditions\n                for req_when_arg in req_when_args:\n                    splited_args_list = req_when_arg.split()\n                    for idx, req_arg in enumerate(splited_args_list):\n                        if req_arg in opts_names:\n                            splited_args_list[idx] = \\\n                                args.get(command_name, {}).get(req_arg.strip())\n                        if splited_args_list[idx] is None:\n                            option_results.append(False)\n                            break\n                        splited_args_list[idx] = str(splited_args_list[idx])\n                        if (splited_args_list[idx] not in ['and', 'or'] and\n                            not any(\n                                (c in '<>=') for c in splited_args_list[idx])):\n                            splited_args_list[idx] = \"'{0}'\".format(\n                                yaml.safe_load(splited_args_list[idx]))\n                    else:\n                        option_results.append(\n                            eval(' '.join(splited_args_list)))\n                if all(option_results) and \\\n                        self.spec_helper.get_option_state(\n                            command_name,\n                            option_spec['name'],\n                            args) == helper.OptionState['NOT_SET']:\n                    missing_args.append(option_spec['name'])\n        return missing_args\n\n    def validate_requires_args(self, args):\n        \"\"\"Check if all the required arguments have been provided. \"\"\"\n\n        silent_args = self.get_silent_args(args)\n\n        def validate_parser(parser_name, expected_options, parser_args):\n            \"\"\"Helper method to resolve dict_merge. \"\"\"\n\n            result = collections.defaultdict(list)\n            condition_req_args = self._get_conditionally_required_args(\n                parser_name, expected_options, args)\n\n            for option in expected_options:\n                name = option['name']\n\n                # check required options.\n                if (option.get('required', False) and\n                    name not in parser_args or\n                    option['name'] in condition_req_args) and \\\n                        name not in silent_args:\n                    result[parser_name].append(name)\n\n            return result\n\n        res = {}\n        for command_data in self.spec_helper.iterate_parsers():\n            cmd_name = command_data['name']\n            if cmd_name in args:\n                dict_utils.dict_merge(\n                    res,\n                    validate_parser(\n                        cmd_name,\n                        self.spec_helper.get_parser_option_specs(cmd_name),\n                        args[cmd_name]))\n\n        missing_args = dict((cmd_name, args)\n                            for cmd_name, args in res.items() if len(args) > 0)\n        if missing_args:\n            raise exceptions.IRRequiredArgsMissingException(missing_args)\n", "contexts_below": "    def validate_choices_args(self, args):\n         \"\"\"Check if value of choice arguments is one of the available choices.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if 'choices' not in spec_option:\n                     # skip options that does not contain choices\n                     continue\n                 option_name = spec_option['name']\n                 if option_name in parser_dict:\n                     # resolve choices\n                     choices = spec_option['choices']\n                     option_value = parser_dict[option_name]\n                     if option_value not in choices:\n                         # found invalid option, append to list of invalid opts\n                         invalid_options.append((\n                             option_name,\n                             option_value,\n                             choices\n                         ))\n         if invalid_options:\n             # raise exception with all arguments that contains invalid choices\n             raise exceptions.IRInvalidChoiceException(invalid_options)\n \n     def validate_min_max_args(self, args):\n         \"\"\"Check if value of arguments is between minimum and maximum values.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if all([key not in spec_option\n                         for key in ('maximum', 'minimum')]):\n                     # skip options that does not contain minimum or maximum\n                     continue\n                 option_name = spec_option['name']\n \n                 if option_name in parser_dict:\n                     option_value = parser_dict[option_name]\n                     min_value = spec_option.get('minimum')\n                     max_value = spec_option.get('maximum')\n                     # handle empty values in spec files which load as None\n                     min_value = '' if 'minimum' in spec_option \\\n                                       and min_value is None else min_value\n                     max_value = '' if 'maximum' in spec_option \\\n                                       and max_value is None else max_value\n \n                     values = {\n                         \"value\": option_value,\n                         \"maximum\": max_value,\n                         \"minimum\": min_value\n                     }\n \n                     # make sure that values are numbers\n                     is_all_values_numbers = True\n                     for name, num in values.items():\n                         if num is not None \\\n                                 and (isinstance(num, bool) or\n                                      not isinstance(num, (int, float))):\n                             invalid_options.append((\n                                 option_name,\n                                 name,\n                                 \"number\",\n                                 type(num).__name__\n                             ))\n                             is_all_values_numbers = False\n \n                     if not is_all_values_numbers:\n                         # don't continue to min max checks since some of the\n                         # values are not numbers\n                         continue\n \n                     # check bigger than minimum\n                     if min_value is not None and option_value < min_value:\n                         invalid_options.append((\n                             option_name,\n                             \"minimum\",\n                             min_value,\n                             option_value\n                         ))\n                     # check smaller than maximum\n                     if max_value is not None and option_value > max_value:\n                         invalid_options.append((\n                             option_name,\n                             \"maximum\",\n                             max_value,\n                             option_value\n                         ))\n \n         if invalid_options:\n             # raise exception with all arguments that contains invalid choices\n             raise exceptions.IRInvalidMinMaxRangeException(invalid_options)\n \n     def get_silent_args(self, args):\n         \"\"\"list of silenced argument\n \n         :param args: The received arguments.\n         :return: list, slienced argument names\n         \"\"\"\n         silent_args_names = []\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if arg_spec and 'silent' in arg_spec and \\\n                     self.spec_helper.get_option_state(\n                         parser_name,\n                         arg_name,\n                         args) == helper.OptionState['IS_SET']:\n                 silent_args_names.extend(arg_spec['silent'])\n \n         return list(set(silent_args_names))\n \n     def get_nested_custom_and_control_args(self, args):\n         \"\"\"Split input arguments to control nested and custom.\n \n         Controls arguments: control the IR behavior. These arguments\n             will not be put into the spec yml file\n         Nested arguments: are used by the Ansible playbooks and will be put\n             into the spec yml file.\n         Custom arguments: Custom ansible variables to be used instead of the\n             normal nested usage.\n \n         :param args: the collected list of args.\n         :return: (dict, dict): flat dicts (control_args, nested_args)\n         \"\"\"\n         # returns flat dicts\n         nested = {}\n         control_args = {}\n         custom_args = {}\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if all([arg_spec, arg_spec.get('type', None),\n                     arg_spec.get('type', None) in\n                     [ctype_name for ctype_name, klass in\n                      COMPLEX_TYPES.items() if klass.is_nested]\n                     ]) or ('is_shared_group_option' not in arg_spec):\n                 if arg_name in nested:\n                     LOG.warning(\n                         \"Duplicated nested argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, nested[arg_name]))\n                 elif arg_name in custom_args:\n                     LOG.warning(\n                         \"Duplicated custom argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, custom_args[arg_name]))\n                 else:\n                     if \"ansible_variable\" in arg_spec:\n                         custom_args[arg_spec[\"ansible_variable\"]] = arg_value\n                     else:\n                         nested[arg_name] = arg_value\n             else:\n                 if arg_name in control_args:\n                     LOG.warning(\n                         \"Duplicated control argument found: '{}'. Using \"\n                         \"old value: '{}'\".format(\n                             arg_name, control_args[arg_name]))\n                 else:\n                     control_args[arg_name] = arg_value\n \n         return nested, control_args, custom_args\n \n     def _iterate_received_arguments(self, args):\n         \"\"\"Iterator helper method over all the received arguments\n \n         :return: yields tuple:\n             (spec name, spec dict,\n              argument name, argument value, argument spec)\n         \"\"\"\n         for spec_parser in self.spec_helper.iterate_parsers():\n             if spec_parser['name'] in args:\n                 parser_dict = args[spec_parser['name']]\n                 for arg_name, arg_val in parser_dict.items():\n                     arg_spec = self.spec_helper.get_option_spec(\n                         spec_parser['name'], arg_name)\n                     yield (spec_parser['name'], parser_dict,\n                            arg_name, arg_val, arg_spec)\n \n     def _convert_non_cli_args(self, parser_name, values_dict):\n         \"\"\"Casts arguments to correct types by modifying values_dict param.\n \n         By default all the values are strings.\n \n         :param parser_name: The command name, e.g. main, virsh, ospd, etc\n         :param values_dict: The dict of with arguments\n        \"\"\"\n         for opt_name, opt_value in values_dict.items():\n             file_option_spec = self.spec_helper.get_option_spec(\n                 parser_name, opt_name)\n             if file_option_spec.get('type', None) in ['int', ] or \\\n                     file_option_spec.get('action', None) in ['count', ]:\n                 values_dict[opt_name] = int(opt_value)\n \n     def _merge_duplicated_cli_args(self, cli_args):\n         \"\"\"Merge duplicated arguments to all the parsers\n \n         This is need to handle control args, shared among several parsers.\n         for example, verbose, inventory\n         \"\"\"\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(cli_args):\n             for parser_name2, parser_dict2 in cli_args.items():\n                 if all([parser_name2, parser_name != parser_name2,\n                         arg_name not in parser_dict2]):\n                     if self.spec_helper.get_option_spec(parser_name2,\n                                                         arg_name):\n                         parser_dict2[arg_name] = arg_value\n ", "input_code": "def validate_length_args(self, args):\n\"\"\"\nCheck if value of arguments is not longer than length specified.\n\n:param args: The received arguments.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def validate_length_args(self, args):\n        \"\"\"Check if value of arguments is not longer than length specified.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if 'length' not in spec_option:\n                    # skip options that does not contain length\n                    continue\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # resolve length\n                    length = spec_option['length']\n                    option_value = parser_dict[option_name]\n                    if len(option_value) > int(length):\n                        # found invalid option, append to list of invalid opts\n                        invalid_options.append((\n                            option_name,\n                            option_value,\n                            length\n                        ))\n        if invalid_options:\n            # raise exception with all arguments that exceed length\n            raise exceptions.IRInvalidLengthException(invalid_options)", "signature": "def validate_length_args(self, args):", "completion_path": "infrared/core/inspector/inspector.py"}
{"ce_id": "6306092e73426c38ae68ad0a", "namespace": "6306092e73426c38ae68ad0a", "namespace_real": "infrared.core.inspector.inspector.validate_choices_args", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "inspector", "function_name": "validate_choices_args", "contexts_above": "import collections\nimport os\nfrom six.moves import configparser\nfrom string import Template\nimport yaml\n\nfrom infrared.core.cli.cli import CliParser\nfrom infrared.core.cli.cli import COMPLEX_TYPES\nfrom infrared.core.inspector import helper\nfrom infrared.core.utils import dict_utils\nfrom infrared.core.utils import exceptions\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n\nclass SpecParser(object):\n    \"\"\"Parses input arguments from different sources (cli, answers file). \"\"\"\n\n    @classmethod\n    def from_plugin(cls, subparser, plugin, base_groups):\n        \"\"\"Reads spec & vars from plugin and constructs the parser instance\n\n        :param subparser: argparse.subparser to extend\n        :param plugin: InfraredPlugin object\n        :param base_groups: dict, included groups\n        :return: SpecParser object based on given plugin spec & vars\n        \"\"\"\n\n        spec_dict = base_groups or {}\n        with open(plugin.spec) as stream:\n            spec = yaml.safe_load(stream) or {}\n            dict_utils.dict_merge(\n                base_groups,\n                spec,\n                dict_utils.ConflictResolver.unique_append_list_resolver)\n\n        # The \"try-excpet\" block here is for adding spec file path if it\n        # includes an unsupported option type\n        try:\n            return SpecParser(subparser, spec_dict, plugin.vars_dir,\n                              plugin.defaults_dir, plugin.path)\n        except exceptions.IRUnsupportedSpecOptionType as ex:\n            ex.message += ' in file: {}'.format(plugin.spec)\n            raise ex\n\n    def __init__(self, subparser, spec_dict, vars_dir, defaults_dir,\n                 plugin_path):\n        \"\"\"Constructor.\n\n        :param subparser: argparse.subparser to extend\n        :param spec_dict: dict with CLI description\n        :param vars_dir: Path to plugin's vars dir\n        :param defaults_dir: Path to plugin's defaults dir\n        \"\"\"\n        self.vars = vars_dir\n        self.defaults = defaults_dir\n        self.plugin_path = plugin_path\n        self.spec_helper = helper.SpecDictHelper(spec_dict)\n\n        # create parser\n        self.parser = CliParser.create_parser(self, subparser)\n\n    def add_shared_groups(self, list_of_groups):\n        \"\"\"Adds the user defined shared groups\n\n        :param list_of_groups: list, of group dicts\n        \"\"\"\n        shared_groups = self.spec_helper.spec_dict.get('shared_groups', [])\n        shared_groups.expand(list_of_groups)\n        self.spec_helper.spec_dict['shared_groups'] = shared_groups\n\n    def _get_defaults(self, default_getter_func):\n        \"\"\"Resolve arguments' values from cli or answers file.\n\n        :param default_getter_func: callable. will be called for all the\n            available options in spec file.\n        \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            default_value = default_getter_func(option)\n            if default_value is not None:\n                sub = parser['name']\n                result[sub][option['name']] = default_value\n\n        return result\n\n    def get_spec_defaults(self):\n        \"\"\"Resolve arguments' values from spec and other sources. \"\"\"\n\n        def spec_default_getter(option):\n            \"\"\"Getter function to retrieve the default value from spec.\n\n            :param option: argument name\n            \"\"\"\n\n            # first try to get environment variable with IR_ prefix\n            default_value = SpecParser.get_env_option(option['name'])\n            if default_value is not None:\n                LOG.info(\n                    \"[environ] Loading '{0}' default value\"\n                    \" '{1}' from the environment variable\".format(\n                        option['name'], default_value))\n            elif option.get('default', None) is not None:\n                default_value = option['default']\n            elif option.get('action', None) in ['store_true']:\n                default_value = False\n            return default_value\n\n        return self._get_defaults(spec_default_getter)\n\n    @staticmethod\n    def get_env_option(name):\n        \"\"\"Try get \"\"\"\n        return os.environ.get('IR_' + name.upper().replace('-', '_'))\n\n    def get_deprecated_args(self):\n        \"\"\"Returning dict with options which deprecate others. \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            if option.get('deprecates') is not None:\n                result[option.get('deprecates')] = option.get('name')\n\n        return result\n\n    @staticmethod\n    def parse_env_variable_from_file(value):\n        if isinstance(value, str):\n            t = Template(value)\n            try:\n                value = t.substitute(os.environ)\n            except KeyError as undefined_var:\n                raise exceptions.IRAnswersFileEnvVarNotDefined(undefined_var)\n        return value\n\n    def get_answers_file_args(self, cli_args):\n        \"\"\"Resolve arguments' values from answers INI file. \"\"\"\n\n        file_result = {}\n        args_to_remove = []\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            file_result[parser_name] = file_result.get(parser_name, {})\n            if option_spec and option_spec.get(\n                    'action', '') == 'read-answers':\n                # Iterate over arguments supplied by file\n                for parsed_arg in parser_dict[arg_name]:\n                    # Supplied arguments' value can be a list\n                    if isinstance(parser_dict[arg_name][parsed_arg], list):\n                        i = 0\n                        # Iterrate over argument values list\n                        for parsed_value in parser_dict[arg_name][parsed_arg]:\n                            parser_dict[arg_name][parsed_arg][i] = \\\n                                SpecParser.parse_env_variable_from_file(parsed_value)\n                            i += 1\n                    else:\n                        parser_dict[arg_name][parsed_arg] = \\\n                            SpecParser.parse_env_variable_from_file(parser_dict[arg_name][parsed_arg])\n                # we have config option. saving it.\n                self._convert_non_cli_args(\n                    parser_name, parser_dict[arg_name])\n                dict_utils.dict_merge(\n                    file_result[parser_name],\n                    parser_dict[arg_name])\n                # remove from cli args\n                args_to_remove.append((parser_name, arg_name))\n\n        # remove parser dict outside loop to avoid iteration dict modification\n        for parser_name, arg_name in args_to_remove:\n            for spec_parser in self.spec_helper.iterate_parsers():\n                if spec_parser['name'] in cli_args and spec_parser['name'] == parser_name:\n                    parser_dict = cli_args[spec_parser['name']]\n                    parser_dict.pop(arg_name)\n                    break\n\n        return file_result\n\n    def generate_answers_file(self, cli_args, spec_defaults):\n        \"\"\"Generates answers INI file\n\n        :param cli_args: list, cli arguments.\n        :param spec_defaults: the default values.\n        \"\"\"\n\n        def put_option(config, parser_name, option_name, value):\n            for opt_help in option.get('help', '').split('\\n'):\n                help_opt = '# ' + opt_help\n\n                # add help comment\n                if config.has_option(parser_name, help_opt):\n                    config.remove_option(parser_name, help_opt)\n                config.set(\n                    parser_name, help_opt)\n\n            if config.has_option(parser_name, option_name):\n                value = config.get(parser_name, option_name)\n                config.remove_option(parser_name, option_name)\n\n            config.set(\n                parser_name,\n                option_name,\n                str(value))\n\n        file_generated = False\n\n        # load generate answers file for all the parsers\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            if option_spec and option_spec.get(\n                    'action', '') == 'generate-answers':\n                options_to_save = \\\n                    self.spec_helper.get_parser_option_specs(parser_name)\n                out_answers = configparser.ConfigParser(allow_no_value=True)\n\n                if not out_answers.has_section(parser_name):\n                    out_answers.add_section(parser_name)\n\n                for option in options_to_save:\n                    opt_name = option['name']\n                    if opt_name in parser_dict:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            parser_dict[opt_name])\n                    elif opt_name in spec_defaults[parser_name]:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            spec_defaults[parser_name][opt_name])\n                    elif option.get('required', False):\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            '# ' + opt_name,\n                            \"Required argument. \"\n                            \"Edit with one of the allowed values OR \"\n                            \"override with \"\n                            \"CLI: --{}=<option>\".format(opt_name))\n\n                # write to file\n                with open(arg_value, 'w') as answers_file:\n                    out_answers.write(answers_file)\n                file_generated = True\n\n        return file_generated\n\n    def resolve_custom_types(self, args):\n        \"\"\"Transforms the arguments with custom types\n\n        :param args: the list of received arguments.\n        \"\"\"\n        for parser_name, parser_dict in args.items():\n            spec_complex_options = [opt for opt in\n                                    self.spec_helper.get_parser_option_specs(\n                                        parser_name) if\n                                    opt.get('type', None) in COMPLEX_TYPES]\n            for spec_option in spec_complex_options:\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # we have custom type to resolve\n                    type_name = spec_option['type']\n                    option_value = parser_dict[option_name]\n                    action = self.create_complex_argumet_type(\n                        parser_name,\n                        type_name,\n                        option_name,\n                        spec_option)\n\n                    # resolving value\n                    parser_dict[option_name] = action.resolve(option_value)\n\n    def create_complex_argumet_type(self, subcommand, type_name, option_name,\n                                    spec_option):\n        \"\"\"Build the complex argument type\n\n        :param subcommand: the command name\n        :param type_name: the complex type name\n        :param option_name: the option name\n        :param spec_option: option's specifications\n        :return: the complex type instance\n        \"\"\"\n        complex_action = COMPLEX_TYPES.get(\n            type_name, None)\n        if complex_action is None:\n            raise exceptions.SpecParserException(\n                \"Unknown complex type: {}\".format(type_name))\n        return complex_action(\n            option_name,\n            (self.vars, self.defaults, self.plugin_path),\n            subcommand,\n            spec_option)\n\n    def parse_args(self, arg_parser, args=None):\n        \"\"\"Parses all the arguments (cli, answers file)\n\n        :return: None, if ``--generate-answers-file`` in arg_arg_parser\n        :return: (dict, dict):\n            * command arguments dict (arguments to control the IR logic)\n            * nested arguments dict (arguments to pass to the playbooks)\n        \"\"\"\n\n        spec_defaults = self.get_spec_defaults()\n        cli_args = CliParser.parse_cli_input(arg_parser, args)\n\n        file_args = self.get_answers_file_args(cli_args)\n\n        # generate answers file and exit\n        if self.generate_answers_file(cli_args, spec_defaults):\n            LOG.warning(\"Answers file generated. Exiting.\")\n\n        # print warnings when something was overridden from non-cli source.\n        self.validate_arg_sources(cli_args, file_args,\n                                  spec_defaults)\n\n        # print warnings for deprecated\n        self.validate_arg_deprecation(cli_args, file_args)\n\n        # now filter defaults to have only parser defined in cli\n        defaults = dict((key, spec_defaults[key])\n                        for key in cli_args.keys() if\n                        key in spec_defaults)\n\n        # copy cli args with the same name to all parser groups\n        self._merge_duplicated_cli_args(cli_args)\n        self._merge_duplicated_cli_args(file_args)\n\n        dict_utils.dict_merge(defaults, file_args)\n        dict_utils.dict_merge(defaults, cli_args)\n        self.validate_requires_args(defaults)\n        self.validate_length_args(defaults)\n        self.validate_choices_args(defaults)\n        self.validate_min_max_args(defaults)\n\n        # now resolve complex types.\n        self.resolve_custom_types(defaults)\n        nested, control, custom = \\\n            self.get_nested_custom_and_control_args(defaults)\n        return nested, control, custom\n\n    def validate_arg_deprecation(self, cli_args, answer_file_args):\n        \"\"\"Validates and prints the deprecated arguments.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        \"\"\"\n\n        for deprecated, deprecates in self.get_deprecated_args().items():\n            for input_args in (answer_file_args.items(), cli_args.items()):\n                for command, command_dict in input_args:\n                    if deprecated in command_dict:\n                        if deprecates in command_dict:\n                            raise exceptions.IRDeprecationException(\n                                \"[{}] Argument '{}' deprecates '{}',\"\n                                \" please use only the new one.\".format(\n                                    command, deprecated, deprecates))\n\n                        if deprecated in answer_file_args[command]:\n                            answer_file_args[command][deprecates] = \\\n                                answer_file_args[command][deprecated]\n\n                        if deprecated in cli_args[command]:\n                            cli_args[command][deprecates] = \\\n                                cli_args[command][deprecated]\n\n                        LOG.warning(\n                            \"[{}] Argument '{}' was deprecated,\"\n                            \" please use '{}'.\".format(\n                                command, deprecated, deprecates))\n\n    @staticmethod\n    def validate_arg_sources(cli_args, answer_file_args, spec_defaults):\n        \"\"\"Validates and prints the arguments' source.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        :param spec_defaults:  the default values from spec files\n        \"\"\"\n\n        def show_diff(diff, command_name, cmd_dict, source_name):\n            if diff:\n                for arg_name in diff:\n                    value = cmd_dict[arg_name]\n                    LOG.info(\n                        \"[{}] Argument '{}' was set to\"\n                        \" '{}' from the {} source.\".format(\n                            command_name, arg_name, value, source_name))\n\n        for command, command_dict in cli_args.items():\n            file_dict = answer_file_args.get(command, {})\n            file_diff = set(file_dict.keys()) - set(command_dict.keys())\n            show_diff(file_diff, command, file_dict, 'answers file')\n\n            def_dict = spec_defaults.get(command, {})\n            default_diff = set(def_dict.keys()) - set(\n                command_dict.keys()) - file_diff\n            show_diff(default_diff, command, def_dict, 'spec defaults')\n\n    def _get_conditionally_required_args(self, command_name, options_spec,\n                                         args):\n        \"\"\"List arguments with ``required_when`` condition matched.\n\n        :param command_name: the command name.\n        :param options_spec:  the list of command spec options.\n        :param args: the received input arguments\n        :return: list, list of argument names with matched ``required_when``\n            condition\n        \"\"\"\n        opts_names = [option_spec['name'] for option_spec in options_spec]\n        missing_args = []\n        for option_spec in options_spec:\n            option_results = []\n            if option_spec and 'required_when' in option_spec:\n                req_when_args = [option_spec['required_when']] \\\n                    if not type(option_spec['required_when']) is list \\\n                    else option_spec['required_when']\n\n                # validate conditions\n                for req_when_arg in req_when_args:\n                    splited_args_list = req_when_arg.split()\n                    for idx, req_arg in enumerate(splited_args_list):\n                        if req_arg in opts_names:\n                            splited_args_list[idx] = \\\n                                args.get(command_name, {}).get(req_arg.strip())\n                        if splited_args_list[idx] is None:\n                            option_results.append(False)\n                            break\n                        splited_args_list[idx] = str(splited_args_list[idx])\n                        if (splited_args_list[idx] not in ['and', 'or'] and\n                            not any(\n                                (c in '<>=') for c in splited_args_list[idx])):\n                            splited_args_list[idx] = \"'{0}'\".format(\n                                yaml.safe_load(splited_args_list[idx]))\n                    else:\n                        option_results.append(\n                            eval(' '.join(splited_args_list)))\n                if all(option_results) and \\\n                        self.spec_helper.get_option_state(\n                            command_name,\n                            option_spec['name'],\n                            args) == helper.OptionState['NOT_SET']:\n                    missing_args.append(option_spec['name'])\n        return missing_args\n\n    def validate_requires_args(self, args):\n        \"\"\"Check if all the required arguments have been provided. \"\"\"\n\n        silent_args = self.get_silent_args(args)\n\n        def validate_parser(parser_name, expected_options, parser_args):\n            \"\"\"Helper method to resolve dict_merge. \"\"\"\n\n            result = collections.defaultdict(list)\n            condition_req_args = self._get_conditionally_required_args(\n                parser_name, expected_options, args)\n\n            for option in expected_options:\n                name = option['name']\n\n                # check required options.\n                if (option.get('required', False) and\n                    name not in parser_args or\n                    option['name'] in condition_req_args) and \\\n                        name not in silent_args:\n                    result[parser_name].append(name)\n\n            return result\n\n        res = {}\n        for command_data in self.spec_helper.iterate_parsers():\n            cmd_name = command_data['name']\n            if cmd_name in args:\n                dict_utils.dict_merge(\n                    res,\n                    validate_parser(\n                        cmd_name,\n                        self.spec_helper.get_parser_option_specs(cmd_name),\n                        args[cmd_name]))\n\n        missing_args = dict((cmd_name, args)\n                            for cmd_name, args in res.items() if len(args) > 0)\n        if missing_args:\n            raise exceptions.IRRequiredArgsMissingException(missing_args)\n\n    def validate_length_args(self, args):\n        \"\"\"Check if value of arguments is not longer than length specified.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if 'length' not in spec_option:\n                    # skip options that does not contain length\n                    continue\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # resolve length\n                    length = spec_option['length']\n                    option_value = parser_dict[option_name]\n                    if len(option_value) > int(length):\n                        # found invalid option, append to list of invalid opts\n                        invalid_options.append((\n                            option_name,\n                            option_value,\n                            length\n                        ))\n        if invalid_options:\n            # raise exception with all arguments that exceed length\n            raise exceptions.IRInvalidLengthException(invalid_options)\n", "contexts_below": "    def validate_min_max_args(self, args):\n         \"\"\"Check if value of arguments is between minimum and maximum values.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if all([key not in spec_option\n                         for key in ('maximum', 'minimum')]):\n                     # skip options that does not contain minimum or maximum\n                     continue\n                 option_name = spec_option['name']\n \n                 if option_name in parser_dict:\n                     option_value = parser_dict[option_name]\n                     min_value = spec_option.get('minimum')\n                     max_value = spec_option.get('maximum')\n                     # handle empty values in spec files which load as None\n                     min_value = '' if 'minimum' in spec_option \\\n                                       and min_value is None else min_value\n                     max_value = '' if 'maximum' in spec_option \\\n                                       and max_value is None else max_value\n \n                     values = {\n                         \"value\": option_value,\n                         \"maximum\": max_value,\n                         \"minimum\": min_value\n                     }\n \n                     # make sure that values are numbers\n                     is_all_values_numbers = True\n                     for name, num in values.items():\n                         if num is not None \\\n                                 and (isinstance(num, bool) or\n                                      not isinstance(num, (int, float))):\n                             invalid_options.append((\n                                 option_name,\n                                 name,\n                                 \"number\",\n                                 type(num).__name__\n                             ))\n                             is_all_values_numbers = False\n \n                     if not is_all_values_numbers:\n                         # don't continue to min max checks since some of the\n                         # values are not numbers\n                         continue\n \n                     # check bigger than minimum\n                     if min_value is not None and option_value < min_value:\n                         invalid_options.append((\n                             option_name,\n                             \"minimum\",\n                             min_value,\n                             option_value\n                         ))\n                     # check smaller than maximum\n                     if max_value is not None and option_value > max_value:\n                         invalid_options.append((\n                             option_name,\n                             \"maximum\",\n                             max_value,\n                             option_value\n                         ))\n \n         if invalid_options:\n             # raise exception with all arguments that contains invalid choices\n             raise exceptions.IRInvalidMinMaxRangeException(invalid_options)\n \n     def get_silent_args(self, args):\n         \"\"\"list of silenced argument\n \n         :param args: The received arguments.\n         :return: list, slienced argument names\n         \"\"\"\n         silent_args_names = []\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if arg_spec and 'silent' in arg_spec and \\\n                     self.spec_helper.get_option_state(\n                         parser_name,\n                         arg_name,\n                         args) == helper.OptionState['IS_SET']:\n                 silent_args_names.extend(arg_spec['silent'])\n \n         return list(set(silent_args_names))\n \n     def get_nested_custom_and_control_args(self, args):\n         \"\"\"Split input arguments to control nested and custom.\n \n         Controls arguments: control the IR behavior. These arguments\n             will not be put into the spec yml file\n         Nested arguments: are used by the Ansible playbooks and will be put\n             into the spec yml file.\n         Custom arguments: Custom ansible variables to be used instead of the\n             normal nested usage.\n \n         :param args: the collected list of args.\n         :return: (dict, dict): flat dicts (control_args, nested_args)\n         \"\"\"\n         # returns flat dicts\n         nested = {}\n         control_args = {}\n         custom_args = {}\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if all([arg_spec, arg_spec.get('type', None),\n                     arg_spec.get('type', None) in\n                     [ctype_name for ctype_name, klass in\n                      COMPLEX_TYPES.items() if klass.is_nested]\n                     ]) or ('is_shared_group_option' not in arg_spec):\n                 if arg_name in nested:\n                     LOG.warning(\n                         \"Duplicated nested argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, nested[arg_name]))\n                 elif arg_name in custom_args:\n                     LOG.warning(\n                         \"Duplicated custom argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, custom_args[arg_name]))\n                 else:\n                     if \"ansible_variable\" in arg_spec:\n                         custom_args[arg_spec[\"ansible_variable\"]] = arg_value\n                     else:\n                         nested[arg_name] = arg_value\n             else:\n                 if arg_name in control_args:\n                     LOG.warning(\n                         \"Duplicated control argument found: '{}'. Using \"\n                         \"old value: '{}'\".format(\n                             arg_name, control_args[arg_name]))\n                 else:\n                     control_args[arg_name] = arg_value\n \n         return nested, control_args, custom_args\n \n     def _iterate_received_arguments(self, args):\n         \"\"\"Iterator helper method over all the received arguments\n \n         :return: yields tuple:\n             (spec name, spec dict,\n              argument name, argument value, argument spec)\n         \"\"\"\n         for spec_parser in self.spec_helper.iterate_parsers():\n             if spec_parser['name'] in args:\n                 parser_dict = args[spec_parser['name']]\n                 for arg_name, arg_val in parser_dict.items():\n                     arg_spec = self.spec_helper.get_option_spec(\n                         spec_parser['name'], arg_name)\n                     yield (spec_parser['name'], parser_dict,\n                            arg_name, arg_val, arg_spec)\n \n     def _convert_non_cli_args(self, parser_name, values_dict):\n         \"\"\"Casts arguments to correct types by modifying values_dict param.\n \n         By default all the values are strings.\n \n         :param parser_name: The command name, e.g. main, virsh, ospd, etc\n         :param values_dict: The dict of with arguments\n        \"\"\"\n         for opt_name, opt_value in values_dict.items():\n             file_option_spec = self.spec_helper.get_option_spec(\n                 parser_name, opt_name)\n             if file_option_spec.get('type', None) in ['int', ] or \\\n                     file_option_spec.get('action', None) in ['count', ]:\n                 values_dict[opt_name] = int(opt_value)\n \n     def _merge_duplicated_cli_args(self, cli_args):\n         \"\"\"Merge duplicated arguments to all the parsers\n \n         This is need to handle control args, shared among several parsers.\n         for example, verbose, inventory\n         \"\"\"\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(cli_args):\n             for parser_name2, parser_dict2 in cli_args.items():\n                 if all([parser_name2, parser_name != parser_name2,\n                         arg_name not in parser_dict2]):\n                     if self.spec_helper.get_option_spec(parser_name2,\n                                                         arg_name):\n                         parser_dict2[arg_name] = arg_value\n ", "input_code": "def validate_choices_args(self, args):\n\"\"\"\nCheck if value of choice arguments is one of the available choices.\n\n:param args: The received arguments.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def validate_choices_args(self, args):\n        \"\"\"Check if value of choice arguments is one of the available choices.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if 'choices' not in spec_option:\n                    # skip options that does not contain choices\n                    continue\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # resolve choices\n                    choices = spec_option['choices']\n                    option_value = parser_dict[option_name]\n                    if option_value not in choices:\n                        # found invalid option, append to list of invalid opts\n                        invalid_options.append((\n                            option_name,\n                            option_value,\n                            choices\n                        ))\n        if invalid_options:\n            # raise exception with all arguments that contains invalid choices\n            raise exceptions.IRInvalidChoiceException(invalid_options)", "signature": "def validate_choices_args(self, args):", "completion_path": "infrared/core/inspector/inspector.py"}
{"ce_id": "6306092e73426c38ae68ad0b", "namespace": "6306092e73426c38ae68ad0b", "namespace_real": "infrared.core.inspector.inspector.validate_min_max_args", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "inspector", "function_name": "validate_min_max_args", "contexts_above": "import collections\nimport os\nfrom six.moves import configparser\nfrom string import Template\nimport yaml\n\nfrom infrared.core.cli.cli import CliParser\nfrom infrared.core.cli.cli import COMPLEX_TYPES\nfrom infrared.core.inspector import helper\nfrom infrared.core.utils import dict_utils\nfrom infrared.core.utils import exceptions\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n\nclass SpecParser(object):\n    \"\"\"Parses input arguments from different sources (cli, answers file). \"\"\"\n\n    @classmethod\n    def from_plugin(cls, subparser, plugin, base_groups):\n        \"\"\"Reads spec & vars from plugin and constructs the parser instance\n\n        :param subparser: argparse.subparser to extend\n        :param plugin: InfraredPlugin object\n        :param base_groups: dict, included groups\n        :return: SpecParser object based on given plugin spec & vars\n        \"\"\"\n\n        spec_dict = base_groups or {}\n        with open(plugin.spec) as stream:\n            spec = yaml.safe_load(stream) or {}\n            dict_utils.dict_merge(\n                base_groups,\n                spec,\n                dict_utils.ConflictResolver.unique_append_list_resolver)\n\n        # The \"try-excpet\" block here is for adding spec file path if it\n        # includes an unsupported option type\n        try:\n            return SpecParser(subparser, spec_dict, plugin.vars_dir,\n                              plugin.defaults_dir, plugin.path)\n        except exceptions.IRUnsupportedSpecOptionType as ex:\n            ex.message += ' in file: {}'.format(plugin.spec)\n            raise ex\n\n    def __init__(self, subparser, spec_dict, vars_dir, defaults_dir,\n                 plugin_path):\n        \"\"\"Constructor.\n\n        :param subparser: argparse.subparser to extend\n        :param spec_dict: dict with CLI description\n        :param vars_dir: Path to plugin's vars dir\n        :param defaults_dir: Path to plugin's defaults dir\n        \"\"\"\n        self.vars = vars_dir\n        self.defaults = defaults_dir\n        self.plugin_path = plugin_path\n        self.spec_helper = helper.SpecDictHelper(spec_dict)\n\n        # create parser\n        self.parser = CliParser.create_parser(self, subparser)\n\n    def add_shared_groups(self, list_of_groups):\n        \"\"\"Adds the user defined shared groups\n\n        :param list_of_groups: list, of group dicts\n        \"\"\"\n        shared_groups = self.spec_helper.spec_dict.get('shared_groups', [])\n        shared_groups.expand(list_of_groups)\n        self.spec_helper.spec_dict['shared_groups'] = shared_groups\n\n    def _get_defaults(self, default_getter_func):\n        \"\"\"Resolve arguments' values from cli or answers file.\n\n        :param default_getter_func: callable. will be called for all the\n            available options in spec file.\n        \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            default_value = default_getter_func(option)\n            if default_value is not None:\n                sub = parser['name']\n                result[sub][option['name']] = default_value\n\n        return result\n\n    def get_spec_defaults(self):\n        \"\"\"Resolve arguments' values from spec and other sources. \"\"\"\n\n        def spec_default_getter(option):\n            \"\"\"Getter function to retrieve the default value from spec.\n\n            :param option: argument name\n            \"\"\"\n\n            # first try to get environment variable with IR_ prefix\n            default_value = SpecParser.get_env_option(option['name'])\n            if default_value is not None:\n                LOG.info(\n                    \"[environ] Loading '{0}' default value\"\n                    \" '{1}' from the environment variable\".format(\n                        option['name'], default_value))\n            elif option.get('default', None) is not None:\n                default_value = option['default']\n            elif option.get('action', None) in ['store_true']:\n                default_value = False\n            return default_value\n\n        return self._get_defaults(spec_default_getter)\n\n    @staticmethod\n    def get_env_option(name):\n        \"\"\"Try get \"\"\"\n        return os.environ.get('IR_' + name.upper().replace('-', '_'))\n\n    def get_deprecated_args(self):\n        \"\"\"Returning dict with options which deprecate others. \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            if option.get('deprecates') is not None:\n                result[option.get('deprecates')] = option.get('name')\n\n        return result\n\n    @staticmethod\n    def parse_env_variable_from_file(value):\n        if isinstance(value, str):\n            t = Template(value)\n            try:\n                value = t.substitute(os.environ)\n            except KeyError as undefined_var:\n                raise exceptions.IRAnswersFileEnvVarNotDefined(undefined_var)\n        return value\n\n    def get_answers_file_args(self, cli_args):\n        \"\"\"Resolve arguments' values from answers INI file. \"\"\"\n\n        file_result = {}\n        args_to_remove = []\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            file_result[parser_name] = file_result.get(parser_name, {})\n            if option_spec and option_spec.get(\n                    'action', '') == 'read-answers':\n                # Iterate over arguments supplied by file\n                for parsed_arg in parser_dict[arg_name]:\n                    # Supplied arguments' value can be a list\n                    if isinstance(parser_dict[arg_name][parsed_arg], list):\n                        i = 0\n                        # Iterrate over argument values list\n                        for parsed_value in parser_dict[arg_name][parsed_arg]:\n                            parser_dict[arg_name][parsed_arg][i] = \\\n                                SpecParser.parse_env_variable_from_file(parsed_value)\n                            i += 1\n                    else:\n                        parser_dict[arg_name][parsed_arg] = \\\n                            SpecParser.parse_env_variable_from_file(parser_dict[arg_name][parsed_arg])\n                # we have config option. saving it.\n                self._convert_non_cli_args(\n                    parser_name, parser_dict[arg_name])\n                dict_utils.dict_merge(\n                    file_result[parser_name],\n                    parser_dict[arg_name])\n                # remove from cli args\n                args_to_remove.append((parser_name, arg_name))\n\n        # remove parser dict outside loop to avoid iteration dict modification\n        for parser_name, arg_name in args_to_remove:\n            for spec_parser in self.spec_helper.iterate_parsers():\n                if spec_parser['name'] in cli_args and spec_parser['name'] == parser_name:\n                    parser_dict = cli_args[spec_parser['name']]\n                    parser_dict.pop(arg_name)\n                    break\n\n        return file_result\n\n    def generate_answers_file(self, cli_args, spec_defaults):\n        \"\"\"Generates answers INI file\n\n        :param cli_args: list, cli arguments.\n        :param spec_defaults: the default values.\n        \"\"\"\n\n        def put_option(config, parser_name, option_name, value):\n            for opt_help in option.get('help', '').split('\\n'):\n                help_opt = '# ' + opt_help\n\n                # add help comment\n                if config.has_option(parser_name, help_opt):\n                    config.remove_option(parser_name, help_opt)\n                config.set(\n                    parser_name, help_opt)\n\n            if config.has_option(parser_name, option_name):\n                value = config.get(parser_name, option_name)\n                config.remove_option(parser_name, option_name)\n\n            config.set(\n                parser_name,\n                option_name,\n                str(value))\n\n        file_generated = False\n\n        # load generate answers file for all the parsers\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            if option_spec and option_spec.get(\n                    'action', '') == 'generate-answers':\n                options_to_save = \\\n                    self.spec_helper.get_parser_option_specs(parser_name)\n                out_answers = configparser.ConfigParser(allow_no_value=True)\n\n                if not out_answers.has_section(parser_name):\n                    out_answers.add_section(parser_name)\n\n                for option in options_to_save:\n                    opt_name = option['name']\n                    if opt_name in parser_dict:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            parser_dict[opt_name])\n                    elif opt_name in spec_defaults[parser_name]:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            spec_defaults[parser_name][opt_name])\n                    elif option.get('required', False):\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            '# ' + opt_name,\n                            \"Required argument. \"\n                            \"Edit with one of the allowed values OR \"\n                            \"override with \"\n                            \"CLI: --{}=<option>\".format(opt_name))\n\n                # write to file\n                with open(arg_value, 'w') as answers_file:\n                    out_answers.write(answers_file)\n                file_generated = True\n\n        return file_generated\n\n    def resolve_custom_types(self, args):\n        \"\"\"Transforms the arguments with custom types\n\n        :param args: the list of received arguments.\n        \"\"\"\n        for parser_name, parser_dict in args.items():\n            spec_complex_options = [opt for opt in\n                                    self.spec_helper.get_parser_option_specs(\n                                        parser_name) if\n                                    opt.get('type', None) in COMPLEX_TYPES]\n            for spec_option in spec_complex_options:\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # we have custom type to resolve\n                    type_name = spec_option['type']\n                    option_value = parser_dict[option_name]\n                    action = self.create_complex_argumet_type(\n                        parser_name,\n                        type_name,\n                        option_name,\n                        spec_option)\n\n                    # resolving value\n                    parser_dict[option_name] = action.resolve(option_value)\n\n    def create_complex_argumet_type(self, subcommand, type_name, option_name,\n                                    spec_option):\n        \"\"\"Build the complex argument type\n\n        :param subcommand: the command name\n        :param type_name: the complex type name\n        :param option_name: the option name\n        :param spec_option: option's specifications\n        :return: the complex type instance\n        \"\"\"\n        complex_action = COMPLEX_TYPES.get(\n            type_name, None)\n        if complex_action is None:\n            raise exceptions.SpecParserException(\n                \"Unknown complex type: {}\".format(type_name))\n        return complex_action(\n            option_name,\n            (self.vars, self.defaults, self.plugin_path),\n            subcommand,\n            spec_option)\n\n    def parse_args(self, arg_parser, args=None):\n        \"\"\"Parses all the arguments (cli, answers file)\n\n        :return: None, if ``--generate-answers-file`` in arg_arg_parser\n        :return: (dict, dict):\n            * command arguments dict (arguments to control the IR logic)\n            * nested arguments dict (arguments to pass to the playbooks)\n        \"\"\"\n\n        spec_defaults = self.get_spec_defaults()\n        cli_args = CliParser.parse_cli_input(arg_parser, args)\n\n        file_args = self.get_answers_file_args(cli_args)\n\n        # generate answers file and exit\n        if self.generate_answers_file(cli_args, spec_defaults):\n            LOG.warning(\"Answers file generated. Exiting.\")\n\n        # print warnings when something was overridden from non-cli source.\n        self.validate_arg_sources(cli_args, file_args,\n                                  spec_defaults)\n\n        # print warnings for deprecated\n        self.validate_arg_deprecation(cli_args, file_args)\n\n        # now filter defaults to have only parser defined in cli\n        defaults = dict((key, spec_defaults[key])\n                        for key in cli_args.keys() if\n                        key in spec_defaults)\n\n        # copy cli args with the same name to all parser groups\n        self._merge_duplicated_cli_args(cli_args)\n        self._merge_duplicated_cli_args(file_args)\n\n        dict_utils.dict_merge(defaults, file_args)\n        dict_utils.dict_merge(defaults, cli_args)\n        self.validate_requires_args(defaults)\n        self.validate_length_args(defaults)\n        self.validate_choices_args(defaults)\n        self.validate_min_max_args(defaults)\n\n        # now resolve complex types.\n        self.resolve_custom_types(defaults)\n        nested, control, custom = \\\n            self.get_nested_custom_and_control_args(defaults)\n        return nested, control, custom\n\n    def validate_arg_deprecation(self, cli_args, answer_file_args):\n        \"\"\"Validates and prints the deprecated arguments.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        \"\"\"\n\n        for deprecated, deprecates in self.get_deprecated_args().items():\n            for input_args in (answer_file_args.items(), cli_args.items()):\n                for command, command_dict in input_args:\n                    if deprecated in command_dict:\n                        if deprecates in command_dict:\n                            raise exceptions.IRDeprecationException(\n                                \"[{}] Argument '{}' deprecates '{}',\"\n                                \" please use only the new one.\".format(\n                                    command, deprecated, deprecates))\n\n                        if deprecated in answer_file_args[command]:\n                            answer_file_args[command][deprecates] = \\\n                                answer_file_args[command][deprecated]\n\n                        if deprecated in cli_args[command]:\n                            cli_args[command][deprecates] = \\\n                                cli_args[command][deprecated]\n\n                        LOG.warning(\n                            \"[{}] Argument '{}' was deprecated,\"\n                            \" please use '{}'.\".format(\n                                command, deprecated, deprecates))\n\n    @staticmethod\n    def validate_arg_sources(cli_args, answer_file_args, spec_defaults):\n        \"\"\"Validates and prints the arguments' source.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        :param spec_defaults:  the default values from spec files\n        \"\"\"\n\n        def show_diff(diff, command_name, cmd_dict, source_name):\n            if diff:\n                for arg_name in diff:\n                    value = cmd_dict[arg_name]\n                    LOG.info(\n                        \"[{}] Argument '{}' was set to\"\n                        \" '{}' from the {} source.\".format(\n                            command_name, arg_name, value, source_name))\n\n        for command, command_dict in cli_args.items():\n            file_dict = answer_file_args.get(command, {})\n            file_diff = set(file_dict.keys()) - set(command_dict.keys())\n            show_diff(file_diff, command, file_dict, 'answers file')\n\n            def_dict = spec_defaults.get(command, {})\n            default_diff = set(def_dict.keys()) - set(\n                command_dict.keys()) - file_diff\n            show_diff(default_diff, command, def_dict, 'spec defaults')\n\n    def _get_conditionally_required_args(self, command_name, options_spec,\n                                         args):\n        \"\"\"List arguments with ``required_when`` condition matched.\n\n        :param command_name: the command name.\n        :param options_spec:  the list of command spec options.\n        :param args: the received input arguments\n        :return: list, list of argument names with matched ``required_when``\n            condition\n        \"\"\"\n        opts_names = [option_spec['name'] for option_spec in options_spec]\n        missing_args = []\n        for option_spec in options_spec:\n            option_results = []\n            if option_spec and 'required_when' in option_spec:\n                req_when_args = [option_spec['required_when']] \\\n                    if not type(option_spec['required_when']) is list \\\n                    else option_spec['required_when']\n\n                # validate conditions\n                for req_when_arg in req_when_args:\n                    splited_args_list = req_when_arg.split()\n                    for idx, req_arg in enumerate(splited_args_list):\n                        if req_arg in opts_names:\n                            splited_args_list[idx] = \\\n                                args.get(command_name, {}).get(req_arg.strip())\n                        if splited_args_list[idx] is None:\n                            option_results.append(False)\n                            break\n                        splited_args_list[idx] = str(splited_args_list[idx])\n                        if (splited_args_list[idx] not in ['and', 'or'] and\n                            not any(\n                                (c in '<>=') for c in splited_args_list[idx])):\n                            splited_args_list[idx] = \"'{0}'\".format(\n                                yaml.safe_load(splited_args_list[idx]))\n                    else:\n                        option_results.append(\n                            eval(' '.join(splited_args_list)))\n                if all(option_results) and \\\n                        self.spec_helper.get_option_state(\n                            command_name,\n                            option_spec['name'],\n                            args) == helper.OptionState['NOT_SET']:\n                    missing_args.append(option_spec['name'])\n        return missing_args\n\n    def validate_requires_args(self, args):\n        \"\"\"Check if all the required arguments have been provided. \"\"\"\n\n        silent_args = self.get_silent_args(args)\n\n        def validate_parser(parser_name, expected_options, parser_args):\n            \"\"\"Helper method to resolve dict_merge. \"\"\"\n\n            result = collections.defaultdict(list)\n            condition_req_args = self._get_conditionally_required_args(\n                parser_name, expected_options, args)\n\n            for option in expected_options:\n                name = option['name']\n\n                # check required options.\n                if (option.get('required', False) and\n                    name not in parser_args or\n                    option['name'] in condition_req_args) and \\\n                        name not in silent_args:\n                    result[parser_name].append(name)\n\n            return result\n\n        res = {}\n        for command_data in self.spec_helper.iterate_parsers():\n            cmd_name = command_data['name']\n            if cmd_name in args:\n                dict_utils.dict_merge(\n                    res,\n                    validate_parser(\n                        cmd_name,\n                        self.spec_helper.get_parser_option_specs(cmd_name),\n                        args[cmd_name]))\n\n        missing_args = dict((cmd_name, args)\n                            for cmd_name, args in res.items() if len(args) > 0)\n        if missing_args:\n            raise exceptions.IRRequiredArgsMissingException(missing_args)\n\n    def validate_length_args(self, args):\n        \"\"\"Check if value of arguments is not longer than length specified.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if 'length' not in spec_option:\n                    # skip options that does not contain length\n                    continue\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # resolve length\n                    length = spec_option['length']\n                    option_value = parser_dict[option_name]\n                    if len(option_value) > int(length):\n                        # found invalid option, append to list of invalid opts\n                        invalid_options.append((\n                            option_name,\n                            option_value,\n                            length\n                        ))\n        if invalid_options:\n            # raise exception with all arguments that exceed length\n            raise exceptions.IRInvalidLengthException(invalid_options)\n\n    def validate_choices_args(self, args):\n        \"\"\"Check if value of choice arguments is one of the available choices.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if 'choices' not in spec_option:\n                    # skip options that does not contain choices\n                    continue\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # resolve choices\n                    choices = spec_option['choices']\n                    option_value = parser_dict[option_name]\n                    if option_value not in choices:\n                        # found invalid option, append to list of invalid opts\n                        invalid_options.append((\n                            option_name,\n                            option_value,\n                            choices\n                        ))\n        if invalid_options:\n            # raise exception with all arguments that contains invalid choices\n            raise exceptions.IRInvalidChoiceException(invalid_options)\n", "contexts_below": "    def get_silent_args(self, args):\n         \"\"\"list of silenced argument\n \n         :param args: The received arguments.\n         :return: list, slienced argument names\n         \"\"\"\n         silent_args_names = []\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if arg_spec and 'silent' in arg_spec and \\\n                     self.spec_helper.get_option_state(\n                         parser_name,\n                         arg_name,\n                         args) == helper.OptionState['IS_SET']:\n                 silent_args_names.extend(arg_spec['silent'])\n \n         return list(set(silent_args_names))\n \n     def get_nested_custom_and_control_args(self, args):\n         \"\"\"Split input arguments to control nested and custom.\n \n         Controls arguments: control the IR behavior. These arguments\n             will not be put into the spec yml file\n         Nested arguments: are used by the Ansible playbooks and will be put\n             into the spec yml file.\n         Custom arguments: Custom ansible variables to be used instead of the\n             normal nested usage.\n \n         :param args: the collected list of args.\n         :return: (dict, dict): flat dicts (control_args, nested_args)\n         \"\"\"\n         # returns flat dicts\n         nested = {}\n         control_args = {}\n         custom_args = {}\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if all([arg_spec, arg_spec.get('type', None),\n                     arg_spec.get('type', None) in\n                     [ctype_name for ctype_name, klass in\n                      COMPLEX_TYPES.items() if klass.is_nested]\n                     ]) or ('is_shared_group_option' not in arg_spec):\n                 if arg_name in nested:\n                     LOG.warning(\n                         \"Duplicated nested argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, nested[arg_name]))\n                 elif arg_name in custom_args:\n                     LOG.warning(\n                         \"Duplicated custom argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, custom_args[arg_name]))\n                 else:\n                     if \"ansible_variable\" in arg_spec:\n                         custom_args[arg_spec[\"ansible_variable\"]] = arg_value\n                     else:\n                         nested[arg_name] = arg_value\n             else:\n                 if arg_name in control_args:\n                     LOG.warning(\n                         \"Duplicated control argument found: '{}'. Using \"\n                         \"old value: '{}'\".format(\n                             arg_name, control_args[arg_name]))\n                 else:\n                     control_args[arg_name] = arg_value\n \n         return nested, control_args, custom_args\n \n     def _iterate_received_arguments(self, args):\n         \"\"\"Iterator helper method over all the received arguments\n \n         :return: yields tuple:\n             (spec name, spec dict,\n              argument name, argument value, argument spec)\n         \"\"\"\n         for spec_parser in self.spec_helper.iterate_parsers():\n             if spec_parser['name'] in args:\n                 parser_dict = args[spec_parser['name']]\n                 for arg_name, arg_val in parser_dict.items():\n                     arg_spec = self.spec_helper.get_option_spec(\n                         spec_parser['name'], arg_name)\n                     yield (spec_parser['name'], parser_dict,\n                            arg_name, arg_val, arg_spec)\n \n     def _convert_non_cli_args(self, parser_name, values_dict):\n         \"\"\"Casts arguments to correct types by modifying values_dict param.\n \n         By default all the values are strings.\n \n         :param parser_name: The command name, e.g. main, virsh, ospd, etc\n         :param values_dict: The dict of with arguments\n        \"\"\"\n         for opt_name, opt_value in values_dict.items():\n             file_option_spec = self.spec_helper.get_option_spec(\n                 parser_name, opt_name)\n             if file_option_spec.get('type', None) in ['int', ] or \\\n                     file_option_spec.get('action', None) in ['count', ]:\n                 values_dict[opt_name] = int(opt_value)\n \n     def _merge_duplicated_cli_args(self, cli_args):\n         \"\"\"Merge duplicated arguments to all the parsers\n \n         This is need to handle control args, shared among several parsers.\n         for example, verbose, inventory\n         \"\"\"\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(cli_args):\n             for parser_name2, parser_dict2 in cli_args.items():\n                 if all([parser_name2, parser_name != parser_name2,\n                         arg_name not in parser_dict2]):\n                     if self.spec_helper.get_option_spec(parser_name2,\n                                                         arg_name):\n                         parser_dict2[arg_name] = arg_value\n ", "input_code": "def validate_min_max_args(self, args):\n\"\"\"\nCheck if value of arguments is between minimum and maximum values.\n\n:param args: The received arguments.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def validate_min_max_args(self, args):\n        \"\"\"Check if value of arguments is between minimum and maximum values.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if all([key not in spec_option\n                        for key in ('maximum', 'minimum')]):\n                    # skip options that does not contain minimum or maximum\n                    continue\n                option_name = spec_option['name']\n\n                if option_name in parser_dict:\n                    option_value = parser_dict[option_name]\n                    min_value = spec_option.get('minimum')\n                    max_value = spec_option.get('maximum')\n                    # handle empty values in spec files which load as None\n                    min_value = '' if 'minimum' in spec_option \\\n                                      and min_value is None else min_value\n                    max_value = '' if 'maximum' in spec_option \\\n                                      and max_value is None else max_value\n\n                    values = {\n                        \"value\": option_value,\n                        \"maximum\": max_value,\n                        \"minimum\": min_value\n                    }\n\n                    # make sure that values are numbers\n                    is_all_values_numbers = True\n                    for name, num in values.items():\n                        if num is not None \\\n                                and (isinstance(num, bool) or\n                                     not isinstance(num, (int, float))):\n                            invalid_options.append((\n                                option_name,\n                                name,\n                                \"number\",\n                                type(num).__name__\n                            ))\n                            is_all_values_numbers = False\n\n                    if not is_all_values_numbers:\n                        # don't continue to min max checks since some of the\n                        # values are not numbers\n                        continue\n\n                    # check bigger than minimum\n                    if min_value is not None and option_value < min_value:\n                        invalid_options.append((\n                            option_name,\n                            \"minimum\",\n                            min_value,\n                            option_value\n                        ))\n                    # check smaller than maximum\n                    if max_value is not None and option_value > max_value:\n                        invalid_options.append((\n                            option_name,\n                            \"maximum\",\n                            max_value,\n                            option_value\n                        ))\n\n        if invalid_options:\n            # raise exception with all arguments that contains invalid choices\n            raise exceptions.IRInvalidMinMaxRangeException(invalid_options)", "signature": "def validate_min_max_args(self, args):", "completion_path": "infrared/core/inspector/inspector.py"}
{"ce_id": "6306092e73426c38ae68ad0d", "namespace": "6306092e73426c38ae68ad0d", "namespace_real": "infrared.core.inspector.inspector.create_complex_argumet_type", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "inspector", "function_name": "create_complex_argumet_type", "contexts_above": "import collections\nimport os\nfrom six.moves import configparser\nfrom string import Template\nimport yaml\n\nfrom infrared.core.cli.cli import CliParser\nfrom infrared.core.cli.cli import COMPLEX_TYPES\nfrom infrared.core.inspector import helper\nfrom infrared.core.utils import dict_utils\nfrom infrared.core.utils import exceptions\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n\nclass SpecParser(object):\n    \"\"\"Parses input arguments from different sources (cli, answers file). \"\"\"\n\n    @classmethod\n    def from_plugin(cls, subparser, plugin, base_groups):\n        \"\"\"Reads spec & vars from plugin and constructs the parser instance\n\n        :param subparser: argparse.subparser to extend\n        :param plugin: InfraredPlugin object\n        :param base_groups: dict, included groups\n        :return: SpecParser object based on given plugin spec & vars\n        \"\"\"\n\n        spec_dict = base_groups or {}\n        with open(plugin.spec) as stream:\n            spec = yaml.safe_load(stream) or {}\n            dict_utils.dict_merge(\n                base_groups,\n                spec,\n                dict_utils.ConflictResolver.unique_append_list_resolver)\n\n        # The \"try-excpet\" block here is for adding spec file path if it\n        # includes an unsupported option type\n        try:\n            return SpecParser(subparser, spec_dict, plugin.vars_dir,\n                              plugin.defaults_dir, plugin.path)\n        except exceptions.IRUnsupportedSpecOptionType as ex:\n            ex.message += ' in file: {}'.format(plugin.spec)\n            raise ex\n\n    def __init__(self, subparser, spec_dict, vars_dir, defaults_dir,\n                 plugin_path):\n        \"\"\"Constructor.\n\n        :param subparser: argparse.subparser to extend\n        :param spec_dict: dict with CLI description\n        :param vars_dir: Path to plugin's vars dir\n        :param defaults_dir: Path to plugin's defaults dir\n        \"\"\"\n        self.vars = vars_dir\n        self.defaults = defaults_dir\n        self.plugin_path = plugin_path\n        self.spec_helper = helper.SpecDictHelper(spec_dict)\n\n        # create parser\n        self.parser = CliParser.create_parser(self, subparser)\n\n    def add_shared_groups(self, list_of_groups):\n        \"\"\"Adds the user defined shared groups\n\n        :param list_of_groups: list, of group dicts\n        \"\"\"\n        shared_groups = self.spec_helper.spec_dict.get('shared_groups', [])\n        shared_groups.expand(list_of_groups)\n        self.spec_helper.spec_dict['shared_groups'] = shared_groups\n\n    def _get_defaults(self, default_getter_func):\n        \"\"\"Resolve arguments' values from cli or answers file.\n\n        :param default_getter_func: callable. will be called for all the\n            available options in spec file.\n        \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            default_value = default_getter_func(option)\n            if default_value is not None:\n                sub = parser['name']\n                result[sub][option['name']] = default_value\n\n        return result\n\n    def get_spec_defaults(self):\n        \"\"\"Resolve arguments' values from spec and other sources. \"\"\"\n\n        def spec_default_getter(option):\n            \"\"\"Getter function to retrieve the default value from spec.\n\n            :param option: argument name\n            \"\"\"\n\n            # first try to get environment variable with IR_ prefix\n            default_value = SpecParser.get_env_option(option['name'])\n            if default_value is not None:\n                LOG.info(\n                    \"[environ] Loading '{0}' default value\"\n                    \" '{1}' from the environment variable\".format(\n                        option['name'], default_value))\n            elif option.get('default', None) is not None:\n                default_value = option['default']\n            elif option.get('action', None) in ['store_true']:\n                default_value = False\n            return default_value\n\n        return self._get_defaults(spec_default_getter)\n\n    @staticmethod\n    def get_env_option(name):\n        \"\"\"Try get \"\"\"\n        return os.environ.get('IR_' + name.upper().replace('-', '_'))\n\n    def get_deprecated_args(self):\n        \"\"\"Returning dict with options which deprecate others. \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            if option.get('deprecates') is not None:\n                result[option.get('deprecates')] = option.get('name')\n\n        return result\n\n    @staticmethod\n    def parse_env_variable_from_file(value):\n        if isinstance(value, str):\n            t = Template(value)\n            try:\n                value = t.substitute(os.environ)\n            except KeyError as undefined_var:\n                raise exceptions.IRAnswersFileEnvVarNotDefined(undefined_var)\n        return value\n\n    def get_answers_file_args(self, cli_args):\n        \"\"\"Resolve arguments' values from answers INI file. \"\"\"\n\n        file_result = {}\n        args_to_remove = []\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            file_result[parser_name] = file_result.get(parser_name, {})\n            if option_spec and option_spec.get(\n                    'action', '') == 'read-answers':\n                # Iterate over arguments supplied by file\n                for parsed_arg in parser_dict[arg_name]:\n                    # Supplied arguments' value can be a list\n                    if isinstance(parser_dict[arg_name][parsed_arg], list):\n                        i = 0\n                        # Iterrate over argument values list\n                        for parsed_value in parser_dict[arg_name][parsed_arg]:\n                            parser_dict[arg_name][parsed_arg][i] = \\\n                                SpecParser.parse_env_variable_from_file(parsed_value)\n                            i += 1\n                    else:\n                        parser_dict[arg_name][parsed_arg] = \\\n                            SpecParser.parse_env_variable_from_file(parser_dict[arg_name][parsed_arg])\n                # we have config option. saving it.\n                self._convert_non_cli_args(\n                    parser_name, parser_dict[arg_name])\n                dict_utils.dict_merge(\n                    file_result[parser_name],\n                    parser_dict[arg_name])\n                # remove from cli args\n                args_to_remove.append((parser_name, arg_name))\n\n        # remove parser dict outside loop to avoid iteration dict modification\n        for parser_name, arg_name in args_to_remove:\n            for spec_parser in self.spec_helper.iterate_parsers():\n                if spec_parser['name'] in cli_args and spec_parser['name'] == parser_name:\n                    parser_dict = cli_args[spec_parser['name']]\n                    parser_dict.pop(arg_name)\n                    break\n\n        return file_result\n\n    def generate_answers_file(self, cli_args, spec_defaults):\n        \"\"\"Generates answers INI file\n\n        :param cli_args: list, cli arguments.\n        :param spec_defaults: the default values.\n        \"\"\"\n\n        def put_option(config, parser_name, option_name, value):\n            for opt_help in option.get('help', '').split('\\n'):\n                help_opt = '# ' + opt_help\n\n                # add help comment\n                if config.has_option(parser_name, help_opt):\n                    config.remove_option(parser_name, help_opt)\n                config.set(\n                    parser_name, help_opt)\n\n            if config.has_option(parser_name, option_name):\n                value = config.get(parser_name, option_name)\n                config.remove_option(parser_name, option_name)\n\n            config.set(\n                parser_name,\n                option_name,\n                str(value))\n\n        file_generated = False\n\n        # load generate answers file for all the parsers\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            if option_spec and option_spec.get(\n                    'action', '') == 'generate-answers':\n                options_to_save = \\\n                    self.spec_helper.get_parser_option_specs(parser_name)\n                out_answers = configparser.ConfigParser(allow_no_value=True)\n\n                if not out_answers.has_section(parser_name):\n                    out_answers.add_section(parser_name)\n\n                for option in options_to_save:\n                    opt_name = option['name']\n                    if opt_name in parser_dict:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            parser_dict[opt_name])\n                    elif opt_name in spec_defaults[parser_name]:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            spec_defaults[parser_name][opt_name])\n                    elif option.get('required', False):\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            '# ' + opt_name,\n                            \"Required argument. \"\n                            \"Edit with one of the allowed values OR \"\n                            \"override with \"\n                            \"CLI: --{}=<option>\".format(opt_name))\n\n                # write to file\n                with open(arg_value, 'w') as answers_file:\n                    out_answers.write(answers_file)\n                file_generated = True\n\n        return file_generated\n\n    def resolve_custom_types(self, args):\n        \"\"\"Transforms the arguments with custom types\n\n        :param args: the list of received arguments.\n        \"\"\"\n        for parser_name, parser_dict in args.items():\n            spec_complex_options = [opt for opt in\n                                    self.spec_helper.get_parser_option_specs(\n                                        parser_name) if\n                                    opt.get('type', None) in COMPLEX_TYPES]\n            for spec_option in spec_complex_options:\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # we have custom type to resolve\n                    type_name = spec_option['type']\n                    option_value = parser_dict[option_name]\n                    action = self.create_complex_argumet_type(\n                        parser_name,\n                        type_name,\n                        option_name,\n                        spec_option)\n\n                    # resolving value\n                    parser_dict[option_name] = action.resolve(option_value)\n", "contexts_below": "    def parse_args(self, arg_parser, args=None):\n         \"\"\"Parses all the arguments (cli, answers file)\n \n         :return: None, if ``--generate-answers-file`` in arg_arg_parser\n         :return: (dict, dict):\n             * command arguments dict (arguments to control the IR logic)\n             * nested arguments dict (arguments to pass to the playbooks)\n         \"\"\"\n \n         spec_defaults = self.get_spec_defaults()\n         cli_args = CliParser.parse_cli_input(arg_parser, args)\n \n         file_args = self.get_answers_file_args(cli_args)\n \n         # generate answers file and exit\n         if self.generate_answers_file(cli_args, spec_defaults):\n             LOG.warning(\"Answers file generated. Exiting.\")\n \n         # print warnings when something was overridden from non-cli source.\n         self.validate_arg_sources(cli_args, file_args,\n                                   spec_defaults)\n \n         # print warnings for deprecated\n         self.validate_arg_deprecation(cli_args, file_args)\n \n         # now filter defaults to have only parser defined in cli\n         defaults = dict((key, spec_defaults[key])\n                         for key in cli_args.keys() if\n                         key in spec_defaults)\n \n         # copy cli args with the same name to all parser groups\n         self._merge_duplicated_cli_args(cli_args)\n         self._merge_duplicated_cli_args(file_args)\n \n         dict_utils.dict_merge(defaults, file_args)\n         dict_utils.dict_merge(defaults, cli_args)\n         self.validate_requires_args(defaults)\n         self.validate_length_args(defaults)\n         self.validate_choices_args(defaults)\n         self.validate_min_max_args(defaults)\n \n         # now resolve complex types.\n         self.resolve_custom_types(defaults)\n         nested, control, custom = \\\n             self.get_nested_custom_and_control_args(defaults)\n         return nested, control, custom\n \n     def validate_arg_deprecation(self, cli_args, answer_file_args):\n         \"\"\"Validates and prints the deprecated arguments.\n \n         :param cli_args: the dict of arguments from cli\n         :param answer_file_args:  the dict of arguments from files\n         \"\"\"\n \n         for deprecated, deprecates in self.get_deprecated_args().items():\n             for input_args in (answer_file_args.items(), cli_args.items()):\n                 for command, command_dict in input_args:\n                     if deprecated in command_dict:\n                         if deprecates in command_dict:\n                             raise exceptions.IRDeprecationException(\n                                 \"[{}] Argument '{}' deprecates '{}',\"\n                                 \" please use only the new one.\".format(\n                                     command, deprecated, deprecates))\n \n                         if deprecated in answer_file_args[command]:\n                             answer_file_args[command][deprecates] = \\\n                                 answer_file_args[command][deprecated]\n \n                         if deprecated in cli_args[command]:\n                             cli_args[command][deprecates] = \\\n                                 cli_args[command][deprecated]\n \n                         LOG.warning(\n                             \"[{}] Argument '{}' was deprecated,\"\n                             \" please use '{}'.\".format(\n                                 command, deprecated, deprecates))\n \n     @staticmethod\n     def validate_arg_sources(cli_args, answer_file_args, spec_defaults):\n         \"\"\"Validates and prints the arguments' source.\n \n         :param cli_args: the dict of arguments from cli\n         :param answer_file_args:  the dict of arguments from files\n         :param spec_defaults:  the default values from spec files\n         \"\"\"\n \n         def show_diff(diff, command_name, cmd_dict, source_name):\n             if diff:\n                 for arg_name in diff:\n                     value = cmd_dict[arg_name]\n                     LOG.info(\n                         \"[{}] Argument '{}' was set to\"\n                         \" '{}' from the {} source.\".format(\n                             command_name, arg_name, value, source_name))\n \n         for command, command_dict in cli_args.items():\n             file_dict = answer_file_args.get(command, {})\n             file_diff = set(file_dict.keys()) - set(command_dict.keys())\n             show_diff(file_diff, command, file_dict, 'answers file')\n \n             def_dict = spec_defaults.get(command, {})\n             default_diff = set(def_dict.keys()) - set(\n                 command_dict.keys()) - file_diff\n             show_diff(default_diff, command, def_dict, 'spec defaults')\n \n     def _get_conditionally_required_args(self, command_name, options_spec,\n                                          args):\n         \"\"\"List arguments with ``required_when`` condition matched.\n \n         :param command_name: the command name.\n         :param options_spec:  the list of command spec options.\n         :param args: the received input arguments\n         :return: list, list of argument names with matched ``required_when``\n             condition\n         \"\"\"\n         opts_names = [option_spec['name'] for option_spec in options_spec]\n         missing_args = []\n         for option_spec in options_spec:\n             option_results = []\n             if option_spec and 'required_when' in option_spec:\n                 req_when_args = [option_spec['required_when']] \\\n                     if not type(option_spec['required_when']) is list \\\n                     else option_spec['required_when']\n \n                 # validate conditions\n                 for req_when_arg in req_when_args:\n                     splited_args_list = req_when_arg.split()\n                     for idx, req_arg in enumerate(splited_args_list):\n                         if req_arg in opts_names:\n                             splited_args_list[idx] = \\\n                                 args.get(command_name, {}).get(req_arg.strip())\n                         if splited_args_list[idx] is None:\n                             option_results.append(False)\n                             break\n                         splited_args_list[idx] = str(splited_args_list[idx])\n                         if (splited_args_list[idx] not in ['and', 'or'] and\n                             not any(\n                                 (c in '<>=') for c in splited_args_list[idx])):\n                             splited_args_list[idx] = \"'{0}'\".format(\n                                 yaml.safe_load(splited_args_list[idx]))\n                     else:\n                         option_results.append(\n                             eval(' '.join(splited_args_list)))\n                 if all(option_results) and \\\n                         self.spec_helper.get_option_state(\n                             command_name,\n                             option_spec['name'],\n                             args) == helper.OptionState['NOT_SET']:\n                     missing_args.append(option_spec['name'])\n         return missing_args\n \n     def validate_requires_args(self, args):\n         \"\"\"Check if all the required arguments have been provided. \"\"\"\n \n         silent_args = self.get_silent_args(args)\n \n         def validate_parser(parser_name, expected_options, parser_args):\n             \"\"\"Helper method to resolve dict_merge. \"\"\"\n \n             result = collections.defaultdict(list)\n             condition_req_args = self._get_conditionally_required_args(\n                 parser_name, expected_options, args)\n \n             for option in expected_options:\n                 name = option['name']\n \n                 # check required options.\n                 if (option.get('required', False) and\n                     name not in parser_args or\n                     option['name'] in condition_req_args) and \\\n                         name not in silent_args:\n                     result[parser_name].append(name)\n \n             return result\n \n         res = {}\n         for command_data in self.spec_helper.iterate_parsers():\n             cmd_name = command_data['name']\n             if cmd_name in args:\n                 dict_utils.dict_merge(\n                     res,\n                     validate_parser(\n                         cmd_name,\n                         self.spec_helper.get_parser_option_specs(cmd_name),\n                         args[cmd_name]))\n \n         missing_args = dict((cmd_name, args)\n                             for cmd_name, args in res.items() if len(args) > 0)\n         if missing_args:\n             raise exceptions.IRRequiredArgsMissingException(missing_args)\n \n     def validate_length_args(self, args):\n         \"\"\"Check if value of arguments is not longer than length specified.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if 'length' not in spec_option:\n                     # skip options that does not contain length\n                     continue\n                 option_name = spec_option['name']\n                 if option_name in parser_dict:\n                     # resolve length\n                     length = spec_option['length']\n                     option_value = parser_dict[option_name]\n                     if len(option_value) > int(length):\n                         # found invalid option, append to list of invalid opts\n                         invalid_options.append((\n                             option_name,\n                             option_value,\n                             length\n                         ))\n         if invalid_options:\n             # raise exception with all arguments that exceed length\n             raise exceptions.IRInvalidLengthException(invalid_options)\n \n     def validate_choices_args(self, args):\n         \"\"\"Check if value of choice arguments is one of the available choices.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if 'choices' not in spec_option:\n                     # skip options that does not contain choices\n                     continue\n                 option_name = spec_option['name']\n                 if option_name in parser_dict:\n                     # resolve choices\n                     choices = spec_option['choices']\n                     option_value = parser_dict[option_name]\n                     if option_value not in choices:\n                         # found invalid option, append to list of invalid opts\n                         invalid_options.append((\n                             option_name,\n                             option_value,\n                             choices\n                         ))\n         if invalid_options:\n             # raise exception with all arguments that contains invalid choices\n             raise exceptions.IRInvalidChoiceException(invalid_options)\n \n     def validate_min_max_args(self, args):\n         \"\"\"Check if value of arguments is between minimum and maximum values.\n \n         :param args: The received arguments.\n         \"\"\"\n         invalid_options = []\n         for parser_name, parser_dict in args.items():\n             for spec_option in \\\n                     self.spec_helper.get_parser_option_specs(parser_name):\n                 if all([key not in spec_option\n                         for key in ('maximum', 'minimum')]):\n                     # skip options that does not contain minimum or maximum\n                     continue\n                 option_name = spec_option['name']\n \n                 if option_name in parser_dict:\n                     option_value = parser_dict[option_name]\n                     min_value = spec_option.get('minimum')\n                     max_value = spec_option.get('maximum')\n                     # handle empty values in spec files which load as None\n                     min_value = '' if 'minimum' in spec_option \\\n                                       and min_value is None else min_value\n                     max_value = '' if 'maximum' in spec_option \\\n                                       and max_value is None else max_value\n \n                     values = {\n                         \"value\": option_value,\n                         \"maximum\": max_value,\n                         \"minimum\": min_value\n                     }\n \n                     # make sure that values are numbers\n                     is_all_values_numbers = True\n                     for name, num in values.items():\n                         if num is not None \\\n                                 and (isinstance(num, bool) or\n                                      not isinstance(num, (int, float))):\n                             invalid_options.append((\n                                 option_name,\n                                 name,\n                                 \"number\",\n                                 type(num).__name__\n                             ))\n                             is_all_values_numbers = False\n \n                     if not is_all_values_numbers:\n                         # don't continue to min max checks since some of the\n                         # values are not numbers\n                         continue\n \n                     # check bigger than minimum\n                     if min_value is not None and option_value < min_value:\n                         invalid_options.append((\n                             option_name,\n                             \"minimum\",\n                             min_value,\n                             option_value\n                         ))\n                     # check smaller than maximum\n                     if max_value is not None and option_value > max_value:\n                         invalid_options.append((\n                             option_name,\n                             \"maximum\",\n                             max_value,\n                             option_value\n                         ))\n \n         if invalid_options:\n             # raise exception with all arguments that contains invalid choices\n             raise exceptions.IRInvalidMinMaxRangeException(invalid_options)\n \n     def get_silent_args(self, args):\n         \"\"\"list of silenced argument\n \n         :param args: The received arguments.\n         :return: list, slienced argument names\n         \"\"\"\n         silent_args_names = []\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if arg_spec and 'silent' in arg_spec and \\\n                     self.spec_helper.get_option_state(\n                         parser_name,\n                         arg_name,\n                         args) == helper.OptionState['IS_SET']:\n                 silent_args_names.extend(arg_spec['silent'])\n \n         return list(set(silent_args_names))\n \n     def get_nested_custom_and_control_args(self, args):\n         \"\"\"Split input arguments to control nested and custom.\n \n         Controls arguments: control the IR behavior. These arguments\n             will not be put into the spec yml file\n         Nested arguments: are used by the Ansible playbooks and will be put\n             into the spec yml file.\n         Custom arguments: Custom ansible variables to be used instead of the\n             normal nested usage.\n \n         :param args: the collected list of args.\n         :return: (dict, dict): flat dicts (control_args, nested_args)\n         \"\"\"\n         # returns flat dicts\n         nested = {}\n         control_args = {}\n         custom_args = {}\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(args):\n             if all([arg_spec, arg_spec.get('type', None),\n                     arg_spec.get('type', None) in\n                     [ctype_name for ctype_name, klass in\n                      COMPLEX_TYPES.items() if klass.is_nested]\n                     ]) or ('is_shared_group_option' not in arg_spec):\n                 if arg_name in nested:\n                     LOG.warning(\n                         \"Duplicated nested argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, nested[arg_name]))\n                 elif arg_name in custom_args:\n                     LOG.warning(\n                         \"Duplicated custom argument found:'{}'. \"\n                         \"Using old value: '{}'\".format(\n                             arg_name, custom_args[arg_name]))\n                 else:\n                     if \"ansible_variable\" in arg_spec:\n                         custom_args[arg_spec[\"ansible_variable\"]] = arg_value\n                     else:\n                         nested[arg_name] = arg_value\n             else:\n                 if arg_name in control_args:\n                     LOG.warning(\n                         \"Duplicated control argument found: '{}'. Using \"\n                         \"old value: '{}'\".format(\n                             arg_name, control_args[arg_name]))\n                 else:\n                     control_args[arg_name] = arg_value\n \n         return nested, control_args, custom_args\n \n     def _iterate_received_arguments(self, args):\n         \"\"\"Iterator helper method over all the received arguments\n \n         :return: yields tuple:\n             (spec name, spec dict,\n              argument name, argument value, argument spec)\n         \"\"\"\n         for spec_parser in self.spec_helper.iterate_parsers():\n             if spec_parser['name'] in args:\n                 parser_dict = args[spec_parser['name']]\n                 for arg_name, arg_val in parser_dict.items():\n                     arg_spec = self.spec_helper.get_option_spec(\n                         spec_parser['name'], arg_name)\n                     yield (spec_parser['name'], parser_dict,\n                            arg_name, arg_val, arg_spec)\n \n     def _convert_non_cli_args(self, parser_name, values_dict):\n         \"\"\"Casts arguments to correct types by modifying values_dict param.\n \n         By default all the values are strings.\n \n         :param parser_name: The command name, e.g. main, virsh, ospd, etc\n         :param values_dict: The dict of with arguments\n        \"\"\"\n         for opt_name, opt_value in values_dict.items():\n             file_option_spec = self.spec_helper.get_option_spec(\n                 parser_name, opt_name)\n             if file_option_spec.get('type', None) in ['int', ] or \\\n                     file_option_spec.get('action', None) in ['count', ]:\n                 values_dict[opt_name] = int(opt_value)\n \n     def _merge_duplicated_cli_args(self, cli_args):\n         \"\"\"Merge duplicated arguments to all the parsers\n \n         This is need to handle control args, shared among several parsers.\n         for example, verbose, inventory\n         \"\"\"\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(cli_args):\n             for parser_name2, parser_dict2 in cli_args.items():\n                 if all([parser_name2, parser_name != parser_name2,\n                         arg_name not in parser_dict2]):\n                     if self.spec_helper.get_option_spec(parser_name2,\n                                                         arg_name):\n                         parser_dict2[arg_name] = arg_value\n ", "input_code": "def create_complex_argumet_type(self, subcommand, type_name, option_name, spec_option):\n\"\"\"\nBuild the complex argument type\n\n:param subcommand: the command name\n:param type_name: the complex type name\n:param option_name: the option name\n:param spec_option: option's specifications\n:return: the complex type instance\n\"\"\"\n", "indent_space": "                                    ", "ground_truth": "    def create_complex_argumet_type(self, subcommand, type_name, option_name,\n                                    spec_option):\n        \"\"\"Build the complex argument type\n\n        :param subcommand: the command name\n        :param type_name: the complex type name\n        :param option_name: the option name\n        :param spec_option: option's specifications\n        :return: the complex type instance\n        \"\"\"\n        complex_action = COMPLEX_TYPES.get(\n            type_name, None)\n        if complex_action is None:\n            raise exceptions.SpecParserException(\n                \"Unknown complex type: {}\".format(type_name))\n        return complex_action(\n            option_name,\n            (self.vars, self.defaults, self.plugin_path),\n            subcommand,\n            spec_option)", "signature": "def create_complex_argumet_type(self, subcommand, type_name, option_name, spec_option):", "completion_path": "infrared/core/inspector/inspector.py"}
{"ce_id": "6306092e73426c38ae68ad0f", "namespace": "6306092e73426c38ae68ad0f", "namespace_real": "infrared.core.inspector.inspector.get_nested_custom_and_control_args", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "inspector", "function_name": "get_nested_custom_and_control_args", "contexts_above": "import collections\nimport os\nfrom six.moves import configparser\nfrom string import Template\nimport yaml\n\nfrom infrared.core.cli.cli import CliParser\nfrom infrared.core.cli.cli import COMPLEX_TYPES\nfrom infrared.core.inspector import helper\nfrom infrared.core.utils import dict_utils\nfrom infrared.core.utils import exceptions\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n\nclass SpecParser(object):\n    \"\"\"Parses input arguments from different sources (cli, answers file). \"\"\"\n\n    @classmethod\n    def from_plugin(cls, subparser, plugin, base_groups):\n        \"\"\"Reads spec & vars from plugin and constructs the parser instance\n\n        :param subparser: argparse.subparser to extend\n        :param plugin: InfraredPlugin object\n        :param base_groups: dict, included groups\n        :return: SpecParser object based on given plugin spec & vars\n        \"\"\"\n\n        spec_dict = base_groups or {}\n        with open(plugin.spec) as stream:\n            spec = yaml.safe_load(stream) or {}\n            dict_utils.dict_merge(\n                base_groups,\n                spec,\n                dict_utils.ConflictResolver.unique_append_list_resolver)\n\n        # The \"try-excpet\" block here is for adding spec file path if it\n        # includes an unsupported option type\n        try:\n            return SpecParser(subparser, spec_dict, plugin.vars_dir,\n                              plugin.defaults_dir, plugin.path)\n        except exceptions.IRUnsupportedSpecOptionType as ex:\n            ex.message += ' in file: {}'.format(plugin.spec)\n            raise ex\n\n    def __init__(self, subparser, spec_dict, vars_dir, defaults_dir,\n                 plugin_path):\n        \"\"\"Constructor.\n\n        :param subparser: argparse.subparser to extend\n        :param spec_dict: dict with CLI description\n        :param vars_dir: Path to plugin's vars dir\n        :param defaults_dir: Path to plugin's defaults dir\n        \"\"\"\n        self.vars = vars_dir\n        self.defaults = defaults_dir\n        self.plugin_path = plugin_path\n        self.spec_helper = helper.SpecDictHelper(spec_dict)\n\n        # create parser\n        self.parser = CliParser.create_parser(self, subparser)\n\n    def add_shared_groups(self, list_of_groups):\n        \"\"\"Adds the user defined shared groups\n\n        :param list_of_groups: list, of group dicts\n        \"\"\"\n        shared_groups = self.spec_helper.spec_dict.get('shared_groups', [])\n        shared_groups.expand(list_of_groups)\n        self.spec_helper.spec_dict['shared_groups'] = shared_groups\n\n    def _get_defaults(self, default_getter_func):\n        \"\"\"Resolve arguments' values from cli or answers file.\n\n        :param default_getter_func: callable. will be called for all the\n            available options in spec file.\n        \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            default_value = default_getter_func(option)\n            if default_value is not None:\n                sub = parser['name']\n                result[sub][option['name']] = default_value\n\n        return result\n\n    def get_spec_defaults(self):\n        \"\"\"Resolve arguments' values from spec and other sources. \"\"\"\n\n        def spec_default_getter(option):\n            \"\"\"Getter function to retrieve the default value from spec.\n\n            :param option: argument name\n            \"\"\"\n\n            # first try to get environment variable with IR_ prefix\n            default_value = SpecParser.get_env_option(option['name'])\n            if default_value is not None:\n                LOG.info(\n                    \"[environ] Loading '{0}' default value\"\n                    \" '{1}' from the environment variable\".format(\n                        option['name'], default_value))\n            elif option.get('default', None) is not None:\n                default_value = option['default']\n            elif option.get('action', None) in ['store_true']:\n                default_value = False\n            return default_value\n\n        return self._get_defaults(spec_default_getter)\n\n    @staticmethod\n    def get_env_option(name):\n        \"\"\"Try get \"\"\"\n        return os.environ.get('IR_' + name.upper().replace('-', '_'))\n\n    def get_deprecated_args(self):\n        \"\"\"Returning dict with options which deprecate others. \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            if option.get('deprecates') is not None:\n                result[option.get('deprecates')] = option.get('name')\n\n        return result\n\n    @staticmethod\n    def parse_env_variable_from_file(value):\n        if isinstance(value, str):\n            t = Template(value)\n            try:\n                value = t.substitute(os.environ)\n            except KeyError as undefined_var:\n                raise exceptions.IRAnswersFileEnvVarNotDefined(undefined_var)\n        return value\n\n    def get_answers_file_args(self, cli_args):\n        \"\"\"Resolve arguments' values from answers INI file. \"\"\"\n\n        file_result = {}\n        args_to_remove = []\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            file_result[parser_name] = file_result.get(parser_name, {})\n            if option_spec and option_spec.get(\n                    'action', '') == 'read-answers':\n                # Iterate over arguments supplied by file\n                for parsed_arg in parser_dict[arg_name]:\n                    # Supplied arguments' value can be a list\n                    if isinstance(parser_dict[arg_name][parsed_arg], list):\n                        i = 0\n                        # Iterrate over argument values list\n                        for parsed_value in parser_dict[arg_name][parsed_arg]:\n                            parser_dict[arg_name][parsed_arg][i] = \\\n                                SpecParser.parse_env_variable_from_file(parsed_value)\n                            i += 1\n                    else:\n                        parser_dict[arg_name][parsed_arg] = \\\n                            SpecParser.parse_env_variable_from_file(parser_dict[arg_name][parsed_arg])\n                # we have config option. saving it.\n                self._convert_non_cli_args(\n                    parser_name, parser_dict[arg_name])\n                dict_utils.dict_merge(\n                    file_result[parser_name],\n                    parser_dict[arg_name])\n                # remove from cli args\n                args_to_remove.append((parser_name, arg_name))\n\n        # remove parser dict outside loop to avoid iteration dict modification\n        for parser_name, arg_name in args_to_remove:\n            for spec_parser in self.spec_helper.iterate_parsers():\n                if spec_parser['name'] in cli_args and spec_parser['name'] == parser_name:\n                    parser_dict = cli_args[spec_parser['name']]\n                    parser_dict.pop(arg_name)\n                    break\n\n        return file_result\n\n    def generate_answers_file(self, cli_args, spec_defaults):\n        \"\"\"Generates answers INI file\n\n        :param cli_args: list, cli arguments.\n        :param spec_defaults: the default values.\n        \"\"\"\n\n        def put_option(config, parser_name, option_name, value):\n            for opt_help in option.get('help', '').split('\\n'):\n                help_opt = '# ' + opt_help\n\n                # add help comment\n                if config.has_option(parser_name, help_opt):\n                    config.remove_option(parser_name, help_opt)\n                config.set(\n                    parser_name, help_opt)\n\n            if config.has_option(parser_name, option_name):\n                value = config.get(parser_name, option_name)\n                config.remove_option(parser_name, option_name)\n\n            config.set(\n                parser_name,\n                option_name,\n                str(value))\n\n        file_generated = False\n\n        # load generate answers file for all the parsers\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            if option_spec and option_spec.get(\n                    'action', '') == 'generate-answers':\n                options_to_save = \\\n                    self.spec_helper.get_parser_option_specs(parser_name)\n                out_answers = configparser.ConfigParser(allow_no_value=True)\n\n                if not out_answers.has_section(parser_name):\n                    out_answers.add_section(parser_name)\n\n                for option in options_to_save:\n                    opt_name = option['name']\n                    if opt_name in parser_dict:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            parser_dict[opt_name])\n                    elif opt_name in spec_defaults[parser_name]:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            spec_defaults[parser_name][opt_name])\n                    elif option.get('required', False):\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            '# ' + opt_name,\n                            \"Required argument. \"\n                            \"Edit with one of the allowed values OR \"\n                            \"override with \"\n                            \"CLI: --{}=<option>\".format(opt_name))\n\n                # write to file\n                with open(arg_value, 'w') as answers_file:\n                    out_answers.write(answers_file)\n                file_generated = True\n\n        return file_generated\n\n    def resolve_custom_types(self, args):\n        \"\"\"Transforms the arguments with custom types\n\n        :param args: the list of received arguments.\n        \"\"\"\n        for parser_name, parser_dict in args.items():\n            spec_complex_options = [opt for opt in\n                                    self.spec_helper.get_parser_option_specs(\n                                        parser_name) if\n                                    opt.get('type', None) in COMPLEX_TYPES]\n            for spec_option in spec_complex_options:\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # we have custom type to resolve\n                    type_name = spec_option['type']\n                    option_value = parser_dict[option_name]\n                    action = self.create_complex_argumet_type(\n                        parser_name,\n                        type_name,\n                        option_name,\n                        spec_option)\n\n                    # resolving value\n                    parser_dict[option_name] = action.resolve(option_value)\n\n    def create_complex_argumet_type(self, subcommand, type_name, option_name,\n                                    spec_option):\n        \"\"\"Build the complex argument type\n\n        :param subcommand: the command name\n        :param type_name: the complex type name\n        :param option_name: the option name\n        :param spec_option: option's specifications\n        :return: the complex type instance\n        \"\"\"\n        complex_action = COMPLEX_TYPES.get(\n            type_name, None)\n        if complex_action is None:\n            raise exceptions.SpecParserException(\n                \"Unknown complex type: {}\".format(type_name))\n        return complex_action(\n            option_name,\n            (self.vars, self.defaults, self.plugin_path),\n            subcommand,\n            spec_option)\n\n    def parse_args(self, arg_parser, args=None):\n        \"\"\"Parses all the arguments (cli, answers file)\n\n        :return: None, if ``--generate-answers-file`` in arg_arg_parser\n        :return: (dict, dict):\n            * command arguments dict (arguments to control the IR logic)\n            * nested arguments dict (arguments to pass to the playbooks)\n        \"\"\"\n\n        spec_defaults = self.get_spec_defaults()\n        cli_args = CliParser.parse_cli_input(arg_parser, args)\n\n        file_args = self.get_answers_file_args(cli_args)\n\n        # generate answers file and exit\n        if self.generate_answers_file(cli_args, spec_defaults):\n            LOG.warning(\"Answers file generated. Exiting.\")\n\n        # print warnings when something was overridden from non-cli source.\n        self.validate_arg_sources(cli_args, file_args,\n                                  spec_defaults)\n\n        # print warnings for deprecated\n        self.validate_arg_deprecation(cli_args, file_args)\n\n        # now filter defaults to have only parser defined in cli\n        defaults = dict((key, spec_defaults[key])\n                        for key in cli_args.keys() if\n                        key in spec_defaults)\n\n        # copy cli args with the same name to all parser groups\n        self._merge_duplicated_cli_args(cli_args)\n        self._merge_duplicated_cli_args(file_args)\n\n        dict_utils.dict_merge(defaults, file_args)\n        dict_utils.dict_merge(defaults, cli_args)\n        self.validate_requires_args(defaults)\n        self.validate_length_args(defaults)\n        self.validate_choices_args(defaults)\n        self.validate_min_max_args(defaults)\n\n        # now resolve complex types.\n        self.resolve_custom_types(defaults)\n        nested, control, custom = \\\n            self.get_nested_custom_and_control_args(defaults)\n        return nested, control, custom\n\n    def validate_arg_deprecation(self, cli_args, answer_file_args):\n        \"\"\"Validates and prints the deprecated arguments.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        \"\"\"\n\n        for deprecated, deprecates in self.get_deprecated_args().items():\n            for input_args in (answer_file_args.items(), cli_args.items()):\n                for command, command_dict in input_args:\n                    if deprecated in command_dict:\n                        if deprecates in command_dict:\n                            raise exceptions.IRDeprecationException(\n                                \"[{}] Argument '{}' deprecates '{}',\"\n                                \" please use only the new one.\".format(\n                                    command, deprecated, deprecates))\n\n                        if deprecated in answer_file_args[command]:\n                            answer_file_args[command][deprecates] = \\\n                                answer_file_args[command][deprecated]\n\n                        if deprecated in cli_args[command]:\n                            cli_args[command][deprecates] = \\\n                                cli_args[command][deprecated]\n\n                        LOG.warning(\n                            \"[{}] Argument '{}' was deprecated,\"\n                            \" please use '{}'.\".format(\n                                command, deprecated, deprecates))\n\n    @staticmethod\n    def validate_arg_sources(cli_args, answer_file_args, spec_defaults):\n        \"\"\"Validates and prints the arguments' source.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        :param spec_defaults:  the default values from spec files\n        \"\"\"\n\n        def show_diff(diff, command_name, cmd_dict, source_name):\n            if diff:\n                for arg_name in diff:\n                    value = cmd_dict[arg_name]\n                    LOG.info(\n                        \"[{}] Argument '{}' was set to\"\n                        \" '{}' from the {} source.\".format(\n                            command_name, arg_name, value, source_name))\n\n        for command, command_dict in cli_args.items():\n            file_dict = answer_file_args.get(command, {})\n            file_diff = set(file_dict.keys()) - set(command_dict.keys())\n            show_diff(file_diff, command, file_dict, 'answers file')\n\n            def_dict = spec_defaults.get(command, {})\n            default_diff = set(def_dict.keys()) - set(\n                command_dict.keys()) - file_diff\n            show_diff(default_diff, command, def_dict, 'spec defaults')\n\n    def _get_conditionally_required_args(self, command_name, options_spec,\n                                         args):\n        \"\"\"List arguments with ``required_when`` condition matched.\n\n        :param command_name: the command name.\n        :param options_spec:  the list of command spec options.\n        :param args: the received input arguments\n        :return: list, list of argument names with matched ``required_when``\n            condition\n        \"\"\"\n        opts_names = [option_spec['name'] for option_spec in options_spec]\n        missing_args = []\n        for option_spec in options_spec:\n            option_results = []\n            if option_spec and 'required_when' in option_spec:\n                req_when_args = [option_spec['required_when']] \\\n                    if not type(option_spec['required_when']) is list \\\n                    else option_spec['required_when']\n\n                # validate conditions\n                for req_when_arg in req_when_args:\n                    splited_args_list = req_when_arg.split()\n                    for idx, req_arg in enumerate(splited_args_list):\n                        if req_arg in opts_names:\n                            splited_args_list[idx] = \\\n                                args.get(command_name, {}).get(req_arg.strip())\n                        if splited_args_list[idx] is None:\n                            option_results.append(False)\n                            break\n                        splited_args_list[idx] = str(splited_args_list[idx])\n                        if (splited_args_list[idx] not in ['and', 'or'] and\n                            not any(\n                                (c in '<>=') for c in splited_args_list[idx])):\n                            splited_args_list[idx] = \"'{0}'\".format(\n                                yaml.safe_load(splited_args_list[idx]))\n                    else:\n                        option_results.append(\n                            eval(' '.join(splited_args_list)))\n                if all(option_results) and \\\n                        self.spec_helper.get_option_state(\n                            command_name,\n                            option_spec['name'],\n                            args) == helper.OptionState['NOT_SET']:\n                    missing_args.append(option_spec['name'])\n        return missing_args\n\n    def validate_requires_args(self, args):\n        \"\"\"Check if all the required arguments have been provided. \"\"\"\n\n        silent_args = self.get_silent_args(args)\n\n        def validate_parser(parser_name, expected_options, parser_args):\n            \"\"\"Helper method to resolve dict_merge. \"\"\"\n\n            result = collections.defaultdict(list)\n            condition_req_args = self._get_conditionally_required_args(\n                parser_name, expected_options, args)\n\n            for option in expected_options:\n                name = option['name']\n\n                # check required options.\n                if (option.get('required', False) and\n                    name not in parser_args or\n                    option['name'] in condition_req_args) and \\\n                        name not in silent_args:\n                    result[parser_name].append(name)\n\n            return result\n\n        res = {}\n        for command_data in self.spec_helper.iterate_parsers():\n            cmd_name = command_data['name']\n            if cmd_name in args:\n                dict_utils.dict_merge(\n                    res,\n                    validate_parser(\n                        cmd_name,\n                        self.spec_helper.get_parser_option_specs(cmd_name),\n                        args[cmd_name]))\n\n        missing_args = dict((cmd_name, args)\n                            for cmd_name, args in res.items() if len(args) > 0)\n        if missing_args:\n            raise exceptions.IRRequiredArgsMissingException(missing_args)\n\n    def validate_length_args(self, args):\n        \"\"\"Check if value of arguments is not longer than length specified.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if 'length' not in spec_option:\n                    # skip options that does not contain length\n                    continue\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # resolve length\n                    length = spec_option['length']\n                    option_value = parser_dict[option_name]\n                    if len(option_value) > int(length):\n                        # found invalid option, append to list of invalid opts\n                        invalid_options.append((\n                            option_name,\n                            option_value,\n                            length\n                        ))\n        if invalid_options:\n            # raise exception with all arguments that exceed length\n            raise exceptions.IRInvalidLengthException(invalid_options)\n\n    def validate_choices_args(self, args):\n        \"\"\"Check if value of choice arguments is one of the available choices.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if 'choices' not in spec_option:\n                    # skip options that does not contain choices\n                    continue\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # resolve choices\n                    choices = spec_option['choices']\n                    option_value = parser_dict[option_name]\n                    if option_value not in choices:\n                        # found invalid option, append to list of invalid opts\n                        invalid_options.append((\n                            option_name,\n                            option_value,\n                            choices\n                        ))\n        if invalid_options:\n            # raise exception with all arguments that contains invalid choices\n            raise exceptions.IRInvalidChoiceException(invalid_options)\n\n    def validate_min_max_args(self, args):\n        \"\"\"Check if value of arguments is between minimum and maximum values.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if all([key not in spec_option\n                        for key in ('maximum', 'minimum')]):\n                    # skip options that does not contain minimum or maximum\n                    continue\n                option_name = spec_option['name']\n\n                if option_name in parser_dict:\n                    option_value = parser_dict[option_name]\n                    min_value = spec_option.get('minimum')\n                    max_value = spec_option.get('maximum')\n                    # handle empty values in spec files which load as None\n                    min_value = '' if 'minimum' in spec_option \\\n                                      and min_value is None else min_value\n                    max_value = '' if 'maximum' in spec_option \\\n                                      and max_value is None else max_value\n\n                    values = {\n                        \"value\": option_value,\n                        \"maximum\": max_value,\n                        \"minimum\": min_value\n                    }\n\n                    # make sure that values are numbers\n                    is_all_values_numbers = True\n                    for name, num in values.items():\n                        if num is not None \\\n                                and (isinstance(num, bool) or\n                                     not isinstance(num, (int, float))):\n                            invalid_options.append((\n                                option_name,\n                                name,\n                                \"number\",\n                                type(num).__name__\n                            ))\n                            is_all_values_numbers = False\n\n                    if not is_all_values_numbers:\n                        # don't continue to min max checks since some of the\n                        # values are not numbers\n                        continue\n\n                    # check bigger than minimum\n                    if min_value is not None and option_value < min_value:\n                        invalid_options.append((\n                            option_name,\n                            \"minimum\",\n                            min_value,\n                            option_value\n                        ))\n                    # check smaller than maximum\n                    if max_value is not None and option_value > max_value:\n                        invalid_options.append((\n                            option_name,\n                            \"maximum\",\n                            max_value,\n                            option_value\n                        ))\n\n        if invalid_options:\n            # raise exception with all arguments that contains invalid choices\n            raise exceptions.IRInvalidMinMaxRangeException(invalid_options)\n\n    def get_silent_args(self, args):\n        \"\"\"list of silenced argument\n\n        :param args: The received arguments.\n        :return: list, slienced argument names\n        \"\"\"\n        silent_args_names = []\n        for (parser_name, parser_dict, arg_name, arg_value,\n             arg_spec) in self._iterate_received_arguments(args):\n            if arg_spec and 'silent' in arg_spec and \\\n                    self.spec_helper.get_option_state(\n                        parser_name,\n                        arg_name,\n                        args) == helper.OptionState['IS_SET']:\n                silent_args_names.extend(arg_spec['silent'])\n\n        return list(set(silent_args_names))\n", "contexts_below": "    def _iterate_received_arguments(self, args):\n         \"\"\"Iterator helper method over all the received arguments\n \n         :return: yields tuple:\n             (spec name, spec dict,\n              argument name, argument value, argument spec)\n         \"\"\"\n         for spec_parser in self.spec_helper.iterate_parsers():\n             if spec_parser['name'] in args:\n                 parser_dict = args[spec_parser['name']]\n                 for arg_name, arg_val in parser_dict.items():\n                     arg_spec = self.spec_helper.get_option_spec(\n                         spec_parser['name'], arg_name)\n                     yield (spec_parser['name'], parser_dict,\n                            arg_name, arg_val, arg_spec)\n \n     def _convert_non_cli_args(self, parser_name, values_dict):\n         \"\"\"Casts arguments to correct types by modifying values_dict param.\n \n         By default all the values are strings.\n \n         :param parser_name: The command name, e.g. main, virsh, ospd, etc\n         :param values_dict: The dict of with arguments\n        \"\"\"\n         for opt_name, opt_value in values_dict.items():\n             file_option_spec = self.spec_helper.get_option_spec(\n                 parser_name, opt_name)\n             if file_option_spec.get('type', None) in ['int', ] or \\\n                     file_option_spec.get('action', None) in ['count', ]:\n                 values_dict[opt_name] = int(opt_value)\n \n     def _merge_duplicated_cli_args(self, cli_args):\n         \"\"\"Merge duplicated arguments to all the parsers\n \n         This is need to handle control args, shared among several parsers.\n         for example, verbose, inventory\n         \"\"\"\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(cli_args):\n             for parser_name2, parser_dict2 in cli_args.items():\n                 if all([parser_name2, parser_name != parser_name2,\n                         arg_name not in parser_dict2]):\n                     if self.spec_helper.get_option_spec(parser_name2,\n                                                         arg_name):\n                         parser_dict2[arg_name] = arg_value\n ", "input_code": "def get_nested_custom_and_control_args(self, args):\n\"\"\"\nSplit input arguments to control nested and custom.\n\nControls arguments: control the IR behavior. These arguments\n    will not be put into the spec yml file\nNested arguments: are used by the Ansible playbooks and will be put\n    into the spec yml file.\nCustom arguments: Custom ansible variables to be used instead of the\n    normal nested usage.\n\n:param args: the collected list of args.\n:return: (dict, dict): flat dicts (control_args, nested_args)\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def get_nested_custom_and_control_args(self, args):\n        \"\"\"Split input arguments to control nested and custom.\n\n        Controls arguments: control the IR behavior. These arguments\n            will not be put into the spec yml file\n        Nested arguments: are used by the Ansible playbooks and will be put\n            into the spec yml file.\n        Custom arguments: Custom ansible variables to be used instead of the\n            normal nested usage.\n\n        :param args: the collected list of args.\n        :return: (dict, dict): flat dicts (control_args, nested_args)\n        \"\"\"\n        # returns flat dicts\n        nested = {}\n        control_args = {}\n        custom_args = {}\n        for (parser_name, parser_dict, arg_name, arg_value,\n             arg_spec) in self._iterate_received_arguments(args):\n            if all([arg_spec, arg_spec.get('type', None),\n                    arg_spec.get('type', None) in\n                    [ctype_name for ctype_name, klass in\n                     COMPLEX_TYPES.items() if klass.is_nested]\n                    ]) or ('is_shared_group_option' not in arg_spec):\n                if arg_name in nested:\n                    LOG.warning(\n                        \"Duplicated nested argument found:'{}'. \"\n                        \"Using old value: '{}'\".format(\n                            arg_name, nested[arg_name]))\n                elif arg_name in custom_args:\n                    LOG.warning(\n                        \"Duplicated custom argument found:'{}'. \"\n                        \"Using old value: '{}'\".format(\n                            arg_name, custom_args[arg_name]))\n                else:\n                    if \"ansible_variable\" in arg_spec:\n                        custom_args[arg_spec[\"ansible_variable\"]] = arg_value\n                    else:\n                        nested[arg_name] = arg_value\n            else:\n                if arg_name in control_args:\n                    LOG.warning(\n                        \"Duplicated control argument found: '{}'. Using \"\n                        \"old value: '{}'\".format(\n                            arg_name, control_args[arg_name]))\n                else:\n                    control_args[arg_name] = arg_value\n\n        return nested, control_args, custom_args", "signature": "def get_nested_custom_and_control_args(self, args):", "completion_path": "infrared/core/inspector/inspector.py"}
{"ce_id": "6306092e73426c38ae68ad11", "namespace": "6306092e73426c38ae68ad11", "namespace_real": "infrared.core.settings.merge_extra_vars", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "settings", "function_name": "merge_extra_vars", "contexts_above": "import yaml\n\nfrom infrared.core.utils import dict_utils\nfrom infrared.core.utils import exceptions\n\n\nclass VarsDictManager(object):\n\n    @staticmethod\n    def generate_settings(entry_point,\n                          nested_args,\n                          delimiter='-'):\n        \"\"\"Unifies all input into a single dict of Ansible extra-vars\n\n        :param entry_point: All input will be nested under this key\n        :param nested_args: dict. these values will be nested\n            example:\n                {\n                    foo-bar: value1,\n                    foo2: value2\n                    foo-another-bar: value3\n                }\n        :param delimiter: character to split keys by.\n        :return: dict. nest input with keys splitted by delimiter\n\n        >>> VarsDictManager.generate_settings(\n        ... 'entry_point', {'foo-bar': 'value1',\n        ...                 'foo2': 'value2',\n        ...                 'foo-another-bar': 'value3'})\n        {'entry_point': {'foo': {'bar': 'value1', 'another':\\\n {'bar': 'value3'}}, 'foo2': 'value2'}}\n        \"\"\"\n        vars_dict = {entry_point: {}}\n        try:\n            for _name, argument in nested_args.items():\n                dict_utils.dict_insert(vars_dict[entry_point],\n                                       argument,\n                                       *_name.split(delimiter))\n\n        # handle errors here and provide more output for user if required\n        except exceptions.IRKeyNotFoundException as key_exception:\n            if key_exception and key_exception.key.startswith(\"private.\"):\n                raise exceptions.IRPrivateSettingsMissingException(\n                    key_exception.key)\n            else:\n                raise\n        return vars_dict\n\n    @staticmethod", "contexts_below": "", "input_code": "@staticmethod\ndef merge_extra_vars(vars_dict, extra_vars=None):\n\"\"\"\nExtend ``vars_dict`` with ``extra-vars``\n\n:param vars_dict: Dictionary to merge extra-vars into\n:param extra_vars: List of extra-vars\n\"\"\"\n", "indent_space": "    ", "ground_truth": "    @staticmethod\n    def merge_extra_vars(vars_dict, extra_vars=None):\n        \"\"\"Extend ``vars_dict`` with ``extra-vars``\n\n        :param vars_dict: Dictionary to merge extra-vars into\n        :param extra_vars: List of extra-vars\n        \"\"\"\n        for extra_var in extra_vars or []:\n            if extra_var.startswith('@'):\n                with open(extra_var[1:]) as f_obj:\n                    loaded_yml = yaml.safe_load(f_obj)\n\n                dict_utils.dict_merge(\n                    vars_dict,\n                    loaded_yml,\n                    conflict_resolver=dict_utils.ConflictResolver.\n                    unique_append_list_resolver)\n\n            else:\n                if '=' not in extra_var:\n                    raise exceptions.IRExtraVarsException(extra_var)\n                key, value = extra_var.split(\"=\", 1)\n                if value.startswith('@'):\n                    with open(value[1:]) as f_obj:\n                        loaded_yml = yaml.safe_load(f_obj)\n\n                    tmp_dict = {}\n                    dict_utils.dict_insert(tmp_dict, loaded_yml, *key.split(\".\"))\n\n                    dict_utils.dict_merge(\n                        vars_dict,\n                        tmp_dict,\n                        conflict_resolver=dict_utils.ConflictResolver.\n                        unique_append_list_resolver)\n\n                else:\n                    dict_utils.dict_insert(vars_dict, value, *key.split(\".\"))", "signature": "@staticmethod\ndef merge_extra_vars(vars_dict, extra_vars=None):", "completion_path": "infrared/core/settings.py"}
{"ce_id": "6306092f73426c38ae68ad13", "namespace": "6306092f73426c38ae68ad13", "namespace_real": "infrared.core.execute.ansible_playbook", "real_proj_path": "redhat-openstack---infrared/", "type": "function", "class_name": null, "function_name": "ansible_playbook", "contexts_above": "from datetime import datetime\nfrom distutils.util import strtobool\nimport errno\nimport json\nimport os\nimport re\nimport sys\nimport tempfile\n\nfrom infrared.core.utils import logger\nimport yaml\n\nLOG = logger.LOG\n\n\nclass NoAnsiFile(object):\n\n    re_ansi = re.compile(r'\\x1b[^m]*m')\n\n    def __init__(self, fd):\n        self.fd = fd\n\n    def write(self, data):\n        no_ansi_data = self.re_ansi.sub('', data)\n        self.fd.write(no_ansi_data)\n\n    def close(self):\n        self.fd.close()\n\n    def flush(self):\n        self.fd.flush()\n\n\nclass IRStdFd(object):\n    pass\n\n\nclass IRStdoutFd(IRStdFd):\n\n    def __init__(self, print_stdout=True):\n        self.print_stdout = print_stdout\n        self.org_stdout = sys.stdout\n        sys.stdout = self\n\n    def write(self, data):\n        if self.print_stdout:\n            sys.__stdout__.write(data)\n            sys.__stdout__.flush()\n        for fd in IRSTDFDManager.fds:\n            if not isinstance(fd, IRStdFd):\n                fd.write(data)\n                fd.flush()\n\n    @staticmethod\n    def flush():\n        sys.__stdout__.flush()\n\n    @staticmethod\n    def close():\n        sys.stdout = sys.__stdout__\n\n    @staticmethod\n    def fileno():\n        return sys.__stdout__.fileno()\n\n\nclass IRStderrFd(IRStdFd):\n\n    def __init__(self, print_stderr=True):\n        self.print_stderr = print_stderr\n        self.org_stderr = sys.stderr\n        sys.stderr = self\n\n    def write(self, data):\n        if self.print_stderr:\n            sys.__stderr__.write(data)\n            sys.__stderr__.flush()\n        for fd in IRSTDFDManager.fds:\n            if not isinstance(fd, IRStdFd):\n                fd.write(data)\n                fd.flush()\n\n    @staticmethod\n    def flush():\n        sys.__stderr__.flush()\n\n    @staticmethod\n    def close():\n        sys.stderr = sys.__stderr__\n\n\nclass IRSTDFDManager(object):\n\n    fds = set()\n\n    def __init__(self, stdout=True, stderr=True, *fds):\n\n        self.stdout = stdout\n        self.stderr = stderr\n\n        for fd in fds:\n            self.add(fd)\n\n        self.add(IRStdoutFd(print_stdout=self.stdout))\n        self.add(IRStderrFd(print_stderr=self.stderr))\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.close()\n\n    def write(self, data):\n        for fd in self.fds:\n            fd.write(data)\n            fd.flush()\n\n    def flush(self):\n        for fd in self.fds:\n            fd.flush()\n\n    def close(self):\n        for fd in self.fds:\n            fd.close()\n\n    def add(self, fd):\n        self.fds.add(fd)\n\n", "contexts_below": "\n def _run_playbook(cli_args, vars_dict, ir_workspace, ir_plugin):\n     \"\"\"Runs ansible cli with vars dict\n \n     :param vars_dict: dict, Will be passed as Ansible extra-vars\n     :param cli_args: the list  of command line arguments\n     :param ir_workspace: An Infrared Workspace object represents the active\n      workspace\n     :param ir_plugin: An InfraredPlugin object of the current plugin\n     :return: ansible results\n     \"\"\"\n \n     # TODO(yfried): use ansible vars object instead of tmpfile\n     # NOTE(oanufrii): !!!this import should be exactly here!!!\n     #                 Ansible uses 'display' singleton from '__main__' and\n     #                 gets it on module level. While we monkeypatching our\n     #                 '__main__' in 'ansible_playbook' function import of\n     #                 PlaybookCLI shoul be after that, to get patched\n     #                 '__main__'. Otherwise ansible gets unpatched '__main__'\n     #                 and creates new 'display' object with default (0)\n     #                 verbosity.\n     # NOTE(afazekas): GlobalCLIArgs gets value only once per invocation, but\n     # since it has singleton decorator, so it would remember to old arguments in different tests\n     # removing the singleton decorator\n     try:\n         from ansible.utils import context_objects\n         context_objects.GlobalCLIArgs = context_objects.CLIArgs\n     except ImportError:\n         # older version\n         pass\n \n     from ansible.cli.playbook import PlaybookCLI\n     from ansible.errors import AnsibleOptionsError\n     from ansible.errors import AnsibleParserError\n \n     with tempfile.NamedTemporaryFile(\n             mode='w+', prefix=\"ir-settings-\", delete=True) as tmp:\n         tmp.write(yaml.safe_dump(vars_dict, default_flow_style=False))\n         # make sure created file is readable.\n         tmp.flush()\n         cli_args.extend(['--extra-vars', \"@\" + tmp.name])\n \n         if not bool(strtobool(os.environ.get('IR_NO_EXTRAS', 'no'))):\n             ir_extras = {\n                 'infrared': {\n                     'python': {\n                         'executable': sys.executable,\n                         'version': {\n                             'full': sys.version.split()[0],\n                             'major': sys.version_info.major,\n                             'minor': sys.version_info.minor,\n                             'micro': sys.version_info.micro,\n                         }\n                     }\n                 }\n             }\n             cli_args.extend(['--extra-vars', str(ir_extras)])\n \n         cli = PlaybookCLI(cli_args)\n         LOG.debug('Starting ansible cli with args: {}'.format(cli_args[1:]))\n         try:\n             cli.parse()\n \n             stdout = not bool(\n                 strtobool(os.environ.get('IR_ANSIBLE_NO_STDOUT', 'no')))\n             stderr = not bool(\n                 strtobool(os.environ.get('IR_ANSIBLE_NO_STDERR', 'no')))\n \n             ansible_outputs_dir = \\\n                 os.path.join(ir_workspace.path, 'ansible_outputs')\n             ansible_vars_dir = \\\n                 os.path.join(ir_workspace.path, 'ansible_vars')\n \n             timestamp = datetime.utcnow().strftime(\"%Y-%m-%d_%H-%M-%S.%f\")\n             filename_template = \\\n                 \"ir_{timestamp}_{plugin_name}{postfix}.{file_ext}\"\n \n             for _dir in (ansible_outputs_dir, ansible_vars_dir):\n                 try:\n                     os.makedirs(_dir)\n                 except OSError as e:\n                     if e.errno != errno.EEXIST:\n                         raise\n \n             if bool(strtobool(os.environ.get('IR_GEN_VARS_JSON', 'no'))):\n                 filename = filename_template.format(\n                     timestamp=timestamp,\n                     plugin_name=ir_plugin.name,\n                     postfix='',\n                     file_ext='json'\n                 )\n                 vars_file = os.path.join(ansible_vars_dir, filename)\n                 with open(vars_file, 'w') as fp:\n                     json.dump(vars_dict, fp, indent=4, sort_keys=True)\n \n             with IRSTDFDManager(stdout=stdout, stderr=stderr) as fd_manager:\n \n                 if bool(strtobool(os.environ.get(\n                         'IR_ANSIBLE_LOG_OUTPUT', 'no'))):\n                     filename = filename_template.format(\n                         timestamp=timestamp,\n                         plugin_name=ir_plugin.name,\n                         postfix='',\n                         file_ext='log'\n                     )\n                     log_file = os.path.join(ansible_outputs_dir, filename)\n                     fd_manager.add(open(log_file, 'w'))\n \n                 if bool(strtobool(os.environ.get(\n                         'IR_ANSIBLE_LOG_OUTPUT_NO_ANSI', 'no'))):\n                     filename = filename_template.format(\n                         timestamp=timestamp,\n                         plugin_name=ir_plugin.name,\n                         postfix='_no_ansi',\n                         file_ext='log'\n                     )\n                     log_file = os.path.join(ansible_outputs_dir, filename)\n                     fd_manager.add(NoAnsiFile(open(log_file, 'w')))\n \n                 # Return the result:\n                 # 0: Success\n                 # 1: \"Error\"\n                 # 2: Host failed\n                 # 3: Unreachable\n                 # 4: Parser Error\n                 # 5: Options error\n \n                 return cli.run()\n \n         except (AnsibleParserError, AnsibleOptionsError) as error:\n             LOG.error('{}: {}'.format(type(error), error))\n             raise error\n ", "input_code": "def ansible_playbook(ir_workspace, ir_plugin, playbook_path, verbose=None, extra_vars=None, ansible_args=None):\n\"\"\"\nWraps the 'ansible-playbook' CLI.\n\n:param ir_workspace: An Infrared Workspace object represents the active\nworkspace\n:param ir_plugin: An InfraredPlugin object of the current plugin\n:param playbook_path: the playbook to invoke\n:param verbose: Ansible verbosity level\n:param extra_vars: dict. Passed to Ansible as extra-vars\n:param ansible_args: dict of ansible-playbook arguments to plumb down\n    directly to Ansible.\n\"\"\"\n", "indent_space": "                     ", "ground_truth": "def ansible_playbook(ir_workspace, ir_plugin, playbook_path, verbose=None,\n                     extra_vars=None, ansible_args=None):\n    \"\"\"Wraps the 'ansible-playbook' CLI.\n\n     :param ir_workspace: An Infrared Workspace object represents the active\n     workspace\n     :param ir_plugin: An InfraredPlugin object of the current plugin\n     :param playbook_path: the playbook to invoke\n     :param verbose: Ansible verbosity level\n     :param extra_vars: dict. Passed to Ansible as extra-vars\n     :param ansible_args: dict of ansible-playbook arguments to plumb down\n         directly to Ansible.\n    \"\"\"\n    ansible_args = ansible_args or []\n    LOG.debug(\"Additional ansible args: {}\".format(ansible_args))\n\n    # hack for verbosity\n    from ansible.utils.display import Display\n    display = Display(verbosity=verbose)\n    import __main__ as main\n    setattr(main, \"display\", display)\n\n    # TODO(yfried): Use proper ansible API instead of emulating CLI\n    cli_args = ['execute',\n                playbook_path,\n                '--inventory', ir_workspace.inventory]\n\n    # infrared should not change ansible verbosity unless user specifies that\n    if verbose:\n        cli_args.append('-' + 'v' * int(verbose))\n\n    cli_args.extend(ansible_args)\n\n    results = _run_playbook(cli_args, vars_dict=extra_vars or {},\n                            ir_workspace=ir_workspace, ir_plugin=ir_plugin)\n\n    if results:\n        LOG.error('Playbook \"%s\" failed!' % playbook_path)\n    return results", "signature": "def ansible_playbook(ir_workspace, ir_plugin, playbook_path, verbose=None, extra_vars=None, ansible_args=None):", "completion_path": "infrared/core/execute.py"}
{"ce_id": "6306093273426c38ae68ad15", "namespace": "6306093273426c38ae68ad15", "namespace_real": "infrared.core.execute._run_playbook", "real_proj_path": "redhat-openstack---infrared/", "type": "function", "class_name": null, "function_name": "_run_playbook", "contexts_above": "from datetime import datetime\nfrom distutils.util import strtobool\nimport errno\nimport json\nimport os\nimport re\nimport sys\nimport tempfile\n\nfrom infrared.core.utils import logger\nimport yaml\n\nLOG = logger.LOG\n\n\nclass NoAnsiFile(object):\n\n    re_ansi = re.compile(r'\\x1b[^m]*m')\n\n    def __init__(self, fd):\n        self.fd = fd\n\n    def write(self, data):\n        no_ansi_data = self.re_ansi.sub('', data)\n        self.fd.write(no_ansi_data)\n\n    def close(self):\n        self.fd.close()\n\n    def flush(self):\n        self.fd.flush()\n\n\nclass IRStdFd(object):\n    pass\n\n\nclass IRStdoutFd(IRStdFd):\n\n    def __init__(self, print_stdout=True):\n        self.print_stdout = print_stdout\n        self.org_stdout = sys.stdout\n        sys.stdout = self\n\n    def write(self, data):\n        if self.print_stdout:\n            sys.__stdout__.write(data)\n            sys.__stdout__.flush()\n        for fd in IRSTDFDManager.fds:\n            if not isinstance(fd, IRStdFd):\n                fd.write(data)\n                fd.flush()\n\n    @staticmethod\n    def flush():\n        sys.__stdout__.flush()\n\n    @staticmethod\n    def close():\n        sys.stdout = sys.__stdout__\n\n    @staticmethod\n    def fileno():\n        return sys.__stdout__.fileno()\n\n\nclass IRStderrFd(IRStdFd):\n\n    def __init__(self, print_stderr=True):\n        self.print_stderr = print_stderr\n        self.org_stderr = sys.stderr\n        sys.stderr = self\n\n    def write(self, data):\n        if self.print_stderr:\n            sys.__stderr__.write(data)\n            sys.__stderr__.flush()\n        for fd in IRSTDFDManager.fds:\n            if not isinstance(fd, IRStdFd):\n                fd.write(data)\n                fd.flush()\n\n    @staticmethod\n    def flush():\n        sys.__stderr__.flush()\n\n    @staticmethod\n    def close():\n        sys.stderr = sys.__stderr__\n\n\nclass IRSTDFDManager(object):\n\n    fds = set()\n\n    def __init__(self, stdout=True, stderr=True, *fds):\n\n        self.stdout = stdout\n        self.stderr = stderr\n\n        for fd in fds:\n            self.add(fd)\n\n        self.add(IRStdoutFd(print_stdout=self.stdout))\n        self.add(IRStderrFd(print_stderr=self.stderr))\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.close()\n\n    def write(self, data):\n        for fd in self.fds:\n            fd.write(data)\n            fd.flush()\n\n    def flush(self):\n        for fd in self.fds:\n            fd.flush()\n\n    def close(self):\n        for fd in self.fds:\n            fd.close()\n\n    def add(self, fd):\n        self.fds.add(fd)\n\n\ndef ansible_playbook(ir_workspace, ir_plugin, playbook_path, verbose=None,\n                     extra_vars=None, ansible_args=None):\n    \"\"\"Wraps the 'ansible-playbook' CLI.\n\n     :param ir_workspace: An Infrared Workspace object represents the active\n     workspace\n     :param ir_plugin: An InfraredPlugin object of the current plugin\n     :param playbook_path: the playbook to invoke\n     :param verbose: Ansible verbosity level\n     :param extra_vars: dict. Passed to Ansible as extra-vars\n     :param ansible_args: dict of ansible-playbook arguments to plumb down\n         directly to Ansible.\n    \"\"\"\n    ansible_args = ansible_args or []\n    LOG.debug(\"Additional ansible args: {}\".format(ansible_args))\n\n    # hack for verbosity\n    from ansible.utils.display import Display\n    display = Display(verbosity=verbose)\n    import __main__ as main\n    setattr(main, \"display\", display)\n\n    # TODO(yfried): Use proper ansible API instead of emulating CLI\n    cli_args = ['execute',\n                playbook_path,\n                '--inventory', ir_workspace.inventory]\n\n    # infrared should not change ansible verbosity unless user specifies that\n    if verbose:\n        cli_args.append('-' + 'v' * int(verbose))\n\n    cli_args.extend(ansible_args)\n\n    results = _run_playbook(cli_args, vars_dict=extra_vars or {},\n                            ir_workspace=ir_workspace, ir_plugin=ir_plugin)\n\n    if results:\n        LOG.error('Playbook \"%s\" failed!' % playbook_path)\n    return results\n\n", "contexts_below": "", "input_code": "def _run_playbook(cli_args, vars_dict, ir_workspace, ir_plugin):\n\"\"\"\nRuns ansible cli with vars dict\n\n:param vars_dict: dict, Will be passed as Ansible extra-vars\n:param cli_args: the list  of command line arguments\n:param ir_workspace: An Infrared Workspace object represents the active\n workspace\n:param ir_plugin: An InfraredPlugin object of the current plugin\n:return: ansible results\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def _run_playbook(cli_args, vars_dict, ir_workspace, ir_plugin):\n    \"\"\"Runs ansible cli with vars dict\n\n    :param vars_dict: dict, Will be passed as Ansible extra-vars\n    :param cli_args: the list  of command line arguments\n    :param ir_workspace: An Infrared Workspace object represents the active\n     workspace\n    :param ir_plugin: An InfraredPlugin object of the current plugin\n    :return: ansible results\n    \"\"\"\n\n    # TODO(yfried): use ansible vars object instead of tmpfile\n    # NOTE(oanufrii): !!!this import should be exactly here!!!\n    #                 Ansible uses 'display' singleton from '__main__' and\n    #                 gets it on module level. While we monkeypatching our\n    #                 '__main__' in 'ansible_playbook' function import of\n    #                 PlaybookCLI shoul be after that, to get patched\n    #                 '__main__'. Otherwise ansible gets unpatched '__main__'\n    #                 and creates new 'display' object with default (0)\n    #                 verbosity.\n    # NOTE(afazekas): GlobalCLIArgs gets value only once per invocation, but\n    # since it has singleton decorator, so it would remember to old arguments in different tests\n    # removing the singleton decorator\n    try:\n        from ansible.utils import context_objects\n        context_objects.GlobalCLIArgs = context_objects.CLIArgs\n    except ImportError:\n        # older version\n        pass\n\n    from ansible.cli.playbook import PlaybookCLI\n    from ansible.errors import AnsibleOptionsError\n    from ansible.errors import AnsibleParserError\n\n    with tempfile.NamedTemporaryFile(\n            mode='w+', prefix=\"ir-settings-\", delete=True) as tmp:\n        tmp.write(yaml.safe_dump(vars_dict, default_flow_style=False))\n        # make sure created file is readable.\n        tmp.flush()\n        cli_args.extend(['--extra-vars', \"@\" + tmp.name])\n\n        if not bool(strtobool(os.environ.get('IR_NO_EXTRAS', 'no'))):\n            ir_extras = {\n                'infrared': {\n                    'python': {\n                        'executable': sys.executable,\n                        'version': {\n                            'full': sys.version.split()[0],\n                            'major': sys.version_info.major,\n                            'minor': sys.version_info.minor,\n                            'micro': sys.version_info.micro,\n                        }\n                    }\n                }\n            }\n            cli_args.extend(['--extra-vars', str(ir_extras)])\n\n        cli = PlaybookCLI(cli_args)\n        LOG.debug('Starting ansible cli with args: {}'.format(cli_args[1:]))\n        try:\n            cli.parse()\n\n            stdout = not bool(\n                strtobool(os.environ.get('IR_ANSIBLE_NO_STDOUT', 'no')))\n            stderr = not bool(\n                strtobool(os.environ.get('IR_ANSIBLE_NO_STDERR', 'no')))\n\n            ansible_outputs_dir = \\\n                os.path.join(ir_workspace.path, 'ansible_outputs')\n            ansible_vars_dir = \\\n                os.path.join(ir_workspace.path, 'ansible_vars')\n\n            timestamp = datetime.utcnow().strftime(\"%Y-%m-%d_%H-%M-%S.%f\")\n            filename_template = \\\n                \"ir_{timestamp}_{plugin_name}{postfix}.{file_ext}\"\n\n            for _dir in (ansible_outputs_dir, ansible_vars_dir):\n                try:\n                    os.makedirs(_dir)\n                except OSError as e:\n                    if e.errno != errno.EEXIST:\n                        raise\n\n            if bool(strtobool(os.environ.get('IR_GEN_VARS_JSON', 'no'))):\n                filename = filename_template.format(\n                    timestamp=timestamp,\n                    plugin_name=ir_plugin.name,\n                    postfix='',\n                    file_ext='json'\n                )\n                vars_file = os.path.join(ansible_vars_dir, filename)\n                with open(vars_file, 'w') as fp:\n                    json.dump(vars_dict, fp, indent=4, sort_keys=True)\n\n            with IRSTDFDManager(stdout=stdout, stderr=stderr) as fd_manager:\n\n                if bool(strtobool(os.environ.get(\n                        'IR_ANSIBLE_LOG_OUTPUT', 'no'))):\n                    filename = filename_template.format(\n                        timestamp=timestamp,\n                        plugin_name=ir_plugin.name,\n                        postfix='',\n                        file_ext='log'\n                    )\n                    log_file = os.path.join(ansible_outputs_dir, filename)\n                    fd_manager.add(open(log_file, 'w'))\n\n                if bool(strtobool(os.environ.get(\n                        'IR_ANSIBLE_LOG_OUTPUT_NO_ANSI', 'no'))):\n                    filename = filename_template.format(\n                        timestamp=timestamp,\n                        plugin_name=ir_plugin.name,\n                        postfix='_no_ansi',\n                        file_ext='log'\n                    )\n                    log_file = os.path.join(ansible_outputs_dir, filename)\n                    fd_manager.add(NoAnsiFile(open(log_file, 'w')))\n\n                # Return the result:\n                # 0: Success\n                # 1: \"Error\"\n                # 2: Host failed\n                # 3: Unreachable\n                # 4: Parser Error\n                # 5: Options error\n\n                return cli.run()\n\n        except (AnsibleParserError, AnsibleOptionsError) as error:\n            LOG.error('{}: {}'.format(type(error), error))\n            raise error", "signature": "def _run_playbook(cli_args, vars_dict, ir_workspace, ir_plugin):", "completion_path": "infrared/core/execute.py"}
{"ce_id": "63060ada73426c38ae68ad31", "namespace": "63060ada73426c38ae68ad31", "namespace_real": "infrared.core.inspector.inspector._convert_non_cli_args", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "inspector", "function_name": "_convert_non_cli_args", "contexts_above": "import collections\nimport os\nfrom six.moves import configparser\nfrom string import Template\nimport yaml\n\nfrom infrared.core.cli.cli import CliParser\nfrom infrared.core.cli.cli import COMPLEX_TYPES\nfrom infrared.core.inspector import helper\nfrom infrared.core.utils import dict_utils\nfrom infrared.core.utils import exceptions\nfrom infrared.core.utils import logger\n\nLOG = logger.LOG\n\n\nclass SpecParser(object):\n    \"\"\"Parses input arguments from different sources (cli, answers file). \"\"\"\n\n    @classmethod\n    def from_plugin(cls, subparser, plugin, base_groups):\n        \"\"\"Reads spec & vars from plugin and constructs the parser instance\n\n        :param subparser: argparse.subparser to extend\n        :param plugin: InfraredPlugin object\n        :param base_groups: dict, included groups\n        :return: SpecParser object based on given plugin spec & vars\n        \"\"\"\n\n        spec_dict = base_groups or {}\n        with open(plugin.spec) as stream:\n            spec = yaml.safe_load(stream) or {}\n            dict_utils.dict_merge(\n                base_groups,\n                spec,\n                dict_utils.ConflictResolver.unique_append_list_resolver)\n\n        # The \"try-excpet\" block here is for adding spec file path if it\n        # includes an unsupported option type\n        try:\n            return SpecParser(subparser, spec_dict, plugin.vars_dir,\n                              plugin.defaults_dir, plugin.path)\n        except exceptions.IRUnsupportedSpecOptionType as ex:\n            ex.message += ' in file: {}'.format(plugin.spec)\n            raise ex\n\n    def __init__(self, subparser, spec_dict, vars_dir, defaults_dir,\n                 plugin_path):\n        \"\"\"Constructor.\n\n        :param subparser: argparse.subparser to extend\n        :param spec_dict: dict with CLI description\n        :param vars_dir: Path to plugin's vars dir\n        :param defaults_dir: Path to plugin's defaults dir\n        \"\"\"\n        self.vars = vars_dir\n        self.defaults = defaults_dir\n        self.plugin_path = plugin_path\n        self.spec_helper = helper.SpecDictHelper(spec_dict)\n\n        # create parser\n        self.parser = CliParser.create_parser(self, subparser)\n\n    def add_shared_groups(self, list_of_groups):\n        \"\"\"Adds the user defined shared groups\n\n        :param list_of_groups: list, of group dicts\n        \"\"\"\n        shared_groups = self.spec_helper.spec_dict.get('shared_groups', [])\n        shared_groups.expand(list_of_groups)\n        self.spec_helper.spec_dict['shared_groups'] = shared_groups\n\n    def _get_defaults(self, default_getter_func):\n        \"\"\"Resolve arguments' values from cli or answers file.\n\n        :param default_getter_func: callable. will be called for all the\n            available options in spec file.\n        \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            default_value = default_getter_func(option)\n            if default_value is not None:\n                sub = parser['name']\n                result[sub][option['name']] = default_value\n\n        return result\n\n    def get_spec_defaults(self):\n        \"\"\"Resolve arguments' values from spec and other sources. \"\"\"\n\n        def spec_default_getter(option):\n            \"\"\"Getter function to retrieve the default value from spec.\n\n            :param option: argument name\n            \"\"\"\n\n            # first try to get environment variable with IR_ prefix\n            default_value = SpecParser.get_env_option(option['name'])\n            if default_value is not None:\n                LOG.info(\n                    \"[environ] Loading '{0}' default value\"\n                    \" '{1}' from the environment variable\".format(\n                        option['name'], default_value))\n            elif option.get('default', None) is not None:\n                default_value = option['default']\n            elif option.get('action', None) in ['store_true']:\n                default_value = False\n            return default_value\n\n        return self._get_defaults(spec_default_getter)\n\n    @staticmethod\n    def get_env_option(name):\n        \"\"\"Try get \"\"\"\n        return os.environ.get('IR_' + name.upper().replace('-', '_'))\n\n    def get_deprecated_args(self):\n        \"\"\"Returning dict with options which deprecate others. \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            if option.get('deprecates') is not None:\n                result[option.get('deprecates')] = option.get('name')\n\n        return result\n\n    @staticmethod\n    def parse_env_variable_from_file(value):\n        if isinstance(value, str):\n            t = Template(value)\n            try:\n                value = t.substitute(os.environ)\n            except KeyError as undefined_var:\n                raise exceptions.IRAnswersFileEnvVarNotDefined(undefined_var)\n        return value\n\n    def get_answers_file_args(self, cli_args):\n        \"\"\"Resolve arguments' values from answers INI file. \"\"\"\n\n        file_result = {}\n        args_to_remove = []\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            file_result[parser_name] = file_result.get(parser_name, {})\n            if option_spec and option_spec.get(\n                    'action', '') == 'read-answers':\n                # Iterate over arguments supplied by file\n                for parsed_arg in parser_dict[arg_name]:\n                    # Supplied arguments' value can be a list\n                    if isinstance(parser_dict[arg_name][parsed_arg], list):\n                        i = 0\n                        # Iterrate over argument values list\n                        for parsed_value in parser_dict[arg_name][parsed_arg]:\n                            parser_dict[arg_name][parsed_arg][i] = \\\n                                SpecParser.parse_env_variable_from_file(parsed_value)\n                            i += 1\n                    else:\n                        parser_dict[arg_name][parsed_arg] = \\\n                            SpecParser.parse_env_variable_from_file(parser_dict[arg_name][parsed_arg])\n                # we have config option. saving it.\n                self._convert_non_cli_args(\n                    parser_name, parser_dict[arg_name])\n                dict_utils.dict_merge(\n                    file_result[parser_name],\n                    parser_dict[arg_name])\n                # remove from cli args\n                args_to_remove.append((parser_name, arg_name))\n\n        # remove parser dict outside loop to avoid iteration dict modification\n        for parser_name, arg_name in args_to_remove:\n            for spec_parser in self.spec_helper.iterate_parsers():\n                if spec_parser['name'] in cli_args and spec_parser['name'] == parser_name:\n                    parser_dict = cli_args[spec_parser['name']]\n                    parser_dict.pop(arg_name)\n                    break\n\n        return file_result\n\n    def generate_answers_file(self, cli_args, spec_defaults):\n        \"\"\"Generates answers INI file\n\n        :param cli_args: list, cli arguments.\n        :param spec_defaults: the default values.\n        \"\"\"\n\n        def put_option(config, parser_name, option_name, value):\n            for opt_help in option.get('help', '').split('\\n'):\n                help_opt = '# ' + opt_help\n\n                # add help comment\n                if config.has_option(parser_name, help_opt):\n                    config.remove_option(parser_name, help_opt)\n                config.set(\n                    parser_name, help_opt)\n\n            if config.has_option(parser_name, option_name):\n                value = config.get(parser_name, option_name)\n                config.remove_option(parser_name, option_name)\n\n            config.set(\n                parser_name,\n                option_name,\n                str(value))\n\n        file_generated = False\n\n        # load generate answers file for all the parsers\n        for (parser_name, parser_dict, arg_name, arg_value,\n             option_spec) in self._iterate_received_arguments(cli_args):\n            if option_spec and option_spec.get(\n                    'action', '') == 'generate-answers':\n                options_to_save = \\\n                    self.spec_helper.get_parser_option_specs(parser_name)\n                out_answers = configparser.ConfigParser(allow_no_value=True)\n\n                if not out_answers.has_section(parser_name):\n                    out_answers.add_section(parser_name)\n\n                for option in options_to_save:\n                    opt_name = option['name']\n                    if opt_name in parser_dict:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            parser_dict[opt_name])\n                    elif opt_name in spec_defaults[parser_name]:\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            opt_name,\n                            spec_defaults[parser_name][opt_name])\n                    elif option.get('required', False):\n                        put_option(\n                            out_answers,\n                            parser_name,\n                            '# ' + opt_name,\n                            \"Required argument. \"\n                            \"Edit with one of the allowed values OR \"\n                            \"override with \"\n                            \"CLI: --{}=<option>\".format(opt_name))\n\n                # write to file\n                with open(arg_value, 'w') as answers_file:\n                    out_answers.write(answers_file)\n                file_generated = True\n\n        return file_generated\n\n    def resolve_custom_types(self, args):\n        \"\"\"Transforms the arguments with custom types\n\n        :param args: the list of received arguments.\n        \"\"\"\n        for parser_name, parser_dict in args.items():\n            spec_complex_options = [opt for opt in\n                                    self.spec_helper.get_parser_option_specs(\n                                        parser_name) if\n                                    opt.get('type', None) in COMPLEX_TYPES]\n            for spec_option in spec_complex_options:\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # we have custom type to resolve\n                    type_name = spec_option['type']\n                    option_value = parser_dict[option_name]\n                    action = self.create_complex_argumet_type(\n                        parser_name,\n                        type_name,\n                        option_name,\n                        spec_option)\n\n                    # resolving value\n                    parser_dict[option_name] = action.resolve(option_value)\n\n    def create_complex_argumet_type(self, subcommand, type_name, option_name,\n                                    spec_option):\n        \"\"\"Build the complex argument type\n\n        :param subcommand: the command name\n        :param type_name: the complex type name\n        :param option_name: the option name\n        :param spec_option: option's specifications\n        :return: the complex type instance\n        \"\"\"\n        complex_action = COMPLEX_TYPES.get(\n            type_name, None)\n        if complex_action is None:\n            raise exceptions.SpecParserException(\n                \"Unknown complex type: {}\".format(type_name))\n        return complex_action(\n            option_name,\n            (self.vars, self.defaults, self.plugin_path),\n            subcommand,\n            spec_option)\n\n    def parse_args(self, arg_parser, args=None):\n        \"\"\"Parses all the arguments (cli, answers file)\n\n        :return: None, if ``--generate-answers-file`` in arg_arg_parser\n        :return: (dict, dict):\n            * command arguments dict (arguments to control the IR logic)\n            * nested arguments dict (arguments to pass to the playbooks)\n        \"\"\"\n\n        spec_defaults = self.get_spec_defaults()\n        cli_args = CliParser.parse_cli_input(arg_parser, args)\n\n        file_args = self.get_answers_file_args(cli_args)\n\n        # generate answers file and exit\n        if self.generate_answers_file(cli_args, spec_defaults):\n            LOG.warning(\"Answers file generated. Exiting.\")\n\n        # print warnings when something was overridden from non-cli source.\n        self.validate_arg_sources(cli_args, file_args,\n                                  spec_defaults)\n\n        # print warnings for deprecated\n        self.validate_arg_deprecation(cli_args, file_args)\n\n        # now filter defaults to have only parser defined in cli\n        defaults = dict((key, spec_defaults[key])\n                        for key in cli_args.keys() if\n                        key in spec_defaults)\n\n        # copy cli args with the same name to all parser groups\n        self._merge_duplicated_cli_args(cli_args)\n        self._merge_duplicated_cli_args(file_args)\n\n        dict_utils.dict_merge(defaults, file_args)\n        dict_utils.dict_merge(defaults, cli_args)\n        self.validate_requires_args(defaults)\n        self.validate_length_args(defaults)\n        self.validate_choices_args(defaults)\n        self.validate_min_max_args(defaults)\n\n        # now resolve complex types.\n        self.resolve_custom_types(defaults)\n        nested, control, custom = \\\n            self.get_nested_custom_and_control_args(defaults)\n        return nested, control, custom\n\n    def validate_arg_deprecation(self, cli_args, answer_file_args):\n        \"\"\"Validates and prints the deprecated arguments.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        \"\"\"\n\n        for deprecated, deprecates in self.get_deprecated_args().items():\n            for input_args in (answer_file_args.items(), cli_args.items()):\n                for command, command_dict in input_args:\n                    if deprecated in command_dict:\n                        if deprecates in command_dict:\n                            raise exceptions.IRDeprecationException(\n                                \"[{}] Argument '{}' deprecates '{}',\"\n                                \" please use only the new one.\".format(\n                                    command, deprecated, deprecates))\n\n                        if deprecated in answer_file_args[command]:\n                            answer_file_args[command][deprecates] = \\\n                                answer_file_args[command][deprecated]\n\n                        if deprecated in cli_args[command]:\n                            cli_args[command][deprecates] = \\\n                                cli_args[command][deprecated]\n\n                        LOG.warning(\n                            \"[{}] Argument '{}' was deprecated,\"\n                            \" please use '{}'.\".format(\n                                command, deprecated, deprecates))\n\n    @staticmethod\n    def validate_arg_sources(cli_args, answer_file_args, spec_defaults):\n        \"\"\"Validates and prints the arguments' source.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        :param spec_defaults:  the default values from spec files\n        \"\"\"\n\n        def show_diff(diff, command_name, cmd_dict, source_name):\n            if diff:\n                for arg_name in diff:\n                    value = cmd_dict[arg_name]\n                    LOG.info(\n                        \"[{}] Argument '{}' was set to\"\n                        \" '{}' from the {} source.\".format(\n                            command_name, arg_name, value, source_name))\n\n        for command, command_dict in cli_args.items():\n            file_dict = answer_file_args.get(command, {})\n            file_diff = set(file_dict.keys()) - set(command_dict.keys())\n            show_diff(file_diff, command, file_dict, 'answers file')\n\n            def_dict = spec_defaults.get(command, {})\n            default_diff = set(def_dict.keys()) - set(\n                command_dict.keys()) - file_diff\n            show_diff(default_diff, command, def_dict, 'spec defaults')\n\n    def _get_conditionally_required_args(self, command_name, options_spec,\n                                         args):\n        \"\"\"List arguments with ``required_when`` condition matched.\n\n        :param command_name: the command name.\n        :param options_spec:  the list of command spec options.\n        :param args: the received input arguments\n        :return: list, list of argument names with matched ``required_when``\n            condition\n        \"\"\"\n        opts_names = [option_spec['name'] for option_spec in options_spec]\n        missing_args = []\n        for option_spec in options_spec:\n            option_results = []\n            if option_spec and 'required_when' in option_spec:\n                req_when_args = [option_spec['required_when']] \\\n                    if not type(option_spec['required_when']) is list \\\n                    else option_spec['required_when']\n\n                # validate conditions\n                for req_when_arg in req_when_args:\n                    splited_args_list = req_when_arg.split()\n                    for idx, req_arg in enumerate(splited_args_list):\n                        if req_arg in opts_names:\n                            splited_args_list[idx] = \\\n                                args.get(command_name, {}).get(req_arg.strip())\n                        if splited_args_list[idx] is None:\n                            option_results.append(False)\n                            break\n                        splited_args_list[idx] = str(splited_args_list[idx])\n                        if (splited_args_list[idx] not in ['and', 'or'] and\n                            not any(\n                                (c in '<>=') for c in splited_args_list[idx])):\n                            splited_args_list[idx] = \"'{0}'\".format(\n                                yaml.safe_load(splited_args_list[idx]))\n                    else:\n                        option_results.append(\n                            eval(' '.join(splited_args_list)))\n                if all(option_results) and \\\n                        self.spec_helper.get_option_state(\n                            command_name,\n                            option_spec['name'],\n                            args) == helper.OptionState['NOT_SET']:\n                    missing_args.append(option_spec['name'])\n        return missing_args\n\n    def validate_requires_args(self, args):\n        \"\"\"Check if all the required arguments have been provided. \"\"\"\n\n        silent_args = self.get_silent_args(args)\n\n        def validate_parser(parser_name, expected_options, parser_args):\n            \"\"\"Helper method to resolve dict_merge. \"\"\"\n\n            result = collections.defaultdict(list)\n            condition_req_args = self._get_conditionally_required_args(\n                parser_name, expected_options, args)\n\n            for option in expected_options:\n                name = option['name']\n\n                # check required options.\n                if (option.get('required', False) and\n                    name not in parser_args or\n                    option['name'] in condition_req_args) and \\\n                        name not in silent_args:\n                    result[parser_name].append(name)\n\n            return result\n\n        res = {}\n        for command_data in self.spec_helper.iterate_parsers():\n            cmd_name = command_data['name']\n            if cmd_name in args:\n                dict_utils.dict_merge(\n                    res,\n                    validate_parser(\n                        cmd_name,\n                        self.spec_helper.get_parser_option_specs(cmd_name),\n                        args[cmd_name]))\n\n        missing_args = dict((cmd_name, args)\n                            for cmd_name, args in res.items() if len(args) > 0)\n        if missing_args:\n            raise exceptions.IRRequiredArgsMissingException(missing_args)\n\n    def validate_length_args(self, args):\n        \"\"\"Check if value of arguments is not longer than length specified.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if 'length' not in spec_option:\n                    # skip options that does not contain length\n                    continue\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # resolve length\n                    length = spec_option['length']\n                    option_value = parser_dict[option_name]\n                    if len(option_value) > int(length):\n                        # found invalid option, append to list of invalid opts\n                        invalid_options.append((\n                            option_name,\n                            option_value,\n                            length\n                        ))\n        if invalid_options:\n            # raise exception with all arguments that exceed length\n            raise exceptions.IRInvalidLengthException(invalid_options)\n\n    def validate_choices_args(self, args):\n        \"\"\"Check if value of choice arguments is one of the available choices.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if 'choices' not in spec_option:\n                    # skip options that does not contain choices\n                    continue\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # resolve choices\n                    choices = spec_option['choices']\n                    option_value = parser_dict[option_name]\n                    if option_value not in choices:\n                        # found invalid option, append to list of invalid opts\n                        invalid_options.append((\n                            option_name,\n                            option_value,\n                            choices\n                        ))\n        if invalid_options:\n            # raise exception with all arguments that contains invalid choices\n            raise exceptions.IRInvalidChoiceException(invalid_options)\n\n    def validate_min_max_args(self, args):\n        \"\"\"Check if value of arguments is between minimum and maximum values.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if all([key not in spec_option\n                        for key in ('maximum', 'minimum')]):\n                    # skip options that does not contain minimum or maximum\n                    continue\n                option_name = spec_option['name']\n\n                if option_name in parser_dict:\n                    option_value = parser_dict[option_name]\n                    min_value = spec_option.get('minimum')\n                    max_value = spec_option.get('maximum')\n                    # handle empty values in spec files which load as None\n                    min_value = '' if 'minimum' in spec_option \\\n                                      and min_value is None else min_value\n                    max_value = '' if 'maximum' in spec_option \\\n                                      and max_value is None else max_value\n\n                    values = {\n                        \"value\": option_value,\n                        \"maximum\": max_value,\n                        \"minimum\": min_value\n                    }\n\n                    # make sure that values are numbers\n                    is_all_values_numbers = True\n                    for name, num in values.items():\n                        if num is not None \\\n                                and (isinstance(num, bool) or\n                                     not isinstance(num, (int, float))):\n                            invalid_options.append((\n                                option_name,\n                                name,\n                                \"number\",\n                                type(num).__name__\n                            ))\n                            is_all_values_numbers = False\n\n                    if not is_all_values_numbers:\n                        # don't continue to min max checks since some of the\n                        # values are not numbers\n                        continue\n\n                    # check bigger than minimum\n                    if min_value is not None and option_value < min_value:\n                        invalid_options.append((\n                            option_name,\n                            \"minimum\",\n                            min_value,\n                            option_value\n                        ))\n                    # check smaller than maximum\n                    if max_value is not None and option_value > max_value:\n                        invalid_options.append((\n                            option_name,\n                            \"maximum\",\n                            max_value,\n                            option_value\n                        ))\n\n        if invalid_options:\n            # raise exception with all arguments that contains invalid choices\n            raise exceptions.IRInvalidMinMaxRangeException(invalid_options)\n\n    def get_silent_args(self, args):\n        \"\"\"list of silenced argument\n\n        :param args: The received arguments.\n        :return: list, slienced argument names\n        \"\"\"\n        silent_args_names = []\n        for (parser_name, parser_dict, arg_name, arg_value,\n             arg_spec) in self._iterate_received_arguments(args):\n            if arg_spec and 'silent' in arg_spec and \\\n                    self.spec_helper.get_option_state(\n                        parser_name,\n                        arg_name,\n                        args) == helper.OptionState['IS_SET']:\n                silent_args_names.extend(arg_spec['silent'])\n\n        return list(set(silent_args_names))\n\n    def get_nested_custom_and_control_args(self, args):\n        \"\"\"Split input arguments to control nested and custom.\n\n        Controls arguments: control the IR behavior. These arguments\n            will not be put into the spec yml file\n        Nested arguments: are used by the Ansible playbooks and will be put\n            into the spec yml file.\n        Custom arguments: Custom ansible variables to be used instead of the\n            normal nested usage.\n\n        :param args: the collected list of args.\n        :return: (dict, dict): flat dicts (control_args, nested_args)\n        \"\"\"\n        # returns flat dicts\n        nested = {}\n        control_args = {}\n        custom_args = {}\n        for (parser_name, parser_dict, arg_name, arg_value,\n             arg_spec) in self._iterate_received_arguments(args):\n            if all([arg_spec, arg_spec.get('type', None),\n                    arg_spec.get('type', None) in\n                    [ctype_name for ctype_name, klass in\n                     COMPLEX_TYPES.items() if klass.is_nested]\n                    ]) or ('is_shared_group_option' not in arg_spec):\n                if arg_name in nested:\n                    LOG.warning(\n                        \"Duplicated nested argument found:'{}'. \"\n                        \"Using old value: '{}'\".format(\n                            arg_name, nested[arg_name]))\n                elif arg_name in custom_args:\n                    LOG.warning(\n                        \"Duplicated custom argument found:'{}'. \"\n                        \"Using old value: '{}'\".format(\n                            arg_name, custom_args[arg_name]))\n                else:\n                    if \"ansible_variable\" in arg_spec:\n                        custom_args[arg_spec[\"ansible_variable\"]] = arg_value\n                    else:\n                        nested[arg_name] = arg_value\n            else:\n                if arg_name in control_args:\n                    LOG.warning(\n                        \"Duplicated control argument found: '{}'. Using \"\n                        \"old value: '{}'\".format(\n                            arg_name, control_args[arg_name]))\n                else:\n                    control_args[arg_name] = arg_value\n\n        return nested, control_args, custom_args\n\n    def _iterate_received_arguments(self, args):\n        \"\"\"Iterator helper method over all the received arguments\n\n        :return: yields tuple:\n            (spec name, spec dict,\n             argument name, argument value, argument spec)\n        \"\"\"\n        for spec_parser in self.spec_helper.iterate_parsers():\n            if spec_parser['name'] in args:\n                parser_dict = args[spec_parser['name']]\n                for arg_name, arg_val in parser_dict.items():\n                    arg_spec = self.spec_helper.get_option_spec(\n                        spec_parser['name'], arg_name)\n                    yield (spec_parser['name'], parser_dict,\n                           arg_name, arg_val, arg_spec)\n", "contexts_below": "    def _merge_duplicated_cli_args(self, cli_args):\n         \"\"\"Merge duplicated arguments to all the parsers\n \n         This is need to handle control args, shared among several parsers.\n         for example, verbose, inventory\n         \"\"\"\n         for (parser_name, parser_dict, arg_name, arg_value,\n              arg_spec) in self._iterate_received_arguments(cli_args):\n             for parser_name2, parser_dict2 in cli_args.items():\n                 if all([parser_name2, parser_name != parser_name2,\n                         arg_name not in parser_dict2]):\n                     if self.spec_helper.get_option_spec(parser_name2,\n                                                         arg_name):\n                         parser_dict2[arg_name] = arg_value\n ", "input_code": "def _convert_non_cli_args(self, parser_name, values_dict):\n\"\"\"\nCasts arguments to correct types by modifying values_dict param.\n\nBy default all the values are strings.\n\n:param parser_name: The command name, e.g. main, virsh, ospd, etc\n:param values_dict: The dict of with arguments\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def _convert_non_cli_args(self, parser_name, values_dict):\n        \"\"\"Casts arguments to correct types by modifying values_dict param.\n\n        By default all the values are strings.\n\n        :param parser_name: The command name, e.g. main, virsh, ospd, etc\n        :param values_dict: The dict of with arguments\n       \"\"\"\n        for opt_name, opt_value in values_dict.items():\n            file_option_spec = self.spec_helper.get_option_spec(\n                parser_name, opt_name)\n            if file_option_spec.get('type', None) in ['int', ] or \\\n                    file_option_spec.get('action', None) in ['count', ]:\n                values_dict[opt_name] = int(opt_value)", "signature": "def _convert_non_cli_args(self, parser_name, values_dict):", "completion_path": "infrared/core/inspector/inspector.py"}
{"ce_id": "63060b1a73426c38ae68ad3e", "namespace": "63060b1a73426c38ae68ad3e", "namespace_real": "tests.test_plugins.get_plugin_spec_flatten_dict", "real_proj_path": "redhat-openstack---infrared/", "type": "function", "class_name": null, "function_name": "get_plugin_spec_flatten_dict", "contexts_above": "from six.moves import configparser\nimport os\nimport git\nimport yaml\nimport shutil\nimport sys\nimport tarfile\nimport tempfile\nimport filecmp\n\nimport pytest\n\nfrom infrared.core.utils.exceptions import IRPluginExistsException, \\\n    IRUnsupportedPluginType\nfrom infrared.core.utils.exceptions import IRFailedToAddPlugin\nfrom infrared.core.utils.exceptions import IRValidatorException\nfrom infrared.core.utils.exceptions import IRFailedToRemovePlugin\nfrom infrared.core.utils.exceptions import IRFailedToUpdatePlugin\nfrom infrared.core.utils.exceptions import IRUnsupportedSpecOptionType\nfrom infrared.core.utils.dict_utils import dict_insert\nimport infrared.core.services.plugins\nfrom infrared.core.services.plugins import InfraredPluginManager\nfrom infrared.core.services.plugins import InfraredPlugin\nfrom infrared.core.utils.validators import SpecValidator, RegistryValidator\nfrom infrared.core.services import CoreServices, ServiceName\n\n\nPLUGIN_SPEC = 'plugin.spec'\nSAMPLE_PLUGINS_DIR = 'tests/example/plugins'\n\nSUPPORTED_TYPES_DICT = dict(\n    supported_types=dict(\n        supported_type1='Tools of supported_type1',\n        supported_type2='Tools of supported_type2',\n        provision='Provisioning plugins',\n        install='Installing plugins',\n        test='Testing plugins'\n    )\n)\n\n\n@pytest.fixture()\ndef plugins_conf_fixture(tmpdir):\n    \"\"\"Creates temporary IR\n\n    :param tmpdir: builtin pytest fixtures to create temporary files & dirs\n    :return: plugins conf file as a LocalPath object (py.path)\n    \"\"\"\n\n    # Creates temporary plugins conf file\n    lp_dir = tmpdir.mkdir('test_tmp_dir')\n    lp_file = lp_dir.join('.plugins.ini')\n\n    try:\n        yield lp_file\n    finally:\n        lp_dir.remove()\n\n\n@pytest.fixture()\ndef plugin_manager_fixture(plugins_conf_fixture):\n    \"\"\"Creates a PluginManager fixture\n\n    Creates a fixture which returns a PluginManager object based on\n    temporary plugins conf with default values(sections - provision, install &\n    test)\n    :param plugins_conf_fixture: fixture that returns a path of a temporary\n    plugins conf\n    \"\"\"\n\n    lp_file = plugins_conf_fixture\n\n    def plugin_manager_helper(plugins_conf_dict=None):\n\n        if plugins_conf_dict is None:\n            plugins_conf_dict = {}\n\n        plugins_conf_dict.update(SUPPORTED_TYPES_DICT)\n\n        with lp_file.open(mode='w') as fp:\n            config = configparser.ConfigParser()\n            for section, section_data in plugins_conf_dict.items():\n                config.add_section(section)\n                for option, value in section_data.items():\n                    config.set(section, option, value)\n            config.write(fp)\n\n        CoreServices.register_service(\n            ServiceName.PLUGINS_MANAGER, InfraredPluginManager(\n                lp_file.strpath,\n                os.path.join(lp_file.dirname, \"plugins\")))\n        return CoreServices.plugins_manager()\n\n    yield plugin_manager_helper\n\n\n@pytest.fixture()\ndef git_plugin_manager_fixture(tmpdir, plugin_manager_fixture):\n    \"\"\"Yields an IRPluginManager obj configured with git plugin\n\n    Just like plugin_manager_fixture but also create two temporary directories\n    that will be used to mimic local and remote git repos of an InfraRed's\n    plugin. The IRPluginManager that will be returned, will be configured with\n    this InfraRed git plugin.\n    :param tmpdir: builtin pytest fixtures to create temporary files & dirs\n    :param plugin_manager_fixture: Fixture object which yields\n    InfraredPluginManger object\n    \"\"\"\n    plugin_tar_gz = os.path.join(\n        os.path.dirname(os.path.realpath(__file__)),\n        'example/plugins/git_plugin/git_plugin_repo.tar.gz')\n\n    plugin_repo_dir = tmpdir.mkdir('plugin_repo_dir')\n    plugin_install_dir = tmpdir.mkdir('plugin_install_dir')\n\n    t_file = tarfile.open(plugin_tar_gz)\n    t_file.extractall(path=str(plugin_repo_dir))\n\n    repo = git.Repo.clone_from(\n        url=str(plugin_repo_dir),\n        to_path=str(plugin_install_dir))\n\n    repo.git.config('user.name', 'dummy-user')\n    repo.git.config('user.email', 'dummy@email.com')\n\n    plugin_spec_dict = get_plugin_spec_flatten_dict(str(plugin_install_dir))\n\n    try:\n        plugin_manager = plugin_manager_fixture({\n            plugin_spec_dict['type']: {\n                plugin_spec_dict['name']: str(plugin_install_dir)}\n        })\n        yield plugin_manager\n    finally:\n        plugin_repo_dir.remove()\n        plugin_install_dir.remove()\n\n", "contexts_below": "\n def plugin_in_conf(plugins_conf, plugin_type, plugin_name):\n     \"\"\"Checks if a plugin exists in a conf file\n \n     :param plugins_conf: A path to the plugins conf file\n     :param plugin_type: The plugin's type\n     :param plugin_name: The Plugin's name\n     :return: True if plugin is in the conf file, otherwise False\n     \"\"\"\n     config = configparser.ConfigParser()\n     with open(plugins_conf) as fp:\n         if (sys.version_info > (3, 2)):\n             config.read_file(fp)\n         else:\n             config.readfp(fp)\n \n     return config.has_option(plugin_type, plugin_name)\n \n \n def test_add_plugin(plugin_manager_fixture):\n     \"\"\"Tests the ability to add plugins\n \n     :param plugin_manager_fixture: Fixture object which yields\n     InfraredPluginManger object\n     \"\"\"\n \n     plugin_manager = plugin_manager_fixture()\n \n     for plugin_dir, plugins_cnt in (\n             ('type1_plugin1', 1),   # Add a plugin\n             ('type1_plugin2', 2),   # Add a plugin - same type\n             ('type2_plugin1', 3)):  # Add a plugin - different type\n \n         plugin_dict = get_plugin_spec_flatten_dict(\n             os.path.join(SAMPLE_PLUGINS_DIR, plugin_dir))\n \n         plugin_manager.add_plugin(plugin_dict['dir'])\n \n         assert plugin_dict['name'] in plugin_manager.PLUGINS_DICT,\\\n             \"Plugin wasn't added to the plugins manager.\"\n         assert plugin_in_conf(\n             plugins_conf=plugin_manager.config_file,\n             plugin_type=plugin_dict['type'],\n             plugin_name=plugin_dict['name']), \\\n             \"Plugin wasn't added to conf file.\"\n         assert len(plugin_manager.PLUGINS_DICT) == plugins_cnt\n \n \n def test_load_plugin(plugin_manager_fixture):\n     \"\"\"Test that an existing plugin can be loaded and it's properties\n \n     :param plugin_manager_fixture: Fixture object which yields\n     InfraredPluginManger object\n     \"\"\"\n \n     plugin_dir = 'type1_plugin1'\n     plugin_dict = get_plugin_spec_flatten_dict(\n         os.path.join(os.path.abspath(SAMPLE_PLUGINS_DIR), plugin_dir))\n \n     plugin_manager = plugin_manager_fixture({\n         plugin_dict['type']: {\n             plugin_dict['name']: plugin_dict['dir']}\n     })\n \n     plugin = plugin_manager.get_plugin(plugin_name=plugin_dict['name'])\n \n     assert type(plugin) is InfraredPlugin, \"Failed to add a plugin\"\n     assert plugin.name == plugin_dict['name'], \"Wrong plugin name\"\n     assert plugin.description == plugin_dict['description'], \\\n         'Wrong plugin description'\n \n \n def test_entry_point(plugin_manager_fixture):\n     \"\"\"Test that spec file has a valid entry point\n      :param plugin_manager_fixture: Fixture object which yields\n     InfraredPluginManger object\n     \"\"\"\n \n     plugin_dir = 'plugin_with_entry_point'\n     plugin_dict = get_plugin_spec_flatten_dict(\n         os.path.join(os.path.abspath(SAMPLE_PLUGINS_DIR), plugin_dir))\n \n     plugin_manager = plugin_manager_fixture({\n         plugin_dict['type']: {\n             plugin_dict['name']: plugin_dict['dir']}\n     })\n \n     plugin = plugin_manager.get_plugin(plugin_name=plugin_dict['name'])\n     assert plugin.playbook == os.path.join(plugin_dict['dir'], \"example.yml\")\n \n \n def test_add_plugin_with_same_name(plugin_manager_fixture):\n     \"\"\"Tests that it not possible to add a plugin with a name that already\n     exists\n \n     :param plugin_manager_fixture: Fixture object which yields\n     InfraredPluginManger object\n     \"\"\"\n \n     plugin_dir = 'type1_plugin1'\n     plugin_dict = get_plugin_spec_flatten_dict(\n         os.path.join(SAMPLE_PLUGINS_DIR, plugin_dir))\n \n     plugin_manager = plugin_manager_fixture({\n         plugin_dict['type']: {\n             plugin_dict['name']: plugin_dict['dir']}\n     })\n \n     plugins_cfg_mtime_before_add = os.path.getmtime(plugin_manager.config_file)\n     plugins_cnt_before_try = len(plugin_manager.PLUGINS_DICT)\n \n     with pytest.raises(IRPluginExistsException):\n         plugin_manager.add_plugin(plugin_dict['dir'])\n \n     assert plugins_cnt_before_try == len(plugin_manager.PLUGINS_DICT)\n     assert os.path.getmtime(\n         plugin_manager.config_file) == plugins_cfg_mtime_before_add, \\\n         \"Plugins configuration file has been modified.\"\n \n \n def test_add_plugin_unsupported_type(plugin_manager_fixture):\n     \"\"\"Test that it's not possible to add a plugin from unsupported type\n \n     :param plugin_manager_fixture: Fixture object which yields\n     InfraredPluginManger object\n     \"\"\"\n \n     plugin_manager = plugin_manager_fixture()\n \n     plugin_dict = get_plugin_spec_flatten_dict(\n         os.path.join(SAMPLE_PLUGINS_DIR, 'unsupported_plugin'))\n \n     plugins_cfg_mtime_before_add = os.path.getmtime(plugin_manager.config_file)\n     plugins_cnt_before_try = len(plugin_manager.PLUGINS_DICT)\n \n     with pytest.raises(IRUnsupportedPluginType):\n         plugin_manager.add_plugin(plugin_dict['dir'])\n \n     assert not plugin_in_conf(\n         plugins_conf=plugin_manager.config_file,\n         plugin_type=plugin_dict['type'],\n         plugin_name=plugin_dict['name']), \\\n         \"Plugin was added to conf file.\"\n     assert plugins_cnt_before_try == len(plugin_manager.PLUGINS_DICT)\n     assert os.path.getmtime(\n         plugin_manager.config_file) == plugins_cfg_mtime_before_add, \\\n         \"Plugins configuration file has been modified.\"\n \n \n def test_remove_plugin(plugin_manager_fixture):\n     \"\"\" Tests the ability to remove a plugin\n \n     :param plugin_manager_fixture: Fixture object which yields\n     InfraredPluginManger object\n     \"\"\"\n \n     plugins_conf = {}\n     for plugin_dir in ('type1_plugin1', 'type1_plugin2', 'type2_plugin1'):\n         plugin_dict = get_plugin_spec_flatten_dict(\n             os.path.join(os.path.abspath(SAMPLE_PLUGINS_DIR), plugin_dir))\n         dict_insert(plugins_conf,\n                     plugin_dict['dir'],\n                     plugin_dict['type'],\n                     plugin_dict['name'],)\n \n     plugin_manager = plugin_manager_fixture(plugins_conf)\n \n     for plugin_dir, plugins_cnt in (\n             ('type1_plugin1', 2),\n             ('type2_plugin1', 1),\n             ('type1_plugin2', 0)):\n         plugin_dict = get_plugin_spec_flatten_dict(\n             os.path.join(SAMPLE_PLUGINS_DIR, plugin_dir))\n \n         assert plugin_dict['name'] in plugin_manager.PLUGINS_DICT, \\\n             \"Can't remove unexisting plugin\"\n \n         plugin_manager.remove_plugin(plugin_dict['name'])\n \n         with pytest.raises(KeyError):\n             plugin_manager.get_plugin(plugin_name=plugin_dict['name'])\n \n         assert not plugin_in_conf(\n             plugins_conf=plugin_manager.config_file,\n             plugin_type=plugin_dict['type'],\n             plugin_name=plugin_dict['name']), \\\n             \"Plugin wasn't removed from conf file.\"\n         assert len(plugin_manager.PLUGINS_DICT) == plugins_cnt\n \n \n def test_remove_unexisting_plugin(plugin_manager_fixture):\n     \"\"\"Tests the behavior of removing unexisting plugin\n \n     Checks that no exception is being raised and no changes in\n     InfraredPluginManager dict and configuration file\n     :param plugin_manager_fixture: Fixture object which yields\n     InfraredPluginManger object\n     \"\"\"\n \n     plugin_manager = plugin_manager_fixture()\n \n     plugins_cfg_mtime_before_add = os.path.getmtime(plugin_manager.config_file)\n     plugins_cnt_before_try = len(plugin_manager.PLUGINS_DICT)\n \n     with pytest.raises(IRFailedToRemovePlugin):\n         plugin_manager.remove_plugin('unexisting_plugin')\n \n     assert plugins_cnt_before_try == len(plugin_manager.PLUGINS_DICT)\n     assert os.path.getmtime(\n         plugin_manager.config_file) == plugins_cfg_mtime_before_add, \\\n         \"Plugins configuration file has been modified.\"\n \n \n @pytest.mark.parametrize(\"input_args, plugins_conf\", [\n     (\"plugin list\", None),\n     (\"plugin add tests/example/plugins/type1_plugin1\", None),\n     (\"plugin remove type1_plugin1\", dict(\n         supported_type1=dict(\n             type1_plugin1='tests/example/plugins/type1_plugin1'))),\n     (\"plugin add \"\n      \"tests/example/plugins/type1_plugin1 \"\n      \"tests/example/plugins/type1_plugin2\", None),\n     (\"plugin remove type1_plugin1 type1_plugin2\", dict(\n             supported_type1=dict(\n                 type1_plugin1='tests/example/plugins/type1_plugin1',\n                 type1_plugin2='tests/example/plugins/type1_plugin2'))),\n ])\n def test_plugin_cli(plugin_manager_fixture, input_args, plugins_conf):\n     \"\"\"Tests that plugin CLI works\n \n     :param plugin_manager_fixture: Fixture object which yields\n     InfraredPluginManger object\n     :param input_args: infrared's testing arguments\n     :param plugins_conf: Plugins conf data as a dictionary\n     \"\"\"\n     plugin_manager_fixture(plugins_conf)\n \n     from infrared.main import main as ir_main\n     rc = ir_main(input_args.split())\n \n     assert rc == 0, \\\n         \"Return code ({}) != 0, cmd='infrared {}'\".format(rc, input_args)\n \n \n def test_add_plugin_no_spec(plugin_manager_fixture):\n     \"\"\"Tests that it's not possible to add plugin without a spec file\n \n     :param plugin_manager_fixture: Fixture object which yields\n     InfraredPluginManger object\n     \"\"\"\n \n     plugin_dir = os.path.join(SAMPLE_PLUGINS_DIR, 'plugin_without_spec')\n \n     plugin_manager = plugin_manager_fixture({})\n \n     plugins_cfg_mtime_before_add = os.path.getmtime(plugin_manager.config_file)\n     plugins_cnt_before_try = len(plugin_manager.PLUGINS_DICT)\n \n     with pytest.raises(IRValidatorException):\n         plugin_manager.add_plugin(plugin_dir)\n \n     assert plugins_cnt_before_try == len(plugin_manager.PLUGINS_DICT)\n     assert os.path.getmtime(\n         plugin_manager.config_file) == plugins_cfg_mtime_before_add, \\\n         \"Plugins configuration file has been modified.\"\n \n \n @pytest.mark.parametrize(\"description, plugin_spec\", [\n     ('no_description', {\n         'plugin_type': 'supported_type',\n         'subparsers': {\n             'sample_plugin1:': {}}}),\n     ('no_type', {\n         'description': 'some plugin description',\n         'subparsers': {\n             'sample_plugin1:': {}}}),\n     ('no_value', {\n         'plugin_type': '',\n         'subparsers': {\n             'sample_plugin1:': {}}}),\n     ('no_subparsers_key', {\n         'plugin_type': 'supported_type',\n         'description': 'some plugin description'}),\n     ('no_subparsers_value', {\n         'plugin_type': 'supported_type',\n         'description': 'some plugin description',\n         'subparsers': ''}),\n     ('no_entry_point_value',{\n         'plugin_type': 'supported_type',\n         'entry_point': '',\n         'subparsers': {\n             'sample_plugin1:': {}}}),\n     ('no_entry_point_value_in_config',{\n         'config': {\n             \"plugin_type\": 'supported_type',\n             \"entry_point\": '',\n         },\n         'subparsers': {\n             'sample_plugin1:': {}}}),\n     ('no_type_in_config', {\n         'config': {\n         },\n         'description': 'some plugin description',\n         'subparsers': {\n             'sample_plugin1:': {}}}),\n ])\n def test_add_plugin_corrupted_spec(tmpdir_factory, description, plugin_spec):\n     \"\"\"Tests that it's not possible to add a plugin with invalid spec file\n \n     :param tmpdir_factory: pytest builtin fixture for creating temp dirs\n     :param description: test description (adds a description in pytest run)\n     :param plugin_spec: dictionary with data for spec file\n     :return:\n     \"\"\"\n \n     lp_dir = tmpdir_factory.mktemp('test_tmp_dir')\n     lp_file = lp_dir.join('plugin.spec')\n \n     with open(lp_file.strpath, 'w') as fp:\n         yaml.dump(plugin_spec, fp, default_flow_style=True)\n \n     try:\n         with pytest.raises(IRValidatorException):\n             SpecValidator.validate_from_file(lp_file.strpath)\n     finally:\n         lp_dir.remove()\n \n \n def test_plugin_with_unsupporetd_option_type_in_spec(plugin_manager_fixture):\n     \"\"\"Tests that the user get a proper error\n \n     :param plugin_manager_fixture: Fixture object which yields\n     InfraredPluginManger object\n     \"\"\"\n     plugin_dir = os.path.join(SAMPLE_PLUGINS_DIR,\n                               'plugin_with_unsupported_option_type_in_spec')\n     plugin_dict = get_plugin_spec_flatten_dict(plugin_dir)\n \n     plugin_manager = plugin_manager_fixture()\n     plugin_manager.add_plugin(plugin_dir)\n \n     from infrared.main import main as ir_main\n     with pytest.raises(IRUnsupportedSpecOptionType):\n         ir_main([plugin_dict['name'], '--help'])\n \n \n def test_add_plugin_from_git(plugin_manager_fixture, mocker):\n \n     plugin_manager = plugin_manager_fixture()\n \n     mock_git = mocker.patch(\"infrared.core.services.plugins.git.Repo\")\n     mock_os = mocker.patch(\"infrared.core.services.plugins.os\")\n     mock_os.path.exists.return_value = False\n     mock_os.listdir.return_value = [\"sample_plugin\"]\n     mock_tempfile = mocker.patch(\"infrared.core.services.plugins.tempfile\")\n     mock_shutil = mocker.patch(\"infrared.core.services.plugins.shutil\")\n \n     plugin_dict = get_plugin_spec_flatten_dict(\n         os.path.join(SAMPLE_PLUGINS_DIR, 'type1_plugin1'))\n     mock_os.path.join.return_value = os.path.join(plugin_dict[\"dir\"],\n                                                   PLUGIN_SPEC)\n \n     # add_plugin call\n     plugin_manager.add_plugin(\n         \"https://sample_github.null/plugin_repo.git\", rev=\"test\",\n         skip_roles=True)\n \n     mock_tempfile.mkdtemp.assert_called_once()\n     mock_git.clone_from.assert_called_with(\n         url='https://sample_github.null/plugin_repo.git',\n         to_path=mock_os.path.join.return_value,\n         kill_after_timeout=300)\n     mock_os.join.has_call(SAMPLE_PLUGINS_DIR, mock_os.listdir.return_value[0])\n     mock_os.join.has_call(mock_tempfile.mkdtemp.return_value,\n                           mock_os.listdir.return_value[0])\n     mock_shutil.rmtree.assert_called_with(mock_os.path.join.return_value)\n \n \n def test_add_plugin_from_git_dirname_from_spec(plugin_manager_fixture, mocker):\n     \"\"\"\n     Validate that we take the folder name from the spec plugin name\n     instead of the git repo name\n     :param plugin_manager_fixture: Fixture object which yields\n     InfraredPluginManger object\n     :param mocker: mocker fixture\n     \"\"\"\n \n     def clone_from_side_effect(url, to_path, **kwargs):\n         \"\"\"\n         Define a side effect function to override the\n         original behaviour of clone_from\n         \"\"\"\n         shutil.copytree(src=plugin_dict[\"dir\"], dst=to_path)\n \n     plugin_manager = plugin_manager_fixture()\n \n     mock_git = mocker.patch(\"infrared.core.services.plugins.git.Repo\")\n     # use side effect to use copytree instead of original clone\n     mock_git.clone_from.side_effect = clone_from_side_effect\n     mock_os_path_exists = mocker.patch(\n         \"infrared.core.services.plugins.os.path.exists\")\n     # set to false in order to enter the git section\n     # in if/else inside add_plugin func\n     mock_os_path_exists.return_value = False\n     mock_tempfile = mocker.patch(\"infrared.core.services.plugins.tempfile\")\n     mock_tempfile.mkdtemp.return_value = tempfile.mkdtemp(prefix=\"ir-\")\n     mock_shutil = mocker.patch(\"infrared.core.services.plugins.shutil\")\n \n     plugin_dict = get_plugin_spec_flatten_dict(\n         os.path.abspath(os.path.join(SAMPLE_PLUGINS_DIR, 'type1_plugin1')))\n \n     # add_plugin call\n     with pytest.raises(IRFailedToAddPlugin):\n         plugin_manager.add_plugin(\n             \"https://sample_github.null/plugin_repo.git\")\n \n     mock_shutil.rmtree.assert_called_with(os.path.join(\n             mock_tempfile.mkdtemp.return_value, \"plugin_repo\"))\n     # clean tmp folder\n     shutil.rmtree(mock_tempfile.mkdtemp.return_value)\n \n     # check it was cloned with the temp name\n     mock_git.clone_from.assert_called_with(\n         url='https://sample_github.null/plugin_repo.git',\n         to_path=os.path.join(\n             mock_tempfile.mkdtemp.return_value, \"plugin_repo\"),\n         kill_after_timeout=300)\n \n     # check that it was copied with the plugin name and not repo name\n     mock_shutil.copytree.assert_called_with(\n         os.path.join(mock_tempfile.mkdtemp.return_value, \"plugin_repo\"),\n         os.path.join(plugin_manager.plugins_dir, plugin_dict[\"name\"]))\n \n \n def test_add_plugin_from_git_exception(plugin_manager_fixture, mocker):\n \n     plugin_manager = plugin_manager_fixture()\n \n     mock_git = mocker.patch(\"infrared.core.services.plugins.git\")\n     mock_git.Repo.clone_from.side_effect = git.exc.GitCommandError(\n         \"some_git_cmd\", 1)\n     mock_git.exc.GitCommandError = git.exc.GitCommandError\n     mock_tempfile = mocker.patch(\"infrared.core.services.plugins.tempfile\")\n     mock_shutil = mocker.patch(\"infrared.core.services.plugins.shutil\")\n     mock_os = mocker.patch(\"infrared.core.services.plugins.os\")\n     mock_os.path.exists.return_value = False\n \n     # add_plugin call\n     with pytest.raises(IRFailedToAddPlugin):\n         plugin_manager.add_plugin(\n             \"https://sample_github.null/plugin_repo.git\")\n \n     mock_shutil.rmtree.assert_called_with(mock_tempfile.mkdtemp.return_value)\n \n \n def validate_plugins_presence_in_conf(\n         plugin_manager, plugins_dict, present=True):\n     \"\"\"Validate presence of plugins in the configuration file\n \n     :param plugin_manager: InfraredPluginManager object\n     :param plugins_dict:  Dict of plugins\n     {plugin_name: plugin_dir_path, ...}\n     :param present: Whether all plugins in the dict should be present in the\n     plugins configuration file or not.\n     \"\"\"\n     assert present in (True, False), \\\n         \"'absent' accept only Boolean values, got: '{}'\".format(str(present))\n \n     with open(plugin_manager.config_file) as config_file:\n         plugins_cfg = configparser.ConfigParser()\n         if (sys.version_info > (3, 2)):\n             plugins_cfg.read_file(config_file)\n         else:\n             plugins_cfg.readfp(config_file)\n \n         for plugin_path in plugins_dict.values():\n             plugin = InfraredPlugin(plugin_path['src'])\n \n             if present:\n                 assert plugins_cfg.has_option(plugin.type, plugin.name), \\\n                     \"Plugin '{}' was suppose to be in the plugins \" \\\n                     \"configuration file\".format(plugin.name)\n             else:\n                 assert not plugins_cfg.has_option(plugin.type, plugin.name), \\\n                     \"Plugin '{}' wasn't suppose to be in the plugins \" \\\n                     \"configuration file\".format(plugin.name)\n \n \n def test_plugin_add_all(plugin_manager_fixture):\n     \"\"\"Tests the add and remove all plugins functioning\n \n     :param plugin_manager_fixture: Fixture object which yields\n     InfraredPluginManger object\n     \"\"\"\n     tests_plugins = (\n         'provision_plugin1', 'provision_plugin2',\n         'install_plugin1', 'install_plugin2',\n         'test_plugin1', 'test_plugin2'\n     )\n     tests_plugins_dir = 'tests/example/plugins/add_remove_all_plugins/'\n \n     plugins_registry = \\\n         dict((pname, {'src': os.path.join(tests_plugins_dir, pname)})\n              for pname in tests_plugins)\n \n     plugin_manager = plugin_manager_fixture()\n \n     # Validates that plugins aren't in configuration file from the beginning\n     validate_plugins_presence_in_conf(\n         plugin_manager, plugins_registry, present=False)\n \n     # Validates all plugins are in the configuration file\n     plugin_manager.add_all_available(plugins_registry=plugins_registry)\n     validate_plugins_presence_in_conf(\n         plugin_manager, plugins_registry, present=True)\n \n     # Validates all plugins are no longer in the configuration file\n     plugin_manager.remove_all()\n     validate_plugins_presence_in_conf(\n         plugin_manager, plugins_registry, present=False)\n \n \n def test_git_plugin_update(git_plugin_manager_fixture):\n     \"\"\"Tests the git plugin update functionality\n \n     Tests the following:\n       1. Plugin update without new changes\n       2. Plugin update to an older commit\n       3. No update when there are local changes\n       4. Switch back to master after checking out old revision\n       5. Switch to revision that does not exists\n     :param git_plugin_manager_fixture: Fixture object which yields\n     InfraredPluginManger object with git plugin installed\n     \"\"\"\n     gpm = git_plugin_manager_fixture\n \n     repo = git.Repo(gpm.get_plugin('git_plugin').path)\n     commits_list = repo.git.rev_list('HEAD').splitlines()\n \n     assert len(commits_list) > 1, \\\n         \"Can perform the test without at least two commits\"\n \n     # Plugin update without new changes\n     assert gpm.update_plugin('git_plugin') is None, \\\n         \"Failed to pull changes from remote with up-to-date local branch\"\n \n     # Plugin update to an older commit\n     gpm.update_plugin(plugin_name='git_plugin', revision=commits_list[-1])\n     assert commits_list[-1] == repo.git.rev_parse('HEAD'), \\\n         \"Failed to Update plugin to: {}\".format(commits_list[-1])\n \n     # No update when there are local changes\n     file_name = os.path.join(repo.working_dir, 'test.txt')\n     # create new file and add it to git to create local changes\n     with open(file_name, 'w') as f:\n         f.write('test')\n     repo.git.add([file_name])\n     with pytest.raises(IRFailedToUpdatePlugin):\n         gpm.update_plugin(plugin_name='git_plugin')\n     assert commits_list[-1] == repo.git.rev_parse('HEAD'), \\\n         \"Plugin wasn't supposed to be changed when update failed...\"\n \n     # Switch back to master after checking out old revision\n     gpm.update_plugin(plugin_name='git_plugin',\n                       revision='master', hard_reset=True)\n     assert commits_list[0] == repo.git.rev_parse('HEAD'), \\\n         \"Plugin haven't been updated from '{}' to '{}'\".format(\n             commits_list[-1], commits_list[0])\n \n     # Switch to revision that does not exists\n     branch_before = repo.active_branch\n     with pytest.raises(IRFailedToUpdatePlugin):\n         gpm.update_plugin(plugin_name='git_plugin', revision='not_exists_rev')\n     assert branch_before == repo.active_branch, \\\n         \"Plugin's revision wasn't supposed to change\"\n \n \n @pytest.mark.parametrize(\"description, registry_yaml\", [\n     ('no_type', {\n         'some_plugin_name': {\n             'src': '/path/to/plugin',\n             'desc': 'some plugin description'\n         }\n     }),\n     ('no_desc', {\n         'some_plugin_name': {\n             'src': '/path/to/plugin',\n             'type': 'supported_type'\n         }\n     }),\n     ('no_src', {\n         'some_plugin_name': {\n             'desc': 'some plugin description',\n             'type': 'supported_type'\n         }\n     }),\n     ('empty_revision', {\n         'some_plugin_name': {\n             'src': '/path/to/plugin',\n             'type': 'supported_type',\n             'desc': 'some plugin description',\n             'rev': ''\n         }\n     }),\n     ('empty_src_path', {\n         'some_plugin_name': {\n             'src': '/path/to/plugin',\n             'type': 'supported_type',\n             'desc': 'some plugin description',\n             'src_path': ''\n         }\n     }),\n     ('empty_plugin_key', {\n         '': {\n             'src': '/path/to/plugin',\n             'type': 'supported_type',\n             'desc': 'some plugin description',\n             'src_path': ''\n         }\n     }),\n     ('additional_not_allowed_param', {\n         '': {\n             'src': '/path/to/plugin',\n             'type': 'supported_type',\n             'desc': 'some plugin description',\n             'src_path': '/relative/path',\n             'rev': 'some_rev',\n             'not_allowed_additional_key': 'some_value'\n         }\n     }),\n ])\n def test_import_plugins_corrupted_registry(tmpdir_factory, description,\n                                            registry_yaml):\n     \"\"\"\n     Tests that it's not possible to import plugins with invalid registry file\n     :param tmpdir_factory: pytest builtin fixture for creating temp dirs\n     :param description: test description (adds a description in pytest run)\n     :param registry_yaml: dictionary with data for registry file\n     :return:\n     \"\"\"\n \n     lp_dir = tmpdir_factory.mktemp('test_tmp_dir')\n     lp_file = lp_dir.join('registry.yaml')\n \n     with open(lp_file.strpath, 'w') as fp:\n         yaml.dump(registry_yaml, fp, default_flow_style=True)\n \n     try:\n         with pytest.raises(IRValidatorException):\n             RegistryValidator.validate_from_file(lp_file.strpath)\n     finally:\n         lp_dir.remove()\n \n \n def test_import_plugins_from_registry(tmpdir, plugin_manager_fixture):\n     \"\"\"\n     Test that plugins import actually imports the plugins specified in the\n     registry file supplied\n     :param tmpdir: pytest builtin fixture for creating temp dirs\n     :param plugin_manager_fixture: Fixture object which yields\n     \"\"\"\n     plugin_manager = plugin_manager_fixture()\n     plugins_registry = os.path.join(SAMPLE_PLUGINS_DIR, \"registry_example.yml\")\n \n     with open(plugins_registry) as fp:\n         registry_yaml = yaml.safe_load(fp)\n \n     # prepare tmp library folder to hold the dependencies\n     tmp_pluginss_dir = str(tmpdir.mkdir(\"tmp_pluginss_dir\"))\n     plugin_manager.plugins_dir = tmp_pluginss_dir\n \n     # Validates that plugins aren't in configuration file from the beginning\n     validate_plugins_presence_in_conf(\n         plugin_manager, registry_yaml, present=False)\n \n     # import all plugins from registry\n     plugin_manager.import_plugins(plugins_registry)\n \n     # check that plugins were copied to the plugins directory\n     assert os.path.isdir(os.path.join(\n         tmp_pluginss_dir, 'type1_plugin1'))\n     assert os.path.isdir(os.path.join(\n         tmp_pluginss_dir, 'type2_plugin1'))\n     assert os.path.isdir(os.path.join(\n         tmp_pluginss_dir, 'type1_plugin2'))\n \n     # Validates all plugins are in the configuration file\n     validate_plugins_presence_in_conf(\n         plugin_manager, registry_yaml, present=True)\n \n \n def test_add_plugin_with_src_path(plugin_manager_fixture, mocker):\n     \"\"\"\n     Validates that add plugin copies the whole directory and only reference\n     to the plugin inside the directory\n     :param plugin_manager_fixture: Fixture object which yields\n     InfraredPluginManger object\n     :param mocker: mocker fixture\n     \"\"\"\n \n     def clone_from_side_effect(url, to_path, **kwargs):\n         \"\"\"\n         Define a side effect function to override the\n         original behaviour of clone_from\n         \"\"\"\n         shutil.copytree(src=plugin_src, dst=to_path)\n         return to_path\n \n     plugin_manager = plugin_manager_fixture()\n \n     mock_git = mocker.patch(\"infrared.core.services.plugins.git.Repo\")\n     # use side effect to use copytree instead of original clone\n     mock_git.clone_from.side_effect = clone_from_side_effect\n \n     plugin_src = os.path.abspath(os.path.join(SAMPLE_PLUGINS_DIR,\n                                               \"plugin_with_src_path\"))\n \n     # add_plugin call\n     plugin_manager.add_plugin(\n         plugin_source=\"https://sample_github.null/plugin_repo.git\",\n         plugin_src_path=\"infrared_plugin\")\n \n     plugin = plugin_manager.get_plugin(\"plugin_with_src_path\")\n     expected_plugin_path = os.path.join(plugin_manager.plugins_dir,\n                                         \"plugin_with_src_path\")\n \n     expected_plugin_src_path = \\\n         os.path.join(expected_plugin_path, \"infrared_plugin\")\n \n     assert expected_plugin_src_path == plugin.path, \\\n         \"Plugin path is not as expected\"\n \n     # compare the dirs before and after to make sure we copied it entirely\n     dirs_cmp = filecmp.dircmp(plugin_src, expected_plugin_path)\n     assert dirs_cmp.right_list == dirs_cmp.left_list, \\\n         \"Plugin directory is does not contain the original files from \" \\\n         \"the original plugin source.\"\n \n \n ", "input_code": "def get_plugin_spec_flatten_dict(plugin_dir):\n\"\"\"\nCreates a flat dict from the plugin spec\n\n:param plugin_dir: A path to the plugin's dir\n:return: A flatten dictionary contains the plugin's properties\n\"\"\"\n", "indent_space": "    ", "ground_truth": "def get_plugin_spec_flatten_dict(plugin_dir):\n    \"\"\"Creates a flat dict from the plugin spec\n\n    :param plugin_dir: A path to the plugin's dir\n    :return: A flatten dictionary contains the plugin's properties\n    \"\"\"\n    with open(os.path.join(plugin_dir, PLUGIN_SPEC)) as fp:\n        spec_yaml = yaml.safe_load(fp)\n\n    plugin_name = list(spec_yaml['subparsers'].keys())[0]\n\n    plugin_description = spec_yaml['description'] \\\n        if \"description\" in spec_yaml \\\n        else spec_yaml['subparsers'][plugin_name]['description']\n\n    plugin_type = spec_yaml[\"config\"][\"plugin_type\"] \\\n        if \"config\" in spec_yaml \\\n        else spec_yaml[\"plugin_type\"]\n\n    plugin_spec_dict = dict(\n        name=plugin_name,\n        dir=plugin_dir,\n        description=plugin_description,\n        type=plugin_type\n    )\n\n    return plugin_spec_dict", "signature": "def get_plugin_spec_flatten_dict(plugin_dir):", "completion_path": "tests/test_plugins.py"}
{"ce_id": "63060b1b73426c38ae68ad42", "namespace": "63060b1b73426c38ae68ad42", "namespace_real": "infrared.core.services.ansible_config.inject_config", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "ansible_config", "function_name": "inject_config", "contexts_above": "from collections import OrderedDict\nimport os\nfrom six.moves import configparser\n\nfrom infrared.core.utils import logger\nfrom infrared.core.utils.validators import AnsibleConfigValidator\n\nLOG = logger.LOG\n\n\nclass AnsibleConfigManager(object):\n\n    def __init__(self, infrared_home):\n        \"\"\"Constructor.\n\n        :param ansible_config: A path to the ansible config\n        \"\"\"\n        self.ansible_config_path = self._get_ansible_conf_path(infrared_home)\n        config_validator = AnsibleConfigValidator()\n\n        if not os.path.isfile(self.ansible_config_path):\n            self._create_ansible_config(infrared_home)\n        else:\n            config_validator.validate_from_file(self.ansible_config_path)\n\n    @staticmethod\n    def _get_ansible_conf_path(infrared_home):\n        \"\"\"Get path to Ansible config.\n\n        Check for Ansible config in specific locations and return the first\n        located.\n\n        :param infrared_home: infrared's home directory\n        :return: the first located Ansible config\n        \"\"\"\n        locations_list = [\n            os.path.join(os.getcwd(), 'ansible.cfg'),\n            os.path.join(infrared_home, 'ansible.cfg'),\n            os.path.join(os.path.expanduser('~'), '.ansible.cfg')\n        ]\n\n        env_var_path = os.environ.get('ANSIBLE_CONFIG', '')\n\n        if env_var_path != '':\n            return env_var_path\n\n        for location in locations_list:\n            if os.path.isfile(location):\n                return location\n\n        return os.path.join(infrared_home, 'ansible.cfg')\n\n    def _create_ansible_config(self, infrared_home):\n        \"\"\"Create ansible config file \"\"\"\n        infrared_common_path = os.path.realpath(__file__ + '/../../../common')\n        default_ansible_settings = dict(\n            defaults=OrderedDict([\n                ('host_key_checking', 'False'),\n                ('forks', 500),\n                ('timeout', 30),\n                ('force_color', 1),\n                ('show_custom_stats', 'True'),\n                ('callback_plugins', infrared_common_path + '/callback_plugins'),\n                ('filter_plugins', infrared_common_path + '/filter_plugins'),\n                ('library', infrared_common_path + '/modules'),\n                ('roles', infrared_common_path + '/roles'),\n                ('collections_paths', infrared_home + '/.ansible/collections'),\n                ('local_tmp', infrared_home + '/.ansible/tmp'),\n            ]),\n            ssh_connection=OrderedDict([\n                ('pipelining', 'True'),\n                ('retries', 2),\n            ]),\n            galaxy=OrderedDict([\n                ('cache_dir', infrared_home + '/.ansible/galaxy_cache'),\n                ('token_path', infrared_home + '/.ansible/galaxy_token'),\n            ]),\n        )\n\n        LOG.warning(\"Ansible conf ('{}') not found, creating it with \"\n                    \"default data\".format(self.ansible_config_path))\n\n        with open(self.ansible_config_path, 'w') as fp:\n            config = configparser.ConfigParser()\n\n            for section, section_data in default_ansible_settings.items():\n                if not config.has_section(section):\n                    config.add_section(section)\n                for option, value in section_data.items():\n                    config.set(section, option, str(value))\n\n            config.write(fp)\n", "contexts_below": "", "input_code": "def inject_config(self):\n\"\"\"\nSet the environment variable for config path, if it is undefined.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def inject_config(self):\n        \"\"\"Set the environment variable for config path, if it is undefined.\"\"\"\n        if os.environ.get('ANSIBLE_CONFIG', '') == '':\n            os.environ['ANSIBLE_CONFIG'] = self.ansible_config_path", "signature": "def inject_config(self):", "completion_path": "infrared/core/services/ansible_config.py"}
{"ce_id": "63060b1b73426c38ae68ad43", "namespace": "63060b1b73426c38ae68ad43", "namespace_real": "infrared.main.extend_cli", "real_proj_path": "redhat-openstack---infrared/", "type": "class", "class_name": "main", "function_name": "extend_cli", "contexts_above": "from __future__ import print_function\n\nimport argcomplete\nimport json\nimport os\nfrom pbr import version\nimport pkg_resources as pkg\nimport sys\n\n\ndef inject_common_paths():\n    \"\"\"Discover the path to the common/ directory provided by infrared core.\"\"\"\n    def override_conf_path(common_path, envvar, specific_dir):\n        conf_path = os.environ.get(envvar, '')\n        additional_conf_path = os.path.join(common_path, specific_dir)\n        if conf_path:\n            full_conf_path = ':'.join([additional_conf_path, conf_path])\n        else:\n            full_conf_path = additional_conf_path\n        os.environ[envvar] = full_conf_path\n\n    version_info = version.VersionInfo('infrared')\n\n    common_path = pkg.resource_filename(version_info.package,\n                                        'common')\n    override_conf_path(common_path, 'ANSIBLE_ROLES_PATH', 'roles')\n    override_conf_path(common_path, 'ANSIBLE_FILTER_PLUGINS', 'filter_plugins')\n    override_conf_path(common_path, 'ANSIBLE_CALLBACK_PLUGINS',\n                       'callback_plugins')\n    override_conf_path(common_path, 'ANSIBLE_LIBRARY', 'library')\n\n\n# This needs to be called here because as soon as an ansible class is loaded\n# the code in constants.py is triggered. That code reads the configuration\n# settings from all sources (ansible.cfg, environment variables, etc).\n# If the first include to ansible modules is moved deeper in the InfraRed\n# code (or on demand), then this call can be moved as well in that place.\ninject_common_paths()\n\nfrom infrared import api  # noqa\nimport infrared.bash_completers as completers  # noqa\nfrom infrared.core.services import CoreServices  # noqa\nfrom infrared.core.services.plugins import PLUGINS_REGISTRY  # noqa\nfrom infrared.core.utils import exceptions  # noqa\nfrom infrared.core.utils import interactive_ssh  # noqa\nfrom infrared.core.utils import logger  # noqa\nfrom infrared.core.utils.print_formats import fancy_table  # noqa\n\nLOG = logger.LOG\n\n\nclass WorkspaceManagerSpec(api.SpecObject):\n    \"\"\"The workspace manager CLI. \"\"\"\n\n    def __init__(self, name, *args, **kwargs):\n        super(WorkspaceManagerSpec, self).__init__(name, **kwargs)\n        self.workspace_manager = CoreServices.workspace_manager()\n", "contexts_below": "    def spec_handler(self, parser, args):\n         \"\"\"Handles all the plugin manager commands\n \n         :param parser: the infrared parser object.\n         :param args: the list of arguments received from cli.\n         \"\"\"\n         pargs = parser.parse_args(args)\n         subcommand = pargs.command0\n \n         if subcommand == 'create':\n             self._create_workspace(pargs.name)\n         elif subcommand == 'checkout':\n             self._checkout_workspace(pargs.name, pargs.checkout_create)\n         elif subcommand == 'inventory':\n             self._fetch_inventory(pargs.name)\n         elif subcommand == 'list':\n             if pargs.print_active:\n                 print(self.workspace_manager.get_active_workspace().name)\n             else:\n                 workspaces = self.workspace_manager.list()\n                 headers = (\"Name\", \"Active\")\n                 workspaces = sorted([workspace.name for workspace in\n                                      self.workspace_manager.list()])\n                 print(fancy_table(\n                     headers,\n                     *[(workspace, ' ' * (len(headers[-1]) // 2) + \"*\" if\n                         self.workspace_manager.is_active(workspace) else \"\")\n                       for workspace in workspaces]))\n         elif subcommand == 'delete':\n             for workspace_name in pargs.name:\n                 self.workspace_manager.delete(workspace_name)\n                 print(\"Workspace '{}' deleted\".format(workspace_name))\n         elif subcommand == 'cleanup':\n             self.workspace_manager.cleanup(pargs.name)\n         elif subcommand == 'export':\n             self.workspace_manager.export_workspace(\n                 pargs.workspacename, pargs.filename, pargs.copykeys)\n         elif subcommand == 'import':\n             self.workspace_manager.import_workspace(\n                 pargs.filename, pargs.workspacename)\n         elif subcommand == 'node-list':\n             nodes = self.workspace_manager.node_list(pargs.name, pargs.group)\n             if pargs.format == 'json':\n                 nodes_dict = [\n                     {'name': name, 'address': address, 'groups': groups}\n                     for name, address, groups in nodes]\n                 print(json.dumps({'nodes': nodes_dict}))\n             else:\n                 print(fancy_table(\n                     (\"Name\", \"Address\", \"Groups\"),\n                     *[node_name for node_name in nodes]))\n         elif subcommand == \"group-list\":\n             groups = self.workspace_manager.group_list(pargs.name)\n             print(fancy_table(\n                 (\"Name\", \"Nodes\"), *[group_name for group_name in groups]))\n \n     def _create_workspace(self, name):\n         \"\"\"Creates a workspace\n \n         :param name: Name of the workspace to create\n         \"\"\"\n         self.workspace_manager.create(name)\n         print(\"Workspace '{}' has been added\".format(name))\n \n     def _checkout_workspace(self, name, create=False):\n         \"\"\"Checkouts (activate) a workspace\n \n         :param name: The name of the workspace to checkout\n         :param create: if set to true will create a new workspace\n         before checking out to it\n         \"\"\"\n         if create:\n             self._create_workspace(name)\n         self.workspace_manager.activate(name)\n         print(\"Now using workspace: '{}'\".format(name))\n \n     def _fetch_inventory(self, name):\n         \"\"\"fetch inventory file for workspace.\n \n         if no active workspace found - create a new workspace\n         \"\"\"\n         if name:\n             wkspc = self.workspace_manager.get(name)\n         else:\n             wkspc = self.workspace_manager.get_active_workspace()\n         if not wkspc:\n             raise exceptions.IRNoActiveWorkspaceFound()\n         print(wkspc.inventory)\n \n \n class PluginManagerSpec(api.SpecObject):\n \n     def __init__(self, name, *args, **kwargs):\n         super(PluginManagerSpec, self).__init__(name, *args, **kwargs)\n         self.plugin_manager = CoreServices.plugins_manager()\n \n     def extend_cli(self, root_subparsers):\n         plugin_parser = root_subparsers.add_parser(\n             self.name,\n             help=self.kwargs[\"description\"],\n             **self.kwargs)\n         plugin_subparsers = plugin_parser.add_subparsers(dest=\"command0\")\n \n         # Add plugin\n         add_parser = plugin_subparsers.add_parser(\n             'add', help='Add a plugin')\n         add_parser.add_argument(\"src\", nargs='+',\n                                 help=\"Plugin Source (name/path/git URL)\\n'all'\"\n                                      \" will install all available plugins\")\n         add_parser.add_argument(\"--revision\", help=\"git branch/tag/revision\"\n                                 \" sourced plugins. Ignored for\"\n                                 \"'plugin add all' command.\")\n \n         add_parser.add_argument(\"--src-path\",\n                                 help=\"Relative path within the repository \"\n                                      \"where infrared plugin can be found.\\n\"\n                                      \"(Required with --link-roles\")\n \n         add_parser.add_argument(\"--link-roles\", action='store_true',\n                                 help=\"Auto creates symbolic 'roles' directory \"\n                                      \"in the path provided with '--src-path' \"\n                                      \"which points to the 'roles' directory \"\n                                      \"inside the project's root dir if exists,\"\n                                      \" otherwise to the project's root dir \"\n                                      \"itself.\")\n \n         add_parser.add_argument(\"--skip-roles\", action='store_true',\n                                 help=\"Skip the from file roles installation. \"\n                                      \"(Don't install Ansible roles from \"\n                                      \"'requirements.yml' or \"\n                                      \"'requirements.yaml' file)\")\n \n         # Remove plugin\n         remove_parser = plugin_subparsers.add_parser(\n             \"remove\",\n             help=\"Remove a plugin, 'all' will remove all installed plugins\")\n         remove_parser.add_argument(\n             \"name\", nargs='+',\n             help=\"Plugin name\").completer = completers.plugin_list\n \n         # List command\n         list_parser = plugin_subparsers.add_parser(\n             'list', help='List all the available plugins')\n         list_parser.add_argument(\n             \"--available\", action='store_true',\n             help=\"Prints all available plugins in addition \"\n                  \"to installed plugins\")\n         list_parser.add_argument(\n             \"--versions\", action='store_true',\n             help=\"Prints version of each installed plugins\")\n \n         # Update plugin\n         update_parser = plugin_subparsers.add_parser(\n             \"update\",\n             help=\"Update a Git-based plugin\")\n         update_parser.add_argument(\n             \"name\",\n             help=\"Name of the plugin to update\")\n         update_parser.add_argument(\n             \"revision\", nargs='?', default='latest',\n             help=\"Revision number to checkout (if not given, will only pull \"\n                  \"changes from the remote)\")\n         update_parser.add_argument(\n             '--skip_reqs', '-s', action='store_true',\n             help=\"Skips plugin's requirements installation\")\n         update_parser.add_argument(\n             '--hard-reset', action='store_true',\n             help=\"Drop all local changes using hard \"\n                  \"reset (changes will be stashed\")\n \n         plugin_subparsers.add_parser(\n             \"freeze\", help=\"Run through installed plugins. For git sourced \"\n             \"one writes its current revision to plugins registry.\")\n \n         # search all plugins from github organization\n         plugin_subparsers.add_parser(\n             'search', help='Search and list all the available plugins from '\n             \"rhos-infra organization on GitHub\")\n \n         # import plugins from registry yml file\n         plugin_subparsers.add_parser(\n             'import', help='Install plugins from a YAML file')\n \n         # Add plugin\n         import_parser = plugin_subparsers.add_parser(\n             'import', help='Install plugins from a registry YML file')\n         import_parser.add_argument(\"src\",\n                                    help=\"The registry YML file Source\")\n \n     def spec_handler(self, parser, args):\n         \"\"\"Handles all the plugin manager commands\n \n         :param parser: the infrared parser object.\n         :param args: the list of arguments received from cli.\n         \"\"\"\n         pargs = parser.parse_args(args)\n         subcommand = pargs.command0\n \n         if subcommand == 'list':\n             self._list_plugins(pargs.available, pargs.versions)\n         elif subcommand == 'add':\n             if 'all' in pargs.src:\n                 self.plugin_manager.add_all_available()\n                 self._list_plugins(print_available=False, print_version=False)\n             else:\n                 if len(pargs.src) > 1 and (pargs.revision or pargs.src_path):\n                     raise exceptions.IRFailedToAddPlugin(\n                         \"'--revision' works with one plugin source only.\")\n                 for _plugin in pargs.src:\n                     self.plugin_manager.add_plugin(\n                         _plugin, rev=pargs.revision,\n                         plugin_src_path=pargs.src_path,\n                         skip_roles=pargs.skip_roles,\n                         link_roles=pargs.link_roles)\n         elif subcommand == 'remove':\n             if 'all' in pargs.name:\n                 self.plugin_manager.remove_all()\n                 self._list_plugins(print_available=False, print_version=False)\n             else:\n                 for _plugin in pargs.name:\n                     self.plugin_manager.remove_plugin(_plugin)\n         elif subcommand == 'freeze':\n             self.plugin_manager.freeze()\n         elif subcommand == 'update':\n             self.plugin_manager.update_plugin(\n                 pargs.name, pargs.revision, pargs.skip_reqs, pargs.hard_reset)\n         elif subcommand == 'search':\n             self._search_plugins()\n         elif subcommand == 'import':\n             self.plugin_manager.import_plugins(pargs.src)\n \n     def _list_plugins(self, print_available=False, print_version=False):\n         \"\"\"Print a list of installed & available plugins\"\"\"\n         table_rows = []\n         table_headers = [\"Type\", \"Name\"]\n         installed_mark = ' ' * (len('Installed') // 2) + '*'\n \n         plugins_dict = \\\n             self.plugin_manager.get_all_plugins() \\\n             if print_available \\\n             else self.plugin_manager.get_installed_plugins()\n \n         for plugins_type, plugins in plugins_dict.items():\n             installed_plugins_list = \\\n                 self.plugin_manager.get_installed_plugins(plugins_type).keys()\n             plugins_names = list(plugins.keys())\n             plugins_names.sort()\n \n             if print_available:\n                 all_plugins_list = []\n                 for plugin_name in plugins_names:\n                     all_plugins_list.append(plugin_name)\n                 installed_plugins_mark_list = \\\n                     [installed_mark if plugin_name in installed_plugins_list\n                      else '' for plugin_name in all_plugins_list]\n \n                 plugins_descs = \\\n                     [PLUGINS_REGISTRY.get(plugin, {}).get('desc', '')\n                      for plugin in all_plugins_list]\n \n                 row = [plugins_type, '\\n'.join(all_plugins_list),\n                        '\\n'.join(installed_plugins_mark_list),\n                        '\\n'.join(plugins_descs)]\n \n                 if print_version:\n                     plugins_version = [\n                         self.plugin_manager.get_plugin_version(plugin_name)\n                         if plugin_name in installed_plugins_list else ''\n                         for plugin_name in all_plugins_list]\n \n                     row.append('\\n'.join(plugins_version))\n \n             else:\n                 row = [\n                     plugins_type,\n                     '\\n'.join(installed_plugins_list)]\n \n                 if print_version:\n                     plugins_version = [self.plugin_manager.get_plugin_version(\n                         plugin_name) for plugin_name in installed_plugins_list]\n                     row.append('\\n'.join(plugins_version))\n \n             table_rows.append(row)\n \n         if print_available:\n             table_headers.append(\"Installed\")\n             table_headers.append(\"Description\")\n \n         if print_version:\n             table_headers.append(\"Version\")\n \n         print(fancy_table(table_headers, *table_rows))\n \n     def _search_plugins(self):\n         \"\"\"Search git organizations and print a list of available plugins \"\"\"\n \n         table_rows = []\n         table_headers = [\"Type\", \"Name\", \"Description\", \"Source\"]\n \n         plugins_dict = \\\n             self.plugin_manager.get_all_git_plugins()\n \n         for plugins_type, plugins in plugins_dict.items():\n             # prepare empty lists\n             all_plugins_list = []\n             plugins_descs = []\n             plugins_sources = []\n \n             for plugin_name in sorted(plugins.iterkeys()):\n                 # get all plugin names\n                 all_plugins_list.append(plugin_name)\n                 # get all plugin descriptions\n                 plugins_descs.append(plugins[plugin_name][\"desc\"])\n                 # get all plugins sources\n                 plugins_sources.append(plugins[plugin_name][\"src\"])\n \n             table_rows.append([\n                 plugins_type,\n                 '\\n'.join(all_plugins_list),\n                 '\\n'.join(plugins_descs),\n                 '\\n'.join(plugins_sources)])\n \n         print(fancy_table(table_headers, *table_rows))\n \n \n class SSHSpec(api.SpecObject):\n \n     def __init__(self, name, *args, **kwargs):\n         super(SSHSpec, self).__init__(name, *args, **kwargs)\n \n     def extend_cli(self, root_subparsers):\n         issh_parser = root_subparsers.add_parser(\n             self.name,\n             help=self.kwargs[\"description\"],\n             **self.kwargs)\n \n         issh_parser.add_argument(\"node_name\", help=\"Node name. \"\n                                  \"Ex.: controller-0\"\n                                  ).completer = completers.node_list\n         issh_parser.add_argument(\"remote_command\", nargs=\"?\", help=\"Run \"\n                                  \"provided command line on remote host and \"\n                                  \"return its output.\")\n \n     def spec_handler(self, parser, args):\n         \"\"\"Handles the ssh command\n \n         :param parser: the infrared parser object.\n         :param args: the list of arguments received from cli.\n         \"\"\"\n         pargs = parser.parse_args(args)\n         return interactive_ssh.ssh_to_host(\n             pargs.node_name, remote_command=pargs.remote_command)\n \n \n def main(args=None):\n     CoreServices.setup()\n \n     # inject ansible config file\n     CoreServices.ansible_config_manager().inject_config()\n \n     specs_manager = api.SpecManager()\n \n     # Init Managers\n     specs_manager.register_spec(\n         WorkspaceManagerSpec('workspace',\n                              description=\"Workspace manager. \"\n                                          \"Allows to create and use an \"\n                                          \"isolated environment for plugins \"\n                                          \"execution.\"))\n     specs_manager.register_spec(\n         PluginManagerSpec('plugin',\n                           description=\"Plugin management\"))\n \n     specs_manager.register_spec(\n         SSHSpec(\n             'ssh',\n             description=\"Interactive ssh session to node from inventory.\"))\n \n     # register all plugins\n     for plugin in CoreServices.plugins_manager().PLUGINS_DICT.values():\n         specs_manager.register_spec(api.InfraredPluginsSpec(plugin))\n \n     argcomplete.autocomplete(specs_manager.parser)\n     return specs_manager.run_specs(args) or 0\n \n \n if __name__ == '__main__':\n     sys.exit(int(main() or 0))\n ", "input_code": "def extend_cli(self, root_subparsers):\n\"\"\"\nAdds the spec cli options to to the main entry point.\n\n:param subparser: the subparser object to extend.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def extend_cli(self, root_subparsers):\n        workspace_plugin = root_subparsers.add_parser(\n            self.name,\n            help=self.kwargs[\"description\"],\n            **self.kwargs)\n        workspace_subparsers = workspace_plugin.add_subparsers(dest=\"command0\")\n\n        # create\n        create_parser = workspace_subparsers.add_parser(\n            'create', help='Creates a new workspace')\n        create_parser.add_argument(\"name\", help=\"Workspace name\")\n\n        # checkout\n        checkout_parser = workspace_subparsers.add_parser(\n            'checkout',\n            help='Switches workspace to the specified workspace')\n        checkout_parser.add_argument(\n            \"name\",\n            help=\"Workspace name\").completer = completers.workspace_list\n        checkout_parser.add_argument(\n            \"-c\", \"--create\", action='store_true', dest=\"checkout_create\",\n            help=\"Creates a workspace if not exists and \"\n                 \"switches to it\")\n\n        # inventory\n        inventory_parser = workspace_subparsers.add_parser(\n            'inventory',\n            help=\"prints workspace's inventory file\")\n        inventory_parser.add_argument(\n            \"name\", help=\"Workspace name\",\n            nargs=\"?\").completer = completers.workspace_list\n\n        # list\n        wrkspc_list_parser = workspace_subparsers.add_parser(\n            'list', help='Lists all the workspaces')\n        wrkspc_list_parser.add_argument(\n            \"--active\", action='store_true', dest='print_active',\n            help=\"Prints the active workspace only\")\n\n        # delete\n        delete_parser = workspace_subparsers.add_parser(\n            'delete', help='Deletes workspaces')\n        delete_parser.add_argument(\n            'name', nargs='+',\n            help=\"Workspace names\").completer = completers.workspace_list\n\n        # cleanup\n        cleanup_parser = workspace_subparsers.add_parser(\n            'cleanup', help='Removes all the files from workspace')\n        cleanup_parser.add_argument(\n            \"name\",\n            help=\"Workspace name\").completer = completers.workspace_list\n\n        # import settings\n        importer_parser = workspace_subparsers.add_parser(\n            'import', help='Import deployment configs.')\n        importer_parser.add_argument(\"filename\", help=\"Archive file name or URL.\")\n        importer_parser.add_argument(\n            \"-n\", \"--name\", dest=\"workspacename\",\n            help=\"Workspace name to import with. \"\n            \"If not specified - file name will be used.\")\n\n        # export settings\n        exporter_parser = workspace_subparsers.add_parser(\n            'export', help='Export deployment configurations.')\n        exporter_parser.add_argument(\n            \"-n\", \"--name\", dest=\"workspacename\",\n            help=\"Workspace name. If not sepecified - active \"\n            \"workspace will be used.\").completer = completers.workspace_list\n        exporter_parser.add_argument(\"-f\", \"--filename\", dest=\"filename\",\n                                     help=\"Archive file name.\")\n\n        exporter_parser.add_argument(\"-K\", \"--copy-keys\", dest=\"copykeys\",\n                                     action=\"store_true\",\n                                     help=\"Silently copy ssh keys \"\n                                     \"to workspace.\")\n        # node list\n        nodelist_parser = workspace_subparsers.add_parser(\n            'node-list',\n            help='List nodes, managed by workspace')\n        nodelist_parser.add_argument(\n            \"-n\", \"--name\",\n            help=\"Workspace name\").completer = completers.workspace_list\n        nodelist_parser.add_argument(\n            \"-g\", \"--group\",\n            help=\"List nodes in specific group\"\n        ).completer = completers.group_list\n        nodelist_parser.add_argument(\n            \"-f\", \"--format\", choices=['fancy', 'json'], default='fancy',\n            help=\"Output format\")\n\n        # group list\n        grouplist_parser = workspace_subparsers.add_parser(\n            'group-list',\n            help='List groups, managed by workspace')\n        grouplist_parser.add_argument(\n            \"-n\", \"--name\",\n            help=\"Workspace name\").completer = completers.workspace_list", "signature": "def extend_cli(self, root_subparsers):", "completion_path": "infrared/main.py"}
{"ce_id": "62ece4982e6aefcf4aabbd64", "namespace": "62ece4982e6aefcf4aabbd64", "namespace_real": "ocfl.dispositor.strip_root", "real_proj_path": "zimeon---ocfl-py/", "type": "class", "class_name": "dispositor", "function_name": "strip_root", "contexts_above": "\"\"\"Base class for Dispositor objects.\"\"\"\nimport os\nimport os.path\nfrom urllib.parse import quote_plus, unquote_plus\n\n\nclass Dispositor:\n    \"\"\"Base class for disposition handlers -- let's call them Dispositors.\"\"\"\n", "contexts_below": "    def is_valid(self, identifier):  # pylint: disable=unused-argument\n         \"\"\"Return True if identifier is valid, always True in this base implementation.\"\"\"\n         return True\n \n     def encode(self, identifier):\n         \"\"\"Encode identifier to get rid of unsafe chars.\"\"\"\n         return quote_plus(identifier)\n \n     def decode(self, identifier):\n         \"\"\"Decode identifier to put back unsafe chars.\"\"\"\n         return unquote_plus(identifier)\n \n     def identifier_to_path(self, identifier):\n         \"\"\"Convert identifier to path relative to some root.\"\"\"\n         raise Exception(\"No yet implemented\")\n \n     def relative_path_to_identifier(self, path):\n         \"\"\"Convert relative path to identifier.\"\"\"\n         raise Exception(\"No yet implemented\")\n \n     def path_to_identifier(self, path, root=None):\n         \"\"\"Convert path relative to root to identifier.\"\"\"\n         if root is not None:\n             path = self.strip_root(path, root)\n         return self.relative_path_to_identifier(path)\n ", "input_code": "def strip_root(self, path, root):\n\"\"\"\nRemove root from path, throw exception on failure.\n\"\"\"\n", "indent_space": "        ", "ground_truth": "    def strip_root(self, path, root):\n        \"\"\"Remove root from path, throw exception on failure.\"\"\"\n        root = root.rstrip(os.sep)  # ditch any trailing path separator\n        if os.path.commonprefix((path, root)) == root:\n            return os.path.relpath(path, start=root)\n        raise Exception(\"Path %s is not in root %s\" % (path, root))", "signature": "def strip_root(self, path, root):", "completion_path": "ocfl/dispositor.py"}
